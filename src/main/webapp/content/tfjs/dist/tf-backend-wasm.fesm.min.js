/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import {
  _FusedMatMul as e,
  broadcast_util as t,
  util as n,
  Abs as a,
  Acos as r,
  Acosh as u,
  backend_util as s,
  Add as i,
  AddN as o,
  Identity as d,
  tensor as p,
  Transpose as l,
  All as c,
  Any as m,
  ArgMax as f,
  ArgMin as h,
  Asin as b,
  Asinh as y,
  Atan as _,
  Atan2 as g,
  Atanh as I,
  AvgPool as w,
  AvgPool3D as k,
  AvgPool3DGrad as M,
  AvgPoolGrad as S,
  Reshape as A,
  BatchMatMul as v,
  slice_util as x,
  buffer as F,
  TensorBuffer as N,
  Slice as D,
  BatchToSpaceND as R,
  Bincount as E,
  BitwiseAnd as W,
  BroadcastArgs as P,
  Cast as O,
  Ceil as C,
  ClipByValue as T,
  Concat as z,
  Conv2D as H,
  Conv2DBackpropInput as B,
  Conv3D as L,
  Conv3DBackpropFilterV2 as U,
  Conv3DBackpropInputV2 as j,
  Cos as G,
  Cosh as q,
  CropAndResize as V,
  Cumprod as $,
  Cumsum as K,
  DenseBincount as X,
  DepthToSpace as Q,
  DepthwiseConv2dNative as J,
  Diag as Z,
  Dilation2D as Y,
  Dilation2DBackpropFilter as ee,
  Dilation2DBackpropInput as te,
  Elu as ne,
  EluGrad as ae,
  Equal as re,
  Erf as ue,
  Exp as se,
  ExpandDims as ie,
  Expm1 as oe,
  Fill as de,
  FlipLeftRight as pe,
  Floor as le,
  FloorDiv as ce,
  FusedBatchNorm as me,
  FusedConv2D as fe,
  FusedDepthwiseConv2D as he,
  GatherNd as be,
  gather_util as ye,
  GatherV2 as _e,
  Greater as ge,
  GreaterEqual as Ie,
  IsFinite as we,
  IsInf as ke,
  IsNan as Me,
  LeakyRelu as Se,
  Less as Ae,
  LessEqual as ve,
  LinSpace as xe,
  Log as Fe,
  Log1p as Ne,
  LogicalAnd as De,
  LogicalNot as Re,
  LogicalOr as Ee,
  LogicalXor as We,
  LRN as Pe,
  LRNGrad as Oe,
  Max as Ce,
  Maximum as Te,
  MaxPool as ze,
  MaxPool3D as He,
  MaxPool3DGrad as Be,
  MaxPoolGrad as Le,
  MaxPoolWithArgmax as Ue,
  Mean as je,
  Min as Ge,
  Minimum as qe,
  MirrorPad as Ve,
  Softmax as $e,
  Multinomial as Ke,
  Mod as Xe,
  Multiply as Qe,
  Neg as Je,
  NonMaxSuppressionV3 as Ze,
  NonMaxSuppressionV4 as Ye,
  NonMaxSuppressionV5 as et,
  NotEqual as tt,
  OneHot as nt,
  OnesLike as at,
  Pack as rt,
  PadV2 as ut,
  Pow as st,
  Prelu as it,
  Prod as ot,
  Range as dt,
  RealDiv as pt,
  Reciprocal as lt,
  Relu as ct,
  Relu6 as mt,
  ResizeBilinear as ft,
  ResizeBilinearGrad as ht,
  ResizeNearestNeighbor as bt,
  ResizeNearestNeighborGrad as yt,
  Reverse as _t,
  RotateWithOffset as gt,
  Round as It,
  Rsqrt as wt,
  ScatterNd as kt,
  scatter_util as Mt,
  SearchSorted as St,
  Select as At,
  Selu as vt,
  Sigmoid as xt,
  Sign as Ft,
  Sin as Nt,
  Sinh as Dt,
  Softplus as Rt,
  SpaceToBatchND as Et,
  SparseFillEmptyRows as Wt,
  SparseReshape as Pt,
  SparseSegmentMean as Ot,
  SparseSegmentSum as Ct,
  SparseToDense as Tt,
  SplitV as zt,
  Sqrt as Ht,
  Square as Bt,
  SquaredDifference as Lt,
  Step as Ut,
  StridedSlice as jt,
  StringNGrams as Gt,
  StringSplit as qt,
  StringToHashBucketFast as Vt,
  Sub as $t,
  Sum as Kt,
  Tan as Xt,
  Tanh as Qt,
  TensorScatterUpdate as Jt,
  Tile as Zt,
  TopK as Yt,
  Transform as en,
  Unique as tn,
  Unpack as nn,
  ZerosLike as an,
  registerKernel as rn,
  env as un,
  KernelBackend as sn,
  DataStorage as on,
  engine as dn,
  deprecationWarn as pn,
  registerBackend as ln,
} from '@tensorflow/tfjs-core';
import cn from 'fs';
import mn from 'path';
import fn from 'perf_hooks';
import hn from 'os';
function bn(e, t) {
  return (
    t.forEach(function (t) {
      t &&
        'string' != typeof t &&
        !Array.isArray(t) &&
        Object.keys(t).forEach(function (n) {
          if ('default' !== n && !(n in e)) {
            var a = Object.getOwnPropertyDescriptor(t, n);
            Object.defineProperty(
              e,
              n,
              a.get
                ? a
                : {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  },
            );
          }
        });
    }),
    e
  );
}
var yn, _n;
let gn;
!(function (e) {
  (e[(e.float32 = 0)] = 'float32'),
    (e[(e.int32 = 1)] = 'int32'),
    (e[(e.bool = 2)] = 'bool'),
    (e[(e.string = 3)] = 'string'),
    (e[(e.complex64 = 4)] = 'complex64');
})(yn || (yn = {})),
  (function (e) {
    (e[(e.linear = 0)] = 'linear'),
      (e[(e.relu = 1)] = 'relu'),
      (e[(e.relu6 = 2)] = 'relu6'),
      (e[(e.prelu = 3)] = 'prelu'),
      (e[(e.leakyrelu = 4)] = 'leakyrelu'),
      (e[(e.sigmoid = 5)] = 'sigmoid'),
      (e[(e.elu = 6)] = 'elu');
  })(_n || (_n = {}));
const In = {
  kernelName: e,
  backendName: 'wasm',
  setupFunc: function (t) {
    gn = t.wasm.cwrap(e, null, [
      'number',
      'array',
      'number',
      'number',
      'array',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: n, backend: a, attrs: r } = e,
      { a: u, b: s, bias: i, preluActivationWeights: o } = n;
    if ('float32' !== u.dtype || 'float32' !== s.dtype) throw new Error('_FusedMatMul for non non-float32 tensors not yet supported.');
    const { transposeA: d, transposeB: p, activation: l, leakyreluAlpha: c } = r,
      m = a.dataIdMap.get(u.dataId).id,
      f = a.dataIdMap.get(s.dataId).id;
    let h = 0;
    if (null != i) {
      const e = a.dataIdMap.get(i.dataId);
      if (1 !== e.shape.length) throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);
      h = e.id;
    }
    const b = null == o ? 0 : a.dataIdMap.get(o.dataId).id,
      y = _n[l];
    if (null == y) throw new Error(`${l} activation not yet supported for FusedConv2D in the wasm backend.`);
    const _ = d ? u.shape[2] : u.shape[1],
      g = p ? s.shape[1] : s.shape[2],
      I = t.assertAndGetBroadcastShape(u.shape.slice(0, -2), s.shape.slice(0, -2)),
      w = a.makeOutput([...I, _, g], u.dtype),
      k = a.dataIdMap.get(w.dataId).id,
      M = new Uint8Array(new Int32Array(u.shape).buffer),
      S = new Uint8Array(new Int32Array(s.shape).buffer);
    return gn(m, M, u.shape.length, f, S, s.shape.length, d, p, y, h, b, c || 0, k), w;
  },
};
function wn(e, t) {
  let a;
  return {
    kernelName: e,
    backendName: 'wasm',
    setupFunc: function (t) {
      a = t.wasm.cwrap(e, null, ['number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const {
          backend: r,
          inputs: { x: u },
        } = e,
        s = r.dataIdMap.get(u.dataId).id,
        i = r.makeOutput(u.shape, t || u.dtype),
        o = r.dataIdMap.get(i.dataId).id;
      return 0 === n.sizeFromShape(i.shape) || a(s, yn[u.dtype], o), i;
    },
  };
}
const kn = wn(a),
  Mn = wn(r),
  Sn = wn(u);
function An(e, t, a) {
  let r;
  return {
    kernelName: e,
    backendName: 'wasm',
    setupFunc: function (t) {
      r = t.wasm.cwrap(e, null, ['number', 'array', 'number', 'number', 'array', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: u } = e,
        { a: i, b: o } = u,
        d = t.dataIdMap.get(i.dataId).id,
        p = t.dataIdMap.get(o.dataId).id,
        l = null != a ? a : i.dtype,
        c = s.assertAndGetBroadcastShape(i.shape, o.shape),
        m = t.makeOutput(c, l);
      if (0 === n.sizeFromShape(c)) return m;
      const f = new Uint8Array(new Int32Array(i.shape).buffer),
        h = new Uint8Array(new Int32Array(o.shape).buffer),
        b = t.dataIdMap.get(m.dataId).id;
      return r(d, f, i.shape.length, p, h, o.shape.length, yn[i.dtype], b), m;
    },
  };
}
const vn = An(i);
let xn;
const Fn = {
  kernelName: o,
  backendName: 'wasm',
  setupFunc: function (e) {
    xn = e.wasm.cwrap(o, null, ['array', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: a } = e,
      r = a.makeOutput(t[0].shape, t[0].dtype);
    if (0 === n.sizeFromShape(r.shape)) return r;
    const u = t.map(e => a.dataIdMap.get(e.dataId).id),
      s = new Uint8Array(new Int32Array(u).buffer),
      i = a.dataIdMap.get(r.dataId).id;
    return xn(s, u.length, yn[r.dtype], i), r;
  },
};
function Nn(e) {
  const {
    inputs: { x: t },
    backend: n,
  } = e;
  if ('string' === t.dtype) return p(n.readSync(t.dataId), t.shape, t.dtype);
  const a = n.makeOutput(t.shape, t.dtype),
    r = n.typedArrayFromHeap(t);
  return n.typedArrayFromHeap(a).set(r), a;
}
const Dn = { kernelName: d, backendName: 'wasm', kernelFunc: Nn };
let Rn;
function En(e) {
  const { inputs: t, backend: n, attrs: a } = e,
    [r, u] = (function (e, t) {
      const n = [],
        a = [];
      for (let r = 0; r < e.length; ++r) 1 !== e[r] && n.push(e[r]), 1 !== e[t[r]] && a.push(t[r]);
      for (let e = 0; e < a.length; ++e) {
        let t = -1;
        for (let n = 0; n < a.length; ++n) a[n] >= e && (-1 === t || a[t] > a[n]) && (t = n);
        a[t] = e;
      }
      return [n, a];
    })(t.x.shape, a.perm);
  let s = !0;
  for (let e = 0; e < u.length; e++) u[e] !== e && (s = !1);
  const i = (function (e, t) {
      const n = new Array(e.length);
      for (let a = 0; a < n.length; a++) n[a] = e[t[a]];
      return n;
    })(t.x.shape, a.perm),
    o = { dataId: t.x.dataId, shape: r, dtype: t.x.dtype };
  if (s) {
    const e = Nn({ inputs: t, backend: n });
    return (e.shape = i), e;
  }
  const d = n.makeOutput(i, o.dtype),
    p = n.dataIdMap.get(o.dataId).id,
    l = n.dataIdMap.get(d.dataId).id,
    c = new Uint8Array(new Int32Array(u).buffer),
    m = new Uint8Array(new Int32Array(o.shape).buffer);
  return Rn(p, m, o.shape.length, yn[o.dtype], l, c, u.length), d;
}
const Wn = {
  kernelName: l,
  backendName: 'wasm',
  kernelFunc: En,
  setupFunc: function (e) {
    Rn = e.wasm.cwrap(l, null, ['number', 'array', 'number', 'number', 'number', 'array', 'number']);
  },
};
function Pn(e, t, a) {
  const r = e.shape,
    u = e.shape.length,
    i = n.parseAxisParam(t, r);
  let o = i;
  const d = s.getAxesPermutation(o, u);
  let p = null,
    l = !1;
  if (null != d) {
    const t = new Array(u);
    for (let e = 0; e < t.length; e++) t[e] = r[d[e]];
    (o = s.getInnerMostAxes(o.length, u)), (p = En({ inputs: { x: e }, attrs: { perm: d }, backend: a }));
    const n = a.dataIdMap.get(e.dataId).id;
    a.dataIdMap.get(p.dataId).id !== n && (l = !0);
  }
  return { transposed: p, originalAxes: i, axes: o, inputWasTransposed: l };
}
let On;
const Cn = {
  kernelName: c,
  backendName: 'wasm',
  setupFunc: function (e) {
    On = e.wasm.cwrap(c, null, ['number, number, number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { axis: u, keepDims: i } = r,
      { x: o } = a;
    let d = t.dataIdMap.get(o.dataId).id,
      p = o;
    const { transposed: l, axes: c, originalAxes: m, inputWasTransposed: f } = Pn(o, u, t);
    if (f) {
      (p = l), (d = t.dataIdMap.get(l.dataId).id);
    }
    const h = p.shape.length;
    s.assertAxesAreInnerMostDims('all', c, h);
    const [b, y] = s.computeOutAndReduceShapes(p.shape, c),
      _ = n.sizeFromShape(y),
      g = t.makeOutput(b, o.dtype);
    if (0 !== n.sizeFromShape(p.shape)) {
      const e = t.dataIdMap.get(g.dataId).id;
      On(d, _, e);
    }
    if ((f && t.disposeData(l.dataId), i)) {
      const e = s.expandShapeToKeepDim(g.shape, m);
      g.shape = e;
    }
    return g;
  },
};
let Tn;
const zn = {
  kernelName: m,
  backendName: 'wasm',
  setupFunc: function (e) {
    Tn = e.wasm.cwrap(m, null, ['number, number, number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { axis: u, keepDims: i } = r,
      { x: o } = a;
    let d = t.dataIdMap.get(o.dataId).id,
      p = o;
    const { transposed: l, axes: c, originalAxes: m, inputWasTransposed: f } = Pn(o, u, t);
    if (f) {
      (p = l), (d = t.dataIdMap.get(l.dataId).id);
    }
    const h = p.shape.length;
    s.assertAxesAreInnerMostDims('any', c, h);
    const [b, y] = s.computeOutAndReduceShapes(p.shape, c),
      _ = n.sizeFromShape(y),
      g = t.makeOutput(b, o.dtype);
    if (0 !== n.sizeFromShape(p.shape)) {
      const e = t.dataIdMap.get(g.dataId).id;
      Tn(d, _, e);
    }
    if ((f && t.disposeData(l.dataId), i)) {
      const e = s.expandShapeToKeepDim(g.shape, m);
      g.shape = e;
    }
    return g;
  },
};
function Hn(e) {
  let t;
  return {
    kernelName: e,
    backendName: 'wasm',
    setupFunc: function (n) {
      t = n.wasm.cwrap(e, null, ['number', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: a, inputs: r, attrs: u } = e,
        { axis: s } = u,
        { x: i } = r,
        o = a.dataIdMap.get(i.dataId).id;
      let d = o,
        p = i;
      const { transposed: l, axes: c, inputWasTransposed: m } = Pn(i, s, a);
      if (m) {
        const e = a.dataIdMap.get(l.dataId).id;
        e !== o && ((p = l), (d = e));
      }
      const f = p.shape.slice(0, -1),
        h = a.makeOutput(f, 'int32'),
        b = a.dataIdMap.get(h.dataId).id,
        y = n.sizeFromShape(h.shape),
        _ = p.shape[c[0]];
      return t(d, yn[p.dtype], y, _, b), m && a.disposeData(l.dataId), h;
    },
  };
}
const Bn = Hn(f),
  Ln = Hn(h),
  Un = wn(b),
  jn = wn(y),
  Gn = wn(_),
  qn = An(g),
  Vn = wn(I);
let $n;
const Kn = {
  kernelName: w,
  backendName: 'wasm',
  setupFunc: function (e) {
    $n = e.wasm.cwrap(w, null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, attrs: n, backend: a } = e,
      r = t.x,
      u = a.dataIdMap.get(r.dataId).id,
      { filterSize: i, strides: o, pad: d, dimRoundingMode: p } = n,
      l = s.computePool2DInfo(r.shape, i, o, 1, d, p),
      c = l.filterHeight,
      m = l.filterWidth,
      f = l.padInfo.top,
      h = l.padInfo.right,
      b = l.padInfo.bottom,
      y = l.padInfo.left,
      _ = l.strideHeight,
      g = l.strideWidth,
      I = l.inChannels;
    if ('channelsLast' !== l.dataFormat)
      throw new Error(`wasm backend does not support dataFormat:'${l.dataFormat}'. Please use 'channelsLast'.`);
    if (1 !== l.dilationWidth || 1 !== l.dilationHeight)
      throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${l.dilationHeight}, ${l.dilationWidth}].`);
    const w = a.makeOutput(l.outShape, 'float32'),
      k = a.dataIdMap.get(w.dataId).id;
    return $n(u, r.shape[0], r.shape[1], r.shape[2], c, m, f, h, b, y, _, g, I, k), w;
  },
};
let Xn;
const Qn = {
  kernelName: k,
  backendName: 'wasm',
  setupFunc: function (e) {
    Xn = e.wasm.cwrap('AvgPool3D', null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { x: r } = t,
      { filterSize: u, strides: i, pad: o, dimRoundingMode: d, dataFormat: p } = a,
      l = s.computePool3DInfo(r.shape, u, i, 1, o, d, p),
      c = n.makeOutput(l.outShape, r.dtype);
    return (
      Xn(
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(c.dataId).id,
        l.batchSize,
        l.inChannels,
        l.inDepth,
        l.inHeight,
        l.inWidth,
        l.outDepth,
        l.outHeight,
        l.outWidth,
        l.strideDepth,
        l.strideHeight,
        l.strideWidth,
        l.dilationDepth,
        l.dilationHeight,
        l.dilationWidth,
        l.effectiveFilterDepth,
        l.effectiveFilterHeight,
        l.effectiveFilterWidth,
        l.padInfo.front,
        l.padInfo.top,
        l.padInfo.left,
      ),
      c
    );
  },
};
let Jn;
const Zn = {
  kernelName: M,
  backendName: 'wasm',
  setupFunc: function (e) {
    Jn = e.wasm.cwrap('AvgPool3DGrad', null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { dy: r, input: u } = t,
      { filterSize: i, strides: o, pad: d, dimRoundingMode: p } = a,
      l = s.computePool3DInfo(u.shape, i, o, 1, d, p),
      c = n.makeOutput(u.shape, u.dtype);
    return (
      Jn(
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(c.dataId).id,
        l.batchSize,
        l.inChannels,
        l.inDepth,
        l.inHeight,
        l.inWidth,
        l.outDepth,
        l.outHeight,
        l.outWidth,
        l.strideDepth,
        l.strideHeight,
        l.strideWidth,
        l.dilationDepth,
        l.dilationHeight,
        l.dilationWidth,
        l.effectiveFilterDepth,
        l.effectiveFilterHeight,
        l.effectiveFilterWidth,
        l.padInfo.front,
        l.padInfo.top,
        l.padInfo.left,
        l.filterDepth,
        l.filterHeight,
        l.filterWidth,
      ),
      c
    );
  },
};
let Yn;
const ea = {
  kernelName: S,
  backendName: 'wasm',
  setupFunc: function (e) {
    Yn = e.wasm.cwrap('AvgPoolGrad', null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { dy: r, input: u } = t,
      { filterSize: i, strides: o, pad: d } = a,
      p = s.computePool2DInfo(u.shape, i, o, 1, d),
      l = n.makeOutput(u.shape, u.dtype);
    return (
      Yn(
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(l.dataId).id,
        p.batchSize,
        p.inChannels,
        p.inHeight,
        p.inWidth,
        p.outHeight,
        p.outWidth,
        p.strideHeight,
        p.strideWidth,
        p.dilationHeight,
        p.dilationWidth,
        p.effectiveFilterHeight,
        p.effectiveFilterWidth,
        p.padInfo.top,
        p.padInfo.left,
        p.filterHeight,
        p.filterWidth,
      ),
      l
    );
  },
};
function ta(e) {
  const { inputs: t, attrs: a } = e,
    { x: r } = t,
    { shape: u } = a,
    s = n.sizeFromShape(r.shape),
    i = n.inferFromImplicitShape(u, s);
  return (
    n.assert(
      s === n.sizeFromShape(i),
      () => `new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`,
    ),
    e.backend.incRef(r.dataId),
    { dataId: r.dataId, shape: i, dtype: r.dtype }
  );
}
const na = { kernelName: A, backendName: 'wasm', kernelFunc: ta };
let aa;
const ra = {
  kernelName: v,
  backendName: 'wasm',
  setupFunc: function (e) {
    aa = e.wasm.cwrap(v, null, ['number', 'array', 'number', 'number', 'array', 'number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { inputs: a, backend: r, attrs: u } = e,
      { a: s, b: i } = a,
      { transposeA: o, transposeB: d } = u;
    if ('float32' !== s.dtype || 'float32' !== i.dtype) throw new Error('BatchMatMul for non non-float32 tensors not yet supported.');
    const p = s.shape.length,
      l = i.shape.length,
      c = o ? s.shape[p - 2] : s.shape[p - 1],
      m = d ? i.shape[l - 1] : i.shape[l - 2],
      f = o ? s.shape[p - 1] : s.shape[p - 2],
      h = d ? i.shape[l - 2] : i.shape[l - 1],
      b = s.shape.slice(0, -2),
      y = i.shape.slice(0, -2),
      _ = n.sizeFromShape(b),
      g = n.sizeFromShape(y),
      I = t.assertAndGetBroadcastShape(s.shape.slice(0, -2), i.shape.slice(0, -2)).concat([f, h]);
    n.assert(
      c === m,
      () =>
        `Error in matMul: inner shapes (${c}) and (${m}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${o} and transposeB=${d} must match.`,
    );
    const w = d ? [g, h, m] : [g, m, h],
      k = ta({ inputs: { x: s }, backend: r, attrs: { shape: o ? [_, c, f] : [_, f, c] } }),
      M = ta({ inputs: { x: i }, backend: r, attrs: { shape: w } }),
      S = r.dataIdMap.get(k.dataId).id,
      A = r.dataIdMap.get(M.dataId).id,
      v = o ? k.shape[2] : k.shape[1],
      x = d ? M.shape[1] : M.shape[2],
      F = Math.max(_, g),
      N = r.makeOutput([F, v, x], k.dtype),
      D = r.dataIdMap.get(N.dataId).id,
      R = new Uint8Array(new Int32Array(k.shape).buffer),
      E = new Uint8Array(new Int32Array(M.shape).buffer);
    return aa(S, R, k.shape.length, A, E, M.shape.length, o, d, D), r.disposeData(k.dataId), r.disposeData(M.dataId), (N.shape = I), N;
  },
};
function ua(e, t, a, r, u) {
  const i = x.isSliceContinous(r, t, a),
    o = n.sizeFromShape(a),
    d = n.computeStrides(r);
  if (i) {
    const n = x.computeFlatOffset(t, d);
    return 'string' === u ? e.slice(n, n + o) : e.subarray(n, n + o);
  }
  const p = 'string' === u ? s.fromUint8ToStringArray(e) : e,
    l = F(r, u, p),
    c = F(a, u);
  for (let e = 0; e < c.size; ++e) {
    const n = c.indexToLoc(e),
      a = n.map((e, n) => e + t[n]);
    c.set(l.get(...a), ...n);
  }
  return 'string' === u ? s.fromStringArrayToUint8(c.values) : c.values;
}
s.RowPartitionType;
class sa {
  constructor(e, t, a, r, u, s) {
    (this.separator = n.encodeString(e)),
      (this.nGramWidths = t),
      (this.leftPad = n.encodeString(a)),
      (this.rightPad = n.encodeString(r)),
      (this.padWidth = u),
      (this.preserveShort = s);
  }
  getPadWidth(e) {
    return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
  }
  getNumNGrams(e, t) {
    const n = this.getPadWidth(t);
    return Math.max(0, e + 2 * n - t + 1);
  }
  createNGrams(e, t, n, a, r, u) {
    for (let s = 0; s < r; ++s) {
      const i = this.getPadWidth(u),
        o = Math.max(0, i - s),
        d = Math.max(0, i - (r - (s + 1))),
        p = u - (o + d),
        l = t + (o > 0 ? 0 : s - i);
      let c = 0;
      c += o * this.leftPad.length;
      for (let t = 0; t < p; ++t) c += e[l + t].length;
      c += d * this.rightPad.length;
      (c += (o + d + p - 1) * this.separator.length), (n[a + s] = new Uint8Array(c));
      const m = n[a + s];
      let f = 0;
      const h = e => e.forEach(e => (m[f++] = e));
      for (let e = 0; e < o; ++e) h(this.leftPad), h(this.separator);
      for (let t = 0; t < p - 1; ++t) h(e[l + t]), h(this.separator);
      if (p > 0) {
        h(e[l + p - 1]);
        for (let e = 0; e < d; ++e) h(this.separator), h(this.rightPad);
      } else {
        for (let e = 0; e < d - 1; ++e) h(this.rightPad), h(this.separator);
        h(this.rightPad);
      }
    }
  }
  compute(e, t) {
    const a = e.length,
      r = t.length;
    if (r > 0) {
      let e = t[0];
      if (0 !== e) throw new Error(`First split value must be 0, got ${e}`);
      for (let n = 1; n < r; ++n) {
        let r = t[n] >= e;
        if (((r = r && t[n] <= a), !r)) throw new Error(`Invalid split value ${t[n]}, must be in [${e}, ${a}]`);
        e = t[n];
      }
      if (e !== a) throw new Error(`Last split value must be data size. Expected ${a}, got ${e}`);
    }
    const u = r - 1,
      s = n.getArrayFromDType('int32', r);
    if (0 === a || 0 === r) {
      const e = new Array(a);
      for (let e = 0; e <= u; ++e) s[e] = 0;
      return [e, s];
    }
    s[0] = 0;
    for (let e = 1; e <= u; ++e) {
      const n = t[e] - t[e - 1];
      let a = 0;
      this.nGramWidths.forEach(e => {
        a += this.getNumNGrams(n, e);
      }),
        this.preserveShort && n > 0 && 0 === a && (a = 1),
        (s[e] = s[e - 1] + a);
    }
    const i = new Array(s[u]);
    for (let n = 0; n < u; ++n) {
      const a = t[n];
      let r = s[n];
      if (
        (this.nGramWidths.forEach(u => {
          const s = t[n + 1] - t[n],
            o = this.getNumNGrams(s, u);
          this.createNGrams(e, a, i, r, o, u), (r += o);
        }),
        this.preserveShort && r === s[n])
      ) {
        const u = t[n + 1] - t[n];
        if (0 === u) continue;
        const s = u + 2 * this.padWidth,
          o = 1;
        this.createNGrams(e, a, i, r, o, s);
      }
    }
    return [i, s];
  }
}
function ia(e, t, n, a) {
  if (!e.length) return;
  if (0 === t.length) {
    for (let t = 0; t < e.length; ++t) a.push(e.subarray(t, t + 1));
    return;
  }
  if (1 === t.length) {
    const r = t[0];
    let u = e.indexOf(r);
    for (; -1 !== u; ) {
      const t = e.subarray(0, u);
      (n && 0 === t.length) || a.push(t), (u = (e = e.subarray(u + 1)).indexOf(r));
    }
    return void ((n && 0 === e.length) || a.push(e));
  }
  let r = 0;
  for (let u = 0; u < e.length + 1; u++)
    if (u === e.length || -1 !== t.indexOf(e[u])) {
      const t = e.subarray(r, u);
      (n && 0 === t.length) || a.push(t), (r = u + 1);
    }
}
function oa(e) {
  const {
      inputs: { x: t },
      attrs: { begin: a, size: r },
      backend: u,
    } = e,
    [s, i] = x.parseSliceParams(t, a, r),
    o = x.isSliceContinous(t.shape, s, i),
    d = u.readSync(t.dataId),
    p = u.makeOutput(i, t.dtype),
    l = n.computeStrides(t.shape),
    c = u.dataIdMap.get(p.dataId);
  if (o) {
    const e = x.computeFlatOffset(s, l);
    if ('string' === t.dtype) c.stringBytes = d.slice(e, e + n.sizeFromShape(i));
    else {
      u.typedArrayFromHeap(p).set(d.subarray(e, e + n.sizeFromShape(i)));
    }
    return p;
  }
  if ('string' === t.dtype) {
    const e = ua(d, s, i, t.shape, t.dtype);
    return (c.stringBytes = e), p;
  }
  const m = u.typedArrayFromHeap(p),
    f = t.shape.length;
  if (2 === f)
    !(function (e, t, n, a, r) {
      let u = 0;
      const s = a[0],
        i = a[1],
        o = s + r[0];
      for (let a = s; a < o; a++) {
        const s = a * t + i;
        n.set(e.subarray(s, s + r[1]), u), (u += r[1]);
      }
    })(d, l[0], m, s, i);
  else if (3 === f)
    !(function (e, t, n, a, r, u) {
      let s = 0;
      const i = r[0],
        o = r[1],
        d = r[2],
        p = i + u[0],
        l = o + u[1];
      for (let r = i; r < p; r++)
        for (let i = o; i < l; i++) {
          const o = r * t + i * n + d;
          a.set(e.subarray(o, o + u[2]), s), (s += u[2]);
        }
    })(d, l[0], l[1], m, s, i);
  else if (4 === f)
    !(function (e, t, n, a, r, u, s) {
      let i = 0;
      const o = u[0],
        d = u[1],
        p = u[2],
        l = o + s[0],
        c = d + s[1],
        m = p + s[2],
        f = u[3];
      for (let u = o; u < l; u++)
        for (let o = d; o < c; o++)
          for (let d = p; d < m; d++) {
            const p = u * t + o * n + d * a + f;
            r.set(e.subarray(p, p + s[3]), i), (i += s[3]);
          }
    })(d, l[0], l[1], l[2], m, s, i);
  else {
    const e = ua(d, s, i, t.shape, t.dtype);
    m.set(e);
  }
  return p;
}
const da = { kernelName: D, backendName: 'wasm', kernelFunc: oa };
const pa = {
  kernelName: R,
  backendName: 'wasm',
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { x: r } = t,
      { blockShape: u, crops: i } = a,
      o = u.reduce((e, t) => e * t),
      d = s.getReshaped(r.shape, u, o),
      p = s.getPermuted(d.length, u.length),
      l = s.getReshapedPermuted(r.shape, u, o),
      c = s.getSliceBeginCoords(i, u.length),
      m = s.getSliceSize(l, i, u.length),
      f = ta({ inputs: { x: r }, backend: n, attrs: { shape: d } }),
      h = En({ inputs: { x: f }, backend: n, attrs: { perm: p } }),
      b = ta({ inputs: { x: h }, backend: n, attrs: { shape: l } }),
      y = oa({ inputs: { x: b }, backend: n, attrs: { begin: c, size: m } });
    return n.disposeData(f.dataId), n.disposeData(h.dataId), n.disposeData(b.dataId), y;
  },
};
let la;
const ca = {
    kernelName: E,
    backendName: 'wasm',
    setupFunc: function (e) {
      la = e.wasm.cwrap(E, null, ['number', 'number', 'boolean', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: n, attrs: a } = e,
        { x: r, weights: u } = n,
        { size: s } = a,
        i = 0 !== u.shape.reduce((e, t) => e * t, 1),
        o = 1 === r.shape.length ? [s] : [r.shape[0], s],
        d = t.makeOutput(o, u.dtype);
      function p(e) {
        return t.dataIdMap.get(e.dataId).id;
      }
      return la(p(r), s, i, p(u), yn[u.dtype], p(d)), d;
    },
  },
  ma = An(W);
const fa = {
  kernelName: P,
  backendName: 'wasm',
  kernelFunc: function (e) {
    const { inputs: t, backend: n } = e,
      { s0: a, s1: r } = t,
      u = n.typedArrayFromHeap(a),
      i = n.typedArrayFromHeap(r),
      o = s.assertAndGetBroadcastShape(Array.from(u), Array.from(i));
    return n.makeOutput([o.length], 'int32', void 0, new Int32Array(o));
  },
};
function ha(e) {
  const {
      inputs: { x: t },
      attrs: { dtype: n },
      backend: a,
    } = e,
    r = a.makeOutput(t.shape, n),
    u = a.typedArrayFromHeap(t);
  return a.typedArrayFromHeap(r).set(u), r;
}
const ba = { kernelName: O, backendName: 'wasm', kernelFunc: ha },
  ya = wn(C);
let _a;
const ga = {
  kernelName: T,
  backendName: 'wasm',
  setupFunc: function (e) {
    _a = e.wasm.cwrap(T, null, ['number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { x: r } = t,
      { clipValueMin: u, clipValueMax: s } = a,
      i = n.dataIdMap.get(r.dataId).id,
      o = n.makeOutput(r.shape, r.dtype),
      d = n.dataIdMap.get(o.dataId).id;
    return _a(i, u, s, d), o;
  },
};
function Ia(e) {
  const { inputs: t, backend: a } = e,
    r = n.parseAxisParam(e.attrs.axis, t[0].shape)[0],
    u = t.map(e => e.shape);
  s.assertParamsConsistent(u, r);
  let i = s.computeOutShape(
    t.map(e => e.shape),
    r,
  );
  const o = t.filter(e => n.sizeFromShape(e.shape) > 0);
  if (1 === o.length) return Nn({ inputs: { x: o[0] }, backend: a });
  const d = a.makeOutput(i, t[0].dtype);
  if (0 === n.sizeFromShape(i)) return d;
  if ('string' === o[0].dtype) {
    const e = o.map(e => {
        const t = n.sizeFromShape(e.shape.slice(r));
        return ta({ inputs: { x: e }, backend: a, attrs: { shape: [-1, t] } });
      }),
      u = e.map(e => ({ vals: a.readSync(e.dataId), shape: e.shape }));
    i = s.computeOutShape(
      e.map(e => e.shape),
      1,
    );
    const p = 1 === e[0].shape[0],
      l = (function (e, t, a, r) {
        const u = n.getArrayFromDType(a, n.sizeFromShape(t));
        if (r && 'string' !== a) {
          let t = 0;
          e.forEach(e => {
            const a = n.sizeFromShape(e.shape);
            u.set(e.vals, t), (t += a);
          });
        } else {
          let n = 0;
          e.forEach(e => {
            const r = 'string' === a ? s.fromUint8ToStringArray(e.vals) : e.vals;
            let i = 0;
            for (let a = 0; a < e.shape[0]; ++a) {
              const s = a * t[1] + n;
              for (let t = 0; t < e.shape[1]; ++t) u[s + t] = r[i++];
            }
            n += e.shape[1];
          });
        }
        return u;
      })(u, i, t[0].dtype, p),
      c = s.computeOutShape(
        o.map(e => e.shape),
        r,
      );
    d.shape = c;
    return (a.dataIdMap.get(d.dataId).stringBytes = s.fromStringArrayToUint8(l)), e.forEach(e => a.disposeData(e.dataId)), d;
  }
  const p = n.sizeFromShape(o[0].shape.slice(0, r));
  let l = 0;
  const c = o.map(e => {
      const t = n.sizeFromShape(e.shape.slice(r));
      return (l += t), t;
    }),
    m = o.map(e => a.typedArrayFromHeap(e)),
    f = a.typedArrayFromHeap(d);
  for (let e = 0; e < p; e++) {
    let t = e * l;
    for (let n = 0; n < m.length; n++) {
      const a = c[n],
        r = e * a,
        u = m[n].subarray(r, r + a);
      f.set(u, t), (t += a);
    }
  }
  return d;
}
const wa = { kernelName: z, backendName: 'wasm', kernelFunc: Ia };
let ka;
const Ma = {
  kernelName: H,
  backendName: 'wasm',
  setupFunc: function (e) {
    ka = e.wasm.cwrap(H, null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, attrs: n, backend: a } = e,
      { x: r, filter: u } = t,
      i = a.dataIdMap.get(r.dataId).id,
      o = a.dataIdMap.get(u.dataId).id,
      { strides: d, dilations: p, pad: l, dimRoundingMode: c, dataFormat: m } = n,
      f = s.convertConv2DDataFormat(m),
      h = s.computeConv2DInfo(r.shape, u.shape, d, p, l, c, !1, f),
      b = h.filterHeight,
      y = h.filterWidth,
      _ = h.padInfo.top,
      g = h.padInfo.right,
      I = h.padInfo.bottom,
      w = h.padInfo.left,
      k = h.dilationHeight,
      M = h.dilationWidth,
      S = h.strideHeight,
      A = h.strideWidth,
      v = h.inChannels,
      x = h.outChannels,
      F = 'SAME' === h.padInfo.type ? 1 : 0;
    if ('channelsLast' !== h.dataFormat)
      throw new Error(`wasm backend Conv2D does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);
    const N = a.makeOutput(h.outShape, 'float32'),
      D = a.dataIdMap.get(N.dataId).id;
    return ka(i, r.shape[0], r.shape[1], r.shape[2], o, b, y, _, g, I, w, F, k, M, S, A, v, x, D), N;
  },
};
let Sa;
const Aa = {
  kernelName: B,
  backendName: 'wasm',
  setupFunc: function (e) {
    Sa = e.wasm.cwrap(B, null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { dy: u, filter: i } = a,
      { strides: o, pad: d, dataFormat: p, dimRoundingMode: l, inputShape: c } = r,
      m = s.convertConv2DDataFormat(p),
      f = s.computeConv2DInfo(c, i.shape, o, 1, d, l, !1, m),
      {
        batchSize: h,
        filterHeight: b,
        filterWidth: y,
        inChannels: _,
        inHeight: g,
        inWidth: I,
        outChannels: w,
        outHeight: k,
        outWidth: M,
        strideHeight: S,
        strideWidth: A,
      } = f,
      v = b - 1 - f.padInfo.top,
      x = y - 1 - f.padInfo.left,
      F = 'channelsLast' === f.dataFormat,
      N = n.computeStrides(f.inShape),
      D = n.computeStrides(u.shape),
      [R, E, W] = n.computeStrides(i.shape),
      P = N[0],
      O = F ? N[1] : N[2],
      C = F ? N[2] : 1,
      T = F ? 1 : N[1],
      z = D[0],
      H = F ? D[1] : D[2],
      B = F ? D[2] : 1,
      L = F ? 1 : D[1],
      U = t.makeOutput(f.inShape, 'float32'),
      j = t.dataIdMap.get(U.dataId).id,
      G = t.dataIdMap.get(u.dataId).id,
      q = t.dataIdMap.get(i.dataId).id;
    return Sa(G, q, h, b, y, g, I, _, k, M, w, S, A, v, x, R, E, W, P, O, C, T, z, H, B, L, j), U;
  },
};
let va;
const xa = {
  kernelName: L,
  backendName: 'wasm',
  setupFunc: function (e) {
    va = e.wasm.cwrap(L, null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { x: r, filter: u } = t,
      { strides: i, pad: o, dilations: d } = a;
    if ('float32' !== r.dtype) throw new Error(`Tensor x must have dtype float32, got ${r.dtype}`);
    if ('float32' !== u.dtype) throw new Error(`Tensor filter must have dtype float32, got ${u.dtype}`);
    const p = s.computeConv3DInfo(r.shape, u.shape, i, d, o),
      l = n.makeOutput(p.outShape, r.dtype);
    return (
      va(
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(u.dataId).id,
        n.dataIdMap.get(l.dataId).id,
        p.batchSize,
        p.inDepth,
        p.inHeight,
        p.inWidth,
        p.inChannels,
        p.outDepth,
        p.outHeight,
        p.outWidth,
        p.outChannels,
        p.strideDepth,
        p.strideHeight,
        p.strideWidth,
        p.dilationDepth,
        p.dilationHeight,
        p.dilationWidth,
        p.filterDepth,
        p.filterHeight,
        p.filterWidth,
        p.padInfo.front,
        p.padInfo.top,
        p.padInfo.left,
      ),
      l
    );
  },
};
let Fa;
const Na = {
  kernelName: U,
  backendName: 'wasm',
  setupFunc: function (e) {
    Fa = e.wasm.cwrap(U, null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { x: r, dy: u } = t,
      { strides: i, pad: o, filterShape: d } = a;
    if ('float32' !== r.dtype) throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);
    if ('float32' !== u.dtype) throw new Error(`Tensor filter must have dtype float32, got ${u.dtype}`);
    const p = s.computeConv3DInfo(r.shape, d, i, 1, o),
      l = n.makeOutput(p.filterShape, u.dtype);
    return (
      Fa(
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(u.dataId).id,
        n.dataIdMap.get(l.dataId).id,
        p.batchSize,
        p.inDepth,
        p.inHeight,
        p.inWidth,
        p.inChannels,
        p.outDepth,
        p.outHeight,
        p.outWidth,
        p.outChannels,
        p.strideDepth,
        p.strideHeight,
        p.strideWidth,
        p.dilationDepth,
        p.dilationHeight,
        p.dilationWidth,
        p.filterDepth,
        p.filterHeight,
        p.filterWidth,
        p.padInfo.front,
        p.padInfo.top,
        p.padInfo.left,
      ),
      l
    );
  },
};
let Da;
const Ra = {
    kernelName: j,
    backendName: 'wasm',
    setupFunc: function (e) {
      Da = e.wasm.cwrap(j, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { dy: r, filter: u } = t,
        { pad: i, strides: o, inputShape: d } = a;
      if ('float32' !== r.dtype) throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);
      if ('float32' !== u.dtype) throw new Error(`Tensor filter must have dtype float32, got ${u.dtype}`);
      const p = s.computeConv3DInfo(d, u.shape, o, 1, i),
        l = n.makeOutput(p.inShape, r.dtype);
      return (
        Da(
          n.dataIdMap.get(u.dataId).id,
          n.dataIdMap.get(r.dataId).id,
          n.dataIdMap.get(l.dataId).id,
          p.batchSize,
          p.inDepth,
          p.inHeight,
          p.inWidth,
          p.inChannels,
          p.outDepth,
          p.outHeight,
          p.outWidth,
          p.outChannels,
          p.strideDepth,
          p.strideHeight,
          p.strideWidth,
          p.dilationDepth,
          p.dilationHeight,
          p.dilationWidth,
          p.filterDepth,
          p.filterHeight,
          p.filterWidth,
          p.padInfo.front,
          p.padInfo.top,
          p.padInfo.left,
        ),
        l
      );
    },
  },
  Ea = wn(G),
  Wa = wn(q);
var Pa;
let Oa;
!(function (e) {
  (e[(e.bilinear = 0)] = 'bilinear'), (e[(e.nearest = 1)] = 'nearest');
})(Pa || (Pa = {}));
const Ca = {
  kernelName: V,
  backendName: 'wasm',
  setupFunc: function (e) {
    Oa = e.wasm.cwrap(V, null, ['number', 'number', 'number', 'number', 'array', 'number', 'number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: n, attrs: a } = e,
      { method: r, extrapolationValue: u, cropSize: s } = a,
      { image: i, boxes: o, boxInd: d } = n,
      p = o.shape[0],
      [l, c] = s,
      m = [p, l, c, i.shape[3]];
    let f,
      h = t.dataIdMap.get(i.dataId);
    'float32' !== i.dtype && ((f = ha({ backend: t, inputs: { x: i }, attrs: { dtype: 'float32' } })), (h = t.dataIdMap.get(f.dataId)));
    const b = h.id,
      y = t.dataIdMap.get(o.dataId).id,
      _ = t.dataIdMap.get(d.dataId).id,
      g = t.makeOutput(m, 'float32'),
      I = t.dataIdMap.get(g.dataId).id,
      w = new Uint8Array(new Int32Array(i.shape).buffer);
    return Oa(b, y, _, p, w, l, c, Pa[r], u, I), null != f && t.disposeData(f.dataId), g;
  },
};
let Ta;
const za = {
  kernelName: $,
  backendName: 'wasm',
  setupFunc: function (e) {
    Ta = e.wasm.cwrap($, null, ['number', 'number', 'number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: a, attrs: r } = e,
      { x: u } = t,
      { axis: i, exclusive: o, reverse: d } = r,
      p = u.shape.length;
    n.assert('float32' === u.dtype || 'int32' === u.dtype, () => `cumprod does not support ${u.dtype} tensors in the WASM backend`);
    const l = s.getAxesPermutation([i], p);
    let c = u;
    null !== l && (c = En({ inputs: { x: u }, attrs: { perm: l }, backend: a }));
    const m = s.getInnerMostAxes(1, p)[0];
    s.assertAxesAreInnerMostDims('cumprod', [m], p);
    const f = a.makeOutput(c.shape, c.dtype),
      h = c.shape[m],
      b = a.dataIdMap.get(c.dataId).id,
      y = a.dataIdMap.get(f.dataId).id;
    Ta(b, o ? 1 : 0, d ? 1 : 0, h, y, yn[u.dtype]);
    let _ = f;
    if (null !== l) {
      (_ = En({ inputs: { x: f }, attrs: { perm: s.getUndoAxesPermutation(l) }, backend: a })),
        a.disposeData(c.dataId),
        a.disposeData(f.dataId);
    }
    return _;
  },
};
let Ha;
const Ba = {
  kernelName: K,
  backendName: 'wasm',
  setupFunc: function (e) {
    Ha = e.wasm.cwrap(K, null, ['number', 'number', 'number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: a, attrs: r } = e,
      { x: u } = t,
      { axis: i, exclusive: o, reverse: d } = r,
      p = u.shape.length;
    n.assert('float32' === u.dtype || 'int32' === u.dtype, () => `cumsum does not support ${u.dtype} tensors in the WASM backend`);
    const l = s.getAxesPermutation([i], p);
    let c = u;
    null !== l && (c = En({ inputs: { x: u }, attrs: { perm: l }, backend: a }));
    const m = s.getInnerMostAxes(1, p)[0];
    s.assertAxesAreInnerMostDims('cumsum', [m], p);
    const f = a.makeOutput(c.shape, c.dtype),
      h = c.shape[m],
      b = a.dataIdMap.get(c.dataId).id,
      y = a.dataIdMap.get(f.dataId).id;
    Ha(b, o ? 1 : 0, d ? 1 : 0, h, y, yn[u.dtype]);
    let _ = f;
    if (null !== l) {
      (_ = En({ inputs: { x: f }, attrs: { perm: s.getUndoAxesPermutation(l) }, backend: a })),
        a.disposeData(c.dataId),
        a.disposeData(f.dataId);
    }
    return _;
  },
};
let La;
const Ua = {
  kernelName: X,
  backendName: 'wasm',
  setupFunc: function (e) {
    La = e.wasm.cwrap('DenseBincount', null, ['number', 'array', 'number', 'number', 'boolean', 'number', 'number', 'boolean', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: n, attrs: a } = e,
      { x: r, weights: u } = n,
      { size: s, binaryOutput: i } = a,
      o = 0 !== u.shape.reduce((e, t) => e * t, 1),
      d = 1 === r.shape.length ? [s] : [r.shape[0], s],
      p = t.makeOutput(d, u.dtype);
    function l(e) {
      return t.dataIdMap.get(e.dataId).id;
    }
    return La(l(r), new Uint8Array(new Int32Array(r.shape).buffer), r.shape.length, s, o, l(u), yn[u.dtype], i, l(p)), p;
  },
};
let ja;
const Ga = {
  kernelName: Q,
  backendName: 'wasm',
  setupFunc: function (e) {
    ja = e.wasm.cwrap(Q, null, ['number', 'number', 'number', 'array', 'number', 'array', 'array', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { x: u } = a,
      { blockSize: s, dataFormat: i } = r,
      o = u.shape[0],
      d = ('NHWC' === i ? u.shape[1] : u.shape[2]) * s,
      p = ('NHWC' === i ? u.shape[2] : u.shape[3]) * s,
      l = ('NHWC' === i ? u.shape[3] : u.shape[1]) / (s * s),
      c = 'NHWC' === i ? [o, d, p, l] : [o, l, d, p],
      m = t.makeOutput(c, 'float32'),
      f = t.dataIdMap.get(u.dataId).id,
      h = new Uint8Array(new Int32Array(n.computeStrides(u.shape)).buffer),
      b = new Uint8Array(new Int32Array(c).buffer),
      y = new Uint8Array(new Int32Array(n.computeStrides(c)).buffer),
      _ = t.dataIdMap.get(m.dataId).id;
    return ja(f, s, 'NHWC' === i ? 1 : 0, h, u.shape.length - 1, b, y, c.length, _), m;
  },
};
let qa;
const Va = {
  kernelName: J,
  backendName: 'wasm',
  setupFunc: function (e) {
    qa = e.wasm.cwrap(J, null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, attrs: n, backend: a } = e,
      { x: r, filter: u } = t,
      i = a.dataIdMap.get(r.dataId).id,
      o = a.dataIdMap.get(u.dataId).id,
      { strides: d, dilations: p, pad: l, dimRoundingMode: c } = n,
      m = null == p ? [1, 1] : p,
      f = s.computeConv2DInfo(r.shape, u.shape, d, m, l, c, !0),
      h = f.filterHeight,
      b = f.filterWidth,
      y = f.padInfo.top,
      _ = f.padInfo.right,
      g = f.padInfo.bottom,
      I = f.padInfo.left,
      w = f.dilationHeight,
      k = f.dilationWidth,
      M = f.strideHeight,
      S = f.strideWidth,
      A = f.inChannels,
      v = f.outChannels,
      x = 'SAME' === f.padInfo.type ? 1 : 0;
    if ('channelsLast' !== f.dataFormat)
      throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);
    const F = a.makeOutput(f.outShape, 'float32'),
      N = a.dataIdMap.get(F.dataId).id;
    return qa(i, r.shape[0], r.shape[1], r.shape[2], o, h, b, y, _, g, I, x, w, k, M, S, A, v, N), F;
  },
};
let $a;
const Ka = {
  kernelName: Z,
  backendName: 'wasm',
  setupFunc: function (e) {
    $a = e.wasm.cwrap('Diag', null, ['number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: a } = e,
      { x: r } = t,
      u = n.sizeFromShape(r.shape),
      s = a.makeOutput([...r.shape, ...r.shape], r.dtype);
    return $a(a.dataIdMap.get(r.dataId).id, yn[r.dtype], u, a.dataIdMap.get(s.dataId).id), s;
  },
};
let Xa;
const Qa = {
  kernelName: Y,
  backendName: 'wasm',
  setupFunc: function (e) {
    Xa = e.wasm.cwrap(Y, null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { x: r, filter: u } = t,
      { strides: i, pad: o, dilations: d } = a;
    if (r.dtype !== u.dtype) throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${r.dtype} and ${u.dtype}`);
    const p = s.computeDilation2DInfo(r.shape, u.shape, i, o, 'NHWC', d),
      l = n.makeOutput(p.outShape, r.dtype);
    return (
      Xa(
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(u.dataId).id,
        n.dataIdMap.get(l.dataId).id,
        yn[r.dtype],
        p.batchSize,
        p.inChannels,
        p.inHeight,
        p.inWidth,
        p.outHeight,
        p.outWidth,
        p.strideHeight,
        p.strideWidth,
        p.dilationHeight,
        p.dilationWidth,
        p.filterHeight,
        p.filterWidth,
        p.padInfo.top,
        p.padInfo.left,
      ),
      l
    );
  },
};
let Ja;
const Za = {
  kernelName: ee,
  backendName: 'wasm',
  setupFunc: function (e) {
    Ja = e.wasm.cwrap(ee, null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { x: r, filter: u, dy: i } = t,
      { strides: o, pad: d, dilations: p } = a;
    if (r.dtype !== u.dtype || r.dtype !== i.dtype)
      throw new Error(
        `Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${u.dtype}, and ${i.dtype}`,
      );
    const l = s.computeDilation2DInfo(r.shape, u.shape, o, d, 'NHWC', p),
      c = n.makeOutput(u.shape, u.dtype);
    return (
      Ja(
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(u.dataId).id,
        n.dataIdMap.get(i.dataId).id,
        n.dataIdMap.get(c.dataId).id,
        yn[r.dtype],
        l.batchSize,
        l.inChannels,
        l.inHeight,
        l.inWidth,
        l.outHeight,
        l.outWidth,
        l.strideHeight,
        l.strideWidth,
        l.dilationHeight,
        l.dilationWidth,
        l.filterHeight,
        l.filterWidth,
        l.padInfo.top,
        l.padInfo.left,
      ),
      c
    );
  },
};
let Ya;
const er = {
    kernelName: te,
    backendName: 'wasm',
    setupFunc: function (e) {
      Ya = e.wasm.cwrap(te, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { x: r, filter: u, dy: i } = t,
        { strides: o, pad: d, dilations: p } = a;
      if (r.dtype !== u.dtype || r.dtype !== i.dtype)
        throw new Error(
          `Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${u.dtype}, and ${i.dtype}`,
        );
      const l = s.computeDilation2DInfo(r.shape, u.shape, o, d, 'NHWC', p),
        c = n.makeOutput(r.shape, r.dtype);
      return (
        Ya(
          n.dataIdMap.get(r.dataId).id,
          n.dataIdMap.get(u.dataId).id,
          n.dataIdMap.get(i.dataId).id,
          n.dataIdMap.get(c.dataId).id,
          yn[r.dtype],
          l.batchSize,
          l.inChannels,
          l.inHeight,
          l.inWidth,
          l.outHeight,
          l.outWidth,
          l.strideHeight,
          l.strideWidth,
          l.dilationHeight,
          l.dilationWidth,
          l.filterHeight,
          l.filterWidth,
          l.padInfo.top,
          l.padInfo.left,
        ),
        c
      );
    },
  },
  tr = wn(ne);
let nr;
const ar = {
    kernelName: ae,
    backendName: 'wasm',
    setupFunc: function (e) {
      nr = e.wasm.cwrap(ae, null, ['number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n } = e,
        { dy: a, y: r } = t,
        u = n.makeOutput(r.shape, 'float32'),
        s = e => n.dataIdMap.get(e.dataId).id;
      return nr(s(r), s(a), s(u)), u;
    },
  },
  rr = An(re, 0, 'bool'),
  ur = wn(ue),
  sr = wn(se, 'float32');
function ir(e) {
  const { inputs: t, attrs: a, backend: r } = e,
    { input: u } = t,
    { dim: s } = a,
    i = u.shape.length,
    o = u.shape.slice();
  let d = s;
  return (
    s < 0 && (n.assert(-(i + 1) <= s, () => `Axis must be in the interval [${-(i + 1)}, ${i}]`), (d = i + s + 1)),
    o.splice(d, 0, 1),
    ta({ inputs: { x: u }, backend: r, attrs: { shape: o } })
  );
}
const or = { kernelName: ie, backendName: 'wasm', kernelFunc: ir },
  dr = wn(oe, 'float32');
function pr(e) {
  const {
    attrs: { shape: t, value: a },
    backend: r,
  } = e;
  let {
    attrs: { dtype: u },
  } = e;
  u = u || n.inferDtype(a);
  const s = r.makeOutput(t, u);
  return r.typedArrayFromHeap(s).fill(a), s;
}
const lr = { kernelName: de, backendName: 'wasm', kernelFunc: pr };
let cr;
const mr = {
    kernelName: pe,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: t, backend: n } = e,
        { image: a } = t,
        r = n.makeOutput(a.shape, a.dtype),
        u = n.dataIdMap.get(a.dataId).id,
        s = n.dataIdMap.get(r.dataId).id,
        [i, o, d, p] = a.shape;
      return cr(u, i, o, d, p, s), r;
    },
    setupFunc: function (e) {
      cr = e.wasm.cwrap(pe, null, ['number', 'number', 'number', 'number', 'number', 'number']);
    },
  },
  fr = wn(le),
  hr = An(ce);
let br;
const yr = {
  kernelName: me,
  backendName: 'wasm',
  setupFunc: function (e) {
    br = e.wasm.cwrap(me, null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { varianceEpsilon: u } = r,
      { x: s, mean: i, variance: o, offset: d, scale: p } = a,
      l = t.dataIdMap.get(s.dataId).id,
      c = t.dataIdMap.get(i.dataId).id,
      m = t.dataIdMap.get(o.dataId).id,
      f = null != d ? t.dataIdMap.get(d.dataId).id : 0,
      h = null != p ? t.dataIdMap.get(p.dataId).id : 0,
      b = t.makeOutput(s.shape, s.dtype);
    if (0 === n.sizeFromShape(s.shape)) return b;
    const y = t.dataIdMap.get(b.dataId).id;
    return br(l, c, m, f, h, u, y), b;
  },
};
let _r;
const gr = {
  kernelName: fe,
  backendName: 'wasm',
  setupFunc: function (e) {
    _r = e.wasm.cwrap(fe, null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, attrs: n, backend: a } = e,
      { x: r, filter: u, bias: i, preluActivationWeights: o } = t,
      { strides: d, pad: p, dilations: l, dataFormat: c, dimRoundingMode: m, activation: f, leakyreluAlpha: h } = n,
      b = s.computeConv2DInfo(r.shape, u.shape, d, l, p, m),
      y = _n[f];
    if (null == y) throw new Error(`${f} activation not yet supported for FusedConv2D in the wasm backend.`);
    const _ = a.dataIdMap.get(r.dataId).id,
      g = a.dataIdMap.get(u.dataId).id,
      I = b.outChannels;
    let w = 0;
    if (null != i) {
      const e = a.dataIdMap.get(i.dataId);
      if (1 !== e.shape.length) throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);
      if (e.shape[0] !== I) throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${I})`);
      w = e.id;
    }
    const k = b.filterHeight,
      M = b.filterWidth,
      S = b.padInfo.top,
      A = b.padInfo.right,
      v = b.padInfo.bottom,
      x = b.padInfo.left,
      F = b.dilationHeight,
      N = b.dilationWidth,
      D = b.strideHeight,
      R = b.strideWidth,
      E = b.inChannels,
      W = 'SAME' === b.padInfo.type ? 1 : 0,
      P = b.batchSize,
      O = b.inHeight,
      C = b.inWidth;
    if ('NHWC' !== c) throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);
    const T = a.makeOutput(b.outShape, 'float32'),
      z = a.dataIdMap.get(T.dataId).id,
      H = null == o ? 0 : a.dataIdMap.get(o.dataId).id;
    return _r(_, P, O, C, g, k, M, w, S, A, v, x, W, F, N, D, R, E, I, y, H, h || 0, z), T;
  },
};
let Ir;
const wr = {
  kernelName: he,
  backendName: 'wasm',
  setupFunc: function (e) {
    Ir = e.wasm.cwrap(he, null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, attrs: n, backend: a } = e,
      { x: r, filter: u, bias: i, preluActivationWeights: o } = t,
      { strides: d, pad: p, dilations: l, dataFormat: c, dimRoundingMode: m, activation: f, leakyreluAlpha: h } = n,
      b = s.computeConv2DInfo(r.shape, u.shape, d, l, p, m, !0),
      y = _n[f];
    if (null == y) throw new Error(`${f} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);
    const _ = a.dataIdMap.get(r.dataId).id,
      g = a.dataIdMap.get(u.dataId).id,
      I = b.outChannels;
    let w = 0;
    if (null != i) {
      const e = a.dataIdMap.get(i.dataId);
      if (1 !== e.shape.length) throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);
      if (e.shape[0] !== I)
        throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${I})`);
      w = e.id;
    }
    const k = b.filterHeight,
      M = b.filterWidth,
      S = b.padInfo.top,
      A = b.padInfo.right,
      v = b.padInfo.bottom,
      x = b.padInfo.left,
      F = b.dilationHeight,
      N = b.dilationWidth,
      D = b.strideHeight,
      R = b.strideWidth,
      E = b.inChannels,
      W = 'SAME' === b.padInfo.type ? 1 : 0,
      P = b.batchSize,
      O = b.inHeight,
      C = b.inWidth;
    if ('NHWC' !== c) throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);
    const T = a.makeOutput(b.outShape, 'float32'),
      z = a.dataIdMap.get(T.dataId).id,
      H = null == o ? 0 : a.dataIdMap.get(o.dataId).id;
    return Ir(_, P, O, C, g, k, M, w, S, A, v, x, W, F, N, D, R, E, I, y, H, h || 0, z), T;
  },
};
let kr;
const Mr = {
  kernelName: be,
  backendName: 'wasm',
  setupFunc: function (e) {
    kr = e.wasm.cwrap(be, null, ['number', 'number', 'number', 'number', 'number', 'number', 'array', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: n } = e,
      { params: a, indices: r } = n,
      [u, s, i, o] = ye.prepareAndValidate(a, r),
      d = t.makeOutput(u, a.dtype);
    if (0 === s) return d;
    const p = r.shape,
      l = p[p.length - 1],
      c = t.dataIdMap.get(a.dataId).id,
      m = t.dataIdMap.get(r.dataId).id,
      f = new Uint8Array(new Int32Array(o).buffer),
      h = t.dataIdMap.get(d.dataId).id;
    return kr(c, yn[a.dtype], m, s, l, i, f, h), d;
  },
};
let Sr;
const Ar = {
    kernelName: _e,
    backendName: 'wasm',
    setupFunc: function (e) {
      Sr = e.wasm.cwrap('Gather', null, ['number', 'number', 'array', 'number', 'number', 'number', 'array', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: a, attrs: r } = e,
        { x: u, indices: i } = a,
        { axis: o, batchDims: d } = r,
        p = n.parseAxisParam(o, u.shape)[0],
        l = t.readSync(i.dataId),
        c = u.shape[p];
      for (let e = 0; e < l.length; ++e) {
        const t = l[e];
        n.assert(t <= c - 1 && t >= 0, () => `GatherV2: the index value ${t} is not in [0, ${c - 1}]`);
      }
      const m = s.segment_util.collectGatherOpShapeInfo(u, i, p, d),
        f = ta({ inputs: { x: u }, attrs: { shape: [m.batchSize, m.outerSize, m.dimSize, m.sliceSize] }, backend: t }),
        h = n.sizeFromShape(i.shape),
        b = ta({ inputs: { x: i }, attrs: { shape: [m.batchSize, h / m.batchSize] }, backend: t }),
        y = [m.batchSize, m.outerSize, h / m.batchSize, m.sliceSize],
        _ = t.makeOutput(y, u.dtype);
      if (0 === n.sizeFromShape(u.shape)) return _;
      const g = f.shape.length - 1,
        I = t.dataIdMap.get(f.dataId).id,
        w = t.dataIdMap.get(b.dataId).id,
        k = t.dataIdMap.get(_.dataId).id,
        M = new Uint8Array(new Int32Array(n.computeStrides(f.shape)).buffer),
        S = new Uint8Array(new Int32Array(n.computeStrides(y)).buffer);
      return Sr(I, yn[u.dtype], M, g, w, m.batchSize, S, k), t.disposeData(f.dataId), t.disposeData(b.dataId), (_.shape = m.outputShape), _;
    },
  },
  vr = An(ge, 0, 'bool'),
  xr = An(Ie, 0, 'bool'),
  Fr = wn(we, 'bool'),
  Nr = wn(ke, 'bool'),
  Dr = wn(Me, 'bool');
let Rr;
const Er = {
    kernelName: Se,
    backendName: 'wasm',
    setupFunc: function (e) {
      Rr = e.wasm.cwrap(Se, null, ['number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const {
          inputs: { x: t },
          attrs: { alpha: a },
          backend: r,
        } = e,
        u = r.dataIdMap.get(t.dataId).id,
        s = r.makeOutput(t.shape, 'float32');
      if (0 !== n.sizeFromShape(t.shape)) {
        const e = r.dataIdMap.get(s.dataId).id;
        Rr(u, yn[t.dtype], a, e);
      }
      return s;
    },
  },
  Wr = An(Ae, 0, 'bool'),
  Pr = An(ve, 0, 'bool');
let Or;
const Cr = {
    kernelName: xe,
    backendName: 'wasm',
    setupFunc: function (e) {
      Or = e.wasm.cwrap(xe, null, ['number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { attrs: t, backend: n } = e,
        { start: a, stop: r, num: u } = t,
        s = Math.floor(u),
        i = n.makeOutput([s], 'float32');
      return Or(n.dataIdMap.get(i.dataId).id, a, r, s), i;
    },
  },
  Tr = wn(Fe),
  zr = wn(Ne),
  Hr = An(De, 0, 'bool'),
  Br = wn(Re),
  Lr = An(Ee, 0, 'bool'),
  Ur = An(We, 0, 'bool');
let jr;
const Gr = {
  kernelName: Pe,
  backendName: 'wasm',
  setupFunc: function (e) {
    jr = e.wasm.cwrap(Pe, null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { x: r } = t,
      { depthRadius: u, bias: s, alpha: i, beta: o } = a;
    if ('float32' !== r.dtype) throw new Error('LRN error: x must have dtype float32');
    const d = n.makeOutput(r.shape, r.dtype);
    return jr(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(d.dataId).id, r.shape[3], u, s, i, o), d;
  },
};
let qr;
const Vr = {
  kernelName: Oe,
  backendName: 'wasm',
  setupFunc: function (e) {
    qr = e.wasm.cwrap(Oe, null, ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { x: r, y: u, dy: s } = t,
      { depthRadius: i, bias: o, alpha: d, beta: p } = a;
    if ('float32' !== r.dtype || 'float32' !== u.dtype || 'float32' !== s.dtype)
      throw new Error('LRNGrad error: x, y, and dy must have dtype float32');
    const l = n.makeOutput(r.shape, r.dtype);
    return (
      qr(
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(u.dataId).id,
        n.dataIdMap.get(s.dataId).id,
        n.dataIdMap.get(l.dataId).id,
        s.shape[3],
        i,
        o,
        d,
        p,
      ),
      l
    );
  },
};
let $r;
const Kr = {
    kernelName: Ce,
    backendName: 'wasm',
    setupFunc: function (e) {
      $r = e.wasm.cwrap(Ce, null, ['number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: a, attrs: r } = e,
        { reductionIndices: u, keepDims: i } = r,
        { x: o } = a;
      let d = t.dataIdMap.get(o.dataId).id,
        p = o;
      const { transposed: l, axes: c, originalAxes: m, inputWasTransposed: f } = Pn(o, u, t);
      if (f) {
        (p = l), (d = t.dataIdMap.get(l.dataId).id);
      }
      const h = p.shape.length;
      s.assertAxesAreInnerMostDims('max', c, h);
      const [b, y] = s.computeOutAndReduceShapes(p.shape, c),
        _ = n.sizeFromShape(y),
        g = t.makeOutput(b, o.dtype);
      if (0 !== n.sizeFromShape(p.shape)) {
        const e = t.dataIdMap.get(g.dataId).id;
        $r(d, yn[o.dtype], _, e);
      }
      if ((f && t.disposeData(l.dataId), i)) {
        const e = s.expandShapeToKeepDim(g.shape, m);
        g.shape = e;
      }
      return g;
    },
  },
  Xr = An(Te);
let Qr;
const Jr = {
  kernelName: ze,
  backendName: 'wasm',
  setupFunc: function (e) {
    Qr = e.wasm.cwrap(ze, null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, attrs: a, backend: r } = e,
      u = t.x,
      i = r.dataIdMap.get(u.dataId).id;
    n.assert('float32' === u.dtype, () => `Error in MaxPool: only float32 input is supported. Got ${u.dtype}.`);
    const { filterSize: o, strides: d, pad: p, dimRoundingMode: l } = a,
      c = s.computePool2DInfo(u.shape, o, d, 1, p, l),
      m = c.filterHeight,
      f = c.filterWidth,
      h = c.padInfo.top,
      b = c.padInfo.right,
      y = c.padInfo.bottom,
      _ = c.padInfo.left,
      g = c.dilationHeight,
      I = c.dilationWidth,
      w = c.strideHeight,
      k = c.strideWidth,
      M = c.inChannels,
      S = c.outChannels;
    if ('channelsLast' !== c.dataFormat)
      throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);
    const A = r.makeOutput(c.outShape, 'float32'),
      v = r.dataIdMap.get(A.dataId).id;
    return Qr(i, u.shape[0], u.shape[1], u.shape[2], m, f, h, b, y, _, g, I, w, k, M, S, v), A;
  },
};
let Zr;
const Yr = {
  kernelName: He,
  backendName: 'wasm',
  setupFunc: function (e) {
    Zr = e.wasm.cwrap('MaxPool3D', null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { x: r } = t,
      { filterSize: u, strides: i, pad: o, dimRoundingMode: d, dataFormat: p } = a,
      l = s.computePool3DInfo(r.shape, u, i, 1, o, d, p),
      c = n.makeOutput(l.outShape, r.dtype);
    return (
      Zr(
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(c.dataId).id,
        l.batchSize,
        l.inChannels,
        l.inDepth,
        l.inHeight,
        l.inWidth,
        l.outDepth,
        l.outHeight,
        l.outWidth,
        l.strideDepth,
        l.strideHeight,
        l.strideWidth,
        l.dilationDepth,
        l.dilationHeight,
        l.dilationWidth,
        l.effectiveFilterDepth,
        l.effectiveFilterHeight,
        l.effectiveFilterWidth,
        l.padInfo.front,
        l.padInfo.top,
        l.padInfo.left,
      ),
      c
    );
  },
};
let eu;
const tu = {
  kernelName: Be,
  backendName: 'wasm',
  setupFunc: function (e) {
    eu = e.wasm.cwrap('MaxPool3DGrad', null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { dy: r, input: u } = t,
      { filterSize: i, strides: o, pad: d, dimRoundingMode: p } = a,
      l = s.computePool3DInfo(u.shape, i, o, 1, d, p),
      c = n.makeOutput(u.shape, u.dtype);
    return (
      eu(
        n.dataIdMap.get(u.dataId).id,
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(c.dataId).id,
        l.batchSize,
        l.inChannels,
        l.inDepth,
        l.inHeight,
        l.inWidth,
        l.outDepth,
        l.outHeight,
        l.outWidth,
        l.strideDepth,
        l.strideHeight,
        l.strideWidth,
        l.dilationDepth,
        l.dilationHeight,
        l.dilationWidth,
        l.effectiveFilterDepth,
        l.effectiveFilterHeight,
        l.effectiveFilterWidth,
        l.padInfo.front,
        l.padInfo.top,
        l.padInfo.left,
      ),
      c
    );
  },
};
let nu;
const au = {
  kernelName: Le,
  backendName: 'wasm',
  setupFunc: function (e) {
    nu = e.wasm.cwrap('MaxPoolGrad', null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { dy: r, input: u } = t,
      { filterSize: i, strides: o, pad: d, dimRoundingMode: p } = a,
      l = s.computePool2DInfo(u.shape, i, o, 1, d, p),
      c = n.makeOutput(u.shape, u.dtype);
    return (
      nu(
        n.dataIdMap.get(u.dataId).id,
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(c.dataId).id,
        l.batchSize,
        l.inChannels,
        l.inHeight,
        l.inWidth,
        l.outHeight,
        l.outWidth,
        l.strideHeight,
        l.strideWidth,
        l.dilationHeight,
        l.dilationWidth,
        l.effectiveFilterHeight,
        l.effectiveFilterWidth,
        l.padInfo.top,
        l.padInfo.left,
      ),
      c
    );
  },
};
let ru;
const uu = {
  kernelName: Ue,
  backendName: 'wasm',
  setupFunc: function (e) {
    ru = e.wasm.cwrap('MaxPoolWithArgmax', null, [
      'number',
      'number',
      'number',
      'number',
      'boolean',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: a, attrs: r } = e,
      { x: u } = t,
      { filterSize: i, strides: o, pad: d, includeBatchInIndex: p } = r;
    n.assert(4 === u.shape.length, () => `Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`);
    const l = [1, 1];
    n.assert(
      s.eitherStridesOrDilationsAreOne(o, l),
      () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`,
    );
    const c = s.computePool2DInfo(u.shape, i, o, [1, 1], d),
      m = a.makeOutput(c.outShape, u.dtype),
      f = a.makeOutput(c.outShape, 'int32');
    return (
      ru(
        a.dataIdMap.get(u.dataId).id,
        a.dataIdMap.get(m.dataId).id,
        a.dataIdMap.get(f.dataId).id,
        yn[u.dtype],
        p,
        c.batchSize,
        c.inChannels,
        c.inHeight,
        c.inWidth,
        c.outHeight,
        c.outWidth,
        c.strideHeight,
        c.strideWidth,
        c.dilationHeight,
        c.dilationWidth,
        c.effectiveFilterHeight,
        c.effectiveFilterWidth,
        c.padInfo.top,
        c.padInfo.left,
      ),
      [m, f]
    );
  },
};
let su;
const iu = {
  kernelName: je,
  backendName: 'wasm',
  setupFunc: function (e) {
    su = e.wasm.cwrap(je, null, ['number, number, number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { axis: u, keepDims: i } = r,
      { x: o } = a,
      d = t.dataIdMap.get(o.dataId).id;
    let p = d,
      l = o;
    const { transposed: c, axes: m, originalAxes: f, inputWasTransposed: h } = Pn(o, u, t);
    let b = m;
    if (h) {
      const e = t.dataIdMap.get(c.dataId).id;
      e !== d && ((l = c), (p = e), (b = s.getInnerMostAxes(b.length, l.shape.length)));
    }
    s.assertAxesAreInnerMostDims('mean', b, l.shape.length);
    const [y, _] = s.computeOutAndReduceShapes(l.shape, b),
      g = n.sizeFromShape(_);
    let I = l;
    'float32' !== l.dtype && ((I = ha({ backend: t, inputs: { x: l }, attrs: { dtype: 'float32' } })), (p = t.dataIdMap.get(I.dataId).id));
    const w = t.makeOutput(y, 'float32');
    if (0 !== n.sizeFromShape(l.shape)) {
      const e = t.dataIdMap.get(w.dataId).id;
      su(p, g, e);
    }
    if ((h && t.disposeData(c.dataId), i)) {
      const e = s.expandShapeToKeepDim(w.shape, f);
      w.shape = e;
    }
    return 'float32' !== l.dtype && t.disposeData(I.dataId), w;
  },
};
let ou;
const du = {
    kernelName: Ge,
    backendName: 'wasm',
    setupFunc: function (e) {
      ou = e.wasm.cwrap(Ge, null, ['number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: a, attrs: r } = e,
        { axis: u, keepDims: i } = r,
        { x: o } = a,
        d = t.dataIdMap.get(o.dataId).id;
      let p = d,
        l = o;
      const { transposed: c, axes: m, originalAxes: f, inputWasTransposed: h } = Pn(o, u, t);
      if (h) {
        const e = t.dataIdMap.get(c.dataId).id;
        e !== d && ((l = c), (p = e));
      }
      const b = l.shape.length;
      s.assertAxesAreInnerMostDims('min', m, b);
      const [y, _] = s.computeOutAndReduceShapes(l.shape, m),
        g = n.sizeFromShape(_),
        I = t.makeOutput(y, l.dtype);
      if (0 !== n.sizeFromShape(l.shape)) {
        const e = t.dataIdMap.get(I.dataId).id;
        ou(p, yn[o.dtype], g, e);
      }
      if ((h && t.disposeData(c.dataId), i)) {
        const e = s.expandShapeToKeepDim(I.shape, f);
        I.shape = e;
      }
      return I;
    },
  },
  pu = An(qe);
var lu;
let cu;
!(function (e) {
  (e[(e.reflect = 0)] = 'reflect'), (e[(e.symmetric = 1)] = 'symmetric');
})(lu || (lu = {}));
const mu = {
  kernelName: Ve,
  backendName: 'wasm',
  kernelFunc: function (e) {
    const {
        inputs: { x: t },
        backend: n,
        attrs: { paddings: a, mode: r },
      } = e,
      u = a.map((e, n) => e[0] + t.shape[n] + e[1]),
      s = n.dataIdMap.get(t.dataId).id,
      i = n.makeOutput(u, t.dtype),
      o = n.dataIdMap.get(i.dataId).id,
      d = new Uint8Array(new Int32Array(t.shape).buffer),
      p = a.map(e => e[0]),
      l = a.map(e => e[1]),
      c = new Uint8Array(new Int32Array(p).buffer),
      m = new Uint8Array(new Int32Array(l).buffer);
    return cu(s, d, t.shape.length, yn[t.dtype], c, m, lu[r], o), i;
  },
  setupFunc: function (e) {
    cu = e.wasm.cwrap(Ve, null, ['number', 'array', 'number', 'number', 'array', 'array', 'number', 'number']);
  },
};
let fu;
function hu(e) {
  const {
      backend: t,
      inputs: { logits: a },
      attrs: { dim: r },
    } = e,
    u = t.dataIdMap.get(a.dataId).id,
    s = t.makeOutput(a.shape, a.dtype),
    i = t.dataIdMap.get(s.dataId).id,
    o = a.shape[r],
    d = n.sizeFromShape(a.shape) / o;
  return 0 === n.sizeFromShape(s.shape) || fu(u, i, o, d), s;
}
const bu = {
  kernelName: $e,
  backendName: 'wasm',
  setupFunc: function (e) {
    fu = e.wasm.cwrap($e, null, ['number', 'number', 'number', 'number']);
  },
  kernelFunc: hu,
};
let yu;
const _u = {
    kernelName: Ke,
    backendName: 'wasm',
    setupFunc: function (e) {
      yu = e.wasm.cwrap(Ke, null, ['number', 'number', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { logits: r } = t,
        { numSamples: u, seed: s, normalized: i } = a;
      if ('float32' !== r.dtype) throw new Error(`Tensor logits must have dtype float32, got ${r.dtype}`);
      const o = i ? r : hu({ inputs: { logits: r }, backend: n, attrs: { dim: r.shape.length - 1 } }),
        [d, p] = o.shape,
        l = n.makeOutput([d, u], 'int32');
      return yu(n.dataIdMap.get(o.dataId).id, d, p, u, s, n.dataIdMap.get(l.dataId).id), i || n.disposeData(o.dataId), l;
    },
  },
  gu = An(Xe),
  Iu = An(Qe),
  wu = wn(Je);
function ku(e, t) {
  const n = new Int32Array(e.wasm.HEAPU8.buffer, t, 4),
    a = n[0],
    r = n[1],
    u = n[2],
    s = n[3];
  return e.wasm._free(t), { pSelectedIndices: a, selectedSize: r, pSelectedScores: u, pValidOutputs: s };
}
let Mu;
const Su = {
  kernelName: Ze,
  backendName: 'wasm',
  setupFunc: function (e) {
    Mu = e.wasm.cwrap(Ze, 'number', ['number', 'number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: n, attrs: a } = e,
      { iouThreshold: r, maxOutputSize: u, scoreThreshold: s } = a,
      { boxes: i, scores: o } = n,
      d = t.dataIdMap.get(i.dataId).id,
      p = t.dataIdMap.get(o.dataId).id,
      l = Mu(d, p, u, r, s),
      { pSelectedIndices: c, selectedSize: m, pSelectedScores: f, pValidOutputs: h } = ku(t, l);
    return t.wasm._free(f), t.wasm._free(h), t.makeOutput([m], 'int32', c);
  },
};
let Au;
const vu = {
  kernelName: Ye,
  backendName: 'wasm',
  setupFunc: function (e) {
    Au = e.wasm.cwrap(Ye, 'number', ['number', 'number', 'number', 'number', 'number', 'bool']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: n, attrs: a } = e,
      { iouThreshold: r, maxOutputSize: u, scoreThreshold: s, padToMaxOutputSize: i } = a,
      { boxes: o, scores: d } = n,
      p = t.dataIdMap.get(o.dataId).id,
      l = t.dataIdMap.get(d.dataId).id,
      c = Au(p, l, u, r, s, i),
      { pSelectedIndices: m, selectedSize: f, pSelectedScores: h, pValidOutputs: b } = ku(t, c);
    return t.wasm._free(h), [t.makeOutput([f], 'int32', m), t.makeOutput([], 'int32', b)];
  },
};
let xu;
const Fu = {
    kernelName: et,
    backendName: 'wasm',
    setupFunc: function (e) {
      xu = e.wasm.cwrap(et, 'number', ['number', 'number', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: n, attrs: a } = e,
        { iouThreshold: r, maxOutputSize: u, scoreThreshold: s, softNmsSigma: i } = a,
        { boxes: o, scores: d } = n,
        p = t.dataIdMap.get(o.dataId).id,
        l = t.dataIdMap.get(d.dataId).id,
        c = xu(p, l, u, r, s, i),
        { pSelectedIndices: m, selectedSize: f, pSelectedScores: h, pValidOutputs: b } = ku(t, c);
      return t.wasm._free(b), [t.makeOutput([f], 'int32', m), t.makeOutput([f], 'float32', h)];
    },
  },
  Nu = An(tt, 0, 'bool');
let Du;
const Ru = {
  kernelName: nt,
  backendName: 'wasm',
  setupFunc: function (e) {
    Du = e.wasm.cwrap(nt, null, ['number', 'number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { indices: r } = t,
      { dtype: u, depth: s, onValue: i, offValue: o } = a,
      d = n.makeOutput([...r.shape, s], u),
      p = n.dataIdMap.get(d.dataId).id,
      l = n.dataIdMap.get(r.dataId).id;
    return Du(l, s, i, o, p), d;
  },
};
const Eu = {
  kernelName: at,
  backendName: 'wasm',
  kernelFunc: function (e) {
    const {
        inputs: { x: t },
        backend: n,
      } = e,
      a = n.makeOutput(t.shape, t.dtype);
    return n.typedArrayFromHeap(a).fill(1), a;
  },
};
const Wu = {
  kernelName: rt,
  backendName: 'wasm',
  kernelFunc: function (e) {
    const { inputs: t, backend: a, attrs: r } = e,
      { axis: u } = r;
    if (1 === t.length) return ir({ inputs: { input: t[0] }, backend: a, attrs: { dim: u } });
    const s = t[0].shape,
      i = t[0].dtype;
    t.forEach(e => {
      n.assertShapesMatch(s, e.shape, 'All tensors passed to stack must have matching shapes'),
        n.assert(i === e.dtype, () => 'All tensors passed to stack must have matching dtypes');
    });
    const o = [],
      d = Ia({
        inputs: t.map(e => {
          const t = ir({ inputs: { input: e }, backend: a, attrs: { dim: u } });
          return o.push(t), t;
        }),
        backend: a,
        attrs: { axis: u },
      });
    return o.forEach(e => a.disposeData(e.dataId)), d;
  },
};
let Pu;
const Ou = {
    kernelName: ut,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const {
          inputs: { x: t },
          backend: a,
          attrs: { paddings: r, constantValue: u },
        } = e,
        s = r.map((e, n) => e[0] + t.shape[n] + e[1]);
      if (0 === n.sizeFromShape(t.shape)) return pr({ backend: a, attrs: { shape: s, value: u, dtype: t.dtype } });
      const i = a.dataIdMap.get(t.dataId).id,
        o = a.makeOutput(s, t.dtype),
        d = a.dataIdMap.get(o.dataId).id,
        p = new Uint8Array(new Int32Array(t.shape).buffer),
        l = r.map(e => e[0]),
        c = r.map(e => e[1]),
        m = new Uint8Array(new Int32Array(l).buffer),
        f = new Uint8Array(new Int32Array(c).buffer);
      return Pu(i, p, t.shape.length, yn[t.dtype], m, f, u, d), o;
    },
    setupFunc: function (e) {
      Pu = e.wasm.cwrap(ut, null, ['number', 'array', 'number', 'number', 'array', 'array', 'number', 'number']);
    },
  },
  Cu = An(st);
let Tu;
const zu = {
  kernelName: it,
  backendName: 'wasm',
  setupFunc: function (e) {
    Tu = e.wasm.cwrap(it, null, ['number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n } = e,
      { x: a, alpha: r } = t,
      u = n.dataIdMap.get(a.dataId).id,
      s = n.dataIdMap.get(r.dataId).id;
    let i = u;
    const o = a;
    let d = o;
    'float32' !== o.dtype && ((d = ha({ backend: n, inputs: { x: a }, attrs: { dtype: 'float32' } })), (i = n.dataIdMap.get(d.dataId).id));
    const p = n.makeOutput(a.shape, 'float32'),
      l = n.dataIdMap.get(p.dataId).id;
    return Tu(i, s, l), 'float32' !== o.dtype && n.disposeData(d.dataId), p;
  },
};
let Hu;
const Bu = {
    kernelName: ot,
    backendName: 'wasm',
    setupFunc: function (e) {
      Hu = e.wasm.cwrap(ot, null, ['number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: a, attrs: r } = e,
        { axis: u, keepDims: i } = r,
        { x: o } = a,
        d = t.dataIdMap.get(o.dataId).id;
      let p = d,
        l = o;
      const { transposed: c, axes: m, originalAxes: f, inputWasTransposed: h } = Pn(o, u, t);
      let b = m;
      if (h) {
        const e = t.dataIdMap.get(c.dataId).id;
        e !== d && ((l = c), (p = e), (b = s.getInnerMostAxes(b.length, l.shape.length)));
      }
      s.assertAxesAreInnerMostDims('prod', b, l.shape.length);
      const [y, _] = s.computeOutAndReduceShapes(l.shape, b),
        g = n.sizeFromShape(_),
        I = t.makeOutput(y, l.dtype);
      if (0 !== n.sizeFromShape(l.shape)) {
        const e = t.dataIdMap.get(I.dataId).id;
        Hu(p, g, yn[I.dtype], e);
      }
      if ((h && t.disposeData(c.dataId), i)) {
        const e = s.expandShapeToKeepDim(I.shape, f);
        I.shape = e;
      }
      return I;
    },
  },
  Lu = {
    kernelName: dt,
    backendName: 'wasm',
    kernelFunc: e => {
      const { backend: t, attrs: a } = e,
        { start: r, stop: u, step: s, dtype: i } = a,
        o = (function (e, t, a, r) {
          if (e === t || (e < t && a < 0) || (t < e && a > 1)) return n.makeZerosTypedArray(0, r);
          const u = Math.abs(Math.ceil((t - e) / a)),
            s = n.makeZerosTypedArray(u, r);
          t < e && 1 === a && (a = -1), (s[0] = e);
          for (let e = 1; e < s.length; e++) s[e] = s[e - 1] + a;
          return s;
        })(r, u, s, i),
        d = t.makeOutput([o.length], i);
      return t.typedArrayFromHeap(d).set(o), d;
    },
  },
  Uu = An(pt),
  ju = wn(lt),
  Gu = wn(ct),
  qu = wn(mt);
let Vu;
const $u = {
  kernelName: ft,
  backendName: 'wasm',
  setupFunc: function (e) {
    Vu = e.wasm.cwrap(ft, null, ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { images: u } = a,
      { alignCorners: s, halfPixelCenters: i, size: o } = r,
      [d, p] = o,
      [l, c, m, f] = u.shape,
      h = [l, d, p, f];
    let b,
      y = t.dataIdMap.get(u.dataId);
    'float32' !== y.dtype && ((b = ha({ backend: t, inputs: { x: u }, attrs: { dtype: 'float32' } })), (y = t.dataIdMap.get(b.dataId)));
    const _ = y.id,
      g = t.makeOutput(h, 'float32');
    if (0 === n.sizeFromShape(u.shape)) return g;
    const I = t.dataIdMap.get(g.dataId).id;
    return Vu(_, l, c, m, f, d, p, s ? 1 : 0, i ? 1 : 0, I), null != b && t.disposeData(b.dataId), g;
  },
};
let Ku;
const Xu = {
  kernelName: ht,
  backendName: 'wasm',
  setupFunc: function (e) {
    Ku = e.wasm.cwrap(ht, null, ['number', 'number', 'number', 'array', 'array', 'boolean']);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { images: r, dy: u } = t,
      { alignCorners: s } = a,
      i = n.makeOutput(r.shape, 'float32');
    let o,
      d = n.dataIdMap.get(r.dataId);
    return (
      'float32' !== d.dtype && ((o = ha({ backend: n, inputs: { x: r }, attrs: { dtype: 'float32' } })), (d = n.dataIdMap.get(o.dataId))),
      Ku(
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(u.dataId).id,
        n.dataIdMap.get(i.dataId).id,
        new Uint8Array(new Int32Array(r.shape).buffer),
        new Uint8Array(new Int32Array(u.shape).buffer),
        s,
      ),
      null != o && n.disposeData(o.dataId),
      i
    );
  },
};
let Qu;
const Ju = {
  kernelName: bt,
  backendName: 'wasm',
  setupFunc: function (e) {
    Qu = e.wasm.cwrap(bt, null, ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { images: u } = a,
      { alignCorners: s, halfPixelCenters: i, size: o } = r,
      [d, p] = o,
      [l, c, m, f] = u.shape,
      h = [l, d, p, f],
      b = t.makeOutput(h, 'float32');
    if (0 === n.sizeFromShape(u.shape)) return b;
    let y,
      _ = t.dataIdMap.get(u.dataId);
    'float32' !== _.dtype && ((y = ha({ backend: t, inputs: { x: u }, attrs: { dtype: 'float32' } })), (_ = t.dataIdMap.get(y.dataId)));
    const g = _.id,
      I = t.dataIdMap.get(b.dataId).id;
    return Qu(g, l, c, m, f, d, p, s ? 1 : 0, i ? 1 : 0, I), null != y && t.disposeData(y.dataId), b;
  },
};
let Zu;
const Yu = {
  kernelName: yt,
  backendName: 'wasm',
  setupFunc: function (e) {
    Zu = e.wasm.cwrap(yt, null, ['number', 'number', 'number', 'array', 'array', 'boolean']);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { images: r, dy: u } = t,
      { alignCorners: s } = a,
      i = n.makeOutput(r.shape, 'float32');
    let o,
      d = n.dataIdMap.get(r.dataId);
    return (
      'float32' !== d.dtype && ((o = ha({ backend: n, inputs: { x: r }, attrs: { dtype: 'float32' } })), (d = n.dataIdMap.get(o.dataId))),
      Zu(
        n.dataIdMap.get(r.dataId).id,
        n.dataIdMap.get(u.dataId).id,
        n.dataIdMap.get(i.dataId).id,
        new Uint8Array(new Int32Array(r.shape).buffer),
        new Uint8Array(new Int32Array(u.shape).buffer),
        s,
      ),
      null != o && n.disposeData(o.dataId),
      i
    );
  },
};
let es;
const ts = {
  kernelName: _t,
  backendName: 'wasm',
  kernelFunc: function (e) {
    const { inputs: t, backend: a, attrs: r } = e,
      { x: u } = t,
      { dims: s } = r,
      i = n.parseAxisParam(s, u.shape);
    if (0 === u.shape.length) return Nn({ inputs: { x: u }, backend: a });
    const o = a.makeOutput(u.shape, u.dtype),
      d = a.dataIdMap.get(u.dataId).id,
      p = a.dataIdMap.get(o.dataId).id,
      l = new Uint8Array(new Int32Array(i).buffer),
      c = new Uint8Array(new Int32Array(u.shape).buffer);
    es(d, l, i.length, c, u.shape.length, p);
    const m = ta({ inputs: { x: o }, attrs: { shape: u.shape }, backend: a });
    return a.disposeData(o.dataId), m;
  },
  setupFunc: function (e) {
    es = e.wasm.cwrap(_t, null, ['number', 'array', 'number', 'array', 'number', 'number']);
  },
};
let ns;
const as = {
    kernelName: gt,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { image: r } = t,
        { radians: u, fillValue: i, center: o } = a,
        d = n.makeOutput(r.shape, r.dtype),
        p = n.dataIdMap.get(r.dataId).id,
        l = n.dataIdMap.get(d.dataId).id,
        [c, m, f, h] = r.shape,
        [b, y] = s.getImageCenter(o, m, f),
        _ = 'number' == typeof i ? [i, i, i, 0 === i ? 0 : 255] : [...i, 255],
        g = new Uint8Array(new Int32Array(_).buffer);
      return ns(p, c, m, f, h, u, b, y, g, _.length, l), d;
    },
    setupFunc: function (e) {
      ns = e.wasm.cwrap(gt, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'array',
        'number',
        'number',
      ]);
    },
  },
  rs = wn(It),
  us = wn(wt);
let ss;
const is = {
  kernelName: kt,
  backendName: 'wasm',
  setupFunc: function (e) {
    ss = e.wasm.cwrap(kt, null, ['number', 'number', 'number', 'number', 'number', 'number', 'array', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { indices: u, updates: s } = a,
      { shape: i } = r,
      o = t.makeOutput(i, s.dtype);
    if (0 === n.sizeFromShape(i)) return o;
    const { sliceRank: d, numUpdates: p, sliceSize: l, strides: c, outputSize: m } = Mt.calculateShapes(s, u, i),
      f = t.dataIdMap.get(u.dataId).id,
      h = t.dataIdMap.get(s.dataId).id,
      b = new Uint8Array(new Int32Array(c).buffer),
      y = t.dataIdMap.get(o.dataId).id;
    return ss(f, h, yn[s.dtype], d, p, l, b, m, y), o;
  },
};
let os;
const ds = {
  kernelName: St,
  backendName: 'wasm',
  setupFunc: function (e) {
    os = e.wasm.cwrap(St, null, ['number', 'number', 'number', 'number', 'number', 'number', 'bool', 'number']);
  },
  kernelFunc: function (e) {
    const { inputs: t, backend: n, attrs: a } = e,
      { sortedSequence: r, values: u } = t,
      { side: s } = a;
    if (r.dtype !== u.dtype)
      throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${r.dtype} and ${u.dtype}`);
    const i = n.makeOutput(u.shape, 'int32');
    function o(e) {
      return n.dataIdMap.get(e.dataId).id;
    }
    return os(o(r), o(u), r.shape[0], r.shape[1], u.shape[1], yn[r.dtype], 'left' === s, o(i)), i;
  },
};
let ps;
const ls = {
    kernelName: At,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: t, backend: a } = e,
        { condition: r, t: u, e: s } = t,
        i = a.dataIdMap.get(r.dataId).id,
        o = a.dataIdMap.get(u.dataId).id,
        d = a.dataIdMap.get(s.dataId).id,
        p = a.makeOutput(u.shape, u.dtype),
        l = a.dataIdMap.get(p.dataId).id,
        c = r.shape.length,
        m = u.shape.length,
        f = 0 === c || c > 1 || 1 === m ? 1 : n.sizeFromShape(u.shape.slice(1));
      return ps(i, o, d, f, l), p;
    },
    setupFunc: function (e) {
      ps = e.wasm.cwrap('SelectV2', null, ['number', 'number', 'number', 'number', 'number']);
    },
  },
  cs = wn(vt);
let ms;
const fs = {
    kernelName: 'Sigmoid',
    backendName: 'wasm',
    setupFunc: function (e) {
      ms = e.wasm.cwrap(xt, null, ['number', 'number']);
    },
    kernelFunc: function (e) {
      const {
          backend: t,
          inputs: { x: a },
        } = e,
        r = t.dataIdMap.get(a.dataId).id,
        u = t.makeOutput(a.shape, a.dtype),
        s = t.dataIdMap.get(u.dataId).id;
      return 0 === n.sizeFromShape(u.shape) || ms(r, s), u;
    },
  },
  hs = wn(Ft),
  bs = wn(Nt),
  ys = wn(Dt),
  _s = wn(Rt);
const gs = {
  kernelName: Et,
  backendName: 'wasm',
  kernelFunc: function (e) {
    const { inputs: t, backend: a, attrs: r } = e,
      { x: u } = t,
      { blockShape: i, paddings: o } = r,
      d = n.sizeFromShape(i),
      p = [[0, 0]];
    p.push(...o);
    for (let e = 1 + i.length; e < u.shape.length; ++e) p.push([0, 0]);
    const l = Ou.kernelFunc({ inputs: { x: u }, backend: a, attrs: { paddings: p, constantValue: 0 } }),
      c = s.getReshaped(l.shape, i, d, !1),
      m = s.getPermuted(c.length, i.length, !1),
      f = s.getReshapedPermuted(l.shape, i, d, !1),
      h = ta({ inputs: { x: l }, backend: a, attrs: { shape: c } }),
      b = En({ inputs: { x: h }, backend: a, attrs: { perm: m } }),
      y = ta({ inputs: { x: b }, backend: a, attrs: { shape: f } });
    return a.disposeData(l.dataId), a.disposeData(h.dataId), a.disposeData(b.dataId), y;
  },
};
let Is;
const ws = {
  kernelName: Wt,
  backendName: 'wasm',
  setupFunc: function (e) {
    Is = e.wasm.cwrap('SparseFillEmptyRows', 'number', [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: n } = e,
      { indices: a, values: r, denseShape: u, defaultValue: i } = n,
      o = a.shape[0],
      d = a.shape[1],
      p = t.readSync(u.dataId)[0],
      l = [o + p, d],
      c = t.dataIdMap.get(a.dataId).id,
      m = t.dataIdMap.get(r.dataId).id,
      f = t.dataIdMap.get(i.dataId).id,
      h = t.makeOutput(l, a.dtype),
      b = t.dataIdMap.get(h.dataId).id,
      y = t.makeOutput(l.slice(0, 1), r.dtype),
      _ = t.dataIdMap.get(y.dataId).id,
      g = t.makeOutput([p], 'bool'),
      I = t.dataIdMap.get(g.dataId).id,
      w = t.makeOutput([o], a.dtype),
      k = t.dataIdMap.get(w.dataId).id,
      M = t.makeOutput([4], 'int32'),
      S = t.dataIdMap.get(M.dataId).id,
      A = Is(c, m, yn[r.dtype], o, p, d, f, b, _, I, k, S),
      v = t.readSync(M.dataId);
    let x;
    switch (v[0]) {
      case 1:
        x = s.getSparseFillEmptyRowsIndicesDenseShapeMismatch(v[1]);
        break;
      case 2:
        x = s.getSparseFillEmptyRowsNegativeIndexErrorMessage(v[1], v[2]);
        break;
      case 3:
        x = s.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(v[1], v[2], v[3]);
        break;
      default:
        x = '';
    }
    if ((t.disposeData(M.dataId), x))
      throw (t.disposeData(h.dataId), t.disposeData(y.dataId), t.disposeData(g.dataId), t.disposeData(w.dataId), new Error(x));
    let F = h,
      N = y;
    return (
      A !== l[0] &&
        ((F = oa({ inputs: { x: h }, attrs: { begin: 0, size: [A, d] }, backend: t })),
        (N = oa({ inputs: { x: y }, attrs: { begin: 0, size: A }, backend: t })),
        t.disposeData(h.dataId),
        t.disposeData(y.dataId)),
      [F, N, g, w]
    );
  },
};
let ks;
const Ms = {
  kernelName: Pt,
  backendName: 'wasm',
  setupFunc: function (e) {
    ks = e.wasm.cwrap(Pt, null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a } = e,
      { inputIndices: r, inputShape: u, newShape: i } = a;
    if (2 !== r.shape.length) throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);
    if (1 !== u.shape.length) throw new Error(`Input shape should be a vector but received shape\n        ${u.shape}`);
    if (1 !== i.shape.length) throw new Error(`Target shape should be a vector but received shape ${i.shape}`);
    const o = t.dataIdMap.get(r.dataId).id,
      d = t.dataIdMap.get(u.dataId).id,
      p = t.dataIdMap.get(i.dataId).id,
      l = r.shape[0],
      c = n.sizeFromShape(i.shape),
      m = t.makeOutput([l, c], r.dtype),
      f = t.dataIdMap.get(m.dataId).id,
      h = t.makeOutput([c], i.dtype),
      b = t.dataIdMap.get(h.dataId).id,
      y = t.makeOutput([3], 'int32'),
      _ = t.dataIdMap.get(y.dataId).id;
    ks(o, d, p, l, f, b, _);
    const g = t.readSync(y.dataId);
    let I;
    switch (g[0]) {
      case 0:
        I = s.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(g[1], g[2]);
        break;
      case 1:
        I = s.getSparseReshapeNegativeOutputDimErrorMessage(g[1], g[2]);
        break;
      case 2:
        I = s.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();
        break;
      case 3: {
        const e = Array.from(t.readSync(u.dataId)),
          n = Array.from(t.readSync(h.dataId));
        I = s.getSparseReshapeInputOutputMultipleErrorMessage(e, n);
        break;
      }
      case 4: {
        const e = Array.from(t.readSync(u.dataId)),
          n = Array.from(t.readSync(h.dataId));
        I = s.getSparseReshapeInputOutputMismatchErrorMessage(e, n);
        break;
      }
      default:
        I = '';
    }
    if ((t.disposeData(y.dataId), I)) throw (t.disposeData(m.dataId), t.disposeData(h.dataId), new Error(I));
    return [m, h];
  },
};
let Ss;
function As(e) {
  Ss = e.wasm.cwrap('SparseSegmentReduction', null, [
    'number',
    'number',
    'number',
    'number',
    'number',
    'number',
    'number',
    'number',
    'number',
  ]);
}
function vs(e, t) {
  const { backend: n, inputs: a } = e,
    { data: r, indices: u, segmentIds: i } = a,
    o = u.shape[0],
    d = n.readSync(i.dataId, o - 1, o)[0],
    p = o > 0 ? d + 1 : 0;
  if (p < 0) throw new Error(s.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
  const l = r.shape.slice();
  l[0] = p;
  const c = n.dataIdMap.get(r.dataId).id,
    m = n.dataIdMap.get(u.dataId).id,
    f = n.dataIdMap.get(i.dataId).id,
    h = n.makeOutput(l, r.dtype),
    b = n.dataIdMap.get(h.dataId).id,
    y = n.makeOutput([4], 'int32'),
    _ = n.dataIdMap.get(y.dataId).id;
  Ss(c, yn[r.dtype], r.shape[0], m, f, b, _, t, 0);
  const g = n.readSync(y.dataId);
  let I;
  switch (g[0]) {
    case 0:
      I = s.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();
      break;
    case 1:
      I = s.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();
      break;
    case 2:
      I = s.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(g[1], g[2]);
      break;
    case 3:
      I = s.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(g[1], g[2], g[3]);
      break;
    default:
      I = '';
  }
  if ((n.disposeData(y.dataId), I)) throw (n.disposeData(h.dataId), new Error(I));
  return h;
}
const xs = {
  kernelName: Ot,
  backendName: 'wasm',
  setupFunc: As,
  kernelFunc: function (e) {
    return vs(e, !0);
  },
};
const Fs = {
  kernelName: Ct,
  backendName: 'wasm',
  setupFunc: As,
  kernelFunc: function (e) {
    return vs(e, !1);
  },
};
let Ns;
const Ds = {
  kernelName: Tt,
  backendName: 'wasm',
  setupFunc: function (e) {
    Ns = e.wasm.cwrap(Tt, null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'array',
      'number',
      'number',
    ]);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { sparseIndices: u, sparseValues: i, defaultValue: o } = a,
      { outputShape: d } = r,
      p = t.makeOutput(d, o.dtype);
    if (0 === n.sizeFromShape(d)) return p;
    const { sliceRank: l, numUpdates: c, sliceSize: m, strides: f, outputSize: h } = s.calculateShapes(i, u, d),
      b = t.dataIdMap.get(u.dataId).id,
      y = t.dataIdMap.get(i.dataId).id,
      _ = t.dataIdMap.get(o.dataId).id,
      g = new Uint8Array(new Int32Array(f).buffer),
      I = t.dataIdMap.get(p.dataId).id;
    return Ns(b, y, i.shape.length, _, yn[o.dtype], l, c, m, g, h, I), p;
  },
};
const Rs = {
    kernelName: zt,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: t, attrs: a, backend: r } = e,
        { x: u } = t,
        { numOrSizeSplits: i, axis: o } = a,
        d = n.parseAxisParam(o, u.shape)[0],
        p = s.prepareSplitSize(u, i, d),
        l = new Array(u.shape.length).fill(0),
        c = u.shape.slice();
      return p.map(e => {
        const t = [...c];
        t[d] = e;
        const n = oa({ inputs: { x: u }, attrs: { begin: l, size: t }, backend: r });
        return (l[d] += e), n;
      });
    },
  },
  Es = wn(Ht),
  Ws = wn(Bt),
  Ps = An(Lt);
let Os;
const Cs = {
  kernelName: Ut,
  backendName: 'wasm',
  setupFunc: function (e) {
    Os = e.wasm.cwrap(Ut, null, ['number', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: n, attrs: a } = e,
      { alpha: r } = a,
      { x: u } = n,
      s = t.dataIdMap.get(u.dataId).id,
      i = t.makeOutput(u.shape, u.dtype),
      o = t.dataIdMap.get(i.dataId).id;
    return Os(s, r, yn[u.dtype], o), i;
  },
};
let Ts;
const zs = {
  kernelName: jt,
  backendName: 'wasm',
  setupFunc: function (e) {
    Ts = e.wasm.cwrap(jt, null, ['number', 'array', 'number', 'array', 'array', 'array', 'array', 'array', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { x: u } = a,
      { begin: s, end: i, strides: o, beginMask: d, endMask: p, ellipsisMask: l, newAxisMask: c, shrinkAxisMask: m } = r,
      {
        finalShapeSparse: f,
        finalShape: h,
        isIdentity: b,
        sliceDim0: y,
        isSimpleSlice: _,
        begin: g,
        end: I,
        strides: w,
      } = x.sliceInfo(u.shape, s, i, o, d, p, l, c, m);
    let k;
    if (b) k = ta({ inputs: { x: u }, backend: t, attrs: { shape: h } });
    else if (y || _) {
      n.assert(u.shape.length >= 1, () => `Input must have rank at least 1, got: ${u.shape.length}`);
      const e = x.computeOutShape(g, I, w),
        a = oa({ inputs: { x: u }, backend: t, attrs: { begin: g, size: e } });
      (k = ta({ inputs: { x: a }, backend: t, attrs: { shape: h } })), t.disposeData(a.dataId);
    } else {
      const e = t.makeOutput(f, 'float32'),
        a = t.dataIdMap.get(u.dataId).id,
        r = new Uint8Array(new Int32Array(n.computeStrides(u.shape)).buffer),
        s = new Uint8Array(new Int32Array(g).buffer),
        i = new Uint8Array(new Int32Array(I).buffer),
        o = new Uint8Array(new Int32Array(w).buffer),
        d = new Uint8Array(new Int32Array(f).buffer),
        p = new Uint8Array(new Int32Array(n.computeStrides(f)).buffer),
        l = t.dataIdMap.get(e.dataId).id;
      Ts(a, r, u.shape.length, s, i, o, d, p, f.length, l),
        (k = ta({ inputs: { x: e }, backend: t, attrs: { shape: h } })),
        t.disposeData(e.dataId);
    }
    return k;
  },
};
const Hs = {
  kernelName: Gt,
  backendName: 'wasm',
  kernelFunc: function (e) {
    const { backend: t, inputs: n, attrs: a } = e,
      { data: r, dataSplits: u } = n,
      { separator: s, nGramWidths: i, leftPad: o, rightPad: d, padWidth: p, preserveShortSequences: l } = a,
      c = t.readSync(r.dataId),
      m = t.readSync(u.dataId),
      [f, h] = (function (e, t, n, a, r, u, s, i) {
        return new sa(n, a, r, u, s, i).compute(e, t);
      })(c, m, s, i, o, d, p, l),
      b = t.makeOutput([f.length], 'string');
    t.dataIdMap.get(b.dataId).stringBytes = f;
    const y = t.makeOutput(u.shape, 'int32');
    return t.typedArrayFromHeap(y).set(h), [b, y];
  },
};
const Bs = {
  kernelName: qt,
  backendName: 'wasm',
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { input: u, delimiter: s } = a,
      { skipEmpty: i } = r,
      o = t.readSync(u.dataId),
      d = t.readSync(s.dataId),
      [p, l, c] = (function (e, t, a) {
        const r = e.length,
          u = [];
        let s = 0,
          i = 0;
        const o = new Array(r);
        for (let n = 0; n < r; ++n) {
          const r = u.length;
          ia(e[n], t, a, u);
          const d = u.length - r;
          (o[n] = d), (s += d), (i = Math.max(i, d));
        }
        const d = n.getArrayFromDType('int32', 2 * s),
          p = new Array(s),
          l = [r, i];
        let c = 0;
        for (let e = 0; e < r; ++e) for (let t = 0; t < o[e]; ++t) (d[2 * c] = e), (d[2 * c + 1] = t), (p[c] = u[c]), ++c;
        return [d, p, l];
      })(o, d[0], i),
      m = l.length,
      f = t.makeOutput([m, 2], 'int32');
    t.typedArrayFromHeap(f).set(p);
    const h = t.makeOutput([m], 'string');
    t.dataIdMap.get(h.dataId).stringBytes = l;
    const b = t.makeOutput([2], 'int32');
    return t.typedArrayFromHeap(b).set(c), [f, h, b];
  },
};
const Ls = {
    kernelName: Vt,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { backend: t, inputs: a, attrs: r } = e,
        { input: u } = a,
        { numBuckets: s } = r,
        i = (function (e, t) {
          const a = n.getArrayFromDType('int32', e.length);
          for (let r = 0; r < e.length; ++r) a[r] = n.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();
          return a;
        })(t.readSync(u.dataId), s),
        o = t.makeOutput(u.shape, 'int32');
      return t.typedArrayFromHeap(o).set(i), o;
    },
  },
  Us = An($t);
let js;
const Gs = {
    kernelName: Kt,
    backendName: 'wasm',
    setupFunc: function (e) {
      js = e.wasm.cwrap(Kt, null, ['number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: a, attrs: r } = e,
        { axis: u, keepDims: i } = r,
        { x: o } = a,
        d = t.dataIdMap.get(o.dataId).id;
      let p = d,
        l = o;
      const { transposed: c, axes: m, originalAxes: f, inputWasTransposed: h } = Pn(o, u, t);
      let b = m;
      if (h) {
        const e = t.dataIdMap.get(c.dataId).id;
        e !== d && ((l = c), (p = e), (b = s.getInnerMostAxes(b.length, l.shape.length)));
      }
      s.assertAxesAreInnerMostDims('sum', b, l.shape.length);
      const [y, _] = s.computeOutAndReduceShapes(l.shape, b),
        g = n.sizeFromShape(_),
        I = t.makeOutput(y, l.dtype);
      if (0 !== n.sizeFromShape(l.shape)) {
        const e = t.dataIdMap.get(I.dataId).id;
        js(p, g, yn[I.dtype], e);
      }
      if ((h && t.disposeData(c.dataId), i)) {
        const e = s.expandShapeToKeepDim(I.shape, f);
        I.shape = e;
      }
      return I;
    },
  },
  qs = wn(Xt),
  Vs = wn(Qt);
let $s;
const Ks = {
  kernelName: Jt,
  backendName: 'wasm',
  setupFunc: function (e) {
    $s = e.wasm.cwrap(Jt, null, ['number', 'number', 'number', 'number', 'number', 'number', 'array', 'number', 'number', 'number']);
  },
  kernelFunc: function (e) {
    const { backend: t, inputs: a, attrs: r } = e,
      { tensor: u, indices: s, updates: i } = a,
      o = t.makeOutput(u.shape, u.dtype);
    if (0 === n.sizeFromShape(u.shape)) return o;
    const { sliceRank: d, numUpdates: p, sliceSize: l, strides: c, outputSize: m } = Mt.calculateShapes(i, s, u.shape),
      f = t.dataIdMap.get(s.dataId).id,
      h = t.dataIdMap.get(i.dataId).id,
      b = t.dataIdMap.get(u.dataId).id,
      y = new Uint8Array(new Int32Array(c).buffer),
      _ = t.dataIdMap.get(o.dataId).id;
    return $s(f, h, yn[i.dtype], d, p, l, y, m, _, b), o;
  },
};
let Xs;
let Qs;
let Js;
const Zs = [
  In,
  kn,
  Mn,
  Sn,
  vn,
  Fn,
  Cn,
  zn,
  Bn,
  Ln,
  Un,
  jn,
  Gn,
  qn,
  Vn,
  Kn,
  ea,
  Qn,
  Zn,
  ra,
  pa,
  ca,
  ma,
  fa,
  ba,
  ya,
  ga,
  wa,
  Ma,
  Aa,
  xa,
  Na,
  Ra,
  Ea,
  Wa,
  Ca,
  za,
  Ba,
  Ua,
  Ga,
  Va,
  Ka,
  Qa,
  Za,
  er,
  tr,
  ar,
  rr,
  ur,
  sr,
  or,
  dr,
  lr,
  mr,
  fr,
  hr,
  yr,
  gr,
  wr,
  Mr,
  Ar,
  vr,
  xr,
  Dn,
  Fr,
  Nr,
  Dr,
  Er,
  Wr,
  Pr,
  Cr,
  zr,
  Tr,
  Hr,
  Br,
  Lr,
  Ur,
  Gr,
  Vr,
  Kr,
  Xr,
  Jr,
  Yr,
  tu,
  au,
  uu,
  iu,
  du,
  pu,
  mu,
  _u,
  gu,
  Iu,
  wu,
  Su,
  vu,
  Fu,
  Nu,
  Ru,
  Eu,
  Wu,
  Ou,
  Cu,
  zu,
  Bu,
  Lu,
  Uu,
  ju,
  Gu,
  qu,
  na,
  $u,
  Xu,
  Ju,
  Yu,
  ts,
  as,
  rs,
  us,
  is,
  ds,
  ls,
  cs,
  fs,
  hs,
  bs,
  ys,
  da,
  bu,
  _s,
  gs,
  ws,
  Ms,
  xs,
  Fs,
  Ds,
  Rs,
  Es,
  Ws,
  Ps,
  Cs,
  zs,
  Hs,
  Bs,
  Ls,
  Us,
  Gs,
  qs,
  Vs,
  Ks,
  {
    kernelName: Zt,
    backendName: 'wasm',
    setupFunc: function (e) {
      Xs = e.wasm.cwrap(Zt, null, ['number', 'array', 'number', 'array', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { x: r } = t,
        u = n.dataIdMap.get(r.dataId).id,
        { reps: s } = a,
        i = new Array(r.shape.length);
      for (let e = 0; e < i.length; e++) i[e] = r.shape[e] * s[e];
      const o = new Uint8Array(new Int32Array(r.shape).buffer),
        d = new Uint8Array(new Int32Array(i).buffer),
        p = n.makeOutput(i, r.dtype),
        l = n.dataIdMap.get(p.dataId).id;
      return Xs(u, o, r.shape.length, d, i.length, yn[p.dtype], l), p;
    },
  },
  {
    kernelName: Yt,
    backendName: 'wasm',
    setupFunc: function (e) {
      Qs = e.wasm.cwrap(Yt, null, ['number', 'array', 'number', 'number', 'number', 'bool', 'number', 'number']);
    },
    kernelFunc: ({ inputs: e, backend: t, attrs: n }) => {
      const { x: a } = e,
        { k: r, sorted: u } = n,
        s = t.dataIdMap.get(a.dataId).id,
        i = new Uint8Array(new Int32Array(a.shape).buffer),
        o = a.shape.slice();
      o[o.length - 1] = r;
      const d = t.makeOutput(o, a.dtype),
        p = t.dataIdMap.get(d.dataId).id,
        l = t.makeOutput(o, 'int32'),
        c = t.dataIdMap.get(l.dataId).id;
      return Qs(s, i, a.shape.length, yn[a.dtype], r, u, p, c), [d, l];
    },
  },
  {
    kernelName: en,
    backendName: 'wasm',
    setupFunc: function (e) {
      Js = e.wasm.cwrap(en, null, [
        'number',
        'number',
        'bool',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'array',
        'number',
        'array',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: a, attrs: r } = e,
        { image: u, transforms: s } = a,
        { interpolation: i, fillMode: o, fillValue: d, outputShape: p } = r,
        [l, c, m, f] = u.shape,
        [h, b] = null != p ? p : [c, m],
        y = [l, h, b, f],
        _ = new Uint8Array(new Int32Array(n.computeStrides(u.shape)).buffer),
        g = new Uint8Array(new Int32Array(n.computeStrides(y)).buffer),
        I = t.makeOutput(y, u.dtype),
        w = t.dataIdMap.get(I.dataId).id,
        k = t.dataIdMap.get(u.dataId).id,
        M = t.dataIdMap.get(s.dataId).id,
        S = 'nearest' === i ? 1 : 2;
      let A;
      switch (o) {
        case 'constant':
        default:
          A = 1;
          break;
        case 'reflect':
          A = 2;
          break;
        case 'wrap':
          A = 3;
          break;
        case 'nearest':
          A = 4;
      }
      return Js(k, M, s.shape[0] > 1, l, h, b, f, m, c, _, u.shape.length - 1, g, y.length - 1, S, A, d, w), I;
    },
  },
  Wn,
  {
    kernelName: tn,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: t, attrs: a, backend: r } = e,
        { axis: u } = a,
        { x: s } = t,
        {
          outputValues: i,
          outputShape: o,
          indices: d,
        } = (function (e, t, a, r) {
          const u = n.parseAxisParam(t, a)[0],
            s = [1, a[0], 1];
          for (let e = 0; e < u; e++) s[0] *= a[e];
          s[1] = a[u];
          for (let e = u + 1; e < a.length; e++) s[2] *= a[e];
          const i = new Map(),
            o = new Int32Array(a[u]),
            d = new N(s, r, e),
            p = [],
            l = 1 === s[0] && 1 === s[2];
          for (let t = 0; t < a[u]; t++) {
            let n;
            if (l) n = e[t].toString();
            else {
              const e = [];
              for (let n = 0; n < s[0]; n++) for (let a = 0; a < s[2]; a++) e.push(d.get(n, t, a));
              n = e.join(',');
            }
            const a = i.get(n);
            if (null != a) o[t] = a;
            else {
              const e = i.size;
              i.set(n, e), (o[t] = e), p.push(t);
            }
          }
          const c = s.slice();
          c[1] = i.size;
          const m = new N(c, r);
          p.forEach((e, t) => {
            for (let n = 0; n < s[0]; n++) for (let a = 0; a < s[2]; a++) m.set(d.get(n, e, a), n, t, a);
          });
          const f = a.slice();
          return (f[u] = c[1]), { outputValues: m.values, outputShape: f, indices: o };
        })(r.readSync(s.dataId), u, s.shape, s.dtype);
      return [r.makeOutput(o, s.dtype, void 0, i), r.makeOutput([d.length], 'int32', void 0, d)];
    },
  },
  {
    kernelName: nn,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { value: r } = t;
      let { axis: u } = a;
      u < 0 && (u += r.shape.length);
      const s = r.shape[u],
        i = r.shape.length,
        o = new Array(i - 1);
      let d = 0;
      for (let e = 0; e < i; e++) e !== u && (o[d++] = r.shape[e]);
      const p = new Array(s),
        l = new Array(i).fill(0),
        c = r.shape.slice();
      c[u] = 1;
      for (let e = 0; e < p.length; e++) (l[u] = e), (p[e] = oa({ inputs: { x: r }, attrs: { begin: l, size: c }, backend: n }));
      return p.map(({ dataId: e, dtype: t }) => ({ dataId: e, dtype: t, shape: o }));
    },
  },
  {
    kernelName: an,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const {
          inputs: { x: t },
          backend: n,
        } = e,
        a = n.makeOutput(t.shape, t.dtype);
      return n.typedArrayFromHeap(a).fill(0), a;
    },
  },
];
for (const e of Zs) rn(e);
const Ys = un();
Ys.registerFlag('WASM_HAS_SIMD_SUPPORT', async () => {
  try {
    return WebAssembly.validate(
      new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]),
    );
  } catch (e) {
    return !1;
  }
}),
  Ys.registerFlag('WASM_HAS_MULTITHREAD_SUPPORT', async () => {
    if (Ys.get('IS_NODE')) return !1;
    try {
      return (
        new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),
        WebAssembly.validate(
          new Uint8Array([
            0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11,
          ]),
        )
      );
    } catch (e) {
      return !1;
    }
  });
var ei =
  'undefined' != typeof globalThis
    ? globalThis
    : 'undefined' != typeof window
    ? window
    : 'undefined' != typeof global
    ? global
    : 'undefined' != typeof self
    ? self
    : {};
function ti(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
}
var ni = { exports: {} };
!(function (e, t) {
  var n,
    a =
      ((n = 'undefined' != typeof document && document.currentScript ? document.currentScript.src : void 0),
      'undefined' != typeof __filename && (n = n || __filename),
      function (e) {
        function t() {
          return N.buffer != W && U(N.buffer), P;
        }
        function a() {
          return N.buffer != W && U(N.buffer), O;
        }
        function r() {
          return N.buffer != W && U(N.buffer), C;
        }
        function u() {
          return N.buffer != W && U(N.buffer), T;
        }
        function s() {
          return N.buffer != W && U(N.buffer), z;
        }
        var i,
          o,
          d,
          p = 'undefined' != typeof (e = e || {}) ? e : {};
        (p.ready = new Promise(function (e, t) {
          (i = e), (o = t);
        })),
          'undefined' != typeof process &&
            process.listeners &&
            (d = {
              uncaughtException: process.listeners('uncaughtException'),
              unhandledRejection: process.listeners('unhandledRejection'),
            });
        var l,
          c,
          m,
          f = Object.assign({}, p),
          h = (e, t) => {
            throw t;
          },
          b = 'object' == typeof window,
          y = 'function' == typeof importScripts,
          _ = 'object' == typeof process && 'object' == typeof process.versions && 'string' == typeof process.versions.node,
          g = p.ENVIRONMENT_IS_PTHREAD || !1,
          I = '';
        function w(e) {
          return p.locateFile ? p.locateFile(e, I) : I + e;
        }
        if (_) {
          var k = cn,
            M = mn;
          let e;
          (I = y ? M.dirname(I) + '/' : __dirname + '/'),
            (l = (e, t) => ((e = te(e) ? new URL(e) : M.normalize(e)), k.readFileSync(e, t ? void 0 : 'utf8'))),
            (m = e => {
              var t = l(e, !0);
              return t.buffer || (t = new Uint8Array(t)), t;
            }),
            (c = (e, t, n) => {
              (e = te(e) ? new URL(e) : M.normalize(e)),
                k.readFile(e, function (e, a) {
                  e ? n(e) : t(a.buffer);
                });
            }),
            process.argv.length > 1 && process.argv[1].replace(/\\/g, '/'),
            process.argv.slice(2),
            process.on('uncaughtException', function (e) {
              if (!(e instanceof re)) throw e;
            }),
            process.on('unhandledRejection', function (e) {
              throw e;
            }),
            (h = (e, t) => {
              if (K()) throw ((process.exitCode = e), t);
              var n;
              (n = t) instanceof re || F('exiting due to exception: ' + n), process.exit(e);
            }),
            (p.inspect = function () {
              return '[Emscripten Module object]';
            });
          try {
            e = require('worker_threads');
          } catch (e) {
            throw (
              (console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), e)
            );
          }
          ei.Worker = e.Worker;
        } else
          (b || y) &&
            (y ? (I = self.location.href) : 'undefined' != typeof document && document.currentScript && (I = document.currentScript.src),
            'undefined' != typeof n && n && (I = n),
            (I = 0 !== I.indexOf('blob:') ? I.substr(0, I.replace(/[?#].*/, '').lastIndexOf('/') + 1) : ''),
            _ ||
              ((l = e => {
                var t = new XMLHttpRequest();
                return t.open('GET', e, !1), t.send(null), t.responseText;
              }),
              y &&
                (m = e => {
                  var t = new XMLHttpRequest();
                  return t.open('GET', e, !1), (t.responseType = 'arraybuffer'), t.send(null), new Uint8Array(t.response);
                }),
              (c = (e, t, n) => {
                var a = new XMLHttpRequest();
                a.open('GET', e, !0),
                  (a.responseType = 'arraybuffer'),
                  (a.onload = () => {
                    200 == a.status || (0 == a.status && a.response) ? t(a.response) : n();
                  }),
                  (a.onerror = n),
                  a.send(null);
              })));
        _ && 'undefined' == typeof performance && (ei.performance = fn.performance);
        var S = console.log.bind(console),
          A = console.warn.bind(console);
        _ && ((S = e => k.writeSync(1, e + '\n')), (A = e => k.writeSync(2, e + '\n')));
        var v,
          x = p.print || S,
          F = p.printErr || A;
        Object.assign(p, f),
          (f = null),
          p.arguments && p.arguments,
          p.thisProgram && p.thisProgram,
          p.quit && (h = p.quit),
          p.wasmBinary && (v = p.wasmBinary);
        var N,
          D,
          R = p.noExitRuntime || !0;
        'object' != typeof WebAssembly && Y('no native wasm support detected');
        var E,
          W,
          P,
          O,
          C,
          T,
          z,
          H = !1,
          B = 'undefined' != typeof TextDecoder ? new TextDecoder('utf8') : void 0;
        function L(e, t, n) {
          for (var a = (t >>>= 0) + n, r = t; e[r] && !(r >= a); ) ++r;
          if (r - t > 16 && e.buffer && B) return B.decode(e.buffer instanceof SharedArrayBuffer ? e.slice(t, r) : e.subarray(t, r));
          for (var u = ''; t < r; ) {
            var s = e[t++];
            if (128 & s) {
              var i = 63 & e[t++];
              if (192 != (224 & s)) {
                var o = 63 & e[t++];
                if (
                  (s = 224 == (240 & s) ? ((15 & s) << 12) | (i << 6) | o : ((7 & s) << 18) | (i << 12) | (o << 6) | (63 & e[t++])) < 65536
                )
                  u += String.fromCharCode(s);
                else {
                  var d = s - 65536;
                  u += String.fromCharCode(55296 | (d >> 10), 56320 | (1023 & d));
                }
              } else u += String.fromCharCode(((31 & s) << 6) | i);
            } else u += String.fromCharCode(s);
          }
          return u;
        }
        function U(e) {
          (W = e),
            (p.HEAP8 = P = new Int8Array(e)),
            (p.HEAP16 = new Int16Array(e)),
            (p.HEAP32 = C = new Int32Array(e)),
            (p.HEAPU8 = O = new Uint8Array(e)),
            (p.HEAPU16 = new Uint16Array(e)),
            (p.HEAPU32 = T = new Uint32Array(e)),
            (p.HEAPF32 = new Float32Array(e)),
            (p.HEAPF64 = z = new Float64Array(e));
        }
        g && (W = p.buffer);
        var j,
          G = p.INITIAL_MEMORY || 16777216;
        if (g) (N = p.wasmMemory), (W = p.buffer);
        else if (p.wasmMemory) N = p.wasmMemory;
        else if (!((N = new WebAssembly.Memory({ initial: G / 65536, maximum: 65536, shared: !0 })).buffer instanceof SharedArrayBuffer))
          throw (
            (F(
              'requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag',
            ),
            _ && F('(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)'),
            Error('bad memory'))
          );
        N && (W = N.buffer), (G = W.byteLength), U(W);
        var q = [],
          V = [],
          $ = [];
        function K() {
          return R;
        }
        function X() {
          g || pe(V);
        }
        var Q,
          J = 0,
          Z = null;
        function Y(e) {
          p.onAbort && p.onAbort(e), F((e = 'Aborted(' + e + ')')), (H = !0), (E = 1), (e += '. Build with -sASSERTIONS for more info.');
          var t = new WebAssembly.RuntimeError(e);
          throw (o(t), t);
        }
        function ee(e) {
          return e.startsWith('data:application/octet-stream;base64,');
        }
        function te(e) {
          return e.startsWith('file://');
        }
        function ne(e) {
          try {
            if (e == Q && v) return new Uint8Array(v);
            if (m) return m(e);
            throw 'both async and sync fetching of the wasm failed';
          } catch (e) {
            Y(e);
          }
        }
        ee((Q = 'tfjs-backend-wasm-threaded-simd.wasm')) || (Q = w(Q));
        var ae = {};
        function re(e) {
          (this.name = 'ExitStatus'), (this.message = 'Program terminated with exit(' + e + ')'), (this.status = e);
        }
        function ue(e) {
          var t,
            n = de.pthreads[e];
          n || Y(t), de.returnWorkerToPool(n);
        }
        function se(e) {
          var t = de.getNewWorker();
          if (!t) return 6;
          de.runningWorkers.push(t), (de.pthreads[e.pthread_ptr] = t), (t.pthread_ptr = e.pthread_ptr);
          var n = { cmd: 'run', start_routine: e.startRoutine, arg: e.arg, pthread_ptr: e.pthread_ptr };
          return (
            (t.runPthread = () => {
              _ && t.ref(), t.postMessage(n, e.transferList), delete t.runPthread;
            }),
            t.loaded && t.runPthread(),
            0
          );
        }
        function ie(e) {
          if (g) return ge(1, 1, e);
          (E = e), K() || (de.terminateAllThreads(), p.onExit && p.onExit(e), (H = !0)), h(e, new re(e));
        }
        var oe = function (e, t) {
            if (((E = e), !t && g)) throw (le(e), 'unwind');
            ie(e);
          },
          de = {
            unusedWorkers: [],
            runningWorkers: [],
            tlsInitFunctions: [],
            pthreads: {},
            init: function () {
              g ? de.initWorker() : de.initMainThread();
            },
            initMainThread: function () {
              for (var e = 8; e--; ) de.allocateUnusedWorker();
            },
            initWorker: function () {
              R = !1;
            },
            setExitStatus: function (e) {
              E = e;
            },
            terminateAllThreads: function () {
              for (var e of Object.values(de.pthreads)) de.returnWorkerToPool(e);
              for (var e of de.unusedWorkers) e.terminate();
              de.unusedWorkers = [];
            },
            returnWorkerToPool: function (e) {
              var t = e.pthread_ptr;
              delete de.pthreads[t],
                de.unusedWorkers.push(e),
                de.runningWorkers.splice(de.runningWorkers.indexOf(e), 1),
                (e.pthread_ptr = 0),
                _ && e.unref(),
                ze(t);
            },
            receiveObjectTransfer: function (e) {},
            threadInitTLS: function () {
              de.tlsInitFunctions.forEach(e => e());
            },
            loadWasmModuleToWorker: function (e, t) {
              (e.onmessage = n => {
                var a,
                  r = n.data,
                  u = r.cmd;
                if ((e.pthread_ptr && (de.currentProxiedOperationCallerThread = e.pthread_ptr), r.targetThread && r.targetThread != Re())) {
                  var s = de.pthreads[r.targetThread];
                  return (
                    s
                      ? s.postMessage(r, r.transferList)
                      : F(
                          'Internal error! Worker sent a message "' +
                            u +
                            '" to target pthread ' +
                            r.targetThread +
                            ', but that thread no longer exists!',
                        ),
                    void (de.currentProxiedOperationCallerThread = void 0)
                  );
                }
                'processProxyingQueue' === u
                  ? be(r.queue)
                  : 'spawnThread' === u
                  ? se(r)
                  : 'cleanupThread' === u
                  ? ue(r.thread)
                  : 'killThread' === u
                  ? (function (e) {
                      var t = de.pthreads[e];
                      delete de.pthreads[e],
                        t.terminate(),
                        ze(e),
                        de.runningWorkers.splice(de.runningWorkers.indexOf(t), 1),
                        (t.pthread_ptr = 0);
                    })(r.thread)
                  : 'cancelThread' === u
                  ? ((a = r.thread), de.pthreads[a].postMessage({ cmd: 'cancel' }))
                  : 'loaded' === u
                  ? ((e.loaded = !0), _ && e.unref(), t && t(e), e.runPthread && e.runPthread())
                  : 'print' === u
                  ? x('Thread ' + r.threadId + ': ' + r.text)
                  : 'printErr' === u
                  ? F('Thread ' + r.threadId + ': ' + r.text)
                  : 'alert' === u
                  ? alert('Thread ' + r.threadId + ': ' + r.text)
                  : 'setimmediate' === r.target
                  ? e.postMessage(r)
                  : 'callHandler' === u
                  ? p[r.handler](...r.args)
                  : u && F('worker sent an unknown command ' + u),
                  (de.currentProxiedOperationCallerThread = void 0);
              }),
                (e.onerror = e => {
                  throw (F('worker sent an error! ' + e.filename + ':' + e.lineno + ': ' + e.message), e);
                }),
                _ &&
                  (e.on('message', function (t) {
                    e.onmessage({ data: t });
                  }),
                  e.on('error', function (t) {
                    e.onerror(t);
                  }),
                  e.on('detachedExit', function () {}));
              var a = [];
              for (var r of ['onExit', 'onAbort', 'print', 'printErr']) p.hasOwnProperty(r) && a.push(r);
              e.postMessage({ cmd: 'load', handlers: a, urlOrBlob: p.mainScriptUrlOrBlob || n, wasmMemory: N, wasmModule: D });
            },
            allocateUnusedWorker: function () {
              var e,
                t = w('tfjs-backend-wasm-threaded-simd.worker.js');
              (e = new Worker(t)), de.unusedWorkers.push(e);
            },
            getNewWorker: function () {
              return (
                0 == de.unusedWorkers.length && (de.allocateUnusedWorker(), de.loadWasmModuleToWorker(de.unusedWorkers[0])),
                de.unusedWorkers.pop()
              );
            },
          };
        function pe(e) {
          for (; e.length > 0; ) e.shift()(p);
        }
        function le(e) {
          if (g) return ge(2, 0, e);
          try {
            oe(e);
          } catch (e) {
            !(function (e) {
              if (e instanceof re || 'unwind' == e) return E;
              h(1, e);
            })(e);
          }
        }
        (p.PThread = de),
          (p.establishStackSpace = function () {
            var e = Re(),
              t = r()[(e + 52) >>> 2],
              n = r()[(e + 56) >>> 2];
            Be(t, t - n), Ue(t);
          });
        var ce,
          me = [];
        function fe(e, t, n, a) {
          return g ? ge(3, 1, e, t, n, a) : he(e, t, n, a);
        }
        function he(e, t, n, a) {
          if ('undefined' == typeof SharedArrayBuffer)
            return F('Current environment does not support SharedArrayBuffer, pthreads are not available!'), 6;
          var r = [];
          if (g && 0 === r.length) return fe(e, t, n, a);
          var u = { startRoutine: n, pthread_ptr: e, arg: a, transferList: r };
          return g ? ((u.cmd = 'spawnThread'), postMessage(u, r), 0) : se(u);
        }
        function be(e) {
          Atomics.store(r(), e >> 2, 1), Re() && Te(e), Atomics.compareExchange(r(), e >> 2, 1, 0);
        }
        function ye(e) {
          ye.shown || (ye.shown = {}), ye.shown[e] || ((ye.shown[e] = 1), _ && (e = 'warning: ' + e), F(e));
        }
        function _e(e) {
          var t = Le(),
            n = e();
          return Ue(t), n;
        }
        function ge(e, t) {
          var n = arguments.length - 2,
            a = arguments;
          return _e(() => {
            for (var r = n, u = je(8 * r), i = u >> 3, o = 0; o < n; o++) {
              var d = a[2 + o];
              s()[(i + o) >>> 0] = d;
            }
            return We(e, r, u, t);
          });
        }
        (p.invokeEntryPoint = function (e, t) {
          var n,
            a,
            r = ((a = me[(n = e)]) || (n >= me.length && (me.length = n + 1), (me[n] = a = j.get(n))), a)(t);
          K() ? de.setExitStatus(r) : He(r);
        }),
          (p.executeNotifiedProxyingQueue = be),
          (ce = _
            ? () => {
                var e = process.hrtime();
                return 1e3 * e[0] + e[1] / 1e6;
              }
            : () => performance.timeOrigin + performance.now());
        var Ie = [];
        function we(e) {
          try {
            return N.grow((e - W.byteLength + 65535) >>> 16), U(N.buffer), 1;
          } catch (e) {}
        }
        function ke(e) {
          return g ? ge(4, 1, e) : 52;
        }
        function Me(e, t, n, a, r) {
          return g ? ge(5, 1, e, t, n, a, r) : 70;
        }
        var Se = [null, [], []];
        function Ae(e, t) {
          var n = Se[e];
          0 === t || 10 === t ? ((1 === e ? x : F)(L(n, 0)), (n.length = 0)) : n.push(t);
        }
        function ve(e, t, n, r) {
          if (g) return ge(6, 1, e, t, n, r);
          for (var s = 0, i = 0; i < n; i++) {
            var o = u()[t >>> 2],
              d = u()[(t + 4) >>> 2];
            t += 8;
            for (var p = 0; p < d; p++) Ae(e, a()[(o + p) >>> 0]);
            s += d;
          }
          return (u()[r >>> 2] = s), 0;
        }
        function xe(e) {
          return p['_' + e];
        }
        function Fe(e, n, r, u, s) {
          var i = {
            string: e => {
              var t = 0;
              if (null != e && 0 !== e) {
                var n = 1 + (e.length << 2);
                !(function (e, t, n) {
                  !(function (e, t, n, a) {
                    if (!(a > 0)) return 0;
                    n >>>= 0;
                    for (var r = n + a - 1, u = 0; u < e.length; ++u) {
                      var s = e.charCodeAt(u);
                      if ((s >= 55296 && s <= 57343 && (s = (65536 + ((1023 & s) << 10)) | (1023 & e.charCodeAt(++u))), s <= 127)) {
                        if (n >= r) break;
                        t[n++ >>> 0] = s;
                      } else if (s <= 2047) {
                        if (n + 1 >= r) break;
                        (t[n++ >>> 0] = 192 | (s >> 6)), (t[n++ >>> 0] = 128 | (63 & s));
                      } else if (s <= 65535) {
                        if (n + 2 >= r) break;
                        (t[n++ >>> 0] = 224 | (s >> 12)), (t[n++ >>> 0] = 128 | ((s >> 6) & 63)), (t[n++ >>> 0] = 128 | (63 & s));
                      } else {
                        if (n + 3 >= r) break;
                        (t[n++ >>> 0] = 240 | (s >> 18)),
                          (t[n++ >>> 0] = 128 | ((s >> 12) & 63)),
                          (t[n++ >>> 0] = 128 | ((s >> 6) & 63)),
                          (t[n++ >>> 0] = 128 | (63 & s));
                      }
                    }
                    t[n >>> 0] = 0;
                  })(e, a(), t, n);
                })(e, (t = je(n)), n);
              }
              return t;
            },
            array: e => {
              var n = je(e.length);
              return (
                (function (e, n) {
                  t().set(e, n >>> 0);
                })(e, n),
                n
              );
            },
          };
          function o(e) {
            return 'string' === n ? ((t = e), (t >>>= 0) ? L(a(), t, r) : '') : 'boolean' === n ? Boolean(e) : e;
            var t, r;
          }
          var d = xe(e),
            p = [],
            l = 0;
          if (u)
            for (var c = 0; c < u.length; c++) {
              var m = i[r[c]];
              m ? (0 === l && (l = Le()), (p[c] = m(u[c]))) : (p[c] = u[c]);
            }
          var f = d.apply(null, p);
          return (f = (function (e) {
            return 0 !== l && Ue(l), o(e);
          })(f));
        }
        de.init();
        var Ne = [null, ie, le, fe, ke, Me, ve],
          De = {
            __emscripten_init_main_thread_js: function (e) {
              Ee(e, !y, 1, !b), de.threadInitTLS();
            },
            __emscripten_thread_cleanup: function (e) {
              g ? postMessage({ cmd: 'cleanupThread', thread: e }) : ue(e);
            },
            __pthread_create_js: he,
            _emscripten_default_pthread_stack_size: function () {
              return 65536;
            },
            _emscripten_get_now_is_monotonic: function () {
              return !0;
            },
            _emscripten_notify_task_queue: function (e, t, n, a) {
              if (e == t) setTimeout(() => be(a));
              else if (g) postMessage({ targetThread: e, cmd: 'processProxyingQueue', queue: a });
              else {
                var r = de.pthreads[e];
                if (!r) return;
                r.postMessage({ cmd: 'processProxyingQueue', queue: a });
              }
              return 1;
            },
            _emscripten_set_offscreencanvas_size: function (e, t, n) {
              return -1;
            },
            abort: function () {
              Y('');
            },
            emscripten_check_blocking_allowed: function () {
              _ ||
                y ||
                ye(
                  'Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread',
                );
            },
            emscripten_date_now: function () {
              return Date.now();
            },
            emscripten_get_heap_max: function () {
              return 4294901760;
            },
            emscripten_get_now: ce,
            emscripten_memcpy_big: function (e, t, n) {
              a().copyWithin(e >>> 0, t >>> 0, (t + n) >>> 0);
            },
            emscripten_num_logical_cores: function () {
              return _ ? hn.cpus().length : navigator.hardwareConcurrency;
            },
            emscripten_receive_on_main_thread_js: function (e, t, n) {
              Ie.length = t;
              for (var a = n >> 3, r = 0; r < t; r++) Ie[r] = s()[(a + r) >>> 0];
              return (e < 0 ? ae[-e - 1] : Ne[e]).apply(null, Ie);
            },
            emscripten_resize_heap: function (e) {
              var t = a().length;
              if ((e >>>= 0) <= t) return !1;
              var n,
                r,
                u = 4294901760;
              if (e > u) return !1;
              for (var s = 1; s <= 4; s *= 2) {
                var i = t * (1 + 0.2 / s);
                if (((i = Math.min(i, e + 100663296)), we(Math.min(u, (n = Math.max(e, i)) + (((r = 65536) - (n % r)) % r))))) return !0;
              }
              return !1;
            },
            emscripten_unwind_to_js_event_loop: function () {
              throw 'unwind';
            },
            exit: oe,
            fd_close: ke,
            fd_seek: Me,
            fd_write: ve,
            memory: N || p.wasmMemory,
          };
        !(function () {
          var e = { env: De, wasi_snapshot_preview1: De };
          function t(e, t) {
            var n,
              a,
              r = e.exports;
            if (
              ((p.asm = r),
              (n = p.asm._emscripten_tls_init),
              de.tlsInitFunctions.push(n),
              (j = p.asm.__indirect_function_table),
              (a = p.asm.__wasm_call_ctors),
              V.unshift(a),
              (D = t),
              !g)
            ) {
              var u = de.unusedWorkers.length;
              de.unusedWorkers.forEach(function (e) {
                de.loadWasmModuleToWorker(e, function () {
                  --u ||
                    (function (e) {
                      if ((J--, p.monitorRunDependencies && p.monitorRunDependencies(J), 0 == J && Z)) {
                        var t = Z;
                        (Z = null), t();
                      }
                    })();
                });
              });
            }
          }
          function n(e) {
            t(e.instance, e.module);
          }
          function a(t) {
            return (function () {
              if (!v && (b || y)) {
                if ('function' == typeof fetch && !te(Q))
                  return fetch(Q, { credentials: 'same-origin' })
                    .then(function (e) {
                      if (!e.ok) throw "failed to load wasm binary file at '" + Q + "'";
                      return e.arrayBuffer();
                    })
                    .catch(function () {
                      return ne(Q);
                    });
                if (c)
                  return new Promise(function (e, t) {
                    c(
                      Q,
                      function (t) {
                        e(new Uint8Array(t));
                      },
                      t,
                    );
                  });
              }
              return Promise.resolve().then(function () {
                return ne(Q);
              });
            })()
              .then(function (t) {
                return WebAssembly.instantiate(t, e);
              })
              .then(function (e) {
                return e;
              })
              .then(t, function (e) {
                F('failed to asynchronously prepare wasm: ' + e), Y(e);
              });
          }
          if ((g || (J++, p.monitorRunDependencies && p.monitorRunDependencies(J)), p.instantiateWasm))
            try {
              return p.instantiateWasm(e, t);
            } catch (e) {
              F('Module.instantiateWasm callback failed with error: ' + e), o(e);
            }
          (v || 'function' != typeof WebAssembly.instantiateStreaming || ee(Q) || te(Q) || _ || 'function' != typeof fetch
            ? a(n)
            : fetch(Q, { credentials: 'same-origin' }).then(function (t) {
                return WebAssembly.instantiateStreaming(t, e).then(n, function (e) {
                  return F('wasm streaming compile failed: ' + e), F('falling back to ArrayBuffer instantiation'), a(n);
                });
              })
          ).catch(o);
        })(),
          (p.___wasm_call_ctors = function () {
            return (p.___wasm_call_ctors = p.asm.__wasm_call_ctors).apply(null, arguments);
          }),
          (p._init = function () {
            return (p._init = p.asm.init).apply(null, arguments);
          }),
          (p._init_with_threads_count = function () {
            return (p._init_with_threads_count = p.asm.init_with_threads_count).apply(null, arguments);
          }),
          (p._get_threads_count = function () {
            return (p._get_threads_count = p.asm.get_threads_count).apply(null, arguments);
          }),
          (p._register_tensor = function () {
            return (p._register_tensor = p.asm.register_tensor).apply(null, arguments);
          }),
          (p._dispose_data = function () {
            return (p._dispose_data = p.asm.dispose_data).apply(null, arguments);
          }),
          (p._dispose = function () {
            return (p._dispose = p.asm.dispose).apply(null, arguments);
          }),
          (p._Abs = function () {
            return (p._Abs = p.asm.Abs).apply(null, arguments);
          }),
          (p._Acos = function () {
            return (p._Acos = p.asm.Acos).apply(null, arguments);
          }),
          (p._Acosh = function () {
            return (p._Acosh = p.asm.Acosh).apply(null, arguments);
          }),
          (p._Add = function () {
            return (p._Add = p.asm.Add).apply(null, arguments);
          }),
          (p._AddN = function () {
            return (p._AddN = p.asm.AddN).apply(null, arguments);
          }),
          (p._All = function () {
            return (p._All = p.asm.All).apply(null, arguments);
          }),
          (p._Any = function () {
            return (p._Any = p.asm.Any).apply(null, arguments);
          }),
          (p._ArgMax = function () {
            return (p._ArgMax = p.asm.ArgMax).apply(null, arguments);
          }),
          (p._ArgMin = function () {
            return (p._ArgMin = p.asm.ArgMin).apply(null, arguments);
          }),
          (p._Asin = function () {
            return (p._Asin = p.asm.Asin).apply(null, arguments);
          }),
          (p._Asinh = function () {
            return (p._Asinh = p.asm.Asinh).apply(null, arguments);
          }),
          (p._Atan = function () {
            return (p._Atan = p.asm.Atan).apply(null, arguments);
          }),
          (p._Atan2 = function () {
            return (p._Atan2 = p.asm.Atan2).apply(null, arguments);
          }),
          (p._Atanh = function () {
            return (p._Atanh = p.asm.Atanh).apply(null, arguments);
          }),
          (p._AvgPool = function () {
            return (p._AvgPool = p.asm.AvgPool).apply(null, arguments);
          }),
          (p._AvgPool3D = function () {
            return (p._AvgPool3D = p.asm.AvgPool3D).apply(null, arguments);
          }),
          (p._AvgPool3DGrad = function () {
            return (p._AvgPool3DGrad = p.asm.AvgPool3DGrad).apply(null, arguments);
          }),
          (p._AvgPoolGrad = function () {
            return (p._AvgPoolGrad = p.asm.AvgPoolGrad).apply(null, arguments);
          }),
          (p._BatchMatMul = function () {
            return (p._BatchMatMul = p.asm.BatchMatMul).apply(null, arguments);
          }),
          (p._Bincount = function () {
            return (p._Bincount = p.asm.Bincount).apply(null, arguments);
          }),
          (p._BitwiseAnd = function () {
            return (p._BitwiseAnd = p.asm.BitwiseAnd).apply(null, arguments);
          }),
          (p._Ceil = function () {
            return (p._Ceil = p.asm.Ceil).apply(null, arguments);
          }),
          (p._ClipByValue = function () {
            return (p._ClipByValue = p.asm.ClipByValue).apply(null, arguments);
          }),
          (p._Conv2D = function () {
            return (p._Conv2D = p.asm.Conv2D).apply(null, arguments);
          }),
          (p._Conv2DBackpropInput = function () {
            return (p._Conv2DBackpropInput = p.asm.Conv2DBackpropInput).apply(null, arguments);
          }),
          (p._Conv3D = function () {
            return (p._Conv3D = p.asm.Conv3D).apply(null, arguments);
          }),
          (p._Conv3DBackpropFilterV2 = function () {
            return (p._Conv3DBackpropFilterV2 = p.asm.Conv3DBackpropFilterV2).apply(null, arguments);
          }),
          (p._Conv3DBackpropInputV2 = function () {
            return (p._Conv3DBackpropInputV2 = p.asm.Conv3DBackpropInputV2).apply(null, arguments);
          }),
          (p._Cos = function () {
            return (p._Cos = p.asm.Cos).apply(null, arguments);
          }),
          (p._Cosh = function () {
            return (p._Cosh = p.asm.Cosh).apply(null, arguments);
          }),
          (p._CropAndResize = function () {
            return (p._CropAndResize = p.asm.CropAndResize).apply(null, arguments);
          }),
          (p._Cumprod = function () {
            return (p._Cumprod = p.asm.Cumprod).apply(null, arguments);
          }),
          (p._Cumsum = function () {
            return (p._Cumsum = p.asm.Cumsum).apply(null, arguments);
          }),
          (p._DenseBincount = function () {
            return (p._DenseBincount = p.asm.DenseBincount).apply(null, arguments);
          }),
          (p._DepthToSpace = function () {
            return (p._DepthToSpace = p.asm.DepthToSpace).apply(null, arguments);
          }),
          (p._DepthwiseConv2dNative = function () {
            return (p._DepthwiseConv2dNative = p.asm.DepthwiseConv2dNative).apply(null, arguments);
          }),
          (p._Diag = function () {
            return (p._Diag = p.asm.Diag).apply(null, arguments);
          }),
          (p._Dilation2D = function () {
            return (p._Dilation2D = p.asm.Dilation2D).apply(null, arguments);
          }),
          (p._Dilation2DBackpropFilter = function () {
            return (p._Dilation2DBackpropFilter = p.asm.Dilation2DBackpropFilter).apply(null, arguments);
          }),
          (p._Dilation2DBackpropInput = function () {
            return (p._Dilation2DBackpropInput = p.asm.Dilation2DBackpropInput).apply(null, arguments);
          }),
          (p._Elu = function () {
            return (p._Elu = p.asm.Elu).apply(null, arguments);
          }),
          (p._EluGrad = function () {
            return (p._EluGrad = p.asm.EluGrad).apply(null, arguments);
          }),
          (p._Equal = function () {
            return (p._Equal = p.asm.Equal).apply(null, arguments);
          }),
          (p._Erf = function () {
            return (p._Erf = p.asm.Erf).apply(null, arguments);
          }),
          (p._Exp = function () {
            return (p._Exp = p.asm.Exp).apply(null, arguments);
          }),
          (p._Expm1 = function () {
            return (p._Expm1 = p.asm.Expm1).apply(null, arguments);
          }),
          (p._FlipLeftRight = function () {
            return (p._FlipLeftRight = p.asm.FlipLeftRight).apply(null, arguments);
          }),
          (p._Floor = function () {
            return (p._Floor = p.asm.Floor).apply(null, arguments);
          }),
          (p._FloorDiv = function () {
            return (p._FloorDiv = p.asm.FloorDiv).apply(null, arguments);
          }),
          (p._FusedBatchNorm = function () {
            return (p._FusedBatchNorm = p.asm.FusedBatchNorm).apply(null, arguments);
          }),
          (p._FusedConv2D = function () {
            return (p._FusedConv2D = p.asm.FusedConv2D).apply(null, arguments);
          }),
          (p._FusedDepthwiseConv2D = function () {
            return (p._FusedDepthwiseConv2D = p.asm.FusedDepthwiseConv2D).apply(null, arguments);
          }),
          (p._Gather = function () {
            return (p._Gather = p.asm.Gather).apply(null, arguments);
          }),
          (p._GatherNd = function () {
            return (p._GatherNd = p.asm.GatherNd).apply(null, arguments);
          }),
          (p._Greater = function () {
            return (p._Greater = p.asm.Greater).apply(null, arguments);
          }),
          (p._GreaterEqual = function () {
            return (p._GreaterEqual = p.asm.GreaterEqual).apply(null, arguments);
          }),
          (p._IsFinite = function () {
            return (p._IsFinite = p.asm.IsFinite).apply(null, arguments);
          }),
          (p._IsInf = function () {
            return (p._IsInf = p.asm.IsInf).apply(null, arguments);
          }),
          (p._IsNan = function () {
            return (p._IsNan = p.asm.IsNan).apply(null, arguments);
          }),
          (p._LRN = function () {
            return (p._LRN = p.asm.LRN).apply(null, arguments);
          }),
          (p._LRNGrad = function () {
            return (p._LRNGrad = p.asm.LRNGrad).apply(null, arguments);
          }),
          (p._LeakyRelu = function () {
            return (p._LeakyRelu = p.asm.LeakyRelu).apply(null, arguments);
          }),
          (p._Less = function () {
            return (p._Less = p.asm.Less).apply(null, arguments);
          }),
          (p._LessEqual = function () {
            return (p._LessEqual = p.asm.LessEqual).apply(null, arguments);
          }),
          (p._LinSpace = function () {
            return (p._LinSpace = p.asm.LinSpace).apply(null, arguments);
          }),
          (p._Log = function () {
            return (p._Log = p.asm.Log).apply(null, arguments);
          }),
          (p._Log1p = function () {
            return (p._Log1p = p.asm.Log1p).apply(null, arguments);
          }),
          (p._LogicalAnd = function () {
            return (p._LogicalAnd = p.asm.LogicalAnd).apply(null, arguments);
          }),
          (p._LogicalNot = function () {
            return (p._LogicalNot = p.asm.LogicalNot).apply(null, arguments);
          }),
          (p._LogicalOr = function () {
            return (p._LogicalOr = p.asm.LogicalOr).apply(null, arguments);
          }),
          (p._LogicalXor = function () {
            return (p._LogicalXor = p.asm.LogicalXor).apply(null, arguments);
          }),
          (p._Max = function () {
            return (p._Max = p.asm.Max).apply(null, arguments);
          }),
          (p._MaxPool = function () {
            return (p._MaxPool = p.asm.MaxPool).apply(null, arguments);
          }),
          (p._MaxPool3D = function () {
            return (p._MaxPool3D = p.asm.MaxPool3D).apply(null, arguments);
          }),
          (p._MaxPool3DGrad = function () {
            return (p._MaxPool3DGrad = p.asm.MaxPool3DGrad).apply(null, arguments);
          }),
          (p._MaxPoolGrad = function () {
            return (p._MaxPoolGrad = p.asm.MaxPoolGrad).apply(null, arguments);
          }),
          (p._MaxPoolWithArgmax = function () {
            return (p._MaxPoolWithArgmax = p.asm.MaxPoolWithArgmax).apply(null, arguments);
          }),
          (p._Maximum = function () {
            return (p._Maximum = p.asm.Maximum).apply(null, arguments);
          }),
          (p._Mean = function () {
            return (p._Mean = p.asm.Mean).apply(null, arguments);
          }),
          (p._Min = function () {
            return (p._Min = p.asm.Min).apply(null, arguments);
          }),
          (p._Minimum = function () {
            return (p._Minimum = p.asm.Minimum).apply(null, arguments);
          }),
          (p._MirrorPad = function () {
            return (p._MirrorPad = p.asm.MirrorPad).apply(null, arguments);
          }),
          (p._Mod = function () {
            return (p._Mod = p.asm.Mod).apply(null, arguments);
          }),
          (p._Multinomial = function () {
            return (p._Multinomial = p.asm.Multinomial).apply(null, arguments);
          }),
          (p._Multiply = function () {
            return (p._Multiply = p.asm.Multiply).apply(null, arguments);
          }),
          (p._Neg = function () {
            return (p._Neg = p.asm.Neg).apply(null, arguments);
          }),
          (p._NonMaxSuppressionV3 = function () {
            return (p._NonMaxSuppressionV3 = p.asm.NonMaxSuppressionV3).apply(null, arguments);
          }),
          (p._NonMaxSuppressionV4 = function () {
            return (p._NonMaxSuppressionV4 = p.asm.NonMaxSuppressionV4).apply(null, arguments);
          }),
          (p._NonMaxSuppressionV5 = function () {
            return (p._NonMaxSuppressionV5 = p.asm.NonMaxSuppressionV5).apply(null, arguments);
          }),
          (p._NotEqual = function () {
            return (p._NotEqual = p.asm.NotEqual).apply(null, arguments);
          }),
          (p._OneHot = function () {
            return (p._OneHot = p.asm.OneHot).apply(null, arguments);
          }),
          (p._PadV2 = function () {
            return (p._PadV2 = p.asm.PadV2).apply(null, arguments);
          }),
          (p._Pow = function () {
            return (p._Pow = p.asm.Pow).apply(null, arguments);
          }),
          (p._Prelu = function () {
            return (p._Prelu = p.asm.Prelu).apply(null, arguments);
          }),
          (p._Prod = function () {
            return (p._Prod = p.asm.Prod).apply(null, arguments);
          }),
          (p._RealDiv = function () {
            return (p._RealDiv = p.asm.RealDiv).apply(null, arguments);
          }),
          (p._Reciprocal = function () {
            return (p._Reciprocal = p.asm.Reciprocal).apply(null, arguments);
          }),
          (p._Relu = function () {
            return (p._Relu = p.asm.Relu).apply(null, arguments);
          }),
          (p._Relu6 = function () {
            return (p._Relu6 = p.asm.Relu6).apply(null, arguments);
          }),
          (p._ResizeBilinear = function () {
            return (p._ResizeBilinear = p.asm.ResizeBilinear).apply(null, arguments);
          }),
          (p._ResizeBilinearGrad = function () {
            return (p._ResizeBilinearGrad = p.asm.ResizeBilinearGrad).apply(null, arguments);
          }),
          (p._ResizeNearestNeighbor = function () {
            return (p._ResizeNearestNeighbor = p.asm.ResizeNearestNeighbor).apply(null, arguments);
          }),
          (p._ResizeNearestNeighborGrad = function () {
            return (p._ResizeNearestNeighborGrad = p.asm.ResizeNearestNeighborGrad).apply(null, arguments);
          }),
          (p._Reverse = function () {
            return (p._Reverse = p.asm.Reverse).apply(null, arguments);
          }),
          (p._RotateWithOffset = function () {
            return (p._RotateWithOffset = p.asm.RotateWithOffset).apply(null, arguments);
          }),
          (p._Round = function () {
            return (p._Round = p.asm.Round).apply(null, arguments);
          }),
          (p._Rsqrt = function () {
            return (p._Rsqrt = p.asm.Rsqrt).apply(null, arguments);
          }),
          (p._ScatterNd = function () {
            return (p._ScatterNd = p.asm.ScatterNd).apply(null, arguments);
          }),
          (p._SearchSorted = function () {
            return (p._SearchSorted = p.asm.SearchSorted).apply(null, arguments);
          }),
          (p._SelectV2 = function () {
            return (p._SelectV2 = p.asm.SelectV2).apply(null, arguments);
          }),
          (p._Selu = function () {
            return (p._Selu = p.asm.Selu).apply(null, arguments);
          }),
          (p._Sigmoid = function () {
            return (p._Sigmoid = p.asm.Sigmoid).apply(null, arguments);
          }),
          (p._Sign = function () {
            return (p._Sign = p.asm.Sign).apply(null, arguments);
          }),
          (p._Sin = function () {
            return (p._Sin = p.asm.Sin).apply(null, arguments);
          }),
          (p._Sinh = function () {
            return (p._Sinh = p.asm.Sinh).apply(null, arguments);
          }),
          (p._Softmax = function () {
            return (p._Softmax = p.asm.Softmax).apply(null, arguments);
          }),
          (p._Softplus = function () {
            return (p._Softplus = p.asm.Softplus).apply(null, arguments);
          }),
          (p._SparseFillEmptyRows = function () {
            return (p._SparseFillEmptyRows = p.asm.SparseFillEmptyRows).apply(null, arguments);
          }),
          (p._SparseReshape = function () {
            return (p._SparseReshape = p.asm.SparseReshape).apply(null, arguments);
          }),
          (p._SparseSegmentReduction = function () {
            return (p._SparseSegmentReduction = p.asm.SparseSegmentReduction).apply(null, arguments);
          }),
          (p._SparseToDense = function () {
            return (p._SparseToDense = p.asm.SparseToDense).apply(null, arguments);
          }),
          (p._Sqrt = function () {
            return (p._Sqrt = p.asm.Sqrt).apply(null, arguments);
          }),
          (p._Square = function () {
            return (p._Square = p.asm.Square).apply(null, arguments);
          }),
          (p._SquaredDifference = function () {
            return (p._SquaredDifference = p.asm.SquaredDifference).apply(null, arguments);
          }),
          (p._Step = function () {
            return (p._Step = p.asm.Step).apply(null, arguments);
          }),
          (p._StridedSlice = function () {
            return (p._StridedSlice = p.asm.StridedSlice).apply(null, arguments);
          }),
          (p._Sub = function () {
            return (p._Sub = p.asm.Sub).apply(null, arguments);
          }),
          (p._Sum = function () {
            return (p._Sum = p.asm.Sum).apply(null, arguments);
          }),
          (p._Tan = function () {
            return (p._Tan = p.asm.Tan).apply(null, arguments);
          }),
          (p._Tanh = function () {
            return (p._Tanh = p.asm.Tanh).apply(null, arguments);
          }),
          (p._TensorScatterUpdate = function () {
            return (p._TensorScatterUpdate = p.asm.TensorScatterUpdate).apply(null, arguments);
          }),
          (p._Tile = function () {
            return (p._Tile = p.asm.Tile).apply(null, arguments);
          }),
          (p._TopK = function () {
            return (p._TopK = p.asm.TopK).apply(null, arguments);
          }),
          (p._Transform = function () {
            return (p._Transform = p.asm.Transform).apply(null, arguments);
          }),
          (p._Transpose = function () {
            return (p._Transpose = p.asm.Transpose).apply(null, arguments);
          }),
          (p.__FusedMatMul = function () {
            return (p.__FusedMatMul = p.asm._FusedMatMul).apply(null, arguments);
          }),
          (p._malloc = function () {
            return (p._malloc = p.asm.malloc).apply(null, arguments);
          }),
          (p._free = function () {
            return (p._free = p.asm.free).apply(null, arguments);
          }),
          (p.__emscripten_tls_init = function () {
            return (p.__emscripten_tls_init = p.asm._emscripten_tls_init).apply(null, arguments);
          });
        var Re = (p._pthread_self = function () {
          return (Re = p._pthread_self = p.asm.pthread_self).apply(null, arguments);
        });
        p.___errno_location = function () {
          return (p.___errno_location = p.asm.__errno_location).apply(null, arguments);
        };
        var Ee = (p.__emscripten_thread_init = function () {
          return (Ee = p.__emscripten_thread_init = p.asm._emscripten_thread_init).apply(null, arguments);
        });
        (p.__emscripten_thread_crashed = function () {
          return (p.__emscripten_thread_crashed = p.asm._emscripten_thread_crashed).apply(null, arguments);
        }),
          (p._emscripten_main_thread_process_queued_calls = function () {
            return (p._emscripten_main_thread_process_queued_calls = p.asm.emscripten_main_thread_process_queued_calls).apply(
              null,
              arguments,
            );
          }),
          (p._emscripten_main_browser_thread_id = function () {
            return (p._emscripten_main_browser_thread_id = p.asm.emscripten_main_browser_thread_id).apply(null, arguments);
          });
        var We = (p._emscripten_run_in_main_runtime_thread_js = function () {
          return (We = p._emscripten_run_in_main_runtime_thread_js = p.asm.emscripten_run_in_main_runtime_thread_js).apply(null, arguments);
        });
        p._emscripten_dispatch_to_thread_ = function () {
          return (p._emscripten_dispatch_to_thread_ = p.asm.emscripten_dispatch_to_thread_).apply(null, arguments);
        };
        var Pe,
          Oe,
          Ce,
          Te = (p.__emscripten_proxy_execute_task_queue = function () {
            return (Te = p.__emscripten_proxy_execute_task_queue = p.asm._emscripten_proxy_execute_task_queue).apply(null, arguments);
          }),
          ze = (p.__emscripten_thread_free_data = function () {
            return (ze = p.__emscripten_thread_free_data = p.asm._emscripten_thread_free_data).apply(null, arguments);
          }),
          He = (p.__emscripten_thread_exit = function () {
            return (He = p.__emscripten_thread_exit = p.asm._emscripten_thread_exit).apply(null, arguments);
          }),
          Be = (p._emscripten_stack_set_limits = function () {
            return (Be = p._emscripten_stack_set_limits = p.asm.emscripten_stack_set_limits).apply(null, arguments);
          }),
          Le = (p.stackSave = function () {
            return (Le = p.stackSave = p.asm.stackSave).apply(null, arguments);
          }),
          Ue = (p.stackRestore = function () {
            return (Ue = p.stackRestore = p.asm.stackRestore).apply(null, arguments);
          }),
          je = (p.stackAlloc = function () {
            return (je = p.stackAlloc = p.asm.stackAlloc).apply(null, arguments);
          });
        function Ge(e) {
          if (!(J > 0)) {
            if (g) return i(p), X(), void startWorker(p);
            !(function () {
              if (p.preRun)
                for ('function' == typeof p.preRun && (p.preRun = [p.preRun]); p.preRun.length; ) (e = p.preRun.shift()), q.unshift(e);
              var e;
              pe(q);
            })(),
              J > 0 ||
                (p.setStatus
                  ? (p.setStatus('Running...'),
                    setTimeout(function () {
                      setTimeout(function () {
                        p.setStatus('');
                      }, 1),
                        t();
                    }, 1))
                  : t());
          }
          function t() {
            Pe ||
              ((Pe = !0),
              (p.calledRun = !0),
              H ||
                (X(),
                i(p),
                p.onRuntimeInitialized && p.onRuntimeInitialized(),
                (function () {
                  if (!g) {
                    if (p.postRun)
                      for ('function' == typeof p.postRun && (p.postRun = [p.postRun]); p.postRun.length; )
                        (e = p.postRun.shift()), $.unshift(e);
                    var e;
                    pe($);
                  }
                })()));
          }
        }
        if (
          ((p.dynCall_iijjiiii = function () {
            return (p.dynCall_iijjiiii = p.asm.dynCall_iijjiiii).apply(null, arguments);
          }),
          (p.dynCall_jiji = function () {
            return (p.dynCall_jiji = p.asm.dynCall_jiji).apply(null, arguments);
          }),
          (p.keepRuntimeAlive = K),
          (p.wasmMemory = N),
          (p.cwrap = function (e, t, n, a) {
            var r = (n = n || []).every(e => 'number' === e || 'boolean' === e);
            return 'string' !== t && r && !a
              ? xe(e)
              : function () {
                  return Fe(e, t, n, arguments);
                };
          }),
          (p.ExitStatus = re),
          (p.PThread = de),
          (Z = function e() {
            Pe || Ge(), Pe || (Z = e);
          }),
          p.preInit)
        )
          for ('function' == typeof p.preInit && (p.preInit = [p.preInit]); p.preInit.length > 0; ) p.preInit.pop()();
        if (
          (Ge(),
          d &&
            (Oe = {
              uncaughtException: process.listeners('uncaughtException').filter(function (e) {
                return !d.uncaughtException.indexOf(e) > -1;
              }),
              unhandledRejection: process.listeners('unhandledRejection').filter(function (e) {
                return !d.unhandledRejection.indexOf(e) > -1;
              }),
            }),
          'undefined' != typeof WasmBackendModule)
        )
          Ce = WasmBackendModule;
        else {
          if ('undefined' == typeof e) throw new Error('Could not find wasm module in post.js');
          Ce = e;
        }
        if (Oe) {
          var qe = Ce._dispose;
          Ce._dispose = function () {
            qe(),
              Oe.uncaughtException.forEach(function (e) {
                process.removeListener('uncaughtException', e);
              }),
              Oe.unhandledRejection.forEach(function (e) {
                process.removeListener('unhandledRejection', e);
              });
          };
        }
        return e.ready;
      });
  e.exports = a;
})(ni);
var ai = ni.exports,
  ri = ti(ai),
  ui = bn({ __proto__: null, default: ri }, [ai]),
  si =
    '"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};',
  ii = { exports: {} };
!(function (e, t) {
  var n,
    a =
      ((n = 'undefined' != typeof document && document.currentScript ? document.currentScript.src : void 0),
      'undefined' != typeof __filename && (n = n || __filename),
      function (e) {
        var t,
          a,
          r,
          u = 'undefined' != typeof (e = e || {}) ? e : {};
        (u.ready = new Promise(function (e, n) {
          (t = e), (a = n);
        })),
          'undefined' != typeof process &&
            process.listeners &&
            (r = {
              uncaughtException: process.listeners('uncaughtException'),
              unhandledRejection: process.listeners('unhandledRejection'),
            });
        var s,
          i,
          o,
          d = Object.assign({}, u),
          p = 'object' == typeof window,
          l = 'function' == typeof importScripts,
          c = 'object' == typeof process && 'object' == typeof process.versions && 'string' == typeof process.versions.node,
          m = '';
        if (c) {
          var f = cn,
            h = mn;
          (m = l ? h.dirname(m) + '/' : __dirname + '/'),
            (s = (e, t) => ((e = T(e) ? new URL(e) : h.normalize(e)), f.readFileSync(e, t ? void 0 : 'utf8'))),
            (o = e => {
              var t = s(e, !0);
              return t.buffer || (t = new Uint8Array(t)), t;
            }),
            (i = (e, t, n) => {
              (e = T(e) ? new URL(e) : h.normalize(e)),
                f.readFile(e, function (e, a) {
                  e ? n(e) : t(a.buffer);
                });
            }),
            process.argv.length > 1 && process.argv[1].replace(/\\/g, '/'),
            process.argv.slice(2),
            process.on('uncaughtException', function (e) {
              if (!(e instanceof H)) throw e;
            }),
            process.on('unhandledRejection', function (e) {
              throw e;
            }),
            (u.inspect = function () {
              return '[Emscripten Module object]';
            });
        } else
          (p || l) &&
            (l ? (m = self.location.href) : 'undefined' != typeof document && document.currentScript && (m = document.currentScript.src),
            n && (m = n),
            (m = 0 !== m.indexOf('blob:') ? m.substr(0, m.replace(/[?#].*/, '').lastIndexOf('/') + 1) : ''),
            (s = e => {
              var t = new XMLHttpRequest();
              return t.open('GET', e, !1), t.send(null), t.responseText;
            }),
            l &&
              (o = e => {
                var t = new XMLHttpRequest();
                return t.open('GET', e, !1), (t.responseType = 'arraybuffer'), t.send(null), new Uint8Array(t.response);
              }),
            (i = (e, t, n) => {
              var a = new XMLHttpRequest();
              a.open('GET', e, !0),
                (a.responseType = 'arraybuffer'),
                (a.onload = () => {
                  200 == a.status || (0 == a.status && a.response) ? t(a.response) : n();
                }),
                (a.onerror = n),
                a.send(null);
            }));
        var b,
          y,
          _ = u.print || console.log.bind(console),
          g = u.printErr || console.warn.bind(console);
        Object.assign(u, d),
          (d = null),
          u.arguments && u.arguments,
          u.thisProgram && u.thisProgram,
          u.quit && u.quit,
          u.wasmBinary && (b = u.wasmBinary),
          u.noExitRuntime,
          'object' != typeof WebAssembly && O('no native wasm support detected');
        var I,
          w,
          k,
          M,
          S = !1,
          A = 'undefined' != typeof TextDecoder ? new TextDecoder('utf8') : void 0;
        function v(e, t, n) {
          for (var a = (t >>>= 0) + n, r = t; e[r] && !(r >= a); ) ++r;
          if (r - t > 16 && e.buffer && A) return A.decode(e.subarray(t, r));
          for (var u = ''; t < r; ) {
            var s = e[t++];
            if (128 & s) {
              var i = 63 & e[t++];
              if (192 != (224 & s)) {
                var o = 63 & e[t++];
                if (
                  (s = 224 == (240 & s) ? ((15 & s) << 12) | (i << 6) | o : ((7 & s) << 18) | (i << 12) | (o << 6) | (63 & e[t++])) < 65536
                )
                  u += String.fromCharCode(s);
                else {
                  var d = s - 65536;
                  u += String.fromCharCode(55296 | (d >> 10), 56320 | (1023 & d));
                }
              } else u += String.fromCharCode(((31 & s) << 6) | i);
            } else u += String.fromCharCode(s);
          }
          return u;
        }
        function x(e) {
          (I = e),
            (u.HEAP8 = w = new Int8Array(e)),
            (u.HEAP16 = new Int16Array(e)),
            (u.HEAP32 = new Int32Array(e)),
            (u.HEAPU8 = k = new Uint8Array(e)),
            (u.HEAPU16 = new Uint16Array(e)),
            (u.HEAPU32 = M = new Uint32Array(e)),
            (u.HEAPF32 = new Float32Array(e)),
            (u.HEAPF64 = new Float64Array(e));
        }
        u.INITIAL_MEMORY;
        var F,
          N,
          D = [],
          R = [],
          E = [],
          W = 0,
          P = null;
        function O(e) {
          u.onAbort && u.onAbort(e), g((e = 'Aborted(' + e + ')')), (S = !0), (e += '. Build with -sASSERTIONS for more info.');
          var t = new WebAssembly.RuntimeError(e);
          throw (a(t), t);
        }
        function C(e) {
          return e.startsWith('data:application/octet-stream;base64,');
        }
        function T(e) {
          return e.startsWith('file://');
        }
        function z(e) {
          try {
            if (e == F && b) return new Uint8Array(b);
            if (o) return o(e);
            throw 'both async and sync fetching of the wasm failed';
          } catch (e) {
            O(e);
          }
        }
        function H(e) {
          (this.name = 'ExitStatus'), (this.message = 'Program terminated with exit(' + e + ')'), (this.status = e);
        }
        function B(e) {
          for (; e.length > 0; ) e.shift()(u);
        }
        function L(e) {
          try {
            return y.grow((e - I.byteLength + 65535) >>> 16), x(y.buffer), 1;
          } catch (e) {}
        }
        C((F = 'tfjs-backend-wasm.wasm')) || ((N = F), (F = u.locateFile ? u.locateFile(N, m) : m + N));
        var U = [null, [], []];
        function j(e, t) {
          var n = U[e];
          0 === t || 10 === t ? ((1 === e ? _ : g)(v(n, 0)), (n.length = 0)) : n.push(t);
        }
        function G(e) {
          return u['_' + e];
        }
        function q(e, t, n, a, r) {
          var u = {
            string: e => {
              var t = 0;
              if (null != e && 0 !== e) {
                var n = 1 + (e.length << 2);
                !(function (e, t, n) {
                  !(function (e, t, n, a) {
                    if (!(a > 0)) return 0;
                    n >>>= 0;
                    for (var r = n + a - 1, u = 0; u < e.length; ++u) {
                      var s = e.charCodeAt(u);
                      if ((s >= 55296 && s <= 57343 && (s = (65536 + ((1023 & s) << 10)) | (1023 & e.charCodeAt(++u))), s <= 127)) {
                        if (n >= r) break;
                        t[n++ >>> 0] = s;
                      } else if (s <= 2047) {
                        if (n + 1 >= r) break;
                        (t[n++ >>> 0] = 192 | (s >> 6)), (t[n++ >>> 0] = 128 | (63 & s));
                      } else if (s <= 65535) {
                        if (n + 2 >= r) break;
                        (t[n++ >>> 0] = 224 | (s >> 12)), (t[n++ >>> 0] = 128 | ((s >> 6) & 63)), (t[n++ >>> 0] = 128 | (63 & s));
                      } else {
                        if (n + 3 >= r) break;
                        (t[n++ >>> 0] = 240 | (s >> 18)),
                          (t[n++ >>> 0] = 128 | ((s >> 12) & 63)),
                          (t[n++ >>> 0] = 128 | ((s >> 6) & 63)),
                          (t[n++ >>> 0] = 128 | (63 & s));
                      }
                    }
                    t[n >>> 0] = 0;
                  })(e, k, t, n);
                })(e, (t = Z(n)), n);
              }
              return t;
            },
            array: e => {
              var t = Z(e.length);
              return (
                (function (e, t) {
                  w.set(e, t >>> 0);
                })(e, t),
                t
              );
            },
          };
          function s(e) {
            return 'string' === t ? ((n = e), (n >>>= 0) ? v(k, n, a) : '') : 'boolean' === t ? Boolean(e) : e;
            var n, a;
          }
          var i = G(e),
            o = [],
            d = 0;
          if (a)
            for (var p = 0; p < a.length; p++) {
              var l = u[n[p]];
              l ? (0 === d && (d = Q()), (o[p] = l(a[p]))) : (o[p] = a[p]);
            }
          var c = i.apply(null, o);
          return (c = (function (e) {
            return 0 !== d && J(d), s(e);
          })(c));
        }
        var V = {
          abort: function () {
            O('');
          },
          emscripten_get_heap_max: function () {
            return 4294901760;
          },
          emscripten_memcpy_big: function (e, t, n) {
            k.copyWithin(e >>> 0, t >>> 0, (t + n) >>> 0);
          },
          emscripten_resize_heap: function (e) {
            var t,
              n,
              a = k.length,
              r = 4294901760;
            if ((e >>>= 0) > r) return !1;
            for (var u = 1; u <= 4; u *= 2) {
              var s = a * (1 + 0.2 / u);
              if (((s = Math.min(s, e + 100663296)), L(Math.min(r, (t = Math.max(e, s)) + (((n = 65536) - (t % n)) % n))))) return !0;
            }
            return !1;
          },
          fd_close: function (e) {
            return 52;
          },
          fd_seek: function (e, t, n, a, r) {
            return 70;
          },
          fd_write: function (e, t, n, a) {
            for (var r = 0, u = 0; u < n; u++) {
              var s = M[t >>> 2],
                i = M[(t + 4) >>> 2];
              t += 8;
              for (var o = 0; o < i; o++) j(e, k[(s + o) >>> 0]);
              r += i;
            }
            return (M[a >>> 2] = r), 0;
          },
        };
        !(function () {
          var e = { env: V, wasi_snapshot_preview1: V };
          function t(e, t) {
            var n,
              a = e.exports;
            (u.asm = a),
              x((y = u.asm.memory).buffer),
              u.asm.__indirect_function_table,
              (n = u.asm.__wasm_call_ctors),
              R.unshift(n),
              (function (e) {
                if ((W--, u.monitorRunDependencies && u.monitorRunDependencies(W), 0 == W && P)) {
                  var t = P;
                  (P = null), t();
                }
              })();
          }
          function n(e) {
            t(e.instance);
          }
          function r(t) {
            return (function () {
              if (!b && (p || l)) {
                if ('function' == typeof fetch && !T(F))
                  return fetch(F, { credentials: 'same-origin' })
                    .then(function (e) {
                      if (!e.ok) throw "failed to load wasm binary file at '" + F + "'";
                      return e.arrayBuffer();
                    })
                    .catch(function () {
                      return z(F);
                    });
                if (i)
                  return new Promise(function (e, t) {
                    i(
                      F,
                      function (t) {
                        e(new Uint8Array(t));
                      },
                      t,
                    );
                  });
              }
              return Promise.resolve().then(function () {
                return z(F);
              });
            })()
              .then(function (t) {
                return WebAssembly.instantiate(t, e);
              })
              .then(function (e) {
                return e;
              })
              .then(t, function (e) {
                g('failed to asynchronously prepare wasm: ' + e), O(e);
              });
          }
          if ((W++, u.monitorRunDependencies && u.monitorRunDependencies(W), u.instantiateWasm))
            try {
              return u.instantiateWasm(e, t);
            } catch (e) {
              g('Module.instantiateWasm callback failed with error: ' + e), a(e);
            }
          (b || 'function' != typeof WebAssembly.instantiateStreaming || C(F) || T(F) || c || 'function' != typeof fetch
            ? r(n)
            : fetch(F, { credentials: 'same-origin' }).then(function (t) {
                return WebAssembly.instantiateStreaming(t, e).then(n, function (e) {
                  return g('wasm streaming compile failed: ' + e), g('falling back to ArrayBuffer instantiation'), r(n);
                });
              })
          ).catch(a);
        })(),
          (u.___wasm_call_ctors = function () {
            return (u.___wasm_call_ctors = u.asm.__wasm_call_ctors).apply(null, arguments);
          }),
          (u._init = function () {
            return (u._init = u.asm.init).apply(null, arguments);
          }),
          (u._init_with_threads_count = function () {
            return (u._init_with_threads_count = u.asm.init_with_threads_count).apply(null, arguments);
          }),
          (u._get_threads_count = function () {
            return (u._get_threads_count = u.asm.get_threads_count).apply(null, arguments);
          }),
          (u._register_tensor = function () {
            return (u._register_tensor = u.asm.register_tensor).apply(null, arguments);
          }),
          (u._dispose_data = function () {
            return (u._dispose_data = u.asm.dispose_data).apply(null, arguments);
          }),
          (u._dispose = function () {
            return (u._dispose = u.asm.dispose).apply(null, arguments);
          }),
          (u._Abs = function () {
            return (u._Abs = u.asm.Abs).apply(null, arguments);
          }),
          (u._Acos = function () {
            return (u._Acos = u.asm.Acos).apply(null, arguments);
          }),
          (u._Acosh = function () {
            return (u._Acosh = u.asm.Acosh).apply(null, arguments);
          }),
          (u._Add = function () {
            return (u._Add = u.asm.Add).apply(null, arguments);
          }),
          (u._AddN = function () {
            return (u._AddN = u.asm.AddN).apply(null, arguments);
          }),
          (u._All = function () {
            return (u._All = u.asm.All).apply(null, arguments);
          }),
          (u._Any = function () {
            return (u._Any = u.asm.Any).apply(null, arguments);
          }),
          (u._ArgMax = function () {
            return (u._ArgMax = u.asm.ArgMax).apply(null, arguments);
          }),
          (u._ArgMin = function () {
            return (u._ArgMin = u.asm.ArgMin).apply(null, arguments);
          }),
          (u._Asin = function () {
            return (u._Asin = u.asm.Asin).apply(null, arguments);
          }),
          (u._Asinh = function () {
            return (u._Asinh = u.asm.Asinh).apply(null, arguments);
          }),
          (u._Atan = function () {
            return (u._Atan = u.asm.Atan).apply(null, arguments);
          }),
          (u._Atan2 = function () {
            return (u._Atan2 = u.asm.Atan2).apply(null, arguments);
          }),
          (u._Atanh = function () {
            return (u._Atanh = u.asm.Atanh).apply(null, arguments);
          }),
          (u._AvgPool = function () {
            return (u._AvgPool = u.asm.AvgPool).apply(null, arguments);
          }),
          (u._AvgPool3D = function () {
            return (u._AvgPool3D = u.asm.AvgPool3D).apply(null, arguments);
          }),
          (u._AvgPool3DGrad = function () {
            return (u._AvgPool3DGrad = u.asm.AvgPool3DGrad).apply(null, arguments);
          }),
          (u._AvgPoolGrad = function () {
            return (u._AvgPoolGrad = u.asm.AvgPoolGrad).apply(null, arguments);
          }),
          (u._BatchMatMul = function () {
            return (u._BatchMatMul = u.asm.BatchMatMul).apply(null, arguments);
          }),
          (u._Bincount = function () {
            return (u._Bincount = u.asm.Bincount).apply(null, arguments);
          }),
          (u._BitwiseAnd = function () {
            return (u._BitwiseAnd = u.asm.BitwiseAnd).apply(null, arguments);
          }),
          (u._Ceil = function () {
            return (u._Ceil = u.asm.Ceil).apply(null, arguments);
          }),
          (u._ClipByValue = function () {
            return (u._ClipByValue = u.asm.ClipByValue).apply(null, arguments);
          }),
          (u._Conv2D = function () {
            return (u._Conv2D = u.asm.Conv2D).apply(null, arguments);
          }),
          (u._Conv2DBackpropInput = function () {
            return (u._Conv2DBackpropInput = u.asm.Conv2DBackpropInput).apply(null, arguments);
          }),
          (u._Conv3D = function () {
            return (u._Conv3D = u.asm.Conv3D).apply(null, arguments);
          }),
          (u._Conv3DBackpropFilterV2 = function () {
            return (u._Conv3DBackpropFilterV2 = u.asm.Conv3DBackpropFilterV2).apply(null, arguments);
          }),
          (u._Conv3DBackpropInputV2 = function () {
            return (u._Conv3DBackpropInputV2 = u.asm.Conv3DBackpropInputV2).apply(null, arguments);
          }),
          (u._Cos = function () {
            return (u._Cos = u.asm.Cos).apply(null, arguments);
          }),
          (u._Cosh = function () {
            return (u._Cosh = u.asm.Cosh).apply(null, arguments);
          }),
          (u._CropAndResize = function () {
            return (u._CropAndResize = u.asm.CropAndResize).apply(null, arguments);
          }),
          (u._Cumprod = function () {
            return (u._Cumprod = u.asm.Cumprod).apply(null, arguments);
          }),
          (u._Cumsum = function () {
            return (u._Cumsum = u.asm.Cumsum).apply(null, arguments);
          }),
          (u._DenseBincount = function () {
            return (u._DenseBincount = u.asm.DenseBincount).apply(null, arguments);
          }),
          (u._DepthToSpace = function () {
            return (u._DepthToSpace = u.asm.DepthToSpace).apply(null, arguments);
          }),
          (u._DepthwiseConv2dNative = function () {
            return (u._DepthwiseConv2dNative = u.asm.DepthwiseConv2dNative).apply(null, arguments);
          }),
          (u._Diag = function () {
            return (u._Diag = u.asm.Diag).apply(null, arguments);
          }),
          (u._Dilation2D = function () {
            return (u._Dilation2D = u.asm.Dilation2D).apply(null, arguments);
          }),
          (u._Dilation2DBackpropFilter = function () {
            return (u._Dilation2DBackpropFilter = u.asm.Dilation2DBackpropFilter).apply(null, arguments);
          }),
          (u._Dilation2DBackpropInput = function () {
            return (u._Dilation2DBackpropInput = u.asm.Dilation2DBackpropInput).apply(null, arguments);
          }),
          (u._Elu = function () {
            return (u._Elu = u.asm.Elu).apply(null, arguments);
          }),
          (u._EluGrad = function () {
            return (u._EluGrad = u.asm.EluGrad).apply(null, arguments);
          }),
          (u._Equal = function () {
            return (u._Equal = u.asm.Equal).apply(null, arguments);
          }),
          (u._Erf = function () {
            return (u._Erf = u.asm.Erf).apply(null, arguments);
          }),
          (u._Exp = function () {
            return (u._Exp = u.asm.Exp).apply(null, arguments);
          }),
          (u._Expm1 = function () {
            return (u._Expm1 = u.asm.Expm1).apply(null, arguments);
          }),
          (u._FlipLeftRight = function () {
            return (u._FlipLeftRight = u.asm.FlipLeftRight).apply(null, arguments);
          }),
          (u._Floor = function () {
            return (u._Floor = u.asm.Floor).apply(null, arguments);
          }),
          (u._FloorDiv = function () {
            return (u._FloorDiv = u.asm.FloorDiv).apply(null, arguments);
          }),
          (u._FusedBatchNorm = function () {
            return (u._FusedBatchNorm = u.asm.FusedBatchNorm).apply(null, arguments);
          }),
          (u._FusedConv2D = function () {
            return (u._FusedConv2D = u.asm.FusedConv2D).apply(null, arguments);
          }),
          (u._FusedDepthwiseConv2D = function () {
            return (u._FusedDepthwiseConv2D = u.asm.FusedDepthwiseConv2D).apply(null, arguments);
          }),
          (u._Gather = function () {
            return (u._Gather = u.asm.Gather).apply(null, arguments);
          }),
          (u._GatherNd = function () {
            return (u._GatherNd = u.asm.GatherNd).apply(null, arguments);
          }),
          (u._Greater = function () {
            return (u._Greater = u.asm.Greater).apply(null, arguments);
          }),
          (u._GreaterEqual = function () {
            return (u._GreaterEqual = u.asm.GreaterEqual).apply(null, arguments);
          }),
          (u._IsFinite = function () {
            return (u._IsFinite = u.asm.IsFinite).apply(null, arguments);
          }),
          (u._IsInf = function () {
            return (u._IsInf = u.asm.IsInf).apply(null, arguments);
          }),
          (u._IsNan = function () {
            return (u._IsNan = u.asm.IsNan).apply(null, arguments);
          }),
          (u._LRN = function () {
            return (u._LRN = u.asm.LRN).apply(null, arguments);
          }),
          (u._LRNGrad = function () {
            return (u._LRNGrad = u.asm.LRNGrad).apply(null, arguments);
          }),
          (u._LeakyRelu = function () {
            return (u._LeakyRelu = u.asm.LeakyRelu).apply(null, arguments);
          }),
          (u._Less = function () {
            return (u._Less = u.asm.Less).apply(null, arguments);
          }),
          (u._LessEqual = function () {
            return (u._LessEqual = u.asm.LessEqual).apply(null, arguments);
          }),
          (u._LinSpace = function () {
            return (u._LinSpace = u.asm.LinSpace).apply(null, arguments);
          }),
          (u._Log = function () {
            return (u._Log = u.asm.Log).apply(null, arguments);
          }),
          (u._Log1p = function () {
            return (u._Log1p = u.asm.Log1p).apply(null, arguments);
          }),
          (u._LogicalAnd = function () {
            return (u._LogicalAnd = u.asm.LogicalAnd).apply(null, arguments);
          }),
          (u._LogicalNot = function () {
            return (u._LogicalNot = u.asm.LogicalNot).apply(null, arguments);
          }),
          (u._LogicalOr = function () {
            return (u._LogicalOr = u.asm.LogicalOr).apply(null, arguments);
          }),
          (u._LogicalXor = function () {
            return (u._LogicalXor = u.asm.LogicalXor).apply(null, arguments);
          }),
          (u._Max = function () {
            return (u._Max = u.asm.Max).apply(null, arguments);
          }),
          (u._MaxPool = function () {
            return (u._MaxPool = u.asm.MaxPool).apply(null, arguments);
          }),
          (u._MaxPool3D = function () {
            return (u._MaxPool3D = u.asm.MaxPool3D).apply(null, arguments);
          }),
          (u._MaxPool3DGrad = function () {
            return (u._MaxPool3DGrad = u.asm.MaxPool3DGrad).apply(null, arguments);
          }),
          (u._MaxPoolGrad = function () {
            return (u._MaxPoolGrad = u.asm.MaxPoolGrad).apply(null, arguments);
          }),
          (u._MaxPoolWithArgmax = function () {
            return (u._MaxPoolWithArgmax = u.asm.MaxPoolWithArgmax).apply(null, arguments);
          }),
          (u._Maximum = function () {
            return (u._Maximum = u.asm.Maximum).apply(null, arguments);
          }),
          (u._Mean = function () {
            return (u._Mean = u.asm.Mean).apply(null, arguments);
          }),
          (u._Min = function () {
            return (u._Min = u.asm.Min).apply(null, arguments);
          }),
          (u._Minimum = function () {
            return (u._Minimum = u.asm.Minimum).apply(null, arguments);
          }),
          (u._MirrorPad = function () {
            return (u._MirrorPad = u.asm.MirrorPad).apply(null, arguments);
          }),
          (u._Mod = function () {
            return (u._Mod = u.asm.Mod).apply(null, arguments);
          }),
          (u._Multinomial = function () {
            return (u._Multinomial = u.asm.Multinomial).apply(null, arguments);
          }),
          (u._Multiply = function () {
            return (u._Multiply = u.asm.Multiply).apply(null, arguments);
          }),
          (u._Neg = function () {
            return (u._Neg = u.asm.Neg).apply(null, arguments);
          }),
          (u._NonMaxSuppressionV3 = function () {
            return (u._NonMaxSuppressionV3 = u.asm.NonMaxSuppressionV3).apply(null, arguments);
          }),
          (u._NonMaxSuppressionV4 = function () {
            return (u._NonMaxSuppressionV4 = u.asm.NonMaxSuppressionV4).apply(null, arguments);
          }),
          (u._NonMaxSuppressionV5 = function () {
            return (u._NonMaxSuppressionV5 = u.asm.NonMaxSuppressionV5).apply(null, arguments);
          }),
          (u._NotEqual = function () {
            return (u._NotEqual = u.asm.NotEqual).apply(null, arguments);
          }),
          (u._OneHot = function () {
            return (u._OneHot = u.asm.OneHot).apply(null, arguments);
          }),
          (u._PadV2 = function () {
            return (u._PadV2 = u.asm.PadV2).apply(null, arguments);
          }),
          (u._Pow = function () {
            return (u._Pow = u.asm.Pow).apply(null, arguments);
          }),
          (u._Prelu = function () {
            return (u._Prelu = u.asm.Prelu).apply(null, arguments);
          }),
          (u._Prod = function () {
            return (u._Prod = u.asm.Prod).apply(null, arguments);
          }),
          (u._RealDiv = function () {
            return (u._RealDiv = u.asm.RealDiv).apply(null, arguments);
          }),
          (u._Reciprocal = function () {
            return (u._Reciprocal = u.asm.Reciprocal).apply(null, arguments);
          }),
          (u._Relu = function () {
            return (u._Relu = u.asm.Relu).apply(null, arguments);
          }),
          (u._Relu6 = function () {
            return (u._Relu6 = u.asm.Relu6).apply(null, arguments);
          }),
          (u._ResizeBilinear = function () {
            return (u._ResizeBilinear = u.asm.ResizeBilinear).apply(null, arguments);
          }),
          (u._ResizeBilinearGrad = function () {
            return (u._ResizeBilinearGrad = u.asm.ResizeBilinearGrad).apply(null, arguments);
          }),
          (u._ResizeNearestNeighbor = function () {
            return (u._ResizeNearestNeighbor = u.asm.ResizeNearestNeighbor).apply(null, arguments);
          }),
          (u._ResizeNearestNeighborGrad = function () {
            return (u._ResizeNearestNeighborGrad = u.asm.ResizeNearestNeighborGrad).apply(null, arguments);
          }),
          (u._Reverse = function () {
            return (u._Reverse = u.asm.Reverse).apply(null, arguments);
          }),
          (u._RotateWithOffset = function () {
            return (u._RotateWithOffset = u.asm.RotateWithOffset).apply(null, arguments);
          }),
          (u._Round = function () {
            return (u._Round = u.asm.Round).apply(null, arguments);
          }),
          (u._Rsqrt = function () {
            return (u._Rsqrt = u.asm.Rsqrt).apply(null, arguments);
          }),
          (u._ScatterNd = function () {
            return (u._ScatterNd = u.asm.ScatterNd).apply(null, arguments);
          }),
          (u._SearchSorted = function () {
            return (u._SearchSorted = u.asm.SearchSorted).apply(null, arguments);
          }),
          (u._SelectV2 = function () {
            return (u._SelectV2 = u.asm.SelectV2).apply(null, arguments);
          }),
          (u._Selu = function () {
            return (u._Selu = u.asm.Selu).apply(null, arguments);
          }),
          (u._Sigmoid = function () {
            return (u._Sigmoid = u.asm.Sigmoid).apply(null, arguments);
          }),
          (u._Sign = function () {
            return (u._Sign = u.asm.Sign).apply(null, arguments);
          }),
          (u._Sin = function () {
            return (u._Sin = u.asm.Sin).apply(null, arguments);
          }),
          (u._Sinh = function () {
            return (u._Sinh = u.asm.Sinh).apply(null, arguments);
          }),
          (u._Softmax = function () {
            return (u._Softmax = u.asm.Softmax).apply(null, arguments);
          }),
          (u._Softplus = function () {
            return (u._Softplus = u.asm.Softplus).apply(null, arguments);
          }),
          (u._SparseFillEmptyRows = function () {
            return (u._SparseFillEmptyRows = u.asm.SparseFillEmptyRows).apply(null, arguments);
          }),
          (u._SparseReshape = function () {
            return (u._SparseReshape = u.asm.SparseReshape).apply(null, arguments);
          }),
          (u._SparseSegmentReduction = function () {
            return (u._SparseSegmentReduction = u.asm.SparseSegmentReduction).apply(null, arguments);
          }),
          (u._SparseToDense = function () {
            return (u._SparseToDense = u.asm.SparseToDense).apply(null, arguments);
          }),
          (u._Sqrt = function () {
            return (u._Sqrt = u.asm.Sqrt).apply(null, arguments);
          }),
          (u._Square = function () {
            return (u._Square = u.asm.Square).apply(null, arguments);
          }),
          (u._SquaredDifference = function () {
            return (u._SquaredDifference = u.asm.SquaredDifference).apply(null, arguments);
          }),
          (u._Step = function () {
            return (u._Step = u.asm.Step).apply(null, arguments);
          }),
          (u._StridedSlice = function () {
            return (u._StridedSlice = u.asm.StridedSlice).apply(null, arguments);
          }),
          (u._Sub = function () {
            return (u._Sub = u.asm.Sub).apply(null, arguments);
          }),
          (u._Sum = function () {
            return (u._Sum = u.asm.Sum).apply(null, arguments);
          }),
          (u._Tan = function () {
            return (u._Tan = u.asm.Tan).apply(null, arguments);
          }),
          (u._Tanh = function () {
            return (u._Tanh = u.asm.Tanh).apply(null, arguments);
          }),
          (u._TensorScatterUpdate = function () {
            return (u._TensorScatterUpdate = u.asm.TensorScatterUpdate).apply(null, arguments);
          }),
          (u._Tile = function () {
            return (u._Tile = u.asm.Tile).apply(null, arguments);
          }),
          (u._TopK = function () {
            return (u._TopK = u.asm.TopK).apply(null, arguments);
          }),
          (u._Transform = function () {
            return (u._Transform = u.asm.Transform).apply(null, arguments);
          }),
          (u._Transpose = function () {
            return (u._Transpose = u.asm.Transpose).apply(null, arguments);
          }),
          (u.__FusedMatMul = function () {
            return (u.__FusedMatMul = u.asm._FusedMatMul).apply(null, arguments);
          }),
          (u._malloc = function () {
            return (u._malloc = u.asm.malloc).apply(null, arguments);
          }),
          (u._free = function () {
            return (u._free = u.asm.free).apply(null, arguments);
          }),
          (u.___errno_location = function () {
            return (u.___errno_location = u.asm.__errno_location).apply(null, arguments);
          });
        var $,
          K,
          X,
          Q = (u.stackSave = function () {
            return (Q = u.stackSave = u.asm.stackSave).apply(null, arguments);
          }),
          J = (u.stackRestore = function () {
            return (J = u.stackRestore = u.asm.stackRestore).apply(null, arguments);
          }),
          Z = (u.stackAlloc = function () {
            return (Z = u.stackAlloc = u.asm.stackAlloc).apply(null, arguments);
          });
        function Y(e) {
          function n() {
            $ ||
              (($ = !0),
              (u.calledRun = !0),
              S ||
                (B(R),
                t(u),
                u.onRuntimeInitialized && u.onRuntimeInitialized(),
                (function () {
                  if (u.postRun)
                    for ('function' == typeof u.postRun && (u.postRun = [u.postRun]); u.postRun.length; )
                      (e = u.postRun.shift()), E.unshift(e);
                  var e;
                  B(E);
                })()));
          }
          W > 0 ||
            ((function () {
              if (u.preRun)
                for ('function' == typeof u.preRun && (u.preRun = [u.preRun]); u.preRun.length; ) (e = u.preRun.shift()), D.unshift(e);
              var e;
              B(D);
            })(),
            W > 0 ||
              (u.setStatus
                ? (u.setStatus('Running...'),
                  setTimeout(function () {
                    setTimeout(function () {
                      u.setStatus('');
                    }, 1),
                      n();
                  }, 1))
                : n()));
        }
        if (
          ((u.dynCall_iijjiiii = function () {
            return (u.dynCall_iijjiiii = u.asm.dynCall_iijjiiii).apply(null, arguments);
          }),
          (u.dynCall_jiji = function () {
            return (u.dynCall_jiji = u.asm.dynCall_jiji).apply(null, arguments);
          }),
          (u.cwrap = function (e, t, n, a) {
            var r = (n = n || []).every(e => 'number' === e || 'boolean' === e);
            return 'string' !== t && r && !a
              ? G(e)
              : function () {
                  return q(e, t, n, arguments);
                };
          }),
          (P = function e() {
            $ || Y(), $ || (P = e);
          }),
          u.preInit)
        )
          for ('function' == typeof u.preInit && (u.preInit = [u.preInit]); u.preInit.length > 0; ) u.preInit.pop()();
        if (
          (Y(),
          r &&
            (K = {
              uncaughtException: process.listeners('uncaughtException').filter(function (e) {
                return !r.uncaughtException.indexOf(e) > -1;
              }),
              unhandledRejection: process.listeners('unhandledRejection').filter(function (e) {
                return !r.unhandledRejection.indexOf(e) > -1;
              }),
            }),
          'undefined' != typeof e)
        )
          X = e;
        else {
          if ('undefined' == typeof WasmBackendModuleThreadedSimd) throw new Error('Could not find wasm module in post.js');
          X = WasmBackendModuleThreadedSimd;
        }
        if (K) {
          var ee = X._dispose;
          X._dispose = function () {
            ee(),
              K.uncaughtException.forEach(function (e) {
                process.removeListener('uncaughtException', e);
              }),
              K.unhandledRejection.forEach(function (e) {
                process.removeListener('unhandledRejection', e);
              });
          };
        }
        return e.ready;
      });
  e.exports = a;
})(ii);
var oi = ii.exports,
  di = ti(oi);
const pi = ri || ui,
  li = di || bn({ __proto__: null, default: di }, [oi]);
class ci extends sn {
  constructor(e) {
    super(),
      (this.wasm = e),
      (this.dataIdNextNumber = 1),
      this.wasm.tfjs.initWithThreadsCount(Mi),
      (Si = this.wasm.tfjs.getThreadsCount()),
      (this.dataIdMap = new on(this, dn()));
  }
  write(e, t, n) {
    const a = { id: this.dataIdNextNumber++ };
    return this.move(a, e, t, n, 1), a;
  }
  numDataIds() {
    return this.dataIdMap.numDataIds();
  }
  async time(e) {
    const t = n.now();
    e();
    return { kernelMs: n.now() - t };
  }
  move(e, t, a, r, u) {
    const s = this.dataIdNextNumber++;
    if ('string' === r) {
      const n = t;
      return void this.dataIdMap.set(e, { id: s, stringBytes: n, shape: a, dtype: r, memoryOffset: null, refCount: u });
    }
    const i = n.sizeFromShape(a),
      o = i * n.bytesPerElement(r),
      d = this.wasm._malloc(o) >>> 0;
    this.dataIdMap.set(e, { id: s, memoryOffset: d, shape: a, dtype: r, refCount: u }),
      this.wasm.tfjs.registerTensor(s, i, d),
      null != t && this.wasm.HEAPU8.set(new Uint8Array(t.buffer, t.byteOffset, o), d);
  }
  async read(e) {
    return this.readSync(e);
  }
  readSync(e, t, a) {
    const { memoryOffset: r, dtype: u, shape: s, stringBytes: i } = this.dataIdMap.get(e);
    if ('string' === u) return (null != t && 0 !== t) || !(null == a || a >= i.length) ? i.slice(t, a) : i;
    (t = t || 0), (a = a || n.sizeFromShape(s));
    const o = n.bytesPerElement(u);
    return (function (e, t) {
      switch (t) {
        case 'float32':
          return new Float32Array(e);
        case 'int32':
          return new Int32Array(e);
        case 'bool':
          return new Uint8Array(e);
        default:
          throw new Error(`Unknown dtype ${t}`);
      }
    })(this.wasm.HEAPU8.slice(r + t * o, r + a * o).buffer, u);
  }
  disposeData(e, t = !1) {
    if (this.dataIdMap.has(e)) {
      const n = this.dataIdMap.get(e);
      if ((n.refCount--, !t && n.refCount > 0)) return !1;
      this.wasm._free(n.memoryOffset), this.wasm.tfjs.disposeData(n.id), this.dataIdMap.delete(e);
    }
    return !0;
  }
  refCount(e) {
    if (this.dataIdMap.has(e)) {
      return this.dataIdMap.get(e).refCount;
    }
    return 0;
  }
  incRef(e) {
    const t = this.dataIdMap.get(e);
    null != t && t.refCount++;
  }
  floatPrecision() {
    return 32;
  }
  getMemoryOffset(e) {
    return this.dataIdMap.get(e).memoryOffset;
  }
  dispose() {
    this.wasm.tfjs.dispose(), 'PThread' in this.wasm && this.wasm.PThread.terminateAllThreads(), (this.wasm = null);
  }
  memory() {
    return { unreliable: !1 };
  }
  makeOutput(e, t, a, r) {
    let u;
    if (null == a) u = this.write(null != r ? r : null, e, t);
    else {
      const r = this.dataIdNextNumber++;
      (u = { id: r }), this.dataIdMap.set(u, { id: r, memoryOffset: a, shape: e, dtype: t, refCount: 1 });
      const s = n.sizeFromShape(e);
      this.wasm.tfjs.registerTensor(r, s, a);
    }
    return { dataId: u, shape: e, dtype: t };
  }
  typedArrayFromHeap({ shape: e, dtype: t, dataId: a }) {
    const r = this.wasm.HEAPU8.buffer,
      { memoryOffset: u } = this.dataIdMap.get(a),
      s = n.sizeFromShape(e);
    switch (t) {
      case 'float32':
        return new Float32Array(r, u, s);
      case 'int32':
        return new Int32Array(r, u, s);
      case 'bool':
        return new Uint8Array(r, u, s);
      default:
        throw new Error(`Unknown dtype ${t}`);
    }
  }
}
function mi(e, t, n) {
  if (null != bi) return bi;
  let a = 'tfjs-backend-wasm.wasm';
  return (
    e && t ? (a = 'tfjs-backend-wasm-threaded-simd.wasm') : e && (a = 'tfjs-backend-wasm-simd.wasm'),
    null != _i && null != _i[a] ? _i[a] : n + a
  );
}
async function fi() {
  const [e, t] = await Promise.all([un().getAsync('WASM_HAS_SIMD_SUPPORT'), un().getAsync('WASM_HAS_MULTITHREAD_SUPPORT')]);
  return new Promise((a, r) => {
    const u = {};
    var s;
    (u.locateFile = (n, a) => {
      if (n.endsWith('.worker.js')) {
        const e = si.replace(/\n/g, '\\n'),
          t = new Blob([e], { type: 'application/javascript' });
        return URL.createObjectURL(t);
      }
      return n.endsWith('.wasm') ? mi(e, t, null != yi ? yi : a) : a + n;
    }),
      Ii &&
        (u.instantiateWasm =
          ((s = mi(e, t, null != yi ? yi : '')),
          (e, t) => (
            n.fetch(s, { credentials: 'same-origin' }).then(n => {
              n.ok || e.env.a(`failed to load wasm binary file at '${s}'`),
                n.arrayBuffer().then(n => {
                  WebAssembly.instantiate(n, e).then(e => {
                    t(e.instance, e.module);
                  });
                });
            }),
            {}
          )));
    let i,
      o = !1;
    (u.onAbort = () => {
      if (o) return;
      if (gi) return;
      gi = !0;
      r({
        message:
          'Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers',
      });
    }),
      t && e && null == bi
        ? ((u.mainScriptUrlOrBlob = new Blob(['var WasmBackendModuleThreadedSimd = ' + pi.toString()], { type: 'text/javascript' })),
          (i = pi(u)))
        : (i = li(u)),
      i
        .then(e => {
          (o = !0), (gi = !1);
          (e.tfjs = {
            init: e.cwrap('init', null, []),
            initWithThreadsCount: e.cwrap('init_with_threads_count', null, ['number']),
            getThreadsCount: e.cwrap('get_threads_count', 'number', []),
            registerTensor: e.cwrap('register_tensor', null, ['number', 'number', 'number']),
            disposeData: e.cwrap('dispose_data', null, ['number']),
            dispose: e.cwrap('dispose', null, []),
          }),
            a({ wasm: e });
        })
        .catch(r);
  });
}
const hi = ['tfjs-backend-wasm.wasm', 'tfjs-backend-wasm-simd.wasm', 'tfjs-backend-wasm-threaded-simd.wasm'];
let bi = null,
  yi = null,
  _i = {},
  gi = !1,
  Ii = !1;
function wi(e, t = !1) {
  if ((pn('setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release.'), gi))
    throw new Error(
      'The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`',
    );
  (bi = e), (Ii = t);
}
function ki(e, t = !1) {
  if (gi)
    throw new Error(
      'The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`',
    );
  if ('string' == typeof e) yi = e;
  else {
    _i = e;
    const t = hi.filter(e => null == _i[e]);
    if (t.length > 0)
      throw new Error(
        `There were no entries found for the following binaries: ${t.join(
          ',',
        )}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`,
      );
  }
  Ii = t;
}
let Mi = -1,
  Si = -1;
function Ai(e) {
  Mi = e;
}
function vi() {
  if (-1 === Si) throw new Error('WASM backend not initialized.');
  return Si;
}
const xi = '4.13.0';
ln(
  'wasm',
  async () => {
    const { wasm: e } = await fi();
    return new ci(e);
  },
  2,
);
export { ci as BackendWasm, vi as getThreadsCount, Ai as setThreadsCount, wi as setWasmPath, ki as setWasmPaths, xi as version_wasm };
//# sourceMappingURL=tf-backend-wasm.fesm.min.js.map
