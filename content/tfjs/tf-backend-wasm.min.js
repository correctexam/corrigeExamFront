/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!(function (e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? t(
        exports,
        require('@tensorflow/tfjs-core'),
        require('path'),
        require('fs'),
        require('worker_threads'),
        require('perf_hooks'),
        require('os'),
      )
    : 'function' == typeof define && define.amd
    ? define(['exports', '@tensorflow/tfjs-core', 'path', 'fs', 'worker_threads', 'perf_hooks', 'os'], t)
    : t(
        (((e = 'undefined' != typeof globalThis ? globalThis : e || self).tf = e.tf || {}), (e.tf.wasm = e.tf.wasm || {})),
        e.tf,
        e.path,
        e.fs,
        e.worker_threads,
        e.perf_hooks,
        e.require$$4,
      );
})(this, function (e, t, n, a, r, u, i) {
  'use strict';
  function s(e) {
    return e && 'object' == typeof e && 'default' in e ? e : { default: e };
  }
  var o,
    d,
    l,
    p = s(n),
    c = s(a),
    m = s(r),
    f = s(u),
    h = s(i),
    b = function (e, t) {
      return (
        (b =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (e, t) {
              e.__proto__ = t;
            }) ||
          function (e, t) {
            for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
          }),
        b(e, t)
      );
    };
  function _(e, t, n, a) {
    return new (n || (n = Promise))(function (r, u) {
      function i(e) {
        try {
          o(a.next(e));
        } catch (e) {
          u(e);
        }
      }
      function s(e) {
        try {
          o(a.throw(e));
        } catch (e) {
          u(e);
        }
      }
      function o(e) {
        var t;
        e.done
          ? r(e.value)
          : ((t = e.value),
            t instanceof n
              ? t
              : new n(function (e) {
                  e(t);
                })).then(i, s);
      }
      o((a = a.apply(e, t || [])).next());
    });
  }
  function y(e, t) {
    var n,
      a,
      r,
      u,
      i = {
        label: 0,
        sent: function () {
          if (1 & r[0]) throw r[1];
          return r[1];
        },
        trys: [],
        ops: [],
      };
    return (
      (u = { next: s(0), throw: s(1), return: s(2) }),
      'function' == typeof Symbol &&
        (u[Symbol.iterator] = function () {
          return this;
        }),
      u
    );
    function s(u) {
      return function (s) {
        return (function (u) {
          if (n) throw new TypeError('Generator is already executing.');
          for (; i; )
            try {
              if (
                ((n = 1),
                a && (r = 2 & u[0] ? a.return : u[0] ? a.throw || ((r = a.return) && r.call(a), 0) : a.next) && !(r = r.call(a, u[1])).done)
              )
                return r;
              switch (((a = 0), r && (u = [2 & u[0], r.value]), u[0])) {
                case 0:
                case 1:
                  r = u;
                  break;
                case 4:
                  return i.label++, { value: u[1], done: !1 };
                case 5:
                  i.label++, (a = u[1]), (u = [0]);
                  continue;
                case 7:
                  (u = i.ops.pop()), i.trys.pop();
                  continue;
                default:
                  if (!((r = i.trys), (r = r.length > 0 && r[r.length - 1]) || (6 !== u[0] && 2 !== u[0]))) {
                    i = 0;
                    continue;
                  }
                  if (3 === u[0] && (!r || (u[1] > r[0] && u[1] < r[3]))) {
                    i.label = u[1];
                    break;
                  }
                  if (6 === u[0] && i.label < r[1]) {
                    (i.label = r[1]), (r = u);
                    break;
                  }
                  if (r && i.label < r[2]) {
                    (i.label = r[2]), i.ops.push(u);
                    break;
                  }
                  r[2] && i.ops.pop(), i.trys.pop();
                  continue;
              }
              u = t.call(e, i);
            } catch (e) {
              (u = [6, e]), (a = 0);
            } finally {
              n = r = 0;
            }
          if (5 & u[0]) throw u[1];
          return { value: u[0] ? u[1] : void 0, done: !0 };
        })([u, s]);
      };
    }
  }
  function g(e, t) {
    var n = 'function' == typeof Symbol && e[Symbol.iterator];
    if (!n) return e;
    var a,
      r,
      u = n.call(e),
      i = [];
    try {
      for (; (void 0 === t || t-- > 0) && !(a = u.next()).done; ) i.push(a.value);
    } catch (e) {
      r = { error: e };
    } finally {
      try {
        a && !a.done && (n = u.return) && n.call(u);
      } finally {
        if (r) throw r.error;
      }
    }
    return i;
  }
  function v() {
    for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(g(arguments[t]));
    return e;
  }
  !(function (e) {
    (e[(e.float32 = 0)] = 'float32'),
      (e[(e.int32 = 1)] = 'int32'),
      (e[(e.bool = 2)] = 'bool'),
      (e[(e.string = 3)] = 'string'),
      (e[(e.complex64 = 4)] = 'complex64');
  })(o || (o = {})),
    (function (e) {
      (e[(e.linear = 0)] = 'linear'),
        (e[(e.relu = 1)] = 'relu'),
        (e[(e.relu6 = 2)] = 'relu6'),
        (e[(e.prelu = 3)] = 'prelu'),
        (e[(e.leakyrelu = 4)] = 'leakyrelu'),
        (e[(e.sigmoid = 5)] = 'sigmoid'),
        (e[(e.elu = 6)] = 'elu');
    })(d || (d = {}));
  var w = {
    kernelName: t._FusedMatMul,
    backendName: 'wasm',
    setupFunc: function (e) {
      l = e.wasm.cwrap(t._FusedMatMul, null, [
        'number',
        'array',
        'number',
        'number',
        'array',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      var n = e.inputs,
        a = e.backend,
        r = e.attrs,
        u = n.a,
        i = n.b,
        s = n.bias,
        o = n.preluActivationWeights;
      if ('float32' !== u.dtype || 'float32' !== i.dtype) throw new Error('_FusedMatMul for non non-float32 tensors not yet supported.');
      var p = r.transposeA,
        c = r.transposeB,
        m = r.activation,
        f = r.leakyreluAlpha,
        h = a.dataIdMap.get(u.dataId).id,
        b = a.dataIdMap.get(i.dataId).id,
        _ = 0;
      if (null != s) {
        var y = a.dataIdMap.get(s.dataId);
        if (1 !== y.shape.length) throw new Error('_FusedMatMul only supports rank-1 bias but got rank ' + y.shape.length + '.');
        _ = y.id;
      }
      var g = null == o ? 0 : a.dataIdMap.get(o.dataId).id,
        w = d[m];
      if (null == w) throw new Error(m + ' activation not yet supported for FusedConv2D in the wasm backend.');
      var k = p ? u.shape[2] : u.shape[1],
        I = c ? i.shape[1] : i.shape[2],
        S = t.broadcast_util.assertAndGetBroadcastShape(u.shape.slice(0, -2), i.shape.slice(0, -2)),
        M = a.makeOutput(v(S, [k, I]), u.dtype),
        x = a.dataIdMap.get(M.dataId).id,
        A = new Uint8Array(new Int32Array(u.shape).buffer),
        F = new Uint8Array(new Int32Array(i.shape).buffer);
      return l(h, A, u.shape.length, b, F, i.shape.length, p, c, w, _, g, f || 0, x), M;
    },
  };
  function k(e, n) {
    var a;
    return {
      kernelName: e,
      backendName: 'wasm',
      setupFunc: function (t) {
        a = t.wasm.cwrap(e, null, ['number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var r = e.backend,
          u = e.inputs.x,
          i = r.dataIdMap.get(u.dataId).id,
          s = r.makeOutput(u.shape, n || u.dtype),
          d = r.dataIdMap.get(s.dataId).id;
        return 0 === t.util.sizeFromShape(s.shape) || a(i, o[u.dtype], d), s;
      },
    };
  }
  var I = k(t.Abs);
  function S(e, n, a) {
    var r;
    return {
      kernelName: e,
      backendName: 'wasm',
      setupFunc: function (t) {
        r = t.wasm.cwrap(e, null, ['number', 'array', 'number', 'number', 'array', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          u = e.inputs,
          i = u.a,
          s = u.b,
          d = n.dataIdMap.get(i.dataId).id,
          l = n.dataIdMap.get(s.dataId).id,
          p = null != a ? a : i.dtype,
          c = t.backend_util.assertAndGetBroadcastShape(i.shape, s.shape),
          m = n.makeOutput(c, p);
        if (0 === t.util.sizeFromShape(c)) return m;
        var f = new Uint8Array(new Int32Array(i.shape).buffer),
          h = new Uint8Array(new Int32Array(s.shape).buffer),
          b = n.dataIdMap.get(m.dataId).id;
        return r(d, f, i.shape.length, l, h, s.shape.length, o[i.dtype], b), m;
      },
    };
  }
  var M,
    x = S(t.Add);
  var A = {
    kernelName: t.AddN,
    backendName: 'wasm',
    setupFunc: function (e) {
      M = e.wasm.cwrap(t.AddN, null, ['array', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      var n = e.inputs,
        a = e.backend,
        r = a.makeOutput(n[0].shape, n[0].dtype);
      if (0 === t.util.sizeFromShape(r.shape)) return r;
      var u = n.map(function (e) {
          return a.dataIdMap.get(e.dataId).id;
        }),
        i = new Uint8Array(new Int32Array(u).buffer),
        s = a.dataIdMap.get(r.dataId).id;
      return M(i, u.length, o[r.dtype], s), r;
    },
  };
  function F(e) {
    var t = e.inputs.x,
      n = e.backend,
      a = n.makeOutput(t.shape, t.dtype),
      r = n.typedArrayFromHeap(t);
    return n.typedArrayFromHeap(a).set(r), a;
  }
  var N,
    E = { kernelName: t.Identity, backendName: 'wasm', kernelFunc: F };
  function R(e) {
    for (
      var t = e.inputs,
        n = e.backend,
        a = e.attrs,
        r = g(
          (function (e, t) {
            for (var n = [], a = [], r = 0; r < e.length; ++r) 1 !== e[r] && n.push(e[r]), 1 !== e[t[r]] && a.push(t[r]);
            for (r = 0; r < a.length; ++r) {
              for (var u = -1, i = 0; i < a.length; ++i) a[i] >= r && (-1 === u || a[u] > a[i]) && (u = i);
              a[u] = r;
            }
            return [n, a];
          })(t.x.shape, a.perm),
          2,
        ),
        u = r[0],
        i = r[1],
        s = !0,
        d = 0;
      d < i.length;
      d++
    )
      i[d] !== d && (s = !1);
    var l = (function (e, t) {
        for (var n = new Array(e.length), a = 0; a < n.length; a++) n[a] = e[t[a]];
        return n;
      })(t.x.shape, a.perm),
      p = { dataId: t.x.dataId, shape: u, dtype: t.x.dtype };
    if (s) {
      var c = F({ inputs: t, backend: n });
      return (c.shape = l), c;
    }
    var m = n.makeOutput(l, p.dtype),
      f = n.dataIdMap.get(p.dataId).id,
      h = n.dataIdMap.get(m.dataId).id,
      b = new Uint8Array(new Int32Array(i).buffer),
      _ = new Uint8Array(new Int32Array(p.shape).buffer);
    return N(f, _, p.shape.length, o[p.dtype], h, b, i.length), m;
  }
  var C,
    D = {
      kernelName: t.Transpose,
      backendName: 'wasm',
      kernelFunc: R,
      setupFunc: function (e) {
        N = e.wasm.cwrap(t.Transpose, null, ['number', 'array', 'number', 'number', 'number', 'array', 'number']);
      },
    };
  function T(e, n, a) {
    var r = e.shape,
      u = e.shape.length,
      i = t.util.parseAxisParam(n, r),
      s = i,
      o = t.backend_util.getAxesPermutation(s, u),
      d = null,
      l = !1;
    if (null != o) {
      for (var p = new Array(u), c = 0; c < p.length; c++) p[c] = r[o[c]];
      (s = t.backend_util.getInnerMostAxes(s.length, u)), (d = R({ inputs: { x: e }, attrs: { perm: o }, backend: a }));
      var m = a.dataIdMap.get(e.dataId).id;
      a.dataIdMap.get(d.dataId).id !== m && (l = !0);
    }
    return { transposed: d, originalAxes: i, axes: s, inputWasTransposed: l };
  }
  var O,
    P = {
      kernelName: t.All,
      backendName: 'wasm',
      setupFunc: function (e) {
        C = e.wasm.cwrap(t.All, null, ['number, number, number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = r.axis,
          i = r.keepDims,
          s = a.x,
          o = n.dataIdMap.get(s.dataId).id,
          d = s,
          l = T(s, u, n),
          p = l.transposed,
          c = l.axes,
          m = l.originalAxes,
          f = l.inputWasTransposed;
        f && ((d = p), (o = n.dataIdMap.get(p.dataId).id));
        var h = d.shape.length;
        t.backend_util.assertAxesAreInnerMostDims('all', c, h);
        var b = g(t.backend_util.computeOutAndReduceShapes(d.shape, c), 2),
          _ = b[0],
          y = b[1],
          v = t.util.sizeFromShape(y),
          w = n.makeOutput(_, s.dtype);
        if (0 !== t.util.sizeFromShape(d.shape)) {
          var k = n.dataIdMap.get(w.dataId).id;
          C(o, v, k);
        }
        if ((f && n.disposeData(p.dataId), i)) {
          var I = t.backend_util.expandShapeToKeepDim(w.shape, m);
          w.shape = I;
        }
        return w;
      },
    };
  var W,
    L = {
      kernelName: t.Any,
      backendName: 'wasm',
      setupFunc: function (e) {
        O = e.wasm.cwrap(t.Any, null, ['number, number, number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = r.axis,
          i = r.keepDims,
          s = a.x,
          o = n.dataIdMap.get(s.dataId).id,
          d = s,
          l = T(s, u, n),
          p = l.transposed,
          c = l.axes,
          m = l.originalAxes,
          f = l.inputWasTransposed;
        f && ((d = p), (o = n.dataIdMap.get(p.dataId).id));
        var h = d.shape.length;
        t.backend_util.assertAxesAreInnerMostDims('any', c, h);
        var b = g(t.backend_util.computeOutAndReduceShapes(d.shape, c), 2),
          _ = b[0],
          y = b[1],
          v = t.util.sizeFromShape(y),
          w = n.makeOutput(_, s.dtype);
        if (0 !== t.util.sizeFromShape(d.shape)) {
          var k = n.dataIdMap.get(w.dataId).id;
          O(o, v, k);
        }
        if ((f && n.disposeData(p.dataId), i)) {
          var I = t.backend_util.expandShapeToKeepDim(w.shape, m);
          w.shape = I;
        }
        return w;
      },
    };
  var z,
    j = {
      kernelName: t.ArgMax,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs.axis,
          u = a.x,
          i = n.dataIdMap.get(u.dataId).id,
          s = i,
          d = u,
          l = T(u, r, n),
          p = l.transposed,
          c = l.axes,
          m = l.inputWasTransposed;
        if (m) {
          var f = n.dataIdMap.get(p.dataId).id;
          f !== i && ((d = p), (s = f));
        }
        var h = d.shape.slice(0, -1),
          b = n.makeOutput(h, 'int32'),
          _ = n.dataIdMap.get(b.dataId).id,
          y = t.util.sizeFromShape(b.shape),
          g = d.shape[c[0]];
        return W(s, o[d.dtype], y, g, _), m && n.disposeData(p.dataId), b;
      },
      setupFunc: function (e) {
        W = e.wasm.cwrap(t.ArgMax, null, ['number', 'number', 'number', 'number', 'number']);
      },
    };
  var H = {
    kernelName: t.AvgPool,
    backendName: 'wasm',
    setupFunc: function (e) {
      z = e.wasm.cwrap(t.AvgPool, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      var n = e.inputs,
        a = e.attrs,
        r = e.backend,
        u = n.x,
        i = r.dataIdMap.get(u.dataId).id,
        s = a.filterSize,
        o = a.strides,
        d = a.pad,
        l = a.dimRoundingMode,
        p = t.backend_util.computePool2DInfo(u.shape, s, o, 1, d, l),
        c = p.filterHeight,
        m = p.filterWidth,
        f = p.padInfo.top,
        h = p.padInfo.right,
        b = p.padInfo.bottom,
        _ = p.padInfo.left,
        y = p.strideHeight,
        g = p.strideWidth,
        v = p.inChannels;
      if ('channelsLast' !== p.dataFormat)
        throw new Error("wasm backend does not support dataFormat:'" + p.dataFormat + "'. Please use 'channelsLast'.");
      if (1 !== p.dilationWidth || 1 !== p.dilationHeight)
        throw new Error(
          'was backend only supports average pooling with dilation = [1, 1], got [' + p.dilationHeight + ', ' + p.dilationWidth + '].',
        );
      var w = r.makeOutput(p.outShape, 'float32'),
        k = r.dataIdMap.get(w.dataId).id;
      return z(i, u.shape[0], u.shape[1], u.shape[2], c, m, f, h, b, _, y, g, v, k), w;
    },
  };
  function B(e) {
    var n = e.inputs,
      a = e.attrs,
      r = n.x,
      u = a.shape,
      i = t.util.sizeFromShape(r.shape),
      s = t.util.inferFromImplicitShape(u, i);
    return (
      t.util.assert(i === t.util.sizeFromShape(s), function () {
        return 'new shape: ' + s + ', old shape: ' + r.shape + '. New shape and old shape must have the same number of elements.';
      }),
      e.backend.incRef(r.dataId),
      { dataId: r.dataId, shape: s, dtype: r.dtype }
    );
  }
  var U,
    q = { kernelName: t.Reshape, backendName: 'wasm', kernelFunc: B };
  var V = {
    kernelName: t.BatchMatMul,
    backendName: 'wasm',
    setupFunc: function (e) {
      U = e.wasm.cwrap(t.BatchMatMul, null, ['number', 'array', 'number', 'number', 'array', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      var n = e.inputs,
        a = e.backend,
        r = e.attrs,
        u = n.a,
        i = n.b,
        s = r.transposeA,
        o = r.transposeB;
      if ('float32' !== u.dtype || 'float32' !== i.dtype) throw new Error('BatchMatMul for non non-float32 tensors not yet supported.');
      var d = u.shape.length,
        l = i.shape.length,
        p = s ? u.shape[d - 2] : u.shape[d - 1],
        c = o ? i.shape[l - 1] : i.shape[l - 2],
        m = s ? u.shape[d - 1] : u.shape[d - 2],
        f = o ? i.shape[l - 2] : i.shape[l - 1],
        h = u.shape.slice(0, -2),
        b = i.shape.slice(0, -2),
        _ = t.util.sizeFromShape(h),
        y = t.util.sizeFromShape(b),
        g = t.broadcast_util.assertAndGetBroadcastShape(u.shape.slice(0, -2), i.shape.slice(0, -2)).concat([m, f]);
      t.util.assert(p === c, function () {
        return (
          'Error in matMul: inner shapes (' +
          p +
          ') and (' +
          c +
          ') of Tensors with shapes ' +
          u.shape +
          ' and ' +
          i.shape +
          ' and transposeA=' +
          s +
          ' and transposeB=' +
          o +
          ' must match.'
        );
      });
      var v = o ? [y, f, c] : [y, c, f],
        w = B({ inputs: { x: u }, backend: a, attrs: { shape: s ? [_, p, m] : [_, m, p] } }),
        k = B({ inputs: { x: i }, backend: a, attrs: { shape: v } }),
        I = a.dataIdMap.get(w.dataId).id,
        S = a.dataIdMap.get(k.dataId).id,
        M = s ? w.shape[2] : w.shape[1],
        x = o ? k.shape[1] : k.shape[2],
        A = Math.max(_, y),
        F = a.makeOutput([A, M, x], w.dtype),
        N = a.dataIdMap.get(F.dataId).id,
        E = new Uint8Array(new Int32Array(w.shape).buffer),
        R = new Uint8Array(new Int32Array(k.shape).buffer);
      return U(I, E, w.shape.length, S, R, k.shape.length, s, o, N), a.disposeData(w.dataId), a.disposeData(k.dataId), (F.shape = g), F;
    },
  };
  function G(e, n, a, r, u) {
    var i = t.slice_util.isSliceContinous(r, n, a),
      s = t.util.sizeFromShape(a),
      o = t.util.computeStrides(r);
    if (i) {
      var d = t.slice_util.computeFlatOffset(n, o);
      return 'string' === u ? e.slice(d, d + s) : e.subarray(d, d + s);
    }
    for (
      var l = 'string' === u ? t.backend_util.fromUint8ToStringArray(e) : e, p = t.buffer(r, u, l), c = t.buffer(a, u), m = 0;
      m < c.size;
      ++m
    ) {
      var f = c.indexToLoc(m),
        h = f.map(function (e, t) {
          return e + n[t];
        });
      c.set.apply(c, v([p.get.apply(p, v(h))], f));
    }
    return 'string' === u ? t.backend_util.fromStringArrayToUint8(c.values) : c.values;
  }
  var K = (function () {
    function e(e, n, a, r, u, i) {
      (this.separator = t.util.encodeString(e)),
        (this.nGramWidths = n),
        (this.leftPad = t.util.encodeString(a)),
        (this.rightPad = t.util.encodeString(r)),
        (this.padWidth = u),
        (this.preserveShort = i);
    }
    return (
      (e.prototype.getPadWidth = function (e) {
        return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
      }),
      (e.prototype.getNumNGrams = function (e, t) {
        var n = this.getPadWidth(t);
        return Math.max(0, e + 2 * n - t + 1);
      }),
      (e.prototype.createNGrams = function (e, t, n, a, r, u) {
        for (
          var i = function (i) {
              var o = s.getPadWidth(u),
                d = Math.max(0, o - i),
                l = Math.max(0, o - (r - (i + 1))),
                p = u - (d + l),
                c = t + (d > 0 ? 0 : i - o),
                m = 0;
              m += d * s.leftPad.length;
              for (var f = 0; f < p; ++f) m += e[c + f].length;
              (m += l * s.rightPad.length), (m += (d + l + p - 1) * s.separator.length), (n[a + i] = new Uint8Array(m));
              var h = n[a + i],
                b = 0,
                _ = function (e) {
                  return e.forEach(function (e) {
                    return (h[b++] = e);
                  });
                };
              for (f = 0; f < d; ++f) _(s.leftPad), _(s.separator);
              for (f = 0; f < p - 1; ++f) _(e[c + f]), _(s.separator);
              if (p > 0) {
                _(e[c + p - 1]);
                for (f = 0; f < l; ++f) _(s.separator), _(s.rightPad);
              } else {
                for (f = 0; f < l - 1; ++f) _(s.rightPad), _(s.separator);
                _(s.rightPad);
              }
            },
            s = this,
            o = 0;
          o < r;
          ++o
        )
          i(o);
      }),
      (e.prototype.compute = function (e, n) {
        var a = this,
          r = e.length,
          u = n.length;
        if (u > 0) {
          var i = n[0];
          if (0 !== i) throw new Error('First split value must be 0, got ' + i);
          for (var s = 1; s < u; ++s) {
            var o = n[s] >= i;
            if (!(o = o && n[s] <= r)) throw new Error('Invalid split value ' + n[s] + ', must be in [' + i + ', ' + r + ']');
            i = n[s];
          }
          if (i !== r) throw new Error('Last split value must be data size. Expected ' + r + ', got ' + i);
        }
        var d = u - 1,
          l = t.util.getArrayFromDType('int32', u);
        if (0 === r || 0 === u) {
          var p = new Array(r);
          for (s = 0; s <= d; ++s) l[s] = 0;
          return [p, l];
        }
        l[0] = 0;
        var c = function (e) {
            var t = n[e] - n[e - 1],
              r = 0;
            m.nGramWidths.forEach(function (e) {
              r += a.getNumNGrams(t, e);
            }),
              m.preserveShort && t > 0 && 0 === r && (r = 1),
              (l[e] = l[e - 1] + r);
          },
          m = this;
        for (s = 1; s <= d; ++s) c(s);
        var f = new Array(l[d]),
          h = function (t) {
            var r = n[t],
              u = l[t];
            if (
              (b.nGramWidths.forEach(function (i) {
                var s = n[t + 1] - n[t],
                  o = a.getNumNGrams(s, i);
                a.createNGrams(e, r, f, u, o, i), (u += o);
              }),
              b.preserveShort && u === l[t])
            ) {
              var i = n[t + 1] - n[t];
              if (0 === i) return 'continue';
              var s = i + 2 * b.padWidth;
              b.createNGrams(e, r, f, u, 1, s);
            }
          },
          b = this;
        for (s = 0; s < d; ++s) h(s);
        return [f, l];
      }),
      e
    );
  })();
  function X(e, t, n, a) {
    if (e.length)
      if (0 !== t.length)
        if (1 !== t.length) {
          var r = 0;
          for (o = 0; o < e.length + 1; o++)
            if (o === e.length || -1 !== t.indexOf(e[o])) {
              s = e.subarray(r, o);
              (n && 0 === s.length) || a.push(s), (r = o + 1);
            }
        } else {
          for (var u = t[0], i = e.indexOf(u); -1 !== i; ) {
            var s = e.subarray(0, i);
            (n && 0 === s.length) || a.push(s), (i = (e = e.subarray(i + 1)).indexOf(u));
          }
          (n && 0 === e.length) || a.push(e);
        }
      else for (var o = 0; o < e.length; ++o) a.push(e.subarray(o, o + 1));
  }
  function Q(e) {
    var n = e.inputs.x,
      a = e.attrs,
      r = a.begin,
      u = a.size,
      i = e.backend,
      s = g(t.slice_util.parseSliceParams(n, r, u), 2),
      o = s[0],
      d = s[1],
      l = t.slice_util.isSliceContinous(n.shape, o, d),
      p = i.readSync(n.dataId),
      c = i.makeOutput(d, n.dtype),
      m = t.util.computeStrides(n.shape),
      f = i.dataIdMap.get(c.dataId);
    if (l) {
      var h = t.slice_util.computeFlatOffset(o, m);
      if ('string' === n.dtype) f.stringBytes = p.slice(h, h + t.util.sizeFromShape(d));
      else i.typedArrayFromHeap(c).set(p.subarray(h, h + t.util.sizeFromShape(d)));
      return c;
    }
    if ('string' === n.dtype) {
      var b = G(p, o, d, n.shape, n.dtype);
      return (f.stringBytes = b), c;
    }
    var _ = i.typedArrayFromHeap(c),
      y = n.shape.length;
    if (2 === y)
      !(function (e, t, n, a, r) {
        for (var u = 0, i = a[0], s = a[1], o = i + r[0], d = i; d < o; d++) {
          var l = d * t + s;
          n.set(e.subarray(l, l + r[1]), u), (u += r[1]);
        }
      })(p, m[0], _, o, d);
    else if (3 === y)
      !(function (e, t, n, a, r, u) {
        for (var i = 0, s = r[0], o = r[1], d = r[2], l = s + u[0], p = o + u[1], c = s; c < l; c++)
          for (var m = o; m < p; m++) {
            var f = c * t + m * n + d;
            a.set(e.subarray(f, f + u[2]), i), (i += u[2]);
          }
      })(p, m[0], m[1], _, o, d);
    else if (4 === y)
      !(function (e, t, n, a, r, u, i) {
        for (var s = 0, o = u[0], d = u[1], l = u[2], p = o + i[0], c = d + i[1], m = l + i[2], f = u[3], h = o; h < p; h++)
          for (var b = d; b < c; b++)
            for (var _ = l; _ < m; _++) {
              var y = h * t + b * n + _ * a + f;
              r.set(e.subarray(y, y + i[3]), s), (s += i[3]);
            }
      })(p, m[0], m[1], m[2], _, o, d);
    else {
      b = G(p, o, d, n.shape, n.dtype);
      _.set(b);
    }
    return c;
  }
  var Z = { kernelName: t.Slice, backendName: 'wasm', kernelFunc: Q };
  var Y = {
    kernelName: t.BatchToSpaceND,
    backendName: 'wasm',
    kernelFunc: function (e) {
      var n = e.inputs,
        a = e.backend,
        r = e.attrs,
        u = n.x,
        i = r.blockShape,
        s = r.crops,
        o = i.reduce(function (e, t) {
          return e * t;
        }),
        d = t.backend_util.getReshaped(u.shape, i, o),
        l = t.backend_util.getPermuted(d.length, i.length),
        p = t.backend_util.getReshapedPermuted(u.shape, i, o),
        c = t.backend_util.getSliceBeginCoords(s, i.length),
        m = t.backend_util.getSliceSize(p, s, i.length),
        f = B({ inputs: { x: u }, backend: a, attrs: { shape: d } }),
        h = R({ inputs: { x: f }, backend: a, attrs: { perm: l } }),
        b = Q({ inputs: { x: B({ inputs: { x: h }, backend: a, attrs: { shape: p } }) }, backend: a, attrs: { begin: c, size: m } });
      return a.disposeData(f.dataId), a.disposeData(h.dataId), a.disposeData(f.dataId), b;
    },
  };
  function $(e) {
    var t = e.inputs.x,
      n = e.attrs.dtype,
      a = e.backend,
      r = a.makeOutput(t.shape, n),
      u = a.typedArrayFromHeap(t);
    return a.typedArrayFromHeap(r).set(u), r;
  }
  var J,
    ee = { kernelName: t.Cast, backendName: 'wasm', kernelFunc: $ },
    te = k(t.Ceil);
  var ne = {
    kernelName: t.ClipByValue,
    backendName: 'wasm',
    setupFunc: function (e) {
      J = e.wasm.cwrap(t.ClipByValue, null, ['number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      var t = e.inputs,
        n = e.backend,
        a = e.attrs,
        r = t.x,
        u = a.clipValueMin,
        i = a.clipValueMax,
        s = n.dataIdMap.get(r.dataId).id,
        o = n.makeOutput(r.shape, r.dtype),
        d = n.dataIdMap.get(o.dataId).id;
      return J(s, u, i, d), o;
    },
  };
  function ae(e) {
    var n = e.inputs,
      a = e.backend,
      r = t.util.parseAxisParam(e.attrs.axis, n[0].shape)[0],
      u = t.backend_util.computeOutShape(
        n.map(function (e) {
          return e.shape;
        }),
        r,
      ),
      i = n.filter(function (e) {
        return t.util.sizeFromShape(e.shape) > 0;
      });
    if (1 === i.length) return F({ inputs: { x: i[0] }, backend: a });
    var s = a.makeOutput(u, n[0].dtype);
    if (0 === t.util.sizeFromShape(u)) return s;
    var o = i.map(function (e) {
      return e.shape;
    });
    if ((t.backend_util.assertParamsConsistent(o, r), 'string' === i[0].dtype)) {
      var d = i.map(function (e) {
          var n = t.util.sizeFromShape(e.shape.slice(r));
          return B({ inputs: { x: e }, backend: a, attrs: { shape: [-1, n] } });
        }),
        l = d.map(function (e) {
          return { vals: a.readSync(e.dataId), shape: e.shape };
        });
      u = t.backend_util.computeOutShape(
        d.map(function (e) {
          return e.shape;
        }),
        1,
      );
      var p = 1 === d[0].shape[0],
        c = (function (e, n, a, r) {
          var u = t.util.getArrayFromDType(a, t.util.sizeFromShape(n));
          if (r && 'string' !== a) {
            var i = 0;
            e.forEach(function (e) {
              var n = t.util.sizeFromShape(e.shape);
              u.set(e.vals, i), (i += n);
            });
          } else {
            var s = 0;
            e.forEach(function (e) {
              for (var r = 'string' === a ? t.backend_util.fromUint8ToStringArray(e.vals) : e.vals, i = 0, o = 0; o < e.shape[0]; ++o)
                for (var d = o * n[1] + s, l = 0; l < e.shape[1]; ++l) u[d + l] = r[i++];
              s += e.shape[1];
            });
          }
          return u;
        })(l, u, n[0].dtype, p),
        m = t.backend_util.computeOutShape(
          i.map(function (e) {
            return e.shape;
          }),
          r,
        );
      return (
        (s.shape = m),
        (a.dataIdMap.get(s.dataId).stringBytes = t.backend_util.fromStringArrayToUint8(c)),
        d.forEach(function (e) {
          return a.disposeData(e.dataId);
        }),
        s
      );
    }
    for (
      var f = t.util.sizeFromShape(i[0].shape.slice(0, r)),
        h = 0,
        b = i.map(function (e) {
          var n = t.util.sizeFromShape(e.shape.slice(r));
          return (h += n), n;
        }),
        _ = i.map(function (e) {
          return a.typedArrayFromHeap(e);
        }),
        y = a.typedArrayFromHeap(s),
        g = 0;
      g < f;
      g++
    )
      for (var v = g * h, w = 0; w < _.length; w++) {
        var k = b[w],
          I = g * k,
          S = _[w].subarray(I, I + k);
        y.set(S, v), (v += k);
      }
    return s;
  }
  var re,
    ue = { kernelName: t.Concat, backendName: 'wasm', kernelFunc: ae };
  var ie,
    se = {
      kernelName: t.Conv2D,
      backendName: 'wasm',
      setupFunc: function (e) {
        re = e.wasm.cwrap(t.Conv2D, null, [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
        ]);
      },
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.attrs,
          r = e.backend,
          u = n.x,
          i = n.filter,
          s = r.dataIdMap.get(u.dataId).id,
          o = r.dataIdMap.get(i.dataId).id,
          d = a.strides,
          l = a.dilations,
          p = a.pad,
          c = a.dimRoundingMode,
          m = a.dataFormat,
          f = t.backend_util.convertConv2DDataFormat(m),
          h = t.backend_util.computeConv2DInfo(u.shape, i.shape, d, l, p, c, !1, f),
          b = h.filterHeight,
          _ = h.filterWidth,
          y = h.padInfo.top,
          g = h.padInfo.right,
          v = h.padInfo.bottom,
          w = h.padInfo.left,
          k = h.dilationHeight,
          I = h.dilationWidth,
          S = h.strideHeight,
          M = h.strideWidth,
          x = h.inChannels,
          A = h.outChannels,
          F = 'SAME' === h.padInfo.type ? 1 : 0;
        if ('channelsLast' !== h.dataFormat)
          throw new Error("wasm backend Conv2D does not support dataFormat:'" + h.dataFormat + "'. Please use 'channelsLast'.");
        var N = r.makeOutput(h.outShape, 'float32'),
          E = r.dataIdMap.get(N.dataId).id;
        return re(s, u.shape[0], u.shape[1], u.shape[2], o, b, _, y, g, v, w, F, k, I, S, M, x, A, E), N;
      },
    };
  var oe,
    de,
    le = {
      kernelName: t.Conv2DBackpropInput,
      backendName: 'wasm',
      setupFunc: function (e) {
        ie = e.wasm.cwrap(t.Conv2DBackpropInput, null, [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
        ]);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = a.dy,
          i = a.filter,
          s = r.strides,
          o = r.pad,
          d = r.dataFormat,
          l = r.dimRoundingMode,
          p = r.inputShape,
          c = t.backend_util.convertConv2DDataFormat(d),
          m = t.backend_util.computeConv2DInfo(p, i.shape, s, 1, o, l, !1, c),
          f = m.batchSize,
          h = m.filterHeight,
          b = m.filterWidth,
          _ = m.inChannels,
          y = m.inHeight,
          v = m.inWidth,
          w = m.outChannels,
          k = m.outHeight,
          I = m.outWidth,
          S = m.strideHeight,
          M = m.strideWidth,
          x = h - 1 - m.padInfo.top,
          A = b - 1 - m.padInfo.left,
          F = 'channelsLast' === m.dataFormat,
          N = t.util.computeStrides(m.inShape),
          E = t.util.computeStrides(u.shape),
          R = g(t.util.computeStrides(i.shape), 3),
          C = R[0],
          D = R[1],
          T = R[2],
          O = N[0],
          P = F ? N[1] : N[2],
          W = F ? N[2] : 1,
          L = F ? 1 : N[1],
          z = E[0],
          j = F ? E[1] : E[2],
          H = F ? E[2] : 1,
          B = F ? 1 : E[1],
          U = n.makeOutput(m.inShape, 'float32'),
          q = n.dataIdMap.get(U.dataId).id,
          V = n.dataIdMap.get(u.dataId).id,
          G = n.dataIdMap.get(i.dataId).id;
        return ie(V, G, f, h, b, y, v, _, k, I, w, S, M, x, A, C, D, T, O, P, W, L, z, j, H, B, q), U;
      },
    },
    pe = k(t.Cos),
    ce = k(t.Cosh);
  !(function (e) {
    (e[(e.bilinear = 0)] = 'bilinear'), (e[(e.nearest = 1)] = 'nearest');
  })(oe || (oe = {}));
  var me,
    fe = {
      kernelName: t.CropAndResize,
      backendName: 'wasm',
      setupFunc: function (e) {
        de = e.wasm.cwrap(t.CropAndResize, null, [
          'number',
          'number',
          'number',
          'number',
          'array',
          'number',
          'number',
          'number',
          'number',
          'number',
        ]);
      },
      kernelFunc: function (e) {
        var t,
          n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = r.method,
          i = r.extrapolationValue,
          s = r.cropSize,
          o = a.image,
          d = a.boxes,
          l = a.boxInd,
          p = d.shape[0],
          c = g(s, 2),
          m = c[0],
          f = c[1],
          h = [p, m, f, o.shape[3]],
          b = n.dataIdMap.get(o.dataId);
        'float32' !== o.dtype && ((t = $({ backend: n, inputs: { x: o }, attrs: { dtype: 'float32' } })), (b = n.dataIdMap.get(t.dataId)));
        var _ = b.id,
          y = n.dataIdMap.get(d.dataId).id,
          v = n.dataIdMap.get(l.dataId).id,
          w = n.makeOutput(h, 'float32'),
          k = n.dataIdMap.get(w.dataId).id,
          I = new Uint8Array(new Int32Array(o.shape).buffer);
        return de(_, y, v, p, I, m, f, oe[u], i, k), null != t && n.disposeData(t.dataId), w;
      },
    };
  var he,
    be = {
      kernelName: t.Cumprod,
      backendName: 'wasm',
      setupFunc: function (e) {
        me = e.wasm.cwrap(t.Cumprod, null, ['number', 'number', 'number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.backend,
          r = e.attrs,
          u = n.x,
          i = r.axis,
          s = r.exclusive,
          d = r.reverse,
          l = u.shape.length;
        t.util.assert('float32' === u.dtype || 'int32' === u.dtype, function () {
          return 'cumprod does not support ' + u.dtype + ' tensors in the WASM backend';
        });
        var p = t.backend_util.getAxesPermutation([i], l),
          c = u;
        null !== p && (c = R({ inputs: { x: u }, attrs: { perm: p }, backend: a }));
        var m = t.backend_util.getInnerMostAxes(1, l)[0];
        t.backend_util.assertAxesAreInnerMostDims('cumprod', [m], l);
        var f = a.makeOutput(c.shape, c.dtype),
          h = c.shape[m],
          b = a.dataIdMap.get(c.dataId).id,
          _ = a.dataIdMap.get(f.dataId).id;
        me(b, s ? 1 : 0, d ? 1 : 0, h, _, o[u.dtype]);
        var y = f;
        return (
          null !== p &&
            ((y = R({ inputs: { x: f }, attrs: { perm: t.backend_util.getUndoAxesPermutation(p) }, backend: a })),
            a.disposeData(c.dataId),
            a.disposeData(f.dataId)),
          y
        );
      },
    };
  var _e,
    ye = {
      kernelName: t.Cumsum,
      backendName: 'wasm',
      setupFunc: function (e) {
        he = e.wasm.cwrap(t.Cumsum, null, ['number', 'number', 'number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.backend,
          r = e.attrs,
          u = n.x,
          i = r.axis,
          s = r.exclusive,
          d = r.reverse,
          l = u.shape.length;
        t.util.assert('float32' === u.dtype || 'int32' === u.dtype, function () {
          return 'cumsum does not support ' + u.dtype + ' tensors in the WASM backend';
        });
        var p = t.backend_util.getAxesPermutation([i], l),
          c = u;
        null !== p && (c = R({ inputs: { x: u }, attrs: { perm: p }, backend: a }));
        var m = t.backend_util.getInnerMostAxes(1, l)[0];
        t.backend_util.assertAxesAreInnerMostDims('cumsum', [m], l);
        var f = a.makeOutput(c.shape, c.dtype),
          h = c.shape[m],
          b = a.dataIdMap.get(c.dataId).id,
          _ = a.dataIdMap.get(f.dataId).id;
        he(b, s ? 1 : 0, d ? 1 : 0, h, _, o[u.dtype]);
        var y = f;
        return (
          null !== p &&
            ((y = R({ inputs: { x: f }, attrs: { perm: t.backend_util.getUndoAxesPermutation(p) }, backend: a })),
            a.disposeData(c.dataId),
            a.disposeData(f.dataId)),
          y
        );
      },
    };
  var ge,
    ve = {
      kernelName: t.DepthToSpace,
      backendName: 'wasm',
      setupFunc: function (e) {
        _e = e.wasm.cwrap(t.DepthToSpace, null, ['number', 'number', 'number', 'array', 'number', 'array', 'array', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = a.x,
          i = r.blockSize,
          s = r.dataFormat,
          o = u.shape[0],
          d = ('NHWC' === s ? u.shape[1] : u.shape[2]) * i,
          l = ('NHWC' === s ? u.shape[2] : u.shape[3]) * i,
          p = ('NHWC' === s ? u.shape[3] : u.shape[1]) / (i * i),
          c = 'NHWC' === s ? [o, d, l, p] : [o, p, d, l],
          m = n.makeOutput(c, 'float32'),
          f = n.dataIdMap.get(u.dataId).id,
          h = new Uint8Array(new Int32Array(t.util.computeStrides(u.shape)).buffer),
          b = new Uint8Array(new Int32Array(c).buffer),
          _ = new Uint8Array(new Int32Array(t.util.computeStrides(c)).buffer),
          y = n.dataIdMap.get(m.dataId).id;
        return _e(f, i, 'NHWC' === s ? 1 : 0, h, u.shape.length - 1, b, _, c.length, y), m;
      },
    };
  var we = {
      kernelName: t.DepthwiseConv2dNative,
      backendName: 'wasm',
      setupFunc: function (e) {
        ge = e.wasm.cwrap(t.DepthwiseConv2dNative, null, [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
        ]);
      },
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.attrs,
          r = e.backend,
          u = n.x,
          i = n.filter,
          s = r.dataIdMap.get(u.dataId).id,
          o = r.dataIdMap.get(i.dataId).id,
          d = a.strides,
          l = a.dilations,
          p = a.pad,
          c = a.dimRoundingMode,
          m = null == l ? [1, 1] : l,
          f = t.backend_util.computeConv2DInfo(u.shape, i.shape, d, m, p, c, !0),
          h = f.filterHeight,
          b = f.filterWidth,
          _ = f.padInfo.top,
          y = f.padInfo.right,
          g = f.padInfo.bottom,
          v = f.padInfo.left,
          w = f.dilationHeight,
          k = f.dilationWidth,
          I = f.strideHeight,
          S = f.strideWidth,
          M = f.inChannels,
          x = f.outChannels,
          A = 'SAME' === f.padInfo.type ? 1 : 0;
        if ('channelsLast' !== f.dataFormat)
          throw new Error(
            "wasm backend DepthwiseConv2dNative does not support dataFormat:'" + f.dataFormat + "'. Please use 'channelsLast'.",
          );
        var F = r.makeOutput(f.outShape, 'float32'),
          N = r.dataIdMap.get(F.dataId).id;
        return ge(s, u.shape[0], u.shape[1], u.shape[2], o, h, b, _, y, g, v, A, w, k, I, S, M, x, N), F;
      },
    },
    ke = k(t.Elu),
    Ie = S(t.Equal, 0, 'bool'),
    Se = k(t.Exp, 'float32');
  function Me(e) {
    var n = e.inputs,
      a = e.attrs,
      r = e.backend,
      u = n.input,
      i = a.dim,
      s = u.shape.length,
      o = u.shape.slice(),
      d = i;
    return (
      i < 0 &&
        (t.util.assert(-(s + 1) <= i, function () {
          return 'Axis must be in the interval [' + -(s + 1) + ', ' + s + ']';
        }),
        (d = s + i + 1)),
      o.splice(d, 0, 1),
      B({ inputs: { x: u }, backend: r, attrs: { shape: o } })
    );
  }
  var xe = { kernelName: t.ExpandDims, backendName: 'wasm', kernelFunc: Me };
  function Ae(e) {
    var t = e.attrs,
      n = t.shape,
      a = t.value,
      r = t.dtype,
      u = e.backend,
      i = u.makeOutput(n, r);
    return u.typedArrayFromHeap(i).fill(a), i;
  }
  var Fe,
    Ne = { kernelName: t.Fill, backendName: 'wasm', kernelFunc: Ae };
  var Ee,
    Re = {
      kernelName: t.FlipLeftRight,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var t = e.inputs,
          n = e.backend,
          a = t.image,
          r = n.makeOutput(a.shape, a.dtype),
          u = n.dataIdMap.get(a.dataId).id,
          i = n.dataIdMap.get(r.dataId).id,
          s = g(a.shape, 4),
          o = s[0],
          d = s[1],
          l = s[2],
          p = s[3];
        return Fe(u, o, d, l, p, i), r;
      },
      setupFunc: function (e) {
        Fe = e.wasm.cwrap(t.FlipLeftRight, null, ['number', 'number', 'number', 'number', 'number', 'number']);
      },
    },
    Ce = k(t.Floor),
    De = S(t.FloorDiv);
  var Te,
    Oe = {
      kernelName: t.FusedBatchNorm,
      backendName: 'wasm',
      setupFunc: function (e) {
        Ee = e.wasm.cwrap(t.FusedBatchNorm, null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs.varianceEpsilon,
          u = a.x,
          i = a.mean,
          s = a.variance,
          o = a.offset,
          d = a.scale,
          l = n.dataIdMap.get(u.dataId).id,
          p = n.dataIdMap.get(i.dataId).id,
          c = n.dataIdMap.get(s.dataId).id,
          m = null != o ? n.dataIdMap.get(o.dataId).id : 0,
          f = null != d ? n.dataIdMap.get(d.dataId).id : 0,
          h = n.makeOutput(u.shape, u.dtype);
        if (0 === t.util.sizeFromShape(u.shape)) return h;
        var b = n.dataIdMap.get(h.dataId).id;
        return Ee(l, p, c, m, f, r, b), h;
      },
    };
  var Pe,
    We = {
      kernelName: t.FusedConv2D,
      backendName: 'wasm',
      setupFunc: function (e) {
        Te = e.wasm.cwrap(t.FusedConv2D, null, [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
        ]);
      },
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.attrs,
          r = e.backend,
          u = n.x,
          i = n.filter,
          s = n.bias,
          o = n.preluActivationWeights,
          l = a.strides,
          p = a.pad,
          c = a.dilations,
          m = a.dataFormat,
          f = a.dimRoundingMode,
          h = a.activation,
          b = a.leakyreluAlpha,
          _ = t.backend_util.computeConv2DInfo(u.shape, i.shape, l, c, p, f),
          y = d[h];
        if (null == y) throw new Error(h + ' activation not yet supported for FusedConv2D in the wasm backend.');
        var g = r.dataIdMap.get(u.dataId).id,
          v = r.dataIdMap.get(i.dataId).id,
          w = _.outChannels,
          k = 0;
        if (null != s) {
          var I = r.dataIdMap.get(s.dataId);
          if (1 !== I.shape.length) throw new Error('FusedConv2D only supports rank-1 bias but got rank ' + I.shape.length + '.');
          if (I.shape[0] !== w)
            throw new Error('FusedConv2D bias shape (' + I.shape + ') does not match the number of output channels (' + w + ')');
          k = I.id;
        }
        var S = _.filterHeight,
          M = _.filterWidth,
          x = _.padInfo.top,
          A = _.padInfo.right,
          F = _.padInfo.bottom,
          N = _.padInfo.left,
          E = _.dilationHeight,
          R = _.dilationWidth,
          C = _.strideHeight,
          D = _.strideWidth,
          T = _.inChannels,
          O = 'SAME' === _.padInfo.type ? 1 : 0,
          P = _.batchSize,
          W = _.inHeight,
          L = _.inWidth;
        if ('NHWC' !== m) throw new Error("wasm backend FusedConv2D does not support dataFormat:'" + m + "'. Please use 'NHWC'.");
        var z = r.makeOutput(_.outShape, 'float32'),
          j = r.dataIdMap.get(z.dataId).id,
          H = null == o ? 0 : r.dataIdMap.get(o.dataId).id;
        return Te(g, P, W, L, v, S, M, k, x, A, F, N, O, E, R, C, D, T, w, y, H, b || 0, j), z;
      },
    };
  var Le,
    ze = {
      kernelName: t.FusedDepthwiseConv2D,
      backendName: 'wasm',
      setupFunc: function (e) {
        Pe = e.wasm.cwrap(t.FusedDepthwiseConv2D, null, [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
        ]);
      },
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.attrs,
          r = e.backend,
          u = n.x,
          i = n.filter,
          s = n.bias,
          o = n.preluActivationWeights,
          l = a.strides,
          p = a.pad,
          c = a.dilations,
          m = a.dataFormat,
          f = a.dimRoundingMode,
          h = a.activation,
          b = a.leakyreluAlpha,
          _ = t.backend_util.computeConv2DInfo(u.shape, i.shape, l, c, p, f, !0),
          y = d[h];
        if (null == y) throw new Error(h + ' activation not yet supported for FusedDepthwiseConv2D in the wasm backend.');
        var g = r.dataIdMap.get(u.dataId).id,
          v = r.dataIdMap.get(i.dataId).id,
          w = _.outChannels,
          k = 0;
        if (null != s) {
          var I = r.dataIdMap.get(s.dataId);
          if (1 !== I.shape.length) throw new Error('FusedDepthwiseConv2D only supports rank-1 bias but got rank ' + I.shape.length + '.');
          if (I.shape[0] !== w)
            throw new Error('FusedDepthwiseConv2D bias shape (' + I.shape + ') does not match the number of output channels (' + w + ')');
          k = I.id;
        }
        var S = _.filterHeight,
          M = _.filterWidth,
          x = _.padInfo.top,
          A = _.padInfo.right,
          F = _.padInfo.bottom,
          N = _.padInfo.left,
          E = _.dilationHeight,
          R = _.dilationWidth,
          C = _.strideHeight,
          D = _.strideWidth,
          T = _.inChannels,
          O = 'SAME' === _.padInfo.type ? 1 : 0,
          P = _.batchSize,
          W = _.inHeight,
          L = _.inWidth;
        if ('NHWC' !== m) throw new Error("wasm backend FusedDepthwiseConv2D does not support dataFormat:'" + m + "'. Please use 'NHWC'.");
        var z = r.makeOutput(_.outShape, 'float32'),
          j = r.dataIdMap.get(z.dataId).id,
          H = null == o ? 0 : r.dataIdMap.get(o.dataId).id;
        return Pe(g, P, W, L, v, S, M, k, x, A, F, N, O, E, R, C, D, T, w, y, H, b || 0, j), z;
      },
    };
  var je,
    He = {
      kernelName: t.GatherNd,
      backendName: 'wasm',
      setupFunc: function (e) {
        Le = e.wasm.cwrap(t.GatherNd, null, ['number', 'number', 'number', 'number', 'number', 'number', 'array', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = a.params,
          u = a.indices,
          i = g(t.gather_util.prepareAndValidate(r, u), 4),
          s = i[0],
          d = i[1],
          l = i[2],
          p = i[3],
          c = n.makeOutput(s, r.dtype);
        if (0 === d) return c;
        var m = u.shape,
          f = m[m.length - 1],
          h = n.dataIdMap.get(r.dataId).id,
          b = n.dataIdMap.get(u.dataId).id,
          _ = new Uint8Array(new Int32Array(p).buffer),
          y = n.dataIdMap.get(c.dataId).id;
        return Le(h, o[r.dtype], b, d, f, l, _, y), c;
      },
    };
  var Be,
    Ue = {
      kernelName: t.GatherV2,
      backendName: 'wasm',
      setupFunc: function (e) {
        je = e.wasm.cwrap('Gather', null, ['number', 'number', 'array', 'number', 'number', 'number', 'array', 'number']);
      },
      kernelFunc: function (e) {
        for (
          var n = e.backend,
            a = e.inputs,
            r = e.attrs,
            u = a.x,
            i = a.indices,
            s = r.axis,
            d = r.batchDims,
            l = t.util.parseAxisParam(s, u.shape)[0],
            p = n.readSync(i.dataId),
            c = u.shape[l],
            m = function (e) {
              var n = p[e];
              t.util.assert(n <= c - 1 && n >= 0, function () {
                return 'GatherV2: the index value ' + n + ' is not in [0, ' + (c - 1) + ']';
              });
            },
            f = 0;
          f < p.length;
          ++f
        )
          m(f);
        var h = t.backend_util.segment_util.collectGatherOpShapeInfo(u, i, l, d),
          b = B({ inputs: { x: u }, attrs: { shape: [h.batchSize, h.outerSize, h.dimSize, h.sliceSize] }, backend: n }),
          _ = t.util.sizeFromShape(i.shape),
          y = B({ inputs: { x: i }, attrs: { shape: [h.batchSize, _ / h.batchSize] }, backend: n }),
          g = [h.batchSize, h.outerSize, _ / h.batchSize, h.sliceSize],
          v = n.makeOutput(g, u.dtype);
        if (0 === t.util.sizeFromShape(u.shape)) return v;
        var w = b.shape.length - 1,
          k = n.dataIdMap.get(b.dataId).id,
          I = n.dataIdMap.get(y.dataId).id,
          S = n.dataIdMap.get(v.dataId).id,
          M = new Uint8Array(new Int32Array(t.util.computeStrides(b.shape)).buffer),
          x = new Uint8Array(new Int32Array(t.util.computeStrides(g)).buffer);
        return (
          je(k, o[u.dtype], M, w, I, h.batchSize, x, S), n.disposeData(b.dataId), n.disposeData(y.dataId), (v.shape = h.outputShape), v
        );
      },
    },
    qe = S(t.Greater, 0, 'bool'),
    Ve = S(t.GreaterEqual, 0, 'bool');
  var Ge,
    Ke = {
      kernelName: t.LeakyRelu,
      backendName: 'wasm',
      setupFunc: function (e) {
        Be = e.wasm.cwrap(t.LeakyRelu, null, ['number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.inputs.x,
          a = e.attrs.alpha,
          r = e.backend,
          u = r.dataIdMap.get(n.dataId).id,
          i = r.makeOutput(n.shape, 'float32');
        if (0 !== t.util.sizeFromShape(n.shape)) {
          var s = r.dataIdMap.get(i.dataId).id;
          Be(u, o[n.dtype], a, s);
        }
        return i;
      },
    },
    Xe = S(t.Less, 0, 'bool'),
    Qe = S(t.LessEqual, 0, 'bool'),
    Ze = k(t.Log),
    Ye = S(t.LogicalAnd, 0, 'bool'),
    $e = k(t.LogicalNot),
    Je = S(t.LogicalOr, 0, 'bool'),
    et = S(t.LogicalXor, 0, 'bool');
  var tt,
    nt = {
      kernelName: t.Max,
      backendName: 'wasm',
      setupFunc: function (e) {
        Ge = e.wasm.cwrap(t.Max, null, ['number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = r.reductionIndices,
          i = r.keepDims,
          s = a.x,
          d = n.dataIdMap.get(s.dataId).id,
          l = s,
          p = T(s, u, n),
          c = p.transposed,
          m = p.axes,
          f = p.originalAxes,
          h = p.inputWasTransposed;
        h && ((l = c), (d = n.dataIdMap.get(c.dataId).id));
        var b = l.shape.length;
        t.backend_util.assertAxesAreInnerMostDims('max', m, b);
        var _ = g(t.backend_util.computeOutAndReduceShapes(l.shape, m), 2),
          y = _[0],
          v = _[1],
          w = t.util.sizeFromShape(v),
          k = n.makeOutput(y, s.dtype);
        if (0 !== t.util.sizeFromShape(l.shape)) {
          var I = n.dataIdMap.get(k.dataId).id;
          Ge(d, o[s.dtype], w, I);
        }
        if ((h && n.disposeData(c.dataId), i)) {
          var S = t.backend_util.expandShapeToKeepDim(k.shape, f);
          k.shape = S;
        }
        return k;
      },
    },
    at = S(t.Maximum);
  var rt,
    ut = {
      kernelName: t.MaxPool,
      backendName: 'wasm',
      setupFunc: function (e) {
        tt = e.wasm.cwrap(t.MaxPool, null, [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
        ]);
      },
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.attrs,
          r = e.backend,
          u = n.x,
          i = r.dataIdMap.get(u.dataId).id;
        t.util.assert('float32' === u.dtype, function () {
          return 'Error in MaxPool: only float32 input is supported. Got ' + u.dtype + '.';
        });
        var s = a.filterSize,
          o = a.strides,
          d = a.pad,
          l = a.dimRoundingMode,
          p = t.backend_util.computePool2DInfo(u.shape, s, o, 1, d, l),
          c = p.filterHeight,
          m = p.filterWidth,
          f = p.padInfo.top,
          h = p.padInfo.right,
          b = p.padInfo.bottom,
          _ = p.padInfo.left,
          y = p.dilationHeight,
          g = p.dilationWidth,
          v = p.strideHeight,
          w = p.strideWidth,
          k = p.inChannels,
          I = p.outChannels;
        if ('channelsLast' !== p.dataFormat)
          throw new Error("wasm backend does not support dataFormat:'" + p.dataFormat + "'. Please use 'channelsLast'.");
        var S = r.makeOutput(p.outShape, 'float32'),
          M = r.dataIdMap.get(S.dataId).id;
        return tt(i, u.shape[0], u.shape[1], u.shape[2], c, m, f, h, b, _, y, g, v, w, k, I, M), S;
      },
    };
  var it,
    st = {
      kernelName: t.Mean,
      backendName: 'wasm',
      setupFunc: function (e) {
        rt = e.wasm.cwrap(t.Mean, null, ['number, number, number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = r.axis,
          i = r.keepDims,
          s = a.x,
          o = n.dataIdMap.get(s.dataId).id,
          d = o,
          l = s,
          p = T(s, u, n),
          c = p.transposed,
          m = p.axes,
          f = p.originalAxes,
          h = p.inputWasTransposed,
          b = m;
        if (h) {
          var _ = n.dataIdMap.get(c.dataId).id;
          _ !== o && ((l = c), (d = _), (b = t.backend_util.getInnerMostAxes(b.length, l.shape.length)));
        }
        t.backend_util.assertAxesAreInnerMostDims('mean', b, l.shape.length);
        var y = g(t.backend_util.computeOutAndReduceShapes(l.shape, b), 2),
          v = y[0],
          w = y[1],
          k = t.util.sizeFromShape(w),
          I = l;
        'float32' !== l.dtype &&
          ((I = $({ backend: n, inputs: { x: l }, attrs: { dtype: 'float32' } })), (d = n.dataIdMap.get(I.dataId).id));
        var S = n.makeOutput(v, 'float32');
        if (0 !== t.util.sizeFromShape(l.shape)) {
          var M = n.dataIdMap.get(S.dataId).id;
          rt(d, k, M);
        }
        if ((h && n.disposeData(c.dataId), i)) {
          var x = t.backend_util.expandShapeToKeepDim(S.shape, f);
          S.shape = x;
        }
        return 'float32' !== l.dtype && n.disposeData(I.dataId), S;
      },
    };
  var ot,
    dt,
    lt = {
      kernelName: t.Min,
      backendName: 'wasm',
      setupFunc: function (e) {
        it = e.wasm.cwrap(t.Min, null, ['number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = r.axis,
          i = r.keepDims,
          s = a.x,
          d = n.dataIdMap.get(s.dataId).id,
          l = d,
          p = s,
          c = T(s, u, n),
          m = c.transposed,
          f = c.axes,
          h = c.originalAxes,
          b = c.inputWasTransposed;
        if (b) {
          var _ = n.dataIdMap.get(m.dataId).id;
          _ !== d && ((p = m), (l = _));
        }
        var y = p.shape.length;
        t.backend_util.assertAxesAreInnerMostDims('min', f, y);
        var v = g(t.backend_util.computeOutAndReduceShapes(p.shape, f), 2),
          w = v[0],
          k = v[1],
          I = t.util.sizeFromShape(k),
          S = n.makeOutput(w, p.dtype);
        if (0 !== t.util.sizeFromShape(p.shape)) {
          var M = n.dataIdMap.get(S.dataId).id;
          it(l, o[s.dtype], I, M);
        }
        if ((b && n.disposeData(m.dataId), i)) {
          var x = t.backend_util.expandShapeToKeepDim(S.shape, h);
          S.shape = x;
        }
        return S;
      },
    },
    pt = S(t.Minimum);
  !(function (e) {
    (e[(e.reflect = 0)] = 'reflect'), (e[(e.symmetric = 1)] = 'symmetric');
  })(ot || (ot = {}));
  var ct,
    mt = {
      kernelName: t.MirrorPad,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var t = e.inputs.x,
          n = e.backend,
          a = e.attrs,
          r = a.paddings,
          u = a.mode,
          i = r.map(function (e, n) {
            return e[0] + t.shape[n] + e[1];
          }),
          s = n.dataIdMap.get(t.dataId).id,
          d = n.makeOutput(i, t.dtype),
          l = n.dataIdMap.get(d.dataId).id,
          p = new Uint8Array(new Int32Array(t.shape).buffer),
          c = r.map(function (e) {
            return e[0];
          }),
          m = r.map(function (e) {
            return e[1];
          }),
          f = new Uint8Array(new Int32Array(c).buffer),
          h = new Uint8Array(new Int32Array(m).buffer);
        return dt(s, p, t.shape.length, o[t.dtype], f, h, ot[u], l), d;
      },
      setupFunc: function (e) {
        dt = e.wasm.cwrap(t.MirrorPad, null, ['number', 'array', 'number', 'number', 'array', 'array', 'number', 'number']);
      },
    },
    ft = S(t.Multiply),
    ht = k(t.Neg);
  function bt(e, t) {
    var n = new Int32Array(e.wasm.HEAPU8.buffer, t, 4),
      a = n[0],
      r = n[1],
      u = n[2],
      i = n[3];
    return e.wasm._free(t), { pSelectedIndices: a, selectedSize: r, pSelectedScores: u, pValidOutputs: i };
  }
  var _t,
    yt = {
      kernelName: t.NonMaxSuppressionV3,
      backendName: 'wasm',
      setupFunc: function (e) {
        ct = e.wasm.cwrap(t.NonMaxSuppressionV3, 'number', ['number', 'number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var t = e.backend,
          n = e.inputs,
          a = e.attrs,
          r = a.iouThreshold,
          u = a.maxOutputSize,
          i = a.scoreThreshold,
          s = n.boxes,
          o = n.scores,
          d = t.dataIdMap.get(s.dataId).id,
          l = t.dataIdMap.get(o.dataId).id,
          p = bt(t, ct(d, l, u, r, i)),
          c = p.pSelectedIndices,
          m = p.selectedSize,
          f = p.pSelectedScores,
          h = p.pValidOutputs;
        return t.wasm._free(f), t.wasm._free(h), t.makeOutput([m], 'int32', c);
      },
    };
  var gt,
    vt = {
      kernelName: t.NonMaxSuppressionV4,
      backendName: 'wasm',
      setupFunc: function (e) {
        _t = e.wasm.cwrap(t.NonMaxSuppressionV4, 'number', ['number', 'number', 'number', 'number', 'number', 'bool']);
      },
      kernelFunc: function (e) {
        var t = e.backend,
          n = e.inputs,
          a = e.attrs,
          r = a.iouThreshold,
          u = a.maxOutputSize,
          i = a.scoreThreshold,
          s = a.padToMaxOutputSize,
          o = n.boxes,
          d = n.scores,
          l = t.dataIdMap.get(o.dataId).id,
          p = t.dataIdMap.get(d.dataId).id,
          c = bt(t, _t(l, p, u, r, i, s)),
          m = c.pSelectedIndices,
          f = c.selectedSize,
          h = c.pSelectedScores,
          b = c.pValidOutputs;
        return t.wasm._free(h), [t.makeOutput([f], 'int32', m), t.makeOutput([], 'int32', b)];
      },
    };
  var wt,
    kt = {
      kernelName: t.NonMaxSuppressionV5,
      backendName: 'wasm',
      setupFunc: function (e) {
        gt = e.wasm.cwrap(t.NonMaxSuppressionV5, 'number', ['number', 'number', 'number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var t = e.backend,
          n = e.inputs,
          a = e.attrs,
          r = a.iouThreshold,
          u = a.maxOutputSize,
          i = a.scoreThreshold,
          s = a.softNmsSigma,
          o = n.boxes,
          d = n.scores,
          l = t.dataIdMap.get(o.dataId).id,
          p = t.dataIdMap.get(d.dataId).id,
          c = bt(t, gt(l, p, u, r, i, s)),
          m = c.pSelectedIndices,
          f = c.selectedSize,
          h = c.pSelectedScores,
          b = c.pValidOutputs;
        return t.wasm._free(b), [t.makeOutput([f], 'int32', m), t.makeOutput([f], 'float32', h)];
      },
    },
    It = S(t.NotEqual, 0, 'bool');
  var St = {
    kernelName: t.OneHot,
    backendName: 'wasm',
    setupFunc: function (e) {
      wt = e.wasm.cwrap(t.OneHot, null, ['number', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      var t = e.inputs,
        n = e.backend,
        a = e.attrs,
        r = t.indices,
        u = a.dtype,
        i = a.depth,
        s = a.onValue,
        o = a.offValue,
        d = n.makeOutput(v(r.shape, [i]), u),
        l = n.dataIdMap.get(d.dataId).id,
        p = n.dataIdMap.get(r.dataId).id;
      return wt(p, i, s, o, l), d;
    },
  };
  var Mt = {
    kernelName: t.OnesLike,
    backendName: 'wasm',
    kernelFunc: function (e) {
      var t = e.inputs.x,
        n = e.backend,
        a = n.makeOutput(t.shape, t.dtype);
      return n.typedArrayFromHeap(a).fill(1), a;
    },
  };
  var xt,
    At = {
      kernelName: t.Pack,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.backend,
          r = e.attrs.axis;
        if (1 === n.length) return Me({ inputs: { input: n[0] }, backend: a, attrs: { dim: r } });
        var u = n[0].shape,
          i = n[0].dtype;
        n.forEach(function (e) {
          t.util.assertShapesMatch(u, e.shape, 'All tensors passed to stack must have matching shapes'),
            t.util.assert(i === e.dtype, function () {
              return 'All tensors passed to stack must have matching dtypes';
            });
        });
        var s = [],
          o = ae({
            inputs: n.map(function (e) {
              var t = Me({ inputs: { input: e }, backend: a, attrs: { dim: r } });
              return s.push(t), t;
            }),
            backend: a,
            attrs: { axis: r },
          });
        return (
          s.forEach(function (e) {
            return a.disposeData(e.dataId);
          }),
          o
        );
      },
    };
  var Ft,
    Nt = {
      kernelName: t.PadV2,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var n = e.inputs.x,
          a = e.backend,
          r = e.attrs,
          u = r.paddings,
          i = r.constantValue,
          s = u.map(function (e, t) {
            return e[0] + n.shape[t] + e[1];
          });
        if (0 === t.util.sizeFromShape(n.shape)) return Ae({ backend: a, attrs: { shape: s, value: i, dtype: n.dtype } });
        var d = a.dataIdMap.get(n.dataId).id,
          l = a.makeOutput(s, n.dtype),
          p = a.dataIdMap.get(l.dataId).id,
          c = new Uint8Array(new Int32Array(n.shape).buffer),
          m = u.map(function (e) {
            return e[0];
          }),
          f = u.map(function (e) {
            return e[1];
          }),
          h = new Uint8Array(new Int32Array(m).buffer),
          b = new Uint8Array(new Int32Array(f).buffer);
        return xt(d, c, n.shape.length, o[n.dtype], h, b, i, p), l;
      },
      setupFunc: function (e) {
        xt = e.wasm.cwrap(t.PadV2, null, ['number', 'array', 'number', 'number', 'array', 'array', 'number', 'number']);
      },
    },
    Et = S(t.Pow);
  var Rt,
    Ct = {
      kernelName: t.Prelu,
      backendName: 'wasm',
      setupFunc: function (e) {
        Ft = e.wasm.cwrap(t.Prelu, null, ['number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var t = e.inputs,
          n = e.backend,
          a = t.x,
          r = t.alpha,
          u = n.dataIdMap.get(a.dataId).id,
          i = n.dataIdMap.get(r.dataId).id,
          s = u,
          o = a,
          d = o;
        'float32' !== o.dtype &&
          ((d = $({ backend: n, inputs: { x: a }, attrs: { dtype: 'float32' } })), (s = n.dataIdMap.get(d.dataId).id));
        var l = n.makeOutput(a.shape, 'float32'),
          p = n.dataIdMap.get(l.dataId).id;
        return Ft(s, i, p), 'float32' !== o.dtype && n.disposeData(d.dataId), l;
      },
    };
  var Dt,
    Tt = {
      kernelName: t.Prod,
      backendName: 'wasm',
      setupFunc: function (e) {
        Rt = e.wasm.cwrap(t.Prod, null, ['number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = r.axis,
          i = r.keepDims,
          s = a.x,
          d = n.dataIdMap.get(s.dataId).id,
          l = d,
          p = s,
          c = T(s, u, n),
          m = c.transposed,
          f = c.axes,
          h = c.originalAxes,
          b = c.inputWasTransposed,
          _ = f;
        if (b) {
          var y = n.dataIdMap.get(m.dataId).id;
          y !== d && ((p = m), (l = y), (_ = t.backend_util.getInnerMostAxes(_.length, p.shape.length)));
        }
        t.backend_util.assertAxesAreInnerMostDims('prod', _, p.shape.length);
        var v = g(t.backend_util.computeOutAndReduceShapes(p.shape, _), 2),
          w = v[0],
          k = v[1],
          I = t.util.sizeFromShape(k),
          S = n.makeOutput(w, p.dtype);
        if (0 !== t.util.sizeFromShape(p.shape)) {
          var M = n.dataIdMap.get(S.dataId).id;
          Rt(l, I, o[S.dtype], M);
        }
        if ((b && n.disposeData(m.dataId), i)) {
          var x = t.backend_util.expandShapeToKeepDim(S.shape, h);
          S.shape = x;
        }
        return S;
      },
    },
    Ot = {
      kernelName: t.Range,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.attrs,
          r = a.start,
          u = a.stop,
          i = a.step,
          s = a.dtype,
          o = (function (e, n, a, r) {
            if (e === n || (e < n && a < 0) || (n < e && a > 1)) return t.util.makeZerosTypedArray(0, r);
            var u = Math.abs(Math.ceil((n - e) / a)),
              i = t.util.makeZerosTypedArray(u, r);
            n < e && 1 === a && (a = -1), (i[0] = e);
            for (var s = 1; s < i.length; s++) i[s] = i[s - 1] + a;
            return i;
          })(r, u, i, s),
          d = n.makeOutput([o.length], s);
        return n.typedArrayFromHeap(d).set(o), d;
      },
    },
    Pt = S(t.RealDiv),
    Wt = k(t.Relu),
    Lt = k(t.Relu6);
  var zt,
    jt = {
      kernelName: t.ResizeBilinear,
      backendName: 'wasm',
      setupFunc: function (e) {
        Dt = e.wasm.cwrap(t.ResizeBilinear, null, [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
        ]);
      },
      kernelFunc: function (e) {
        var n,
          a = e.backend,
          r = e.inputs,
          u = e.attrs,
          i = r.images,
          s = u.alignCorners,
          o = u.halfPixelCenters,
          d = g(u.size, 2),
          l = d[0],
          p = d[1],
          c = g(i.shape, 4),
          m = c[0],
          f = c[1],
          h = c[2],
          b = c[3],
          _ = [m, l, p, b],
          y = a.dataIdMap.get(i.dataId);
        'float32' !== y.dtype && ((n = $({ backend: a, inputs: { x: i }, attrs: { dtype: 'float32' } })), (y = a.dataIdMap.get(n.dataId)));
        var v = y.id,
          w = a.makeOutput(_, 'float32');
        if (0 === t.util.sizeFromShape(i.shape)) return w;
        var k = a.dataIdMap.get(w.dataId).id;
        return Dt(v, m, f, h, b, l, p, s ? 1 : 0, o ? 1 : 0, k), null != n && a.disposeData(n.dataId), w;
      },
    };
  var Ht,
    Bt = {
      kernelName: t.ResizeNearestNeighbor,
      backendName: 'wasm',
      setupFunc: function (e) {
        zt = e.wasm.cwrap(t.ResizeNearestNeighbor, null, [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
        ]);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = a.images,
          i = r.alignCorners,
          s = r.halfPixelCenters,
          o = g(r.size, 2),
          d = o[0],
          l = o[1],
          p = g(u.shape, 4),
          c = p[0],
          m = p[1],
          f = p[2],
          h = p[3],
          b = [c, d, l, h],
          _ = n.makeOutput(b, 'float32');
        if (0 === t.util.sizeFromShape(u.shape)) return _;
        var y,
          v = n.dataIdMap.get(u.dataId);
        'float32' !== v.dtype && ((y = $({ backend: n, inputs: { x: u }, attrs: { dtype: 'float32' } })), (v = n.dataIdMap.get(y.dataId)));
        var w = v.id,
          k = n.dataIdMap.get(_.dataId).id;
        return zt(w, c, m, f, h, d, l, i ? 1 : 0, s ? 1 : 0, k), null != y && n.disposeData(y.dataId), _;
      },
    };
  var Ut,
    qt = {
      kernelName: t.Reverse,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.backend,
          r = e.attrs,
          u = n.x,
          i = r.dims,
          s = t.util.parseAxisParam(i, u.shape);
        if (0 === u.shape.length) return F({ inputs: { x: u }, backend: a });
        var o = a.makeOutput(u.shape, u.dtype),
          d = a.dataIdMap.get(u.dataId).id,
          l = a.dataIdMap.get(o.dataId).id,
          p = new Uint8Array(new Int32Array(s).buffer),
          c = new Uint8Array(new Int32Array(u.shape).buffer);
        Ht(d, p, s.length, c, u.shape.length, l);
        var m = B({ inputs: { x: o }, attrs: { shape: u.shape }, backend: a });
        return a.disposeData(o.dataId), m;
      },
      setupFunc: function (e) {
        Ht = e.wasm.cwrap(t.Reverse, null, ['number', 'array', 'number', 'array', 'number', 'number']);
      },
    };
  var Vt,
    Gt = {
      kernelName: t.RotateWithOffset,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.backend,
          r = e.attrs,
          u = n.image,
          i = r.radians,
          s = r.fillValue,
          o = r.center,
          d = a.makeOutput(u.shape, u.dtype),
          l = a.dataIdMap.get(u.dataId).id,
          p = a.dataIdMap.get(d.dataId).id,
          c = g(u.shape, 4),
          m = c[0],
          f = c[1],
          h = c[2],
          b = c[3],
          _ = g(t.backend_util.getImageCenter(o, f, h), 2),
          y = _[0],
          w = _[1],
          k = 'number' == typeof s ? [s, s, s, 0 === s ? 0 : 255] : v(s, [255]),
          I = new Uint8Array(new Int32Array(k).buffer);
        return Ut(l, m, f, h, b, i, y, w, I, k.length, p), d;
      },
      setupFunc: function (e) {
        Ut = e.wasm.cwrap(t.RotateWithOffset, null, [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'array',
          'number',
          'number',
        ]);
      },
    },
    Kt = k(t.Round),
    Xt = k(t.Rsqrt);
  var Qt,
    Zt = {
      kernelName: t.ScatterNd,
      backendName: 'wasm',
      setupFunc: function (e) {
        Vt = e.wasm.cwrap(t.ScatterNd, null, ['number', 'number', 'number', 'number', 'number', 'number', 'array', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = a.indices,
          i = a.updates,
          s = r.shape,
          d = n.makeOutput(s, i.dtype);
        if (0 === t.util.sizeFromShape(s)) return d;
        var l = t.scatter_util.calculateShapes(i, u, s),
          p = l.sliceRank,
          c = l.numUpdates,
          m = l.sliceSize,
          f = l.strides,
          h = l.outputSize,
          b = n.dataIdMap.get(u.dataId).id,
          _ = n.dataIdMap.get(i.dataId).id,
          y = new Uint8Array(new Int32Array(f).buffer),
          g = n.dataIdMap.get(d.dataId).id;
        return Vt(b, _, o[i.dtype], p, c, m, y, h, g), d;
      },
    };
  var Yt,
    $t = {
      kernelName: t.Select,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.backend,
          r = n.condition,
          u = n.t,
          i = n.e,
          s = a.dataIdMap.get(r.dataId).id,
          o = a.dataIdMap.get(u.dataId).id,
          d = a.dataIdMap.get(i.dataId).id,
          l = a.makeOutput(u.shape, u.dtype),
          p = a.dataIdMap.get(l.dataId).id,
          c = r.shape.length,
          m = u.shape.length,
          f = 0 === c || c > 1 || 1 === m ? 1 : t.util.sizeFromShape(u.shape.slice(1));
        return Qt(s, o, d, f, p), l;
      },
      setupFunc: function (e) {
        Qt = e.wasm.cwrap('SelectV2', null, ['number', 'number', 'number', 'number', 'number']);
      },
    };
  var Jt,
    en = {
      kernelName: 'Sigmoid',
      backendName: 'wasm',
      setupFunc: function (e) {
        Yt = e.wasm.cwrap(t.Sigmoid, null, ['number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs.x,
          r = n.dataIdMap.get(a.dataId).id,
          u = n.makeOutput(a.shape, a.dtype),
          i = n.dataIdMap.get(u.dataId).id;
        return 0 === t.util.sizeFromShape(u.shape) || Yt(r, i), u;
      },
    },
    tn = k(t.Sin);
  var nn = {
    kernelName: t.Softmax,
    backendName: 'wasm',
    setupFunc: function (e) {
      Jt = e.wasm.cwrap(t.Softmax, null, ['number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      var n = e.backend,
        a = e.inputs.logits,
        r = e.attrs.dim,
        u = n.dataIdMap.get(a.dataId).id,
        i = n.makeOutput(a.shape, a.dtype),
        s = n.dataIdMap.get(i.dataId).id,
        o = a.shape[r],
        d = t.util.sizeFromShape(a.shape) / o;
      return 0 === t.util.sizeFromShape(i.shape) || Jt(u, s, o, d), i;
    },
  };
  var an,
    rn = {
      kernelName: t.SpaceToBatchND,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.backend,
          r = e.attrs,
          u = n.x,
          i = r.blockShape,
          s = r.paddings,
          o = t.util.sizeFromShape(i),
          d = [[0, 0]];
        d.push.apply(d, v(s));
        for (var l = 1 + i.length; l < u.shape.length; ++l) d.push([0, 0]);
        var p = Nt.kernelFunc({ inputs: { x: u }, backend: a, attrs: { paddings: d, constantValue: 0 } }),
          c = t.backend_util.getReshaped(p.shape, i, o, !1),
          m = t.backend_util.getPermuted(c.length, i.length, !1),
          f = t.backend_util.getReshapedPermuted(p.shape, i, o, !1),
          h = B({ inputs: { x: p }, backend: a, attrs: { shape: c } }),
          b = R({ inputs: { x: h }, backend: a, attrs: { perm: m } }),
          _ = B({ inputs: { x: b }, backend: a, attrs: { shape: f } });
        return a.disposeData(p.dataId), a.disposeData(h.dataId), a.disposeData(b.dataId), _;
      },
    };
  var un,
    sn = {
      kernelName: t.SparseFillEmptyRows,
      backendName: 'wasm',
      setupFunc: function (e) {
        an = e.wasm.cwrap('SparseFillEmptyRows', 'number', [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
        ]);
      },
      kernelFunc: function (e) {
        var n,
          a = e.backend,
          r = e.inputs,
          u = r.indices,
          i = r.values,
          s = r.denseShape,
          d = r.defaultValue,
          l = u.shape[0],
          p = u.shape[1],
          c = a.readSync(s.dataId)[0],
          m = [l + c, p],
          f = a.dataIdMap.get(u.dataId).id,
          h = a.dataIdMap.get(i.dataId).id,
          b = a.dataIdMap.get(d.dataId).id,
          _ = a.makeOutput(m, u.dtype),
          y = a.dataIdMap.get(_.dataId).id,
          g = a.makeOutput(m.slice(0, 1), i.dtype),
          v = a.dataIdMap.get(g.dataId).id,
          w = a.makeOutput([c], 'bool'),
          k = a.dataIdMap.get(w.dataId).id,
          I = a.makeOutput([l], u.dtype),
          S = a.dataIdMap.get(I.dataId).id,
          M = a.makeOutput([4], 'int32'),
          x = a.dataIdMap.get(M.dataId).id,
          A = an(f, h, o[i.dtype], l, c, p, b, y, v, k, S, x),
          F = a.readSync(M.dataId);
        switch (F[0]) {
          case 1:
            n = t.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(F[1]);
            break;
          case 2:
            n = t.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(F[1], F[2]);
            break;
          case 3:
            n = t.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(F[1], F[2], F[3]);
            break;
          default:
            n = '';
        }
        if ((a.disposeData(M.dataId), n))
          throw (a.disposeData(_.dataId), a.disposeData(g.dataId), a.disposeData(w.dataId), a.disposeData(I.dataId), new Error(n));
        var N = _,
          E = g;
        return (
          A !== m[0] &&
            ((N = Q({ inputs: { x: _ }, attrs: { begin: 0, size: [A, p] }, backend: a })),
            (E = Q({ inputs: { x: g }, attrs: { begin: 0, size: A }, backend: a })),
            a.disposeData(_.dataId),
            a.disposeData(g.dataId)),
          [N, E, w, I]
        );
      },
    };
  var on,
    dn = {
      kernelName: t.SparseReshape,
      backendName: 'wasm',
      setupFunc: function (e) {
        un = e.wasm.cwrap(t.SparseReshape, null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = a.inputIndices,
          u = a.inputShape,
          i = a.newShape;
        if (2 !== r.shape.length) throw new Error('Input indices should be a matrix but received shape\n        ' + r.shape);
        if (1 !== u.shape.length) throw new Error('Input shape should be a vector but received shape\n        ' + u.shape);
        if (1 !== i.shape.length) throw new Error('Target shape should be a vector but received shape ' + i.shape);
        var s = n.dataIdMap.get(r.dataId).id,
          o = n.dataIdMap.get(u.dataId).id,
          d = n.dataIdMap.get(i.dataId).id,
          l = r.shape[0],
          p = t.util.sizeFromShape(i.shape),
          c = n.makeOutput([l, p], r.dtype),
          m = n.dataIdMap.get(c.dataId).id,
          f = n.makeOutput([p], i.dtype),
          h = n.dataIdMap.get(f.dataId).id,
          b = n.makeOutput([3], 'int32'),
          _ = n.dataIdMap.get(b.dataId).id;
        un(s, o, d, l, m, h, _);
        var y,
          g = n.readSync(b.dataId);
        switch (g[0]) {
          case 0:
            y = t.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(g[1], g[2]);
            break;
          case 1:
            y = t.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(g[1], g[2]);
            break;
          case 2:
            y = t.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();
            break;
          case 3:
            var v = Array.from(n.readSync(u.dataId)),
              w = Array.from(n.readSync(f.dataId));
            y = t.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(v, w);
            break;
          case 4:
            (v = Array.from(n.readSync(u.dataId))), (w = Array.from(n.readSync(f.dataId)));
            y = t.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(v, w);
            break;
          default:
            y = '';
        }
        if ((n.disposeData(b.dataId), y)) throw (n.disposeData(c.dataId), n.disposeData(f.dataId), new Error(y));
        return [c, f];
      },
    };
  function ln(e) {
    on = e.wasm.cwrap('SparseSegmentReduction', null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  }
  function pn(e, n) {
    var a = e.backend,
      r = e.inputs,
      u = r.data,
      i = r.indices,
      s = r.segmentIds,
      d = i.shape[0],
      l = a.readSync(s.dataId, d - 1, d)[0],
      p = d > 0 ? l + 1 : 0;
    if (p < 0) throw new Error(t.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    var c = u.shape.slice();
    c[0] = p;
    var m = a.dataIdMap.get(u.dataId).id,
      f = a.dataIdMap.get(i.dataId).id,
      h = a.dataIdMap.get(s.dataId).id,
      b = a.makeOutput(c, u.dtype),
      _ = a.dataIdMap.get(b.dataId).id,
      y = a.makeOutput([4], 'int32'),
      g = a.dataIdMap.get(y.dataId).id;
    on(m, o[u.dtype], u.shape[0], f, h, _, g, n, 0);
    var v,
      w = a.readSync(y.dataId);
    switch (w[0]) {
      case 0:
        v = t.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();
        break;
      case 1:
        v = t.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();
        break;
      case 2:
        v = t.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w[1], w[2]);
        break;
      case 3:
        v = t.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w[1], w[2], w[3]);
        break;
      default:
        v = '';
    }
    if ((a.disposeData(y.dataId), v)) throw (a.disposeData(b.dataId), new Error(v));
    return b;
  }
  var cn = {
    kernelName: t.SparseSegmentMean,
    backendName: 'wasm',
    setupFunc: ln,
    kernelFunc: function (e) {
      return pn(e, !0);
    },
  };
  var mn = {
    kernelName: t.SparseSegmentSum,
    backendName: 'wasm',
    setupFunc: ln,
    kernelFunc: function (e) {
      return pn(e, !1);
    },
  };
  var fn,
    hn = {
      kernelName: t.SplitV,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var n = e.inputs,
          a = e.attrs,
          r = e.backend,
          u = n.x,
          i = a.numOrSizeSplits,
          s = a.axis,
          o = t.util.parseAxisParam(s, u.shape)[0],
          d = t.backend_util.prepareSplitSize(u, i, o),
          l = new Array(u.shape.length).fill(0),
          p = u.shape.slice();
        return d.map(function (e) {
          var t = v(p);
          t[o] = e;
          var n = Q({ inputs: { x: u }, attrs: { begin: l, size: t }, backend: r });
          return (l[o] += e), n;
        });
      },
    },
    bn = k(t.Sqrt),
    _n = k(t.Square),
    yn = S(t.SquaredDifference);
  var gn,
    vn = {
      kernelName: t.Step,
      backendName: 'wasm',
      setupFunc: function (e) {
        fn = e.wasm.cwrap(t.Step, null, ['number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var t = e.backend,
          n = e.inputs,
          a = e.attrs.alpha,
          r = n.x,
          u = t.dataIdMap.get(r.dataId).id,
          i = t.makeOutput(r.shape, r.dtype),
          s = t.dataIdMap.get(i.dataId).id;
        return fn(u, a, o[r.dtype], s), i;
      },
    };
  var wn = {
    kernelName: t.StridedSlice,
    backendName: 'wasm',
    setupFunc: function (e) {
      gn = e.wasm.cwrap(t.StridedSlice, null, [
        'number',
        'array',
        'number',
        'array',
        'array',
        'array',
        'array',
        'array',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      var n,
        a = e.backend,
        r = e.inputs,
        u = e.attrs,
        i = r.x,
        s = u.begin,
        o = u.end,
        d = u.strides,
        l = u.beginMask,
        p = u.endMask,
        c = u.ellipsisMask,
        m = u.newAxisMask,
        f = u.shrinkAxisMask,
        h = t.slice_util.sliceInfo(i.shape, s, o, d, l, p, c, m, f),
        b = h.finalShapeSparse,
        _ = h.finalShape,
        y = h.isIdentity,
        g = h.sliceDim0,
        v = h.isSimpleSlice,
        w = h.begin,
        k = h.end,
        I = h.strides;
      if (y) n = B({ inputs: { x: i }, backend: a, attrs: { shape: _ } });
      else if (g || v) {
        t.util.assert(i.shape.length >= 1, function () {
          return 'Input must have rank at least 1, got: ' + i.shape.length;
        });
        var S = t.slice_util.computeOutShape(w, k, I),
          M = Q({ inputs: { x: i }, backend: a, attrs: { begin: w, size: S } });
        (n = B({ inputs: { x: M }, backend: a, attrs: { shape: _ } })), a.disposeData(M.dataId);
      } else {
        var x = a.makeOutput(b, 'float32'),
          A = a.dataIdMap.get(i.dataId).id,
          F = new Uint8Array(new Int32Array(t.util.computeStrides(i.shape)).buffer),
          N = new Uint8Array(new Int32Array(w).buffer),
          E = new Uint8Array(new Int32Array(k).buffer),
          R = new Uint8Array(new Int32Array(I).buffer),
          C = new Uint8Array(new Int32Array(b).buffer),
          D = new Uint8Array(new Int32Array(t.util.computeStrides(b)).buffer),
          T = a.dataIdMap.get(x.dataId).id;
        gn(A, F, i.shape.length, N, E, R, C, D, b.length, T),
          (n = B({ inputs: { x: x }, backend: a, attrs: { shape: _ } })),
          a.disposeData(x.dataId);
      }
      return n;
    },
  };
  var kn = {
    kernelName: t.StringNGrams,
    backendName: 'wasm',
    kernelFunc: function (e) {
      var t = e.backend,
        n = e.inputs,
        a = e.attrs,
        r = n.data,
        u = n.dataSplits,
        i = a.separator,
        s = a.nGramWidths,
        o = a.leftPad,
        d = a.rightPad,
        l = a.padWidth,
        p = a.preserveShortSequences,
        c = g(
          (function (e, t, n, a, r, u, i, s) {
            return new K(n, a, r, u, i, s).compute(e, t);
          })(t.readSync(r.dataId), t.readSync(u.dataId), i, s, o, d, l, p),
          2,
        ),
        m = c[0],
        f = c[1],
        h = t.makeOutput([m.length], 'string');
      t.dataIdMap.get(h.dataId).stringBytes = m;
      var b = t.makeOutput(u.shape, 'int32');
      return t.typedArrayFromHeap(b).set(f), [h, b];
    },
  };
  var In = {
    kernelName: t.StringSplit,
    backendName: 'wasm',
    kernelFunc: function (e) {
      var n = e.backend,
        a = e.inputs,
        r = e.attrs,
        u = a.input,
        i = a.delimiter,
        s = r.skipEmpty,
        o = g(
          (function (e, n, a) {
            for (var r = e.length, u = [], i = 0, s = 0, o = new Array(r), d = 0; d < r; ++d) {
              var l = u.length;
              X(e[d], n, a, u);
              var p = u.length - l;
              (o[d] = p), (i += p), (s = Math.max(s, p));
            }
            var c = t.util.getArrayFromDType('int32', 2 * i),
              m = new Array(i),
              f = [r, s],
              h = 0;
            for (d = 0; d < r; ++d) for (var b = 0; b < o[d]; ++b) (c[2 * h] = d), (c[2 * h + 1] = b), (m[h] = u[h]), ++h;
            return [c, m, f];
          })(n.readSync(u.dataId), n.readSync(i.dataId)[0], s),
          3,
        ),
        d = o[0],
        l = o[1],
        p = o[2],
        c = l.length,
        m = n.makeOutput([c, 2], 'int32');
      n.typedArrayFromHeap(m).set(d);
      var f = n.makeOutput([c], 'string');
      n.dataIdMap.get(f.dataId).stringBytes = l;
      var h = n.makeOutput([2], 'int32');
      return n.typedArrayFromHeap(h).set(p), [m, f, h];
    },
  };
  var Sn,
    Mn = {
      kernelName: t.StringToHashBucketFast,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = a.input,
          i = r.numBuckets,
          s = (function (e, n) {
            for (var a = t.util.getArrayFromDType('int32', e.length), r = 0; r < e.length; ++r)
              a[r] = t.util.fingerPrint64(e[r]).modulo(n).getLowBitsUnsigned();
            return a;
          })(n.readSync(u.dataId), i),
          o = n.makeOutput(u.shape, 'int32');
        return n.typedArrayFromHeap(o).set(s), o;
      },
    },
    xn = S(t.Sub);
  var An,
    Fn = {
      kernelName: t.Sum,
      backendName: 'wasm',
      setupFunc: function (e) {
        Sn = e.wasm.cwrap(t.Sum, null, ['number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var n = e.backend,
          a = e.inputs,
          r = e.attrs,
          u = r.axis,
          i = r.keepDims,
          s = a.x,
          d = n.dataIdMap.get(s.dataId).id,
          l = d,
          p = s,
          c = T(s, u, n),
          m = c.transposed,
          f = c.axes,
          h = c.originalAxes,
          b = c.inputWasTransposed,
          _ = f;
        if (b) {
          var y = n.dataIdMap.get(m.dataId).id;
          y !== d && ((p = m), (l = y), (_ = t.backend_util.getInnerMostAxes(_.length, p.shape.length)));
        }
        t.backend_util.assertAxesAreInnerMostDims('sum', _, p.shape.length);
        var v = g(t.backend_util.computeOutAndReduceShapes(p.shape, _), 2),
          w = v[0],
          k = v[1],
          I = t.util.sizeFromShape(k),
          S = n.makeOutput(w, p.dtype);
        if (0 !== t.util.sizeFromShape(p.shape)) {
          var M = n.dataIdMap.get(S.dataId).id;
          Sn(l, I, o[S.dtype], M);
        }
        if ((b && n.disposeData(m.dataId), i)) {
          var x = t.backend_util.expandShapeToKeepDim(S.shape, h);
          S.shape = x;
        }
        return S;
      },
    },
    Nn = k(t.Tan),
    En = k(t.Tanh);
  var Rn,
    Cn = {
      kernelName: t.Tile,
      backendName: 'wasm',
      setupFunc: function (e) {
        An = e.wasm.cwrap(t.Tile, null, ['number', 'array', 'number', 'array', 'number', 'number']);
      },
      kernelFunc: function (e) {
        for (
          var t = e.inputs,
            n = e.backend,
            a = e.attrs,
            r = t.x,
            u = n.dataIdMap.get(r.dataId).id,
            i = a.reps,
            s = new Array(r.shape.length),
            d = 0;
          d < s.length;
          d++
        )
          s[d] = r.shape[d] * i[d];
        var l = new Uint8Array(new Int32Array(r.shape).buffer),
          p = new Uint8Array(new Int32Array(s).buffer),
          c = n.makeOutput(s, r.dtype),
          m = n.dataIdMap.get(c.dataId).id;
        return An(u, l, r.shape.length, p, s.length, o[c.dtype], m), c;
      },
    };
  var Dn,
    Tn = {
      kernelName: t.TopK,
      backendName: 'wasm',
      setupFunc: function (e) {
        Rn = e.wasm.cwrap(t.TopK, null, ['number', 'array', 'number', 'number', 'number', 'bool', 'number', 'number']);
      },
      kernelFunc: function (e) {
        var t = e.inputs,
          n = e.backend,
          a = e.attrs,
          r = t.x,
          u = a.k,
          i = a.sorted,
          s = n.dataIdMap.get(r.dataId).id,
          d = new Uint8Array(new Int32Array(r.shape).buffer),
          l = r.shape.slice();
        l[l.length - 1] = u;
        var p = n.makeOutput(l, r.dtype),
          c = n.dataIdMap.get(p.dataId).id,
          m = n.makeOutput(l, 'int32'),
          f = n.dataIdMap.get(m.dataId).id;
        return Rn(s, d, r.shape.length, o[r.dtype], u, i, c, f), [p, m];
      },
    };
  var On = {
    kernelName: t.Transform,
    backendName: 'wasm',
    setupFunc: function (e) {
      Dn = e.wasm.cwrap(t.Transform, null, [
        'number',
        'number',
        'bool',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'array',
        'number',
        'array',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      var n,
        a = e.backend,
        r = e.inputs,
        u = e.attrs,
        i = r.image,
        s = r.transforms,
        o = u.interpolation,
        d = u.fillMode,
        l = u.fillValue,
        p = u.outputShape,
        c = g(i.shape, 4),
        m = c[0],
        f = c[1],
        h = c[2],
        b = c[3],
        _ = g(null != p ? p : [f, h], 2),
        y = _[0],
        v = _[1],
        w = [m, y, v, b],
        k = new Uint8Array(new Int32Array(t.util.computeStrides(i.shape)).buffer),
        I = new Uint8Array(new Int32Array(t.util.computeStrides(w)).buffer),
        S = a.makeOutput(w, i.dtype),
        M = a.dataIdMap.get(S.dataId).id,
        x = a.dataIdMap.get(i.dataId).id,
        A = a.dataIdMap.get(s.dataId).id,
        F = 'nearest' === o ? 1 : 2;
      switch (d) {
        case 'constant':
        default:
          n = 1;
          break;
        case 'reflect':
          n = 2;
          break;
        case 'wrap':
          n = 3;
          break;
        case 'nearest':
          n = 4;
      }
      return Dn(x, A, s.shape[0] > 1, m, y, v, b, h, f, k, i.shape.length - 1, I, w.length - 1, F, n, l, M), S;
    },
  };
  var Pn = {
    kernelName: t.Unpack,
    backendName: 'wasm',
    kernelFunc: function (e) {
      var t = e.inputs,
        n = e.backend,
        a = e.attrs,
        r = t.value,
        u = a.axis;
      u < 0 && (u += r.shape.length);
      for (var i = r.shape[u], s = r.shape.length, o = new Array(s - 1), d = 0, l = 0; l < s; l++) l !== u && (o[d++] = r.shape[l]);
      var p = new Array(i),
        c = new Array(s).fill(0),
        m = r.shape.slice();
      for (m[u] = 1, l = 0; l < p.length; l++) (c[u] = l), (p[l] = Q({ inputs: { x: r }, attrs: { begin: c, size: m }, backend: n }));
      return p.map(function (e) {
        return { dataId: e.dataId, dtype: e.dtype, shape: o };
      });
    },
  };
  var Wn,
    Ln,
    zn = {
      kernelName: t.ZerosLike,
      backendName: 'wasm',
      kernelFunc: function (e) {
        var t = e.inputs.x,
          n = e.backend,
          a = n.makeOutput(t.shape, t.dtype);
        return n.typedArrayFromHeap(a).fill(0), a;
      },
    },
    jn = [
      w,
      I,
      x,
      A,
      P,
      L,
      j,
      H,
      V,
      Y,
      ee,
      te,
      ne,
      ue,
      se,
      le,
      pe,
      ce,
      fe,
      be,
      ye,
      ve,
      we,
      ke,
      Ie,
      Se,
      xe,
      Ne,
      Re,
      Ce,
      De,
      Oe,
      We,
      ze,
      He,
      Ue,
      qe,
      Ve,
      E,
      Ke,
      Xe,
      Qe,
      Ze,
      Ye,
      $e,
      Je,
      et,
      nt,
      at,
      ut,
      st,
      lt,
      pt,
      mt,
      ft,
      ht,
      yt,
      vt,
      kt,
      It,
      St,
      Mt,
      At,
      Nt,
      Et,
      Ct,
      Tt,
      Ot,
      Pt,
      Wt,
      Lt,
      q,
      jt,
      Bt,
      qt,
      Gt,
      Kt,
      Xt,
      Zt,
      $t,
      en,
      tn,
      Z,
      nn,
      rn,
      sn,
      dn,
      cn,
      mn,
      hn,
      bn,
      _n,
      yn,
      vn,
      wn,
      kn,
      In,
      Mn,
      xn,
      Fn,
      Nn,
      En,
      Cn,
      Tn,
      On,
      D,
      Pn,
      zn,
    ];
  try {
    for (
      var Hn = (function (e) {
          var t = 'function' == typeof Symbol && Symbol.iterator,
            n = t && e[t],
            a = 0;
          if (n) return n.call(e);
          if (e && 'number' == typeof e.length)
            return {
              next: function () {
                return e && a >= e.length && (e = void 0), { value: e && e[a++], done: !e };
              },
            };
          throw new TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
        })(jn),
        Bn = Hn.next();
      !Bn.done;
      Bn = Hn.next()
    ) {
      var Un = Bn.value;
      t.registerKernel(Un);
    }
  } catch (e) {
    Wn = { error: e };
  } finally {
    try {
      Bn && !Bn.done && (Ln = Hn.return) && Ln.call(Hn);
    } finally {
      if (Wn) throw Wn.error;
    }
  }
  var qn = void 0,
    Vn = t.env();
  Vn.registerFlag('WASM_HAS_SIMD_SUPPORT', function () {
    return _(qn, void 0, void 0, function () {
      return y(this, function (e) {
        return [
          2,
          WebAssembly.validate(
            new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]),
          ),
        ];
      });
    });
  }),
    Vn.registerFlag('WASM_HAS_MULTITHREAD_SUPPORT', function () {
      return _(qn, void 0, void 0, function () {
        return y(this, function (e) {
          if (Vn.get('IS_NODE')) return [2, !1];
          try {
            return (
              new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),
              [
                2,
                WebAssembly.validate(
                  new Uint8Array([
                    0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26,
                    11,
                  ]),
                ),
              ]
            );
          } catch (e) {
            return [2, !1];
          }
          return [2];
        });
      });
    });
  var Gn =
    'undefined' != typeof globalThis
      ? globalThis
      : 'undefined' != typeof window
      ? window
      : 'undefined' != typeof global
      ? global
      : 'undefined' != typeof self
      ? self
      : {};
  function Kn(e) {
    var t = { exports: {} };
    return e(t, t.exports), t.exports;
  }
  var Xn = Kn(function (e, t) {
      var n,
        a =
          ((n = 'undefined' != typeof document && document.currentScript ? document.currentScript.src : void 0),
          'undefined' != typeof __filename && (n = n || __filename),
          function (e) {
            function t() {
              return P.buffer != q && J(P.buffer), V;
            }
            function a() {
              return P.buffer != q && J(P.buffer), G;
            }
            function r() {
              return P.buffer != q && J(P.buffer), K;
            }
            function u() {
              return P.buffer != q && J(P.buffer), X;
            }
            var i,
              s,
              o,
              d = 'undefined' != typeof (e = e || {}) ? e : {};
            (d.ready = new Promise(function (e, t) {
              (i = e), (s = t);
            })),
              'undefined' != typeof process &&
                process.listeners &&
                (o = {
                  uncaughtException: process.listeners('uncaughtException'),
                  unhandledRejection: process.listeners('unhandledRejection'),
                });
            var l,
              b,
              _,
              y,
              g,
              v,
              w = Object.assign({}, d),
              k = function (e, t) {
                throw t;
              },
              I = 'object' == typeof window,
              S = 'function' == typeof importScripts,
              M = 'object' == typeof process && 'object' == typeof process.versions && 'string' == typeof process.versions.node,
              x = d.ENVIRONMENT_IS_PTHREAD || !1,
              A = '';
            function F(e) {
              return d.locateFile ? d.locateFile(e, A) : A + e;
            }
            if (M) {
              (A = S ? p.default.dirname(A) + '/' : __dirname + '/'),
                (v = function () {
                  g || ((y = c.default), (g = p.default));
                }),
                (l = function (e, t) {
                  return v(), (e = g.normalize(e)), y.readFileSync(e, t ? void 0 : 'utf8');
                }),
                (_ = function (e) {
                  var t = l(e, !0);
                  return t.buffer || (t = new Uint8Array(t)), t;
                }),
                (b = function (e, t, n) {
                  v(),
                    (e = g.normalize(e)),
                    y.readFile(e, function (e, a) {
                      e ? n(e) : t(a.buffer);
                    });
                }),
                process.argv.length > 1 && process.argv[1].replace(/\\/g, '/'),
                process.argv.slice(2),
                process.on('uncaughtException', function (e) {
                  if (!(e instanceof lt)) throw e;
                }),
                process.on('unhandledRejection', function (e) {
                  throw e;
                }),
                (k = function (e, t) {
                  if (ue()) throw ((process.exitCode = e), t);
                  var n;
                  (n = t) instanceof lt || T('exiting due to exception: ' + n), process.exit(e);
                }),
                (d.inspect = function () {
                  return '[Emscripten Module object]';
                });
              var N = void 0;
              try {
                N = m.default;
              } catch (e) {
                throw (
                  (console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),
                  e)
                );
              }
              Gn.Worker = N.Worker;
            } else
              (I || S) &&
                (S
                  ? (A = self.location.href)
                  : 'undefined' != typeof document && document.currentScript && (A = document.currentScript.src),
                'undefined' != typeof n && n && (A = n),
                (A = 0 !== A.indexOf('blob:') ? A.substr(0, A.replace(/[?#].*/, '').lastIndexOf('/') + 1) : ''),
                M ||
                  ((l = function (e) {
                    var t = new XMLHttpRequest();
                    return t.open('GET', e, !1), t.send(null), t.responseText;
                  }),
                  S &&
                    (_ = function (e) {
                      var t = new XMLHttpRequest();
                      return t.open('GET', e, !1), (t.responseType = 'arraybuffer'), t.send(null), new Uint8Array(t.response);
                    }),
                  (b = function (e, t, n) {
                    var a = new XMLHttpRequest();
                    a.open('GET', e, !0),
                      (a.responseType = 'arraybuffer'),
                      (a.onload = function () {
                        200 == a.status || (0 == a.status && a.response) ? t(a.response) : n();
                      }),
                      (a.onerror = n),
                      a.send(null);
                  })));
            M && 'undefined' == typeof performance && (Gn.performance = f.default.performance);
            var E = console.log.bind(console),
              R = console.warn.bind(console);
            M &&
              (v(),
              (E = function (e) {
                return y.writeSync(1, e + '\n');
              }),
              (R = function (e) {
                return y.writeSync(2, e + '\n');
              }));
            var C,
              D = d.print || E,
              T = d.printErr || R;
            function O(e) {
              O.shown || (O.shown = {}), O.shown[e] || ((O.shown[e] = 1), T(e));
            }
            Object.assign(d, w), (w = null), d.arguments, d.thisProgram, d.quit && (k = d.quit), d.wasmBinary && (C = d.wasmBinary);
            var P,
              W,
              L = d.noExitRuntime || !0;
            'object' != typeof WebAssembly && le('no native wasm support detected');
            var z,
              j = !1;
            function H(e) {
              return d['_' + e];
            }
            function B(e, n, a, r, u) {
              var i = {
                  string: function (e) {
                    var t = 0;
                    if (null != e && 0 !== e) {
                      var n = 1 + (e.length << 2);
                      $(e, (t = ut(n)), n);
                    }
                    return t;
                  },
                  array: function (e) {
                    var n = ut(e.length);
                    return (
                      (function (e, n) {
                        t().set(e, n);
                      })(e, n),
                      n
                    );
                  },
                },
                s = H(e),
                o = [],
                d = 0;
              if (r)
                for (var l = 0; l < r.length; l++) {
                  var p = i[a[l]];
                  p ? (0 === d && (d = at()), (o[l] = p(r[l]))) : (o[l] = r[l]);
                }
              var c = s.apply(null, o);
              return (c = (function (e) {
                return (
                  0 !== d && rt(d),
                  (function (e) {
                    return 'string' === n ? Y(e) : 'boolean' === n ? Boolean(e) : e;
                  })(e)
                );
              })(c));
            }
            function U(e) {
              var t = new TextDecoder(e);
              this.decode = function (e) {
                return e.buffer instanceof SharedArrayBuffer && (e = new Uint8Array(e)), t.decode.call(t, e);
              };
            }
            var q,
              V,
              G,
              K,
              X,
              Q = 'undefined' != typeof TextDecoder ? new U('utf8') : void 0;
            function Z(e, t, n) {
              for (var a = t + n, r = t; e[r] && !(r >= a); ) ++r;
              if (r - t > 16 && e.subarray && Q) return Q.decode(e.subarray(t, r));
              for (var u = ''; t < r; ) {
                var i = e[t++];
                if (128 & i) {
                  var s = 63 & e[t++];
                  if (192 != (224 & i)) {
                    var o = 63 & e[t++];
                    if (
                      (i = 224 == (240 & i) ? ((15 & i) << 12) | (s << 6) | o : ((7 & i) << 18) | (s << 12) | (o << 6) | (63 & e[t++])) <
                      65536
                    )
                      u += String.fromCharCode(i);
                    else {
                      var d = i - 65536;
                      u += String.fromCharCode(55296 | (d >> 10), 56320 | (1023 & d));
                    }
                  } else u += String.fromCharCode(((31 & i) << 6) | s);
                } else u += String.fromCharCode(i);
              }
              return u;
            }
            function Y(e, t) {
              return e ? Z(a(), e, t) : '';
            }
            function $(e, t, n) {
              return (function (e, t, n, a) {
                if (!(a > 0)) return 0;
                for (var r = n, u = n + a - 1, i = 0; i < e.length; ++i) {
                  var s = e.charCodeAt(i);
                  if ((s >= 55296 && s <= 57343 && (s = (65536 + ((1023 & s) << 10)) | (1023 & e.charCodeAt(++i))), s <= 127)) {
                    if (n >= u) break;
                    t[n++] = s;
                  } else if (s <= 2047) {
                    if (n + 1 >= u) break;
                    (t[n++] = 192 | (s >> 6)), (t[n++] = 128 | (63 & s));
                  } else if (s <= 65535) {
                    if (n + 2 >= u) break;
                    (t[n++] = 224 | (s >> 12)), (t[n++] = 128 | ((s >> 6) & 63)), (t[n++] = 128 | (63 & s));
                  } else {
                    if (n + 3 >= u) break;
                    (t[n++] = 240 | (s >> 18)),
                      (t[n++] = 128 | ((s >> 12) & 63)),
                      (t[n++] = 128 | ((s >> 6) & 63)),
                      (t[n++] = 128 | (63 & s));
                  }
                }
                return (t[n] = 0), n - r;
              })(e, a(), t, n);
            }
            function J(e) {
              (q = e),
                (d.HEAP8 = V = new Int8Array(e)),
                (d.HEAP16 = new Int16Array(e)),
                (d.HEAP32 = K = new Int32Array(e)),
                (d.HEAPU8 = G = new Uint8Array(e)),
                (d.HEAPU16 = new Uint16Array(e)),
                (d.HEAPU32 = new Uint32Array(e)),
                (d.HEAPF32 = new Float32Array(e)),
                (d.HEAPF64 = X = new Float64Array(e));
            }
            'undefined' != typeof TextDecoder && new U('utf-16le'), x && (q = d.buffer);
            var ee,
              te = d.INITIAL_MEMORY || 16777216;
            if (x) (P = d.wasmMemory), (q = d.buffer);
            else if (d.wasmMemory) P = d.wasmMemory;
            else if (
              !((P = new WebAssembly.Memory({ initial: te / 65536, maximum: 32768, shared: !0 })).buffer instanceof SharedArrayBuffer)
            )
              throw (
                (T(
                  'requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag',
                ),
                M &&
                  console.log(
                    '(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)',
                  ),
                Error('bad memory'))
              );
            P && (q = P.buffer), (te = q.byteLength), J(q);
            var ne = [],
              ae = [],
              re = [];
            function ue() {
              return L || !1;
            }
            function ie() {
              x || he(ae);
            }
            var se,
              oe = 0,
              de = null;
            function le(e) {
              x ? postMessage({ cmd: 'onAbort', arg: e }) : d.onAbort && d.onAbort(e),
                T((e = 'Aborted(' + e + ')')),
                (j = !0),
                (z = 1),
                (e += '. Build with -s ASSERTIONS=1 for more info.');
              var t = new WebAssembly.RuntimeError(e);
              throw (s(t), t);
            }
            function pe(e) {
              return e.startsWith('data:application/octet-stream;base64,');
            }
            function ce(e) {
              return e.startsWith('file://');
            }
            function me(e) {
              try {
                if (e == se && C) return new Uint8Array(C);
                if (_) return _(e);
                throw 'both async and sync fetching of the wasm failed';
              } catch (e) {
                le(e);
              }
            }
            (d.preloadedImages = {}), (d.preloadedAudios = {}), pe((se = 'tfjs-backend-wasm-threaded-simd.wasm')) || (se = F(se));
            var fe = {};
            function he(e) {
              for (; e.length > 0; ) {
                var t = e.shift();
                if ('function' != typeof t) {
                  var n = t.func;
                  'number' == typeof n ? (void 0 === t.arg ? Ie(n)() : Ie(n)(t.arg)) : n(void 0 === t.arg ? null : t.arg);
                } else t(d);
              }
            }
            function be(e) {
              var t = at(),
                n = e();
              return rt(t), n;
            }
            function _e(e) {
              var t = ge.pthreads[e];
              if (t) {
                r()[e >> 2] = 0;
                var n = t.worker;
                ge.returnWorkerToPool(n);
              }
            }
            function ye(e) {
              !(function (e, t) {
                if (((z = e), !t && x)) throw (ve(e), 'unwind');
                var n;
                ue() || x || ge.terminateAllThreads(),
                  (z = n = e),
                  ue() || (ge.terminateAllThreads(), d.onExit && d.onExit(n), (j = !0)),
                  k(n, new lt(n));
              })(e);
            }
            var ge = {
              unusedWorkers: [],
              runningWorkers: [],
              tlsInitFunctions: [],
              init: function () {
                x ? ge.initWorker() : ge.initMainThread();
              },
              initMainThread: function () {
                for (var e = 0; e < 8; ++e) ge.allocateUnusedWorker();
              },
              initWorker: function () {
                L = !1;
              },
              pthreads: {},
              setExitStatus: function (e) {
                z = e;
              },
              terminateAllThreads: function () {
                for (var e in ge.pthreads) {
                  var t = ge.pthreads[e];
                  t && t.worker && ge.returnWorkerToPool(t.worker);
                }
                for (var n = 0; n < ge.unusedWorkers.length; ++n) ge.unusedWorkers[n].terminate();
                ge.unusedWorkers = [];
              },
              returnWorkerToPool: function (e) {
                ge.runWithoutMainThreadQueuedCalls(function () {
                  delete ge.pthreads[e.pthread.threadInfoStruct],
                    ge.unusedWorkers.push(e),
                    ge.runningWorkers.splice(ge.runningWorkers.indexOf(e), 1),
                    tt(e.pthread.threadInfoStruct),
                    (e.pthread = void 0);
                });
              },
              runWithoutMainThreadQueuedCalls: function (e) {
                r()[dt >> 2] = 0;
                try {
                  e();
                } finally {
                  r()[dt >> 2] = 1;
                }
              },
              receiveObjectTransfer: function (e) {},
              threadInit: function () {
                for (var e in ge.tlsInitFunctions) ge.tlsInitFunctions[e]();
              },
              loadWasmModuleToWorker: function (e, t) {
                (e.onmessage = function (n) {
                  var a,
                    u = n.data,
                    i = u.cmd;
                  if (
                    (e.pthread && (ge.currentProxiedOperationCallerThread = e.pthread.threadInfoStruct),
                    u.targetThread && u.targetThread != Qe())
                  ) {
                    var s = ge.pthreads[u.targetThread];
                    return (
                      s
                        ? s.worker.postMessage(u, u.transferList)
                        : T(
                            'Internal error! Worker sent a message "' +
                              i +
                              '" to target pthread ' +
                              u.targetThread +
                              ', but that thread no longer exists!',
                          ),
                      void (ge.currentProxiedOperationCallerThread = void 0)
                    );
                  }
                  'processQueuedMainThreadWork' === i
                    ? Ze()
                    : 'spawnThread' === i
                    ? Me(u)
                    : 'cleanupThread' === i
                    ? _e(u.thread)
                    : 'killThread' === i
                    ? (function (e) {
                        r()[e >> 2] = 0;
                        var t = ge.pthreads[e];
                        delete ge.pthreads[e],
                          t.worker.terminate(),
                          tt(e),
                          ge.runningWorkers.splice(ge.runningWorkers.indexOf(t.worker), 1),
                          (t.worker.pthread = void 0);
                      })(u.thread)
                    : 'cancelThread' === i
                    ? ((a = u.thread), ge.pthreads[a].worker.postMessage({ cmd: 'cancel' }))
                    : 'loaded' === i
                    ? ((e.loaded = !0), t && t(e), e.runPthread && (e.runPthread(), delete e.runPthread))
                    : 'print' === i
                    ? D('Thread ' + u.threadId + ': ' + u.text)
                    : 'printErr' === i
                    ? T('Thread ' + u.threadId + ': ' + u.text)
                    : 'alert' === i
                    ? alert('Thread ' + u.threadId + ': ' + u.text)
                    : 'setimmediate' === u.target
                    ? e.postMessage(u)
                    : 'onAbort' === i
                    ? d.onAbort && d.onAbort(u.arg)
                    : T('worker sent an unknown command ' + i),
                    (ge.currentProxiedOperationCallerThread = void 0);
                }),
                  (e.onerror = function (e) {
                    throw (T('worker sent an error! ' + e.filename + ':' + e.lineno + ': ' + e.message), e);
                  }),
                  M &&
                    (e.on('message', function (t) {
                      e.onmessage({ data: t });
                    }),
                    e.on('error', function (t) {
                      e.onerror(t);
                    }),
                    e.on('detachedExit', function () {})),
                  e.postMessage({ cmd: 'load', urlOrBlob: d.mainScriptUrlOrBlob || n, wasmMemory: P, wasmModule: W });
              },
              allocateUnusedWorker: function () {
                var e = F('tfjs-backend-wasm-threaded-simd.worker.js');
                ge.unusedWorkers.push(new Worker(e));
              },
              getNewWorker: function () {
                return (
                  0 == ge.unusedWorkers.length && (ge.allocateUnusedWorker(), ge.loadWasmModuleToWorker(ge.unusedWorkers[0])),
                  ge.unusedWorkers.pop()
                );
              },
            };
            function ve(e) {
              if (x) return Ae(1, 0, e);
              try {
                ye(e);
              } catch (e) {
                !(function (e) {
                  if (e instanceof lt || 'unwind' == e) return z;
                  k(1, e);
                })(e);
              }
            }
            d.establishStackSpace = function () {
              var e = Qe(),
                t = r()[(e + 44) >> 2],
                n = r()[(e + 48) >> 2];
              nt(t, t - n), rt(t);
            };
            var we,
              ke = [];
            function Ie(e) {
              var t = ke[e];
              return t || (e >= ke.length && (ke.length = e + 1), (ke[e] = t = ee.get(e))), t;
            }
            function Se(e, t) {
              var n, a;
              if (0 === e) n = Date.now();
              else {
                if (1 !== e && 4 !== e) return (a = 28), (r()[Xe() >> 2] = a), -1;
                n = we();
              }
              return (r()[t >> 2] = (n / 1e3) | 0), (r()[(t + 4) >> 2] = ((n % 1e3) * 1e3 * 1e3) | 0), 0;
            }
            function Me(e) {
              var t = ge.getNewWorker();
              if (!t) return 6;
              ge.runningWorkers.push(t);
              var n = (ge.pthreads[e.pthread_ptr] = { worker: t, threadInfoStruct: e.pthread_ptr });
              t.pthread = n;
              var a = { cmd: 'run', start_routine: e.startRoutine, arg: e.arg, threadInfoStruct: e.pthread_ptr };
              return (
                (t.runPthread = function () {
                  (a.time = performance.now()), t.postMessage(a, e.transferList);
                }),
                t.loaded && (t.runPthread(), delete t.runPthread),
                0
              );
            }
            function xe() {
              return 2147483648;
            }
            function Ae(e, t) {
              var n = arguments.length - 2,
                a = arguments;
              return be(function () {
                for (var r = n, i = ut(8 * r), s = i >> 3, o = 0; o < n; o++) {
                  var d = a[2 + o];
                  u()[s + o] = d;
                }
                return Je(e, r, i, t);
              });
            }
            (d.invokeEntryPoint = function (e, t) {
              return Ie(e)(t);
            }),
              (we = M
                ? function () {
                    var e = process.hrtime();
                    return 1e3 * e[0] + e[1] / 1e6;
                  }
                : x
                ? function () {
                    return performance.now() - d.__performance_now_clock_drift;
                  }
                : function () {
                    return performance.now();
                  });
            var Fe = [];
            function Ne(e) {
              try {
                return P.grow((e - q.byteLength + 65535) >>> 16), J(P.buffer), 1;
              } catch (e) {}
            }
            var Ee = {
              inEventHandler: 0,
              removeAllEventListeners: function () {
                for (var e = Ee.eventHandlers.length - 1; e >= 0; --e) Ee._removeHandler(e);
                (Ee.eventHandlers = []), (Ee.deferredCalls = []);
              },
              registerRemoveEventListeners: function () {
                Ee.removeEventListenersRegistered || (Ee.removeEventListenersRegistered = !0);
              },
              deferredCalls: [],
              deferCall: function (e, t, n) {
                function a(e, t) {
                  if (e.length != t.length) return !1;
                  for (var n in e) if (e[n] != t[n]) return !1;
                  return !0;
                }
                for (var r in Ee.deferredCalls) {
                  var u = Ee.deferredCalls[r];
                  if (u.targetFunction == e && a(u.argsList, n)) return;
                }
                Ee.deferredCalls.push({ targetFunction: e, precedence: t, argsList: n }),
                  Ee.deferredCalls.sort(function (e, t) {
                    return e.precedence < t.precedence;
                  });
              },
              removeDeferredCalls: function (e) {
                for (var t = 0; t < Ee.deferredCalls.length; ++t)
                  Ee.deferredCalls[t].targetFunction == e && (Ee.deferredCalls.splice(t, 1), --t);
              },
              canPerformEventHandlerRequests: function () {
                return Ee.inEventHandler && Ee.currentEventHandler.allowsDeferredCalls;
              },
              runDeferredCalls: function () {
                if (Ee.canPerformEventHandlerRequests())
                  for (var e = 0; e < Ee.deferredCalls.length; ++e) {
                    var t = Ee.deferredCalls[e];
                    Ee.deferredCalls.splice(e, 1), --e, t.targetFunction.apply(null, t.argsList);
                  }
              },
              eventHandlers: [],
              removeAllHandlersOnTarget: function (e, t) {
                for (var n = 0; n < Ee.eventHandlers.length; ++n)
                  Ee.eventHandlers[n].target != e || (t && t != Ee.eventHandlers[n].eventTypeString) || Ee._removeHandler(n--);
              },
              _removeHandler: function (e) {
                var t = Ee.eventHandlers[e];
                t.target.removeEventListener(t.eventTypeString, t.eventListenerFunc, t.useCapture), Ee.eventHandlers.splice(e, 1);
              },
              registerOrRemoveHandler: function (e) {
                var t = function (t) {
                  ++Ee.inEventHandler,
                    (Ee.currentEventHandler = e),
                    Ee.runDeferredCalls(),
                    e.handlerFunc(t),
                    Ee.runDeferredCalls(),
                    --Ee.inEventHandler;
                };
                if (e.callbackfunc)
                  (e.eventListenerFunc = t),
                    e.target.addEventListener(e.eventTypeString, t, e.useCapture),
                    Ee.eventHandlers.push(e),
                    Ee.registerRemoveEventListeners();
                else
                  for (var n = 0; n < Ee.eventHandlers.length; ++n)
                    Ee.eventHandlers[n].target == e.target &&
                      Ee.eventHandlers[n].eventTypeString == e.eventTypeString &&
                      Ee._removeHandler(n--);
              },
              queueEventHandlerOnThread_iiii: function (e, t, n, a, u) {
                be(function () {
                  var i = ut(12);
                  (r()[i >> 2] = n), (r()[(i + 4) >> 2] = a), (r()[(i + 8) >> 2] = u), et(e, 637534208, t, a, i);
                });
              },
              getTargetThreadForEventCallback: function (e) {
                switch (e) {
                  case 1:
                    return 0;
                  case 2:
                    return ge.currentProxiedOperationCallerThread;
                  default:
                    return e;
                }
              },
              getNodeNameForTarget: function (e) {
                return e ? (e == window ? '#window' : e == screen ? '#screen' : e && e.nodeName ? e.nodeName : '') : '';
              },
              fullscreenEnabled: function () {
                return document.fullscreenEnabled || document.webkitFullscreenEnabled;
              },
            };
            function Re(e, t, n, a) {
              be(function () {
                var u,
                  i,
                  s,
                  o = ut(12),
                  d = 0;
                t &&
                  ((i =
                    (function (e) {
                      for (var t = 0, n = 0; n < e.length; ++n) {
                        var a = e.charCodeAt(n);
                        a >= 55296 && a <= 57343 && (a = (65536 + ((1023 & a) << 10)) | (1023 & e.charCodeAt(++n))),
                          a <= 127 ? ++t : (t += a <= 2047 ? 2 : a <= 65535 ? 3 : 4);
                      }
                      return t;
                    })((u = t)) + 1),
                  (s = Ge(i)),
                  $(u, s, i),
                  (d = s)),
                  (r()[o >> 2] = d),
                  (r()[(o + 4) >> 2] = n),
                  (r()[(o + 8) >> 2] = a),
                  et(e, 657457152, 0, d, o);
              });
            }
            var Ce = [0, 'undefined' != typeof document ? document : 0, 'undefined' != typeof window ? window : 0];
            function De(e) {
              var t;
              return (e = (t = e) > 2 ? Y(t) : t), Ce[e] || ('undefined' != typeof document ? document.querySelector(e) : void 0);
            }
            function Te(e) {
              return De(e);
            }
            function Oe(e, t, n) {
              var a = Te(e);
              if (!a) return -4;
              if (
                (a.canvasSharedPtr && ((r()[a.canvasSharedPtr >> 2] = t), (r()[(a.canvasSharedPtr + 4) >> 2] = n)),
                !a.offscreenCanvas && a.controlTransferredOffscreen)
              )
                return a.canvasSharedPtr
                  ? ((function (e, t, n, a) {
                      Re(e, (t = t ? Y(t) : ''), n, a);
                    })(r()[(a.canvasSharedPtr + 8) >> 2], e, t, n),
                    1)
                  : -4;
              a.offscreenCanvas && (a = a.offscreenCanvas);
              var u = !1;
              if (a.GLctxObject && a.GLctxObject.GLctx) {
                var i = a.GLctxObject.GLctx.getParameter(2978);
                u = 0 === i[0] && 0 === i[1] && i[2] === a.width && i[3] === a.height;
              }
              return (a.width = t), (a.height = n), u && a.GLctxObject.GLctx.viewport(0, 0, t, n), 0;
            }
            function Pe(e, t, n) {
              return x ? Ae(2, 1, e, t, n) : Oe(e, t, n);
            }
            var We,
              Le = {
                counter: 1,
                buffers: [],
                programs: [],
                framebuffers: [],
                renderbuffers: [],
                textures: [],
                shaders: [],
                vaos: [],
                contexts: {},
                offscreenCanvases: {},
                queries: [],
                stringCache: {},
                unpackAlignment: 4,
                recordError: function (e) {
                  Le.lastError || (Le.lastError = e);
                },
                getNewId: function (e) {
                  for (var t = Le.counter++, n = e.length; n < t; n++) e[n] = null;
                  return t;
                },
                getSource: function (e, t, n, a) {
                  for (var u = '', i = 0; i < t; ++i) {
                    var s = a ? r()[(a + 4 * i) >> 2] : -1;
                    u += Y(r()[(n + 4 * i) >> 2], s < 0 ? void 0 : s);
                  }
                  return u;
                },
                createContext: function (e, t) {
                  e.getContextSafariWebGL2Fixed ||
                    ((e.getContextSafariWebGL2Fixed = e.getContext),
                    (e.getContext = function (t, n) {
                      var a = e.getContextSafariWebGL2Fixed(t, n);
                      return ('webgl' == t) == a instanceof WebGLRenderingContext ? a : null;
                    }));
                  var n = e.getContext('webgl', t);
                  return n ? Le.registerContext(n, t) : 0;
                },
                registerContext: function (e, t) {
                  var n = Ge(8);
                  r()[(n + 4) >> 2] = Qe();
                  var a = { handle: n, attributes: t, version: t.majorVersion, GLctx: e };
                  return (
                    e.canvas && (e.canvas.GLctxObject = a),
                    (Le.contexts[n] = a),
                    ('undefined' == typeof t.enableExtensionsByDefault || t.enableExtensionsByDefault) && Le.initExtensions(a),
                    n
                  );
                },
                makeContextCurrent: function (e) {
                  return (Le.currentContext = Le.contexts[e]), (d.ctx = We = Le.currentContext && Le.currentContext.GLctx), !(e && !We);
                },
                getContext: function (e) {
                  return Le.contexts[e];
                },
                deleteContext: function (e) {
                  Le.currentContext === Le.contexts[e] && (Le.currentContext = null),
                    'object' == typeof Ee && Ee.removeAllHandlersOnTarget(Le.contexts[e].GLctx.canvas),
                    Le.contexts[e] && Le.contexts[e].GLctx.canvas && (Le.contexts[e].GLctx.canvas.GLctxObject = void 0),
                    Ke(Le.contexts[e].handle),
                    (Le.contexts[e] = null);
                },
                initExtensions: function (e) {
                  if ((e || (e = Le.currentContext), !e.initExtensionsDone)) {
                    e.initExtensionsDone = !0;
                    var t,
                      n = e.GLctx;
                    !(function (e) {
                      var t = e.getExtension('ANGLE_instanced_arrays');
                      t &&
                        ((e.vertexAttribDivisor = function (e, n) {
                          t.vertexAttribDivisorANGLE(e, n);
                        }),
                        (e.drawArraysInstanced = function (e, n, a, r) {
                          t.drawArraysInstancedANGLE(e, n, a, r);
                        }),
                        (e.drawElementsInstanced = function (e, n, a, r, u) {
                          t.drawElementsInstancedANGLE(e, n, a, r, u);
                        }));
                    })(n),
                      (function (e) {
                        var t = e.getExtension('OES_vertex_array_object');
                        t &&
                          ((e.createVertexArray = function () {
                            return t.createVertexArrayOES();
                          }),
                          (e.deleteVertexArray = function (e) {
                            t.deleteVertexArrayOES(e);
                          }),
                          (e.bindVertexArray = function (e) {
                            t.bindVertexArrayOES(e);
                          }),
                          (e.isVertexArray = function (e) {
                            return t.isVertexArrayOES(e);
                          }));
                      })(n),
                      (function (e) {
                        var t = e.getExtension('WEBGL_draw_buffers');
                        t &&
                          (e.drawBuffers = function (e, n) {
                            t.drawBuffersWEBGL(e, n);
                          });
                      })(n),
                      (n.disjointTimerQueryExt = n.getExtension('EXT_disjoint_timer_query')),
                      ((t = n).multiDrawWebgl = t.getExtension('WEBGL_multi_draw')),
                      (n.getSupportedExtensions() || []).forEach(function (e) {
                        e.includes('lose_context') || e.includes('debug') || n.getExtension(e);
                      });
                  }
                },
              },
              ze = ['default', 'low-power', 'high-performance'],
              je = {
                mappings: {},
                buffers: [null, [], []],
                printChar: function (e, t) {
                  var n = je.buffers[e];
                  0 === t || 10 === t ? ((1 === e ? D : T)(Z(n, 0)), (n.length = 0)) : n.push(t);
                },
                varargs: void 0,
                get: function () {
                  return (je.varargs += 4), r()[(je.varargs - 4) >> 2];
                },
                getStr: function (e) {
                  return Y(e);
                },
                get64: function (e, t) {
                  return e;
                },
              };
            function He(e) {
              return x ? Ae(3, 1, e) : 0;
            }
            function Be(e, t, n, a, r) {
              if (x) return Ae(4, 1, e, t, n, a, r);
            }
            function Ue(e, t, n, u) {
              if (x) return Ae(5, 1, e, t, n, u);
              for (var i = 0, s = 0; s < n; s++) {
                var o = r()[t >> 2],
                  d = r()[(t + 4) >> 2];
                t += 8;
                for (var l = 0; l < d; l++) je.printChar(e, a()[o + l]);
                i += d;
              }
              return (r()[u >> 2] = i), 0;
            }
            ge.init();
            var qe = [null, ve, Pe, He, Be, Ue],
              Ve = {
                __clock_gettime: function (e, t) {
                  return Se(e, t);
                },
                __emscripten_init_main_thread_js: function (e) {
                  Ye(e, !S, 1, !I), ge.threadInit();
                },
                __emscripten_thread_cleanup: function (e) {
                  x ? postMessage({ cmd: 'cleanupThread', thread: e }) : _e(e);
                },
                __pthread_create_js: function (e, t, n, a) {
                  if ('undefined' == typeof SharedArrayBuffer)
                    return T('Current environment does not support SharedArrayBuffer, pthreads are not available!'), 6;
                  var r = [];
                  if (x && 0 === r.length) return $e(687865856, e, t, n, a);
                  var u = { startRoutine: n, pthread_ptr: e, arg: a, transferList: r };
                  return x ? ((u.cmd = 'spawnThread'), postMessage(u, r), 0) : Me(u);
                },
                _emscripten_default_pthread_stack_size: function () {
                  return 2097152;
                },
                _emscripten_notify_thread_queue: function (e, t) {
                  if (e == t) postMessage({ cmd: 'processQueuedMainThreadWork' });
                  else if (x) postMessage({ targetThread: e, cmd: 'processThreadQueue' });
                  else {
                    var n = ge.pthreads[e],
                      a = n && n.worker;
                    if (!a) return;
                    a.postMessage({ cmd: 'processThreadQueue' });
                  }
                  return 1;
                },
                abort: function () {
                  le('');
                },
                emscripten_check_blocking_allowed: function () {
                  M ||
                    S ||
                    O(
                      'Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread',
                    );
                },
                emscripten_get_heap_max: xe,
                emscripten_get_now: we,
                emscripten_memcpy_big: function (e, t, n) {
                  a().copyWithin(e, t, t + n);
                },
                emscripten_num_logical_cores: function () {
                  return M ? h.default.cpus().length : navigator.hardwareConcurrency;
                },
                emscripten_receive_on_main_thread_js: function (e, t, n) {
                  Fe.length = t;
                  for (var a = n >> 3, r = 0; r < t; r++) Fe[r] = u()[a + r];
                  return (e < 0 ? fe[-e - 1] : qe[e]).apply(null, Fe);
                },
                emscripten_resize_heap: function (e) {
                  var t = a().length;
                  if ((e >>>= 0) <= t) return !1;
                  var n,
                    r,
                    u = 2147483648;
                  if (e > u) return !1;
                  for (var i = 1; i <= 4; i *= 2) {
                    var s = t * (1 + 0.2 / i);
                    if (
                      ((s = Math.min(s, e + 100663296)), Ne(Math.min(u, ((n = Math.max(e, s)) % (r = 65536) > 0 && (n += r - (n % r)), n))))
                    )
                      return !0;
                  }
                  return !1;
                },
                emscripten_set_canvas_element_size: function (e, t, n) {
                  return Te(e) ? Oe(e, t, n) : Pe(e, t, n);
                },
                emscripten_unwind_to_js_event_loop: function () {
                  throw 'unwind';
                },
                emscripten_webgl_create_context: function (e, t) {
                  return (
                    (n = e),
                    (a = t >> 2),
                    (u = r()[a + 6]),
                    (i = {
                      alpha: !!r()[a + 0],
                      depth: !!r()[a + 1],
                      stencil: !!r()[a + 2],
                      antialias: !!r()[a + 3],
                      premultipliedAlpha: !!r()[a + 4],
                      preserveDrawingBuffer: !!r()[a + 5],
                      powerPreference: ze[u],
                      failIfMajorPerformanceCaveat: !!r()[a + 7],
                      majorVersion: r()[a + 8],
                      minorVersion: r()[a + 9],
                      enableExtensionsByDefault: r()[a + 10],
                      explicitSwapControl: r()[a + 11],
                      proxyContextToMainThread: r()[a + 12],
                      renderViaOffscreenBackBuffer: r()[a + 13],
                    }),
                    (s = Te(n)) ? (i.explicitSwapControl ? 0 : Le.createContext(s, i)) : 0
                  );
                  var n, a, u, i, s;
                },
                exit: ye,
                fd_close: He,
                fd_seek: Be,
                fd_write: Ue,
                memory: P || d.wasmMemory,
                setTempRet0: function (e) {},
              };
            !(function () {
              var e = { env: Ve, wasi_snapshot_preview1: Ve };
              function t(e, t) {
                var n,
                  a,
                  r = e.exports;
                if (
                  ((d.asm = r),
                  (n = d.asm.emscripten_tls_init),
                  ge.tlsInitFunctions.push(n),
                  (ee = d.asm.__indirect_function_table),
                  (a = d.asm.__wasm_call_ctors),
                  ae.unshift(a),
                  (W = t),
                  !x)
                ) {
                  var u = ge.unusedWorkers.length;
                  ge.unusedWorkers.forEach(function (e) {
                    ge.loadWasmModuleToWorker(e, function () {
                      --u ||
                        (function (e) {
                          if ((oe--, d.monitorRunDependencies && d.monitorRunDependencies(oe), 0 == oe && de)) {
                            var t = de;
                            (de = null), t();
                          }
                        })();
                    });
                  });
                }
              }
              function n(e) {
                t(e.instance, e.module);
              }
              function a(t) {
                return (function () {
                  if (!C && (I || S)) {
                    if ('function' == typeof fetch && !ce(se))
                      return fetch(se, { credentials: 'same-origin' })
                        .then(function (e) {
                          if (!e.ok) throw "failed to load wasm binary file at '" + se + "'";
                          return e.arrayBuffer();
                        })
                        .catch(function () {
                          return me(se);
                        });
                    if (b)
                      return new Promise(function (e, t) {
                        b(
                          se,
                          function (t) {
                            e(new Uint8Array(t));
                          },
                          t,
                        );
                      });
                  }
                  return Promise.resolve().then(function () {
                    return me(se);
                  });
                })()
                  .then(function (t) {
                    return WebAssembly.instantiate(t, e);
                  })
                  .then(function (e) {
                    return e;
                  })
                  .then(t, function (e) {
                    T('failed to asynchronously prepare wasm: ' + e), le(e);
                  });
              }
              if ((x || (oe++, d.monitorRunDependencies && d.monitorRunDependencies(oe)), d.instantiateWasm))
                try {
                  return d.instantiateWasm(e, t);
                } catch (e) {
                  return T('Module.instantiateWasm callback failed with error: ' + e), !1;
                }
              (C || 'function' != typeof WebAssembly.instantiateStreaming || pe(se) || ce(se) || 'function' != typeof fetch
                ? a(n)
                : fetch(se, { credentials: 'same-origin' }).then(function (t) {
                    return WebAssembly.instantiateStreaming(t, e).then(n, function (e) {
                      return T('wasm streaming compile failed: ' + e), T('falling back to ArrayBuffer instantiation'), a(n);
                    });
                  })
              ).catch(s);
            })(),
              (d.___wasm_call_ctors = function () {
                return (d.___wasm_call_ctors = d.asm.__wasm_call_ctors).apply(null, arguments);
              }),
              (d._init = function () {
                return (d._init = d.asm.init).apply(null, arguments);
              }),
              (d._init_with_threads_count = function () {
                return (d._init_with_threads_count = d.asm.init_with_threads_count).apply(null, arguments);
              }),
              (d._get_threads_count = function () {
                return (d._get_threads_count = d.asm.get_threads_count).apply(null, arguments);
              }),
              (d._register_tensor = function () {
                return (d._register_tensor = d.asm.register_tensor).apply(null, arguments);
              }),
              (d._dispose_data = function () {
                return (d._dispose_data = d.asm.dispose_data).apply(null, arguments);
              }),
              (d._dispose = function () {
                return (d._dispose = d.asm.dispose).apply(null, arguments);
              }),
              (d._Abs = function () {
                return (d._Abs = d.asm.Abs).apply(null, arguments);
              }),
              (d._Add = function () {
                return (d._Add = d.asm.Add).apply(null, arguments);
              }),
              (d._AddN = function () {
                return (d._AddN = d.asm.AddN).apply(null, arguments);
              }),
              (d._All = function () {
                return (d._All = d.asm.All).apply(null, arguments);
              }),
              (d._Any = function () {
                return (d._Any = d.asm.Any).apply(null, arguments);
              }),
              (d._ArgMax = function () {
                return (d._ArgMax = d.asm.ArgMax).apply(null, arguments);
              }),
              (d._AvgPool = function () {
                return (d._AvgPool = d.asm.AvgPool).apply(null, arguments);
              }),
              (d._BatchMatMul = function () {
                return (d._BatchMatMul = d.asm.BatchMatMul).apply(null, arguments);
              }),
              (d._Ceil = function () {
                return (d._Ceil = d.asm.Ceil).apply(null, arguments);
              }),
              (d._ClipByValue = function () {
                return (d._ClipByValue = d.asm.ClipByValue).apply(null, arguments);
              }),
              (d._Conv2D = function () {
                return (d._Conv2D = d.asm.Conv2D).apply(null, arguments);
              }),
              (d._Conv2DBackpropInput = function () {
                return (d._Conv2DBackpropInput = d.asm.Conv2DBackpropInput).apply(null, arguments);
              }),
              (d._Cos = function () {
                return (d._Cos = d.asm.Cos).apply(null, arguments);
              }),
              (d._Cosh = function () {
                return (d._Cosh = d.asm.Cosh).apply(null, arguments);
              }),
              (d._CropAndResize = function () {
                return (d._CropAndResize = d.asm.CropAndResize).apply(null, arguments);
              }),
              (d._Cumprod = function () {
                return (d._Cumprod = d.asm.Cumprod).apply(null, arguments);
              }),
              (d._Cumsum = function () {
                return (d._Cumsum = d.asm.Cumsum).apply(null, arguments);
              }),
              (d._DepthToSpace = function () {
                return (d._DepthToSpace = d.asm.DepthToSpace).apply(null, arguments);
              }),
              (d._DepthwiseConv2dNative = function () {
                return (d._DepthwiseConv2dNative = d.asm.DepthwiseConv2dNative).apply(null, arguments);
              }),
              (d._Elu = function () {
                return (d._Elu = d.asm.Elu).apply(null, arguments);
              }),
              (d._Equal = function () {
                return (d._Equal = d.asm.Equal).apply(null, arguments);
              }),
              (d._Exp = function () {
                return (d._Exp = d.asm.Exp).apply(null, arguments);
              }),
              (d._FlipLeftRight = function () {
                return (d._FlipLeftRight = d.asm.FlipLeftRight).apply(null, arguments);
              }),
              (d._Floor = function () {
                return (d._Floor = d.asm.Floor).apply(null, arguments);
              }),
              (d._FloorDiv = function () {
                return (d._FloorDiv = d.asm.FloorDiv).apply(null, arguments);
              }),
              (d._FusedBatchNorm = function () {
                return (d._FusedBatchNorm = d.asm.FusedBatchNorm).apply(null, arguments);
              }),
              (d._FusedConv2D = function () {
                return (d._FusedConv2D = d.asm.FusedConv2D).apply(null, arguments);
              }),
              (d._FusedDepthwiseConv2D = function () {
                return (d._FusedDepthwiseConv2D = d.asm.FusedDepthwiseConv2D).apply(null, arguments);
              }),
              (d._Gather = function () {
                return (d._Gather = d.asm.Gather).apply(null, arguments);
              }),
              (d._GatherNd = function () {
                return (d._GatherNd = d.asm.GatherNd).apply(null, arguments);
              }),
              (d._Greater = function () {
                return (d._Greater = d.asm.Greater).apply(null, arguments);
              }),
              (d._GreaterEqual = function () {
                return (d._GreaterEqual = d.asm.GreaterEqual).apply(null, arguments);
              }),
              (d._LeakyRelu = function () {
                return (d._LeakyRelu = d.asm.LeakyRelu).apply(null, arguments);
              }),
              (d._Less = function () {
                return (d._Less = d.asm.Less).apply(null, arguments);
              }),
              (d._LessEqual = function () {
                return (d._LessEqual = d.asm.LessEqual).apply(null, arguments);
              }),
              (d._Log = function () {
                return (d._Log = d.asm.Log).apply(null, arguments);
              }),
              (d._LogicalAnd = function () {
                return (d._LogicalAnd = d.asm.LogicalAnd).apply(null, arguments);
              }),
              (d._LogicalNot = function () {
                return (d._LogicalNot = d.asm.LogicalNot).apply(null, arguments);
              }),
              (d._LogicalOr = function () {
                return (d._LogicalOr = d.asm.LogicalOr).apply(null, arguments);
              }),
              (d._LogicalXor = function () {
                return (d._LogicalXor = d.asm.LogicalXor).apply(null, arguments);
              }),
              (d._Max = function () {
                return (d._Max = d.asm.Max).apply(null, arguments);
              }),
              (d._MaxPool = function () {
                return (d._MaxPool = d.asm.MaxPool).apply(null, arguments);
              }),
              (d._Maximum = function () {
                return (d._Maximum = d.asm.Maximum).apply(null, arguments);
              }),
              (d._Mean = function () {
                return (d._Mean = d.asm.Mean).apply(null, arguments);
              }),
              (d._Min = function () {
                return (d._Min = d.asm.Min).apply(null, arguments);
              }),
              (d._Minimum = function () {
                return (d._Minimum = d.asm.Minimum).apply(null, arguments);
              }),
              (d._MirrorPad = function () {
                return (d._MirrorPad = d.asm.MirrorPad).apply(null, arguments);
              }),
              (d._Multiply = function () {
                return (d._Multiply = d.asm.Multiply).apply(null, arguments);
              }),
              (d._Neg = function () {
                return (d._Neg = d.asm.Neg).apply(null, arguments);
              }),
              (d._NonMaxSuppressionV3 = function () {
                return (d._NonMaxSuppressionV3 = d.asm.NonMaxSuppressionV3).apply(null, arguments);
              }),
              (d._NonMaxSuppressionV4 = function () {
                return (d._NonMaxSuppressionV4 = d.asm.NonMaxSuppressionV4).apply(null, arguments);
              }),
              (d._NonMaxSuppressionV5 = function () {
                return (d._NonMaxSuppressionV5 = d.asm.NonMaxSuppressionV5).apply(null, arguments);
              }),
              (d._NotEqual = function () {
                return (d._NotEqual = d.asm.NotEqual).apply(null, arguments);
              }),
              (d._OneHot = function () {
                return (d._OneHot = d.asm.OneHot).apply(null, arguments);
              }),
              (d._PadV2 = function () {
                return (d._PadV2 = d.asm.PadV2).apply(null, arguments);
              }),
              (d._Pow = function () {
                return (d._Pow = d.asm.Pow).apply(null, arguments);
              }),
              (d._Prelu = function () {
                return (d._Prelu = d.asm.Prelu).apply(null, arguments);
              }),
              (d._Prod = function () {
                return (d._Prod = d.asm.Prod).apply(null, arguments);
              }),
              (d._RealDiv = function () {
                return (d._RealDiv = d.asm.RealDiv).apply(null, arguments);
              }),
              (d._Relu = function () {
                return (d._Relu = d.asm.Relu).apply(null, arguments);
              }),
              (d._Relu6 = function () {
                return (d._Relu6 = d.asm.Relu6).apply(null, arguments);
              }),
              (d._ResizeBilinear = function () {
                return (d._ResizeBilinear = d.asm.ResizeBilinear).apply(null, arguments);
              }),
              (d._ResizeNearestNeighbor = function () {
                return (d._ResizeNearestNeighbor = d.asm.ResizeNearestNeighbor).apply(null, arguments);
              }),
              (d._Reverse = function () {
                return (d._Reverse = d.asm.Reverse).apply(null, arguments);
              }),
              (d._RotateWithOffset = function () {
                return (d._RotateWithOffset = d.asm.RotateWithOffset).apply(null, arguments);
              }),
              (d._Round = function () {
                return (d._Round = d.asm.Round).apply(null, arguments);
              }),
              (d._Rsqrt = function () {
                return (d._Rsqrt = d.asm.Rsqrt).apply(null, arguments);
              }),
              (d._ScatterNd = function () {
                return (d._ScatterNd = d.asm.ScatterNd).apply(null, arguments);
              }),
              (d._SelectV2 = function () {
                return (d._SelectV2 = d.asm.SelectV2).apply(null, arguments);
              }),
              (d._Sigmoid = function () {
                return (d._Sigmoid = d.asm.Sigmoid).apply(null, arguments);
              }),
              (d._Sin = function () {
                return (d._Sin = d.asm.Sin).apply(null, arguments);
              }),
              (d._Softmax = function () {
                return (d._Softmax = d.asm.Softmax).apply(null, arguments);
              }),
              (d._SparseFillEmptyRows = function () {
                return (d._SparseFillEmptyRows = d.asm.SparseFillEmptyRows).apply(null, arguments);
              }),
              (d._SparseReshape = function () {
                return (d._SparseReshape = d.asm.SparseReshape).apply(null, arguments);
              }),
              (d._SparseSegmentReduction = function () {
                return (d._SparseSegmentReduction = d.asm.SparseSegmentReduction).apply(null, arguments);
              }),
              (d._Sqrt = function () {
                return (d._Sqrt = d.asm.Sqrt).apply(null, arguments);
              }),
              (d._Square = function () {
                return (d._Square = d.asm.Square).apply(null, arguments);
              }),
              (d._SquaredDifference = function () {
                return (d._SquaredDifference = d.asm.SquaredDifference).apply(null, arguments);
              }),
              (d._Step = function () {
                return (d._Step = d.asm.Step).apply(null, arguments);
              }),
              (d._StridedSlice = function () {
                return (d._StridedSlice = d.asm.StridedSlice).apply(null, arguments);
              }),
              (d._Sub = function () {
                return (d._Sub = d.asm.Sub).apply(null, arguments);
              }),
              (d._Sum = function () {
                return (d._Sum = d.asm.Sum).apply(null, arguments);
              }),
              (d._Tan = function () {
                return (d._Tan = d.asm.Tan).apply(null, arguments);
              }),
              (d._Tanh = function () {
                return (d._Tanh = d.asm.Tanh).apply(null, arguments);
              }),
              (d._Tile = function () {
                return (d._Tile = d.asm.Tile).apply(null, arguments);
              }),
              (d._TopK = function () {
                return (d._TopK = d.asm.TopK).apply(null, arguments);
              }),
              (d._Transform = function () {
                return (d._Transform = d.asm.Transform).apply(null, arguments);
              }),
              (d._Transpose = function () {
                return (d._Transpose = d.asm.Transpose).apply(null, arguments);
              }),
              (d.__FusedMatMul = function () {
                return (d.__FusedMatMul = d.asm._FusedMatMul).apply(null, arguments);
              });
            var Ge = (d._malloc = function () {
                return (Ge = d._malloc = d.asm.malloc).apply(null, arguments);
              }),
              Ke = (d._free = function () {
                return (Ke = d._free = d.asm.free).apply(null, arguments);
              });
            d._emscripten_tls_init = function () {
              return (d._emscripten_tls_init = d.asm.emscripten_tls_init).apply(null, arguments);
            };
            var Xe = (d.___errno_location = function () {
                return (Xe = d.___errno_location = d.asm.__errno_location).apply(null, arguments);
              }),
              Qe = (d._pthread_self = function () {
                return (Qe = d._pthread_self = d.asm.pthread_self).apply(null, arguments);
              }),
              Ze = (d._emscripten_main_thread_process_queued_calls = function () {
                return (Ze = d._emscripten_main_thread_process_queued_calls = d.asm.emscripten_main_thread_process_queued_calls).apply(
                  null,
                  arguments,
                );
              });
            d.__emscripten_thread_crashed = function () {
              return (d.__emscripten_thread_crashed = d.asm._emscripten_thread_crashed).apply(null, arguments);
            };
            var Ye = (d.__emscripten_thread_init = function () {
              return (Ye = d.__emscripten_thread_init = d.asm._emscripten_thread_init).apply(null, arguments);
            });
            (d._emscripten_current_thread_process_queued_calls = function () {
              return (d._emscripten_current_thread_process_queued_calls = d.asm.emscripten_current_thread_process_queued_calls).apply(
                null,
                arguments,
              );
            }),
              (d._emscripten_main_browser_thread_id = function () {
                return (d._emscripten_main_browser_thread_id = d.asm.emscripten_main_browser_thread_id).apply(null, arguments);
              }),
              (d._emscripten_sync_run_in_main_thread_2 = function () {
                return (d._emscripten_sync_run_in_main_thread_2 = d.asm.emscripten_sync_run_in_main_thread_2).apply(null, arguments);
              });
            var $e = (d._emscripten_sync_run_in_main_thread_4 = function () {
                return ($e = d._emscripten_sync_run_in_main_thread_4 = d.asm.emscripten_sync_run_in_main_thread_4).apply(null, arguments);
              }),
              Je = (d._emscripten_run_in_main_runtime_thread_js = function () {
                return (Je = d._emscripten_run_in_main_runtime_thread_js = d.asm.emscripten_run_in_main_runtime_thread_js).apply(
                  null,
                  arguments,
                );
              }),
              et = (d._emscripten_dispatch_to_thread_ = function () {
                return (et = d._emscripten_dispatch_to_thread_ = d.asm.emscripten_dispatch_to_thread_).apply(null, arguments);
              }),
              tt = (d.__emscripten_thread_free_data = function () {
                return (tt = d.__emscripten_thread_free_data = d.asm._emscripten_thread_free_data).apply(null, arguments);
              });
            (d.__emscripten_thread_exit = function () {
              return (d.__emscripten_thread_exit = d.asm._emscripten_thread_exit).apply(null, arguments);
            }),
              (d._memalign = function () {
                return (d._memalign = d.asm.memalign).apply(null, arguments);
              });
            var nt = (d._emscripten_stack_set_limits = function () {
                return (nt = d._emscripten_stack_set_limits = d.asm.emscripten_stack_set_limits).apply(null, arguments);
              }),
              at = (d.stackSave = function () {
                return (at = d.stackSave = d.asm.stackSave).apply(null, arguments);
              }),
              rt = (d.stackRestore = function () {
                return (rt = d.stackRestore = d.asm.stackRestore).apply(null, arguments);
              }),
              ut = (d.stackAlloc = function () {
                return (ut = d.stackAlloc = d.asm.stackAlloc).apply(null, arguments);
              });
            (d.dynCall_iijjiiii = function () {
              return (d.dynCall_iijjiiii = d.asm.dynCall_iijjiiii).apply(null, arguments);
            }),
              (d.dynCall_jiji = function () {
                return (d.dynCall_jiji = d.asm.dynCall_jiji).apply(null, arguments);
              });
            var it,
              st,
              ot,
              dt = (d.__emscripten_allow_main_runtime_queued_calls = 21672);
            function lt(e) {
              (this.name = 'ExitStatus'), (this.message = 'Program terminated with exit(' + e + ')'), (this.status = e);
            }
            function pt(e) {
              if (!(oe > 0)) {
                if (x) return i(d), ie(), void postMessage({ cmd: 'loaded' });
                !(function () {
                  if (d.preRun)
                    for ('function' == typeof d.preRun && (d.preRun = [d.preRun]); d.preRun.length; ) (e = d.preRun.shift()), ne.unshift(e);
                  var e;
                  he(ne);
                })(),
                  oe > 0 ||
                    (d.setStatus
                      ? (d.setStatus('Running...'),
                        setTimeout(function () {
                          setTimeout(function () {
                            d.setStatus('');
                          }, 1),
                            t();
                        }, 1))
                      : t());
              }
              function t() {
                it ||
                  ((it = !0),
                  (d.calledRun = !0),
                  j ||
                    (ie(),
                    i(d),
                    d.onRuntimeInitialized && d.onRuntimeInitialized(),
                    (function () {
                      if (!x) {
                        if (d.postRun)
                          for ('function' == typeof d.postRun && (d.postRun = [d.postRun]); d.postRun.length; )
                            (e = d.postRun.shift()), re.unshift(e);
                        var e;
                        he(re);
                      }
                    })()));
              }
            }
            if (
              ((d.cwrap = function (e, t, n, a) {
                var r = (n = n || []).every(function (e) {
                  return 'number' === e;
                });
                return 'string' !== t && r && !a
                  ? H(e)
                  : function () {
                      return B(e, t, n, arguments);
                    };
              }),
              (d.keepRuntimeAlive = ue),
              (d.PThread = ge),
              (d.PThread = ge),
              (d.wasmMemory = P),
              (d.ExitStatus = lt),
              (de = function e() {
                it || pt(), it || (de = e);
              }),
              (d.run = pt),
              d.preInit)
            )
              for ('function' == typeof d.preInit && (d.preInit = [d.preInit]); d.preInit.length > 0; ) d.preInit.pop()();
            if (
              (pt(),
              o &&
                (st = {
                  uncaughtException: process.listeners('uncaughtException').filter(function (e) {
                    return !o.uncaughtException.indexOf(e) > -1;
                  }),
                  unhandledRejection: process.listeners('unhandledRejection').filter(function (e) {
                    return !o.unhandledRejection.indexOf(e) > -1;
                  }),
                }),
              'undefined' != typeof WasmBackendModule)
            )
              ot = WasmBackendModule;
            else {
              if ('undefined' == typeof e) throw new Error('Could not find wasm module in post.js');
              ot = e;
            }
            if (st) {
              var ct = ot._dispose;
              ot._dispose = function () {
                ct(),
                  st.uncaughtException.forEach(function (e) {
                    process.removeListener('uncaughtException', e);
                  }),
                  st.unhandledRejection.forEach(function (e) {
                    process.removeListener('unhandledRejection', e);
                  });
              };
            }
            return e.ready;
          });
      e.exports = a;
    }),
    Qn = Object.assign(Object.create(null), Xn, { default: Xn }),
    Zn = Kn(function (e, t) {
      var n,
        a =
          ((n = 'undefined' != typeof document && document.currentScript ? document.currentScript.src : void 0),
          'undefined' != typeof __filename && (n = n || __filename),
          function (e) {
            var t,
              a,
              r,
              u = 'undefined' != typeof (e = e || {}) ? e : {};
            (u.ready = new Promise(function (e, n) {
              (t = e), (a = n);
            })),
              'undefined' != typeof process &&
                process.listeners &&
                (r = {
                  uncaughtException: process.listeners('uncaughtException'),
                  unhandledRejection: process.listeners('unhandledRejection'),
                });
            var i,
              s,
              o,
              d,
              l,
              m,
              f = Object.assign({}, u),
              h = 'object' == typeof window,
              b = 'function' == typeof importScripts,
              _ = 'object' == typeof process && 'object' == typeof process.versions && 'string' == typeof process.versions.node,
              y = '';
            _
              ? ((y = b ? p.default.dirname(y) + '/' : __dirname + '/'),
                (m = function () {
                  l || ((d = c.default), (l = p.default));
                }),
                (i = function (e, t) {
                  return m(), (e = l.normalize(e)), d.readFileSync(e, t ? void 0 : 'utf8');
                }),
                (o = function (e) {
                  var t = i(e, !0);
                  return t.buffer || (t = new Uint8Array(t)), t;
                }),
                (s = function (e, t, n) {
                  m(),
                    (e = l.normalize(e)),
                    d.readFile(e, function (e, a) {
                      e ? n(e) : t(a.buffer);
                    });
                }),
                process.argv.length > 1 && process.argv[1].replace(/\\/g, '/'),
                process.argv.slice(2),
                process.on('uncaughtException', function (e) {
                  if (!(e instanceof ue)) throw e;
                }),
                process.on('unhandledRejection', function (e) {
                  throw e;
                }),
                (u.inspect = function () {
                  return '[Emscripten Module object]';
                }))
              : (h || b) &&
                (b
                  ? (y = self.location.href)
                  : 'undefined' != typeof document && document.currentScript && (y = document.currentScript.src),
                n && (y = n),
                (y = 0 !== y.indexOf('blob:') ? y.substr(0, y.replace(/[?#].*/, '').lastIndexOf('/') + 1) : ''),
                (i = function (e) {
                  var t = new XMLHttpRequest();
                  return t.open('GET', e, !1), t.send(null), t.responseText;
                }),
                b &&
                  (o = function (e) {
                    var t = new XMLHttpRequest();
                    return t.open('GET', e, !1), (t.responseType = 'arraybuffer'), t.send(null), new Uint8Array(t.response);
                  }),
                (s = function (e, t, n) {
                  var a = new XMLHttpRequest();
                  a.open('GET', e, !0),
                    (a.responseType = 'arraybuffer'),
                    (a.onload = function () {
                      200 == a.status || (0 == a.status && a.response) ? t(a.response) : n();
                    }),
                    (a.onerror = n),
                    a.send(null);
                }));
            var g,
              v,
              w = u.print || console.log.bind(console),
              k = u.printErr || console.warn.bind(console);
            Object.assign(u, f),
              (f = null),
              u.arguments,
              u.thisProgram,
              u.quit,
              u.wasmBinary && (g = u.wasmBinary),
              u.noExitRuntime,
              'object' != typeof WebAssembly && B('no native wasm support detected');
            var I = !1;
            function S(e) {
              return u['_' + e];
            }
            function M(e, t, n, a, r) {
              var u = {
                  string: function (e) {
                    var t = 0;
                    if (null != e && 0 !== e) {
                      var n = 1 + (e.length << 2);
                      !(function (e, t, n) {
                        !(function (e, t, n, a) {
                          if (!(a > 0)) return 0;
                          for (var r = n + a - 1, u = 0; u < e.length; ++u) {
                            var i = e.charCodeAt(u);
                            if ((i >= 55296 && i <= 57343 && (i = (65536 + ((1023 & i) << 10)) | (1023 & e.charCodeAt(++u))), i <= 127)) {
                              if (n >= r) break;
                              t[n++] = i;
                            } else if (i <= 2047) {
                              if (n + 1 >= r) break;
                              (t[n++] = 192 | (i >> 6)), (t[n++] = 128 | (63 & i));
                            } else if (i <= 65535) {
                              if (n + 2 >= r) break;
                              (t[n++] = 224 | (i >> 12)), (t[n++] = 128 | ((i >> 6) & 63)), (t[n++] = 128 | (63 & i));
                            } else {
                              if (n + 3 >= r) break;
                              (t[n++] = 240 | (i >> 18)),
                                (t[n++] = 128 | ((i >> 12) & 63)),
                                (t[n++] = 128 | ((i >> 6) & 63)),
                                (t[n++] = 128 | (63 & i));
                            }
                          }
                          t[n] = 0;
                        })(e, F, t, n);
                      })(e, (t = re(n)), n);
                    }
                    return t;
                  },
                  array: function (e) {
                    var t = re(e.length);
                    return (
                      (function (e, t) {
                        A.set(e, t);
                      })(e, t),
                      t
                    );
                  },
                },
                i = S(e),
                s = [],
                o = 0;
              if (a)
                for (var d = 0; d < a.length; d++) {
                  var l = u[n[d]];
                  l ? (0 === o && (o = ne()), (s[d] = l(a[d]))) : (s[d] = a[d]);
                }
              var p = i.apply(null, s);
              return (p = (function (e) {
                return (
                  0 !== o && ae(o),
                  (function (e) {
                    return 'string' === t ? D(e) : 'boolean' === t ? Boolean(e) : e;
                  })(e)
                );
              })(p));
            }
            var x,
              A,
              F,
              N,
              E,
              R = 'undefined' != typeof TextDecoder ? new TextDecoder('utf8') : void 0;
            function C(e, t, n) {
              for (var a = t + n, r = t; e[r] && !(r >= a); ) ++r;
              if (r - t > 16 && e.subarray && R) return R.decode(e.subarray(t, r));
              for (var u = ''; t < r; ) {
                var i = e[t++];
                if (128 & i) {
                  var s = 63 & e[t++];
                  if (192 != (224 & i)) {
                    var o = 63 & e[t++];
                    if (
                      (i = 224 == (240 & i) ? ((15 & i) << 12) | (s << 6) | o : ((7 & i) << 18) | (s << 12) | (o << 6) | (63 & e[t++])) <
                      65536
                    )
                      u += String.fromCharCode(i);
                    else {
                      var d = i - 65536;
                      u += String.fromCharCode(55296 | (d >> 10), 56320 | (1023 & d));
                    }
                  } else u += String.fromCharCode(((31 & i) << 6) | s);
                } else u += String.fromCharCode(i);
              }
              return u;
            }
            function D(e, t) {
              return e ? C(F, e, t) : '';
            }
            function T(e) {
              (x = e),
                (u.HEAP8 = A = new Int8Array(e)),
                (u.HEAP16 = new Int16Array(e)),
                (u.HEAP32 = N = new Int32Array(e)),
                (u.HEAPU8 = F = new Uint8Array(e)),
                (u.HEAPU16 = new Uint16Array(e)),
                (u.HEAPU32 = new Uint32Array(e)),
                (u.HEAPF32 = new Float32Array(e)),
                (u.HEAPF64 = new Float64Array(e));
            }
            'undefined' != typeof TextDecoder && new TextDecoder('utf-16le'), u.INITIAL_MEMORY;
            var O,
              P,
              W = [],
              L = [],
              z = [],
              j = 0,
              H = null;
            function B(e) {
              u.onAbort && u.onAbort(e), k((e = 'Aborted(' + e + ')')), (I = !0), (e += '. Build with -s ASSERTIONS=1 for more info.');
              var t = new WebAssembly.RuntimeError(e);
              throw (a(t), t);
            }
            function U(e) {
              return e.startsWith('data:application/octet-stream;base64,');
            }
            function q(e) {
              return e.startsWith('file://');
            }
            function V(e) {
              try {
                if (e == O && g) return new Uint8Array(g);
                if (o) return o(e);
                throw 'both async and sync fetching of the wasm failed';
              } catch (e) {
                B(e);
              }
            }
            function G(e) {
              for (; e.length > 0; ) {
                var t = e.shift();
                if ('function' != typeof t) {
                  var n = t.func;
                  'number' == typeof n ? (void 0 === t.arg ? X(n)() : X(n)(t.arg)) : n(void 0 === t.arg ? null : t.arg);
                } else t(u);
              }
            }
            (u.preloadedImages = {}),
              (u.preloadedAudios = {}),
              U((O = 'tfjs-backend-wasm.wasm')) || ((P = O), (O = u.locateFile ? u.locateFile(P, y) : y + P));
            var K = [];
            function X(e) {
              var t = K[e];
              return t || (e >= K.length && (K.length = e + 1), (K[e] = t = E.get(e))), t;
            }
            function Q() {
              return 2147483648;
            }
            function Z(e) {
              try {
                return v.grow((e - x.byteLength + 65535) >>> 16), T(v.buffer), 1;
              } catch (e) {}
            }
            var Y = {
                mappings: {},
                buffers: [null, [], []],
                printChar: function (e, t) {
                  var n = Y.buffers[e];
                  0 === t || 10 === t ? ((1 === e ? w : k)(C(n, 0)), (n.length = 0)) : n.push(t);
                },
                varargs: void 0,
                get: function () {
                  return (Y.varargs += 4), N[(Y.varargs - 4) >> 2];
                },
                getStr: function (e) {
                  return D(e);
                },
                get64: function (e, t) {
                  return e;
                },
              },
              $ = {
                abort: function () {
                  B('');
                },
                emscripten_get_heap_max: Q,
                emscripten_memcpy_big: function (e, t, n) {
                  F.copyWithin(e, t, t + n);
                },
                emscripten_resize_heap: function (e) {
                  var t,
                    n,
                    a = F.length,
                    r = 2147483648;
                  if ((e >>>= 0) > r) return !1;
                  for (var u = 1; u <= 4; u *= 2) {
                    var i = a * (1 + 0.2 / u);
                    if (
                      ((i = Math.min(i, e + 100663296)), Z(Math.min(r, ((t = Math.max(e, i)) % (n = 65536) > 0 && (t += n - (t % n)), t))))
                    )
                      return !0;
                  }
                  return !1;
                },
                fd_close: function (e) {
                  return 0;
                },
                fd_seek: function (e, t, n, a, r) {},
                fd_write: function (e, t, n, a) {
                  for (var r = 0, u = 0; u < n; u++) {
                    var i = N[t >> 2],
                      s = N[(t + 4) >> 2];
                    t += 8;
                    for (var o = 0; o < s; o++) Y.printChar(e, F[i + o]);
                    r += s;
                  }
                  return (N[a >> 2] = r), 0;
                },
                setTempRet0: function (e) {},
              };
            !(function () {
              var e = { env: $, wasi_snapshot_preview1: $ };
              function t(e, t) {
                var n,
                  a = e.exports;
                (u.asm = a),
                  T((v = u.asm.memory).buffer),
                  (E = u.asm.__indirect_function_table),
                  (n = u.asm.__wasm_call_ctors),
                  L.unshift(n),
                  (function (e) {
                    if ((j--, u.monitorRunDependencies && u.monitorRunDependencies(j), 0 == j && H)) {
                      var t = H;
                      (H = null), t();
                    }
                  })();
              }
              function n(e) {
                t(e.instance);
              }
              function r(t) {
                return (function () {
                  if (!g && (h || b)) {
                    if ('function' == typeof fetch && !q(O))
                      return fetch(O, { credentials: 'same-origin' })
                        .then(function (e) {
                          if (!e.ok) throw "failed to load wasm binary file at '" + O + "'";
                          return e.arrayBuffer();
                        })
                        .catch(function () {
                          return V(O);
                        });
                    if (s)
                      return new Promise(function (e, t) {
                        s(
                          O,
                          function (t) {
                            e(new Uint8Array(t));
                          },
                          t,
                        );
                      });
                  }
                  return Promise.resolve().then(function () {
                    return V(O);
                  });
                })()
                  .then(function (t) {
                    return WebAssembly.instantiate(t, e);
                  })
                  .then(function (e) {
                    return e;
                  })
                  .then(t, function (e) {
                    k('failed to asynchronously prepare wasm: ' + e), B(e);
                  });
              }
              if ((j++, u.monitorRunDependencies && u.monitorRunDependencies(j), u.instantiateWasm))
                try {
                  return u.instantiateWasm(e, t);
                } catch (e) {
                  return k('Module.instantiateWasm callback failed with error: ' + e), !1;
                }
              (g || 'function' != typeof WebAssembly.instantiateStreaming || U(O) || q(O) || 'function' != typeof fetch
                ? r(n)
                : fetch(O, { credentials: 'same-origin' }).then(function (t) {
                    return WebAssembly.instantiateStreaming(t, e).then(n, function (e) {
                      return k('wasm streaming compile failed: ' + e), k('falling back to ArrayBuffer instantiation'), r(n);
                    });
                  })
              ).catch(a);
            })(),
              (u.___wasm_call_ctors = function () {
                return (u.___wasm_call_ctors = u.asm.__wasm_call_ctors).apply(null, arguments);
              }),
              (u._init = function () {
                return (u._init = u.asm.init).apply(null, arguments);
              }),
              (u._init_with_threads_count = function () {
                return (u._init_with_threads_count = u.asm.init_with_threads_count).apply(null, arguments);
              }),
              (u._get_threads_count = function () {
                return (u._get_threads_count = u.asm.get_threads_count).apply(null, arguments);
              }),
              (u._register_tensor = function () {
                return (u._register_tensor = u.asm.register_tensor).apply(null, arguments);
              }),
              (u._dispose_data = function () {
                return (u._dispose_data = u.asm.dispose_data).apply(null, arguments);
              }),
              (u._dispose = function () {
                return (u._dispose = u.asm.dispose).apply(null, arguments);
              }),
              (u._Abs = function () {
                return (u._Abs = u.asm.Abs).apply(null, arguments);
              }),
              (u._Add = function () {
                return (u._Add = u.asm.Add).apply(null, arguments);
              }),
              (u._AddN = function () {
                return (u._AddN = u.asm.AddN).apply(null, arguments);
              }),
              (u._All = function () {
                return (u._All = u.asm.All).apply(null, arguments);
              }),
              (u._Any = function () {
                return (u._Any = u.asm.Any).apply(null, arguments);
              }),
              (u._ArgMax = function () {
                return (u._ArgMax = u.asm.ArgMax).apply(null, arguments);
              }),
              (u._AvgPool = function () {
                return (u._AvgPool = u.asm.AvgPool).apply(null, arguments);
              }),
              (u._BatchMatMul = function () {
                return (u._BatchMatMul = u.asm.BatchMatMul).apply(null, arguments);
              }),
              (u._Ceil = function () {
                return (u._Ceil = u.asm.Ceil).apply(null, arguments);
              }),
              (u._ClipByValue = function () {
                return (u._ClipByValue = u.asm.ClipByValue).apply(null, arguments);
              }),
              (u._Conv2D = function () {
                return (u._Conv2D = u.asm.Conv2D).apply(null, arguments);
              }),
              (u._Conv2DBackpropInput = function () {
                return (u._Conv2DBackpropInput = u.asm.Conv2DBackpropInput).apply(null, arguments);
              }),
              (u._Cos = function () {
                return (u._Cos = u.asm.Cos).apply(null, arguments);
              }),
              (u._Cosh = function () {
                return (u._Cosh = u.asm.Cosh).apply(null, arguments);
              }),
              (u._CropAndResize = function () {
                return (u._CropAndResize = u.asm.CropAndResize).apply(null, arguments);
              }),
              (u._Cumprod = function () {
                return (u._Cumprod = u.asm.Cumprod).apply(null, arguments);
              }),
              (u._Cumsum = function () {
                return (u._Cumsum = u.asm.Cumsum).apply(null, arguments);
              }),
              (u._DepthToSpace = function () {
                return (u._DepthToSpace = u.asm.DepthToSpace).apply(null, arguments);
              }),
              (u._DepthwiseConv2dNative = function () {
                return (u._DepthwiseConv2dNative = u.asm.DepthwiseConv2dNative).apply(null, arguments);
              }),
              (u._Elu = function () {
                return (u._Elu = u.asm.Elu).apply(null, arguments);
              }),
              (u._Equal = function () {
                return (u._Equal = u.asm.Equal).apply(null, arguments);
              }),
              (u._Exp = function () {
                return (u._Exp = u.asm.Exp).apply(null, arguments);
              }),
              (u._FlipLeftRight = function () {
                return (u._FlipLeftRight = u.asm.FlipLeftRight).apply(null, arguments);
              }),
              (u._Floor = function () {
                return (u._Floor = u.asm.Floor).apply(null, arguments);
              }),
              (u._FloorDiv = function () {
                return (u._FloorDiv = u.asm.FloorDiv).apply(null, arguments);
              }),
              (u._FusedBatchNorm = function () {
                return (u._FusedBatchNorm = u.asm.FusedBatchNorm).apply(null, arguments);
              }),
              (u._FusedConv2D = function () {
                return (u._FusedConv2D = u.asm.FusedConv2D).apply(null, arguments);
              }),
              (u._FusedDepthwiseConv2D = function () {
                return (u._FusedDepthwiseConv2D = u.asm.FusedDepthwiseConv2D).apply(null, arguments);
              }),
              (u._Gather = function () {
                return (u._Gather = u.asm.Gather).apply(null, arguments);
              }),
              (u._GatherNd = function () {
                return (u._GatherNd = u.asm.GatherNd).apply(null, arguments);
              }),
              (u._Greater = function () {
                return (u._Greater = u.asm.Greater).apply(null, arguments);
              }),
              (u._GreaterEqual = function () {
                return (u._GreaterEqual = u.asm.GreaterEqual).apply(null, arguments);
              }),
              (u._LeakyRelu = function () {
                return (u._LeakyRelu = u.asm.LeakyRelu).apply(null, arguments);
              }),
              (u._Less = function () {
                return (u._Less = u.asm.Less).apply(null, arguments);
              }),
              (u._LessEqual = function () {
                return (u._LessEqual = u.asm.LessEqual).apply(null, arguments);
              }),
              (u._Log = function () {
                return (u._Log = u.asm.Log).apply(null, arguments);
              }),
              (u._LogicalAnd = function () {
                return (u._LogicalAnd = u.asm.LogicalAnd).apply(null, arguments);
              }),
              (u._LogicalNot = function () {
                return (u._LogicalNot = u.asm.LogicalNot).apply(null, arguments);
              }),
              (u._LogicalOr = function () {
                return (u._LogicalOr = u.asm.LogicalOr).apply(null, arguments);
              }),
              (u._LogicalXor = function () {
                return (u._LogicalXor = u.asm.LogicalXor).apply(null, arguments);
              }),
              (u._Max = function () {
                return (u._Max = u.asm.Max).apply(null, arguments);
              }),
              (u._MaxPool = function () {
                return (u._MaxPool = u.asm.MaxPool).apply(null, arguments);
              }),
              (u._Maximum = function () {
                return (u._Maximum = u.asm.Maximum).apply(null, arguments);
              }),
              (u._Mean = function () {
                return (u._Mean = u.asm.Mean).apply(null, arguments);
              }),
              (u._Min = function () {
                return (u._Min = u.asm.Min).apply(null, arguments);
              }),
              (u._Minimum = function () {
                return (u._Minimum = u.asm.Minimum).apply(null, arguments);
              }),
              (u._MirrorPad = function () {
                return (u._MirrorPad = u.asm.MirrorPad).apply(null, arguments);
              }),
              (u._Multiply = function () {
                return (u._Multiply = u.asm.Multiply).apply(null, arguments);
              }),
              (u._Neg = function () {
                return (u._Neg = u.asm.Neg).apply(null, arguments);
              }),
              (u._NonMaxSuppressionV3 = function () {
                return (u._NonMaxSuppressionV3 = u.asm.NonMaxSuppressionV3).apply(null, arguments);
              }),
              (u._NonMaxSuppressionV4 = function () {
                return (u._NonMaxSuppressionV4 = u.asm.NonMaxSuppressionV4).apply(null, arguments);
              }),
              (u._NonMaxSuppressionV5 = function () {
                return (u._NonMaxSuppressionV5 = u.asm.NonMaxSuppressionV5).apply(null, arguments);
              }),
              (u._NotEqual = function () {
                return (u._NotEqual = u.asm.NotEqual).apply(null, arguments);
              }),
              (u._OneHot = function () {
                return (u._OneHot = u.asm.OneHot).apply(null, arguments);
              }),
              (u._PadV2 = function () {
                return (u._PadV2 = u.asm.PadV2).apply(null, arguments);
              }),
              (u._Pow = function () {
                return (u._Pow = u.asm.Pow).apply(null, arguments);
              }),
              (u._Prelu = function () {
                return (u._Prelu = u.asm.Prelu).apply(null, arguments);
              }),
              (u._Prod = function () {
                return (u._Prod = u.asm.Prod).apply(null, arguments);
              }),
              (u._RealDiv = function () {
                return (u._RealDiv = u.asm.RealDiv).apply(null, arguments);
              }),
              (u._Relu = function () {
                return (u._Relu = u.asm.Relu).apply(null, arguments);
              }),
              (u._Relu6 = function () {
                return (u._Relu6 = u.asm.Relu6).apply(null, arguments);
              }),
              (u._ResizeBilinear = function () {
                return (u._ResizeBilinear = u.asm.ResizeBilinear).apply(null, arguments);
              }),
              (u._ResizeNearestNeighbor = function () {
                return (u._ResizeNearestNeighbor = u.asm.ResizeNearestNeighbor).apply(null, arguments);
              }),
              (u._Reverse = function () {
                return (u._Reverse = u.asm.Reverse).apply(null, arguments);
              }),
              (u._RotateWithOffset = function () {
                return (u._RotateWithOffset = u.asm.RotateWithOffset).apply(null, arguments);
              }),
              (u._Round = function () {
                return (u._Round = u.asm.Round).apply(null, arguments);
              }),
              (u._Rsqrt = function () {
                return (u._Rsqrt = u.asm.Rsqrt).apply(null, arguments);
              }),
              (u._ScatterNd = function () {
                return (u._ScatterNd = u.asm.ScatterNd).apply(null, arguments);
              }),
              (u._SelectV2 = function () {
                return (u._SelectV2 = u.asm.SelectV2).apply(null, arguments);
              }),
              (u._Sigmoid = function () {
                return (u._Sigmoid = u.asm.Sigmoid).apply(null, arguments);
              }),
              (u._Sin = function () {
                return (u._Sin = u.asm.Sin).apply(null, arguments);
              }),
              (u._Softmax = function () {
                return (u._Softmax = u.asm.Softmax).apply(null, arguments);
              }),
              (u._SparseFillEmptyRows = function () {
                return (u._SparseFillEmptyRows = u.asm.SparseFillEmptyRows).apply(null, arguments);
              }),
              (u._SparseReshape = function () {
                return (u._SparseReshape = u.asm.SparseReshape).apply(null, arguments);
              }),
              (u._SparseSegmentReduction = function () {
                return (u._SparseSegmentReduction = u.asm.SparseSegmentReduction).apply(null, arguments);
              }),
              (u._Sqrt = function () {
                return (u._Sqrt = u.asm.Sqrt).apply(null, arguments);
              }),
              (u._Square = function () {
                return (u._Square = u.asm.Square).apply(null, arguments);
              }),
              (u._SquaredDifference = function () {
                return (u._SquaredDifference = u.asm.SquaredDifference).apply(null, arguments);
              }),
              (u._Step = function () {
                return (u._Step = u.asm.Step).apply(null, arguments);
              }),
              (u._StridedSlice = function () {
                return (u._StridedSlice = u.asm.StridedSlice).apply(null, arguments);
              }),
              (u._Sub = function () {
                return (u._Sub = u.asm.Sub).apply(null, arguments);
              }),
              (u._Sum = function () {
                return (u._Sum = u.asm.Sum).apply(null, arguments);
              }),
              (u._Tan = function () {
                return (u._Tan = u.asm.Tan).apply(null, arguments);
              }),
              (u._Tanh = function () {
                return (u._Tanh = u.asm.Tanh).apply(null, arguments);
              }),
              (u._Tile = function () {
                return (u._Tile = u.asm.Tile).apply(null, arguments);
              }),
              (u._TopK = function () {
                return (u._TopK = u.asm.TopK).apply(null, arguments);
              }),
              (u._Transform = function () {
                return (u._Transform = u.asm.Transform).apply(null, arguments);
              }),
              (u._Transpose = function () {
                return (u._Transpose = u.asm.Transpose).apply(null, arguments);
              }),
              (u.__FusedMatMul = function () {
                return (u.__FusedMatMul = u.asm._FusedMatMul).apply(null, arguments);
              }),
              (u._malloc = function () {
                return (u._malloc = u.asm.malloc).apply(null, arguments);
              }),
              (u._free = function () {
                return (u._free = u.asm.free).apply(null, arguments);
              }),
              (u.___errno_location = function () {
                return (u.___errno_location = u.asm.__errno_location).apply(null, arguments);
              }),
              (u._emscripten_main_thread_process_queued_calls = function () {
                return (u._emscripten_main_thread_process_queued_calls = u.asm.emscripten_main_thread_process_queued_calls).apply(
                  null,
                  arguments,
                );
              });
            var J,
              ee,
              te,
              ne = (u.stackSave = function () {
                return (ne = u.stackSave = u.asm.stackSave).apply(null, arguments);
              }),
              ae = (u.stackRestore = function () {
                return (ae = u.stackRestore = u.asm.stackRestore).apply(null, arguments);
              }),
              re = (u.stackAlloc = function () {
                return (re = u.stackAlloc = u.asm.stackAlloc).apply(null, arguments);
              });
            function ue(e) {
              (this.name = 'ExitStatus'), (this.message = 'Program terminated with exit(' + e + ')'), (this.status = e);
            }
            function ie(e) {
              function n() {
                J ||
                  ((J = !0),
                  (u.calledRun = !0),
                  I ||
                    (G(L),
                    t(u),
                    u.onRuntimeInitialized && u.onRuntimeInitialized(),
                    (function () {
                      if (u.postRun)
                        for ('function' == typeof u.postRun && (u.postRun = [u.postRun]); u.postRun.length; )
                          (e = u.postRun.shift()), z.unshift(e);
                      var e;
                      G(z);
                    })()));
              }
              j > 0 ||
                ((function () {
                  if (u.preRun)
                    for ('function' == typeof u.preRun && (u.preRun = [u.preRun]); u.preRun.length; ) (e = u.preRun.shift()), W.unshift(e);
                  var e;
                  G(W);
                })(),
                j > 0 ||
                  (u.setStatus
                    ? (u.setStatus('Running...'),
                      setTimeout(function () {
                        setTimeout(function () {
                          u.setStatus('');
                        }, 1),
                          n();
                      }, 1))
                    : n()));
            }
            if (
              ((u.dynCall_iijjiiii = function () {
                return (u.dynCall_iijjiiii = u.asm.dynCall_iijjiiii).apply(null, arguments);
              }),
              (u.dynCall_jiji = function () {
                return (u.dynCall_jiji = u.asm.dynCall_jiji).apply(null, arguments);
              }),
              (u.cwrap = function (e, t, n, a) {
                var r = (n = n || []).every(function (e) {
                  return 'number' === e;
                });
                return 'string' !== t && r && !a
                  ? S(e)
                  : function () {
                      return M(e, t, n, arguments);
                    };
              }),
              (H = function e() {
                J || ie(), J || (H = e);
              }),
              (u.run = ie),
              u.preInit)
            )
              for ('function' == typeof u.preInit && (u.preInit = [u.preInit]); u.preInit.length > 0; ) u.preInit.pop()();
            if (
              (ie(),
              r &&
                (ee = {
                  uncaughtException: process.listeners('uncaughtException').filter(function (e) {
                    return !r.uncaughtException.indexOf(e) > -1;
                  }),
                  unhandledRejection: process.listeners('unhandledRejection').filter(function (e) {
                    return !r.unhandledRejection.indexOf(e) > -1;
                  }),
                }),
              'undefined' != typeof e)
            )
              te = e;
            else {
              if ('undefined' == typeof WasmBackendModuleThreadedSimd) throw new Error('Could not find wasm module in post.js');
              te = WasmBackendModuleThreadedSimd;
            }
            if (ee) {
              var se = te._dispose;
              te._dispose = function () {
                se(),
                  ee.uncaughtException.forEach(function (e) {
                    process.removeListener('uncaughtException', e);
                  }),
                  ee.unhandledRejection.forEach(function (e) {
                    process.removeListener('unhandledRejection', e);
                  });
              };
            }
            return e.ready;
          });
      e.exports = a;
    }),
    Yn = Xn || Qn,
    $n = Zn || Object.assign(Object.create(null), Zn, { default: Zn }),
    Jn = (function (e) {
      function n(n) {
        var a = e.call(this) || this;
        return (
          (a.wasm = n),
          (a.dataIdNextNumber = 1),
          a.wasm.tfjs.initWithThreadsCount(oa),
          (da = a.wasm.tfjs.getThreadsCount()),
          (a.dataIdMap = new t.DataStorage(a, t.engine())),
          a
        );
      }
      return (
        (function (e, t) {
          if ('function' != typeof t && null !== t)
            throw new TypeError('Class extends value ' + String(t) + ' is not a constructor or null');
          function n() {
            this.constructor = e;
          }
          b(e, t), (e.prototype = null === t ? Object.create(t) : ((n.prototype = t.prototype), new n()));
        })(n, e),
        (n.prototype.write = function (e, t, n) {
          var a = { id: this.dataIdNextNumber++ };
          return this.move(a, e, t, n, 1), a;
        }),
        (n.prototype.numDataIds = function () {
          return this.dataIdMap.numDataIds();
        }),
        (n.prototype.time = function (e) {
          return _(this, void 0, void 0, function () {
            var n;
            return y(this, function (a) {
              return (n = t.util.now()), e(), [2, { kernelMs: t.util.now() - n }];
            });
          });
        }),
        (n.prototype.move = function (e, n, a, r, u) {
          var i = this.dataIdNextNumber++;
          if ('string' !== r) {
            var s = t.util.sizeFromShape(a),
              o = s * t.util.bytesPerElement(r),
              d = this.wasm._malloc(o);
            this.dataIdMap.set(e, { id: i, memoryOffset: d, shape: a, dtype: r, refCount: u }),
              this.wasm.tfjs.registerTensor(i, s, d),
              null != n && this.wasm.HEAPU8.set(new Uint8Array(n.buffer, n.byteOffset, o), d);
          } else {
            var l = n;
            this.dataIdMap.set(e, { id: i, stringBytes: l, shape: a, dtype: r, memoryOffset: null, refCount: u });
          }
        }),
        (n.prototype.read = function (e) {
          return _(this, void 0, void 0, function () {
            return y(this, function (t) {
              return [2, this.readSync(e)];
            });
          });
        }),
        (n.prototype.readSync = function (e, n, a) {
          var r = this.dataIdMap.get(e),
            u = r.memoryOffset,
            i = r.dtype,
            s = r.shape,
            o = r.stringBytes;
          if ('string' === i) return (null != n && 0 !== n) || !(null == a || a >= o.length) ? o.slice(n, a) : o;
          (n = n || 0), (a = a || t.util.sizeFromShape(s));
          var d = t.util.bytesPerElement(i);
          return (function (e, t) {
            switch (t) {
              case 'float32':
                return new Float32Array(e);
              case 'int32':
                return new Int32Array(e);
              case 'bool':
                return new Uint8Array(e);
              default:
                throw new Error('Unknown dtype ' + t);
            }
          })(this.wasm.HEAPU8.slice(u + n * d, u + a * d).buffer, i);
        }),
        (n.prototype.disposeData = function (e, t) {
          if ((void 0 === t && (t = !1), this.dataIdMap.has(e))) {
            var n = this.dataIdMap.get(e);
            if ((n.refCount--, !t && n.refCount > 0)) return !1;
            this.wasm._free(n.memoryOffset), this.wasm.tfjs.disposeData(n.id), this.dataIdMap.delete(e);
          }
          return !0;
        }),
        (n.prototype.refCount = function (e) {
          return this.dataIdMap.has(e) ? this.dataIdMap.get(e).refCount : 0;
        }),
        (n.prototype.incRef = function (e) {
          var t = this.dataIdMap.get(e);
          null != t && t.refCount++;
        }),
        (n.prototype.floatPrecision = function () {
          return 32;
        }),
        (n.prototype.getMemoryOffset = function (e) {
          return this.dataIdMap.get(e).memoryOffset;
        }),
        (n.prototype.dispose = function () {
          this.wasm.tfjs.dispose(), 'PThread' in this.wasm && this.wasm.PThread.terminateAllThreads(), (this.wasm = null);
        }),
        (n.prototype.memory = function () {
          return { unreliable: !1 };
        }),
        (n.prototype.makeOutput = function (e, n, a) {
          var r;
          if (null == a) r = this.write(null, e, n);
          else {
            var u = this.dataIdNextNumber++;
            (r = { id: u }), this.dataIdMap.set(r, { id: u, memoryOffset: a, shape: e, dtype: n, refCount: 1 });
            var i = t.util.sizeFromShape(e);
            this.wasm.tfjs.registerTensor(u, i, a);
          }
          return { dataId: r, shape: e, dtype: n };
        }),
        (n.prototype.typedArrayFromHeap = function (e) {
          var n = e.shape,
            a = e.dtype,
            r = e.dataId,
            u = this.wasm.HEAPU8.buffer,
            i = this.dataIdMap.get(r).memoryOffset,
            s = t.util.sizeFromShape(n);
          switch (a) {
            case 'float32':
              return new Float32Array(u, i, s);
            case 'int32':
              return new Int32Array(u, i, s);
            case 'bool':
              return new Uint8Array(u, i, s);
            default:
              throw new Error('Unknown dtype ' + a);
          }
        }),
        n
      );
    })(t.KernelBackend);
  function ea(e, t, n) {
    if (null != aa) return aa;
    var a = 'tfjs-backend-wasm.wasm';
    return (
      e && t ? (a = 'tfjs-backend-wasm-threaded-simd.wasm') : e && (a = 'tfjs-backend-wasm-simd.wasm'),
      null != ua && null != ua[a] ? ua[a] : n + a
    );
  }
  function ta() {
    return _(this, void 0, void 0, function () {
      var e, n, a;
      return y(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, Promise.all([t.env().getAsync('WASM_HAS_SIMD_SUPPORT'), t.env().getAsync('WASM_HAS_MULTITHREAD_SUPPORT')])];
          case 1:
            return (
              (e = g.apply(void 0, [r.sent(), 2])),
              (n = e[0]),
              (a = e[1]),
              [
                2,
                new Promise(function (e, r) {
                  var u,
                    i = {};
                  (i.locateFile = function (e, t) {
                    if (e.endsWith('.worker.js')) {
                      var r =
                          '"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=((info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports});self.onmessage=(e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInit();try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(Module["keepRuntimeAlive"]()){Module["PThread"].setExitStatus(result)}else{Module["__emscripten_thread_exit"](result)}}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else if(e.data.cmd==="processProxyingQueue"){if(Module["_pthread_self"]()){Module["_emscripten_proxy_execute_queue"](e.data.queue)}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}});'.replace(
                            /\n/g,
                            '\\n',
                          ),
                        u = new Blob([r], { type: 'application/javascript' });
                      return URL.createObjectURL(u);
                    }
                    return e.endsWith('.wasm') ? ea(n, a, null != ra ? ra : t) : t + e;
                  }),
                    sa &&
                      (i.instantiateWasm =
                        ((u = ea(n, a, null != ra ? ra : '')),
                        function (e, n) {
                          return (
                            t.util.fetch(u, { credentials: 'same-origin' }).then(function (t) {
                              t.ok || e.env.a("failed to load wasm binary file at '" + u + "'"),
                                t.arrayBuffer().then(function (t) {
                                  WebAssembly.instantiate(t, e).then(function (e) {
                                    n(e.instance, e.module);
                                  });
                                });
                            }),
                            {}
                          );
                        }));
                  var s,
                    o = !1;
                  (i.onAbort = function () {
                    if (!o && !ia) {
                      ia = !0;
                      r({
                        message:
                          'Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers',
                      });
                    }
                  }),
                    a && n && null == aa
                      ? ((i.mainScriptUrlOrBlob = new Blob(['var WasmBackendModuleThreadedSimd = ' + Yn.toString()], {
                          type: 'text/javascript',
                        })),
                        (s = Yn(i)))
                      : (s = $n(i)),
                    s
                      .then(function (t) {
                        (o = !0), (ia = !1);
                        (t.tfjs = {
                          init: t.cwrap('init', null, []),
                          initWithThreadsCount: t.cwrap('init_with_threads_count', null, ['number']),
                          getThreadsCount: t.cwrap('get_threads_count', 'number', []),
                          registerTensor: t.cwrap('register_tensor', null, ['number', 'number', 'number']),
                          disposeData: t.cwrap('dispose_data', null, ['number']),
                          dispose: t.cwrap('dispose', null, []),
                        }),
                          e({ wasm: t });
                      })
                      .catch(r);
                }),
              ]
            );
        }
      });
    });
  }
  var na = ['tfjs-backend-wasm.wasm', 'tfjs-backend-wasm-simd.wasm', 'tfjs-backend-wasm-threaded-simd.wasm'],
    aa = null,
    ra = null,
    ua = {},
    ia = !1,
    sa = !1;
  var oa = -1,
    da = -1;
  t.registerBackend(
    'wasm',
    function () {
      return _(undefined, void 0, void 0, function () {
        var e;
        return y(this, function (t) {
          switch (t.label) {
            case 0:
              return [4, ta()];
            case 1:
              return (e = t.sent().wasm), [2, new Jn(e)];
          }
        });
      });
    },
    2,
  ),
    (e.BackendWasm = Jn),
    (e.getThreadsCount = function () {
      if (-1 === da) throw new Error('WASM backend not initialized.');
      return da;
    }),
    (e.setThreadsCount = function (e) {
      oa = e;
    }),
    (e.setWasmPath = function (e, n) {
      if (
        (void 0 === n && (n = !1),
        t.deprecationWarn('setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release.'),
        ia)
      )
        throw new Error(
          'The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`',
        );
      (aa = e), (sa = n);
    }),
    (e.setWasmPaths = function (e, t) {
      if ((void 0 === t && (t = !1), ia))
        throw new Error(
          'The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`',
        );
      if ('string' == typeof e) ra = e;
      else {
        ua = e;
        var n = na.filter(function (e) {
          return null == ua[e];
        });
        if (n.length > 0)
          throw new Error(
            'There were no entries found for the following binaries: ' +
              n.join(',') +
              '. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.',
          );
      }
      sa = t;
    }),
    (e.version_wasm = '3.20.0'),
    Object.defineProperty(e, '__esModule', { value: !0 });
});
//# sourceMappingURL=tf-backend-wasm.min.js.map
