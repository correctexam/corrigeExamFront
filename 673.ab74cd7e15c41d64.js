(self.webpackChunkgrade_scope_istic=self.webpackChunkgrade_scope_istic||[]).push([[673],{69989:(H,C,t)=>{"use strict";t.d(C,{O:()=>h});var e=t(15861),a=t(30003),u=t(14050);const c=a.GDt.whereImpl;let h=(()=>{class i extends a.Zuw{nextDataId(){return i.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new a.JLz(this,(0,a.SRH)())}write(l,o,n){this.firstUse&&(this.firstUse=!1,(0,a.OBj)().get("IS_NODE")&&a.backend_util.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:l,dtype:n,refCount:1}),s}makeTensorInfo(l,o,n){let s;if("string"===o&&null!=n&&n.length>0&&a.D5U.isString(n[0])){const r=n.map(d=>a.D5U.encodeString(d));s=this.write(r,l,o)}else s=this.write(n,l,o);return{dataId:s,shape:l,dtype:o}}refCount(l){return this.data.has(l)?this.data.get(l).refCount:0}incRef(l){this.data.get(l).refCount++}decRef(l){this.data.has(l)&&this.data.get(l).refCount--}move(l,o,n,s,r){this.data.set(l,{values:o,dtype:s,refCount:r})}numDataIds(){return this.data.numDataIds()}read(l){var o=this;return(0,e.Z)(function*(){return o.readSync(l)})()}readSync(l){const{dtype:o,complexTensorInfos:n}=this.data.get(l);if("complex64"===o){const s=this.readSync(n.real.dataId),r=this.readSync(n.imag.dataId);return a.backend_util.mergeRealAndImagArrays(s,r)}return a.D5U.convertBackendValuesAndArrayBuffer(this.data.get(l).values,o)}bufferSync(l){const o=this.readSync(l.dataId);if("string"===l.dtype)try{const n=o.map(s=>a.D5U.decodeString(s));return(0,a.f3b)(l.shape,l.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,a.f3b)(l.shape,l.dtype,o)}makeOutput(l,o,n){return(0,a.SRH)().makeTensorFromTensorInfo(this.makeTensorInfo(o,n,l),this)}disposeData(l,o=!1){if(this.data.has(l)){if(this.data.get(l).refCount--,!o&&this.data.get(l).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(l);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(l)}return!0}disposeIntermediateTensorInfo(l){this.disposeData(l.dataId)}time(l){return(0,e.Z)(function*(){const o=a.D5U.now();return l(),{kernelMs:a.D5U.now()-o}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(l){(0,u.H)([l],"where");const o=this.readSync(l.dataId);return c(l.shape,o)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return i.nextDataId=0,i})()},14050:(H,C,t)=>{"use strict";t.d(C,{H:()=>a});var e=t(30003);function a(u,c){Array.isArray(u)||(u=[u]),u.forEach(h=>{null!=h&&e.D5U.assert("complex64"!==h.dtype,()=>`${c} does not support complex64 tensors in the CPU backend.`)})}},53777:(H,C,t)=>{"use strict";t.d(C,{bk:()=>u,fC:()=>h});var e=t(30003),a=t(14050);function u(i){const f=new Float32Array(i.length);for(let l=0;l<i.length;++l)f[l]=Math.abs(i[l]);return f}const h={kernelName:e.SYM,backendName:"cpu",kernelFunc:i=>{const{x:f}=i.inputs,l=i.backend;(0,a.H)(f,"abs");let o=new Float32Array(e.D5U.sizeFromShape(f.shape));return o=u(l.data.get(f.dataId).values),l.makeOutput(o,f.shape,f.dtype)}}},76931:(H,C,t)=>{"use strict";t.d(C,{EH:()=>c,IH:()=>i,j4:()=>f});var e=t(30003),a=t(89450),u=t(9642);const c=(0,a.b)((l,o)=>l+o),h=(0,u.H)((l,o,n,s)=>({real:l+n,imag:o+s})),i=(0,u.j)(e.mm_,c,h),f={kernelName:e.mm_,backendName:"cpu",kernelFunc:i}},19569:(H,C,t)=>{"use strict";t.d(C,{W:()=>a,i:()=>u});var e=t(30003);function a(c,h,i,f,l){const o=e.D5U.sizeFromShape(f),n=e.D5U.makeZerosTypedArray(l,i);for(let s=0;s<c.length;s++){const r=c[s];if(r<0)throw new Error("Input x must be non-negative!");r>=l||(n[r]+=o>0?h[s]:1)}return n}function u(c,h,i,f=!1){const l=c.shape[0],o=c.shape[1],n=(0,e.f3b)([l,i],h.dtype);for(let s=0;s<l;s++)for(let r=0;r<o;r++){const d=c.get(s,r);if(d<0)throw new Error("Input x must be non-negative!");d>=i||n.set(f?1:h.size>0?n.get(s,d)+h.get(s,r):n.get(s,d)+1,s,d)}return n}},38642:(H,C,t)=>{"use strict";t.d(C,{T0:()=>i,nv:()=>c});var e=t(30003),a=t(89450),u=t(9642);const c=(0,a.b)((f,l)=>f&l),h=(0,u.j)(e.hCO,c),i={kernelName:e.hCO,backendName:"cpu",kernelFunc:h}},21928:(H,C,t)=>{"use strict";t.d(C,{Mq:()=>o,pj:()=>l,sJ:()=>f});var e=t(30003),a=t(89450),u=t(33176),c=t(23392),h=t(36781),i=t(84353);function f(n,s,r,d){if("int32"===d)return[s,"int32",Int32Array.from(n)];if("bool"===d){const p=e.D5U.toTypedArray([0],r),[g,_]=(0,a.b)((v,M)=>v!==M?1:0)(s,[],n,p,"bool");return[_,"bool",g]}throw new Error(`Error in Cast: failed to cast ${r} to ${d}`)}function l(n){const{inputs:s,backend:r,attrs:d}=n,{x:p}=s,{dtype:g}=d;if("complex64"===g){if("complex64"===p.dtype)return(0,h.y)({inputs:{x:p},backend:r});const S=(0,u.l)(r,p.shape,p.dtype),P=l({inputs:{x:p},backend:r,attrs:{dtype:"float32"}}),L=(0,c.P)({inputs:{real:P,imag:S},backend:r});return r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(P),L}if("complex64"===p.dtype){const S=(0,i.k)({inputs:{input:p},backend:r}),P=l({inputs:{x:S},backend:r,attrs:{dtype:g}});return r.disposeIntermediateTensorInfo(S),P}if(!e.D5U.hasEncodingLoss(p.dtype,g)){const S=(0,h.y)({inputs:{x:p},backend:r});return{dataId:S.dataId,shape:S.shape,dtype:g}}const _=r.data.get(p.dataId).values,[v,M,T]=f(_,p.shape,p.dtype,g);return r.makeTensorInfo(v,M,T)}const o={kernelName:e.RFZ,backendName:"cpu",kernelFunc:l}},75079:(H,C,t)=>{"use strict";t.d(C,{__:()=>c,y2:()=>i});var e=t(30003),a=t(91623),u=t(91832);const c=(0,a.a)(f=>Math.ceil(f)),h=(0,u.O)(e.gJX,c),i={kernelName:e.gJX,backendName:"cpu",kernelFunc:h}},23392:(H,C,t)=>{"use strict";function a(c){const{inputs:h,backend:i}=c,{real:f,imag:l}=h,o=i.data.get(f.dataId).values,n=i.data.get(l.dataId).values,s=i.makeTensorInfo(f.shape,"complex64");return i.data.get(s.dataId).complexTensorInfos={real:i.makeTensorInfo(f.shape,"float32",o),imag:i.makeTensorInfo(l.shape,"float32",n)},s}t.d(C,{P:()=>a,z:()=>u});const u={kernelName:t(30003).Zz9,backendName:"cpu",kernelFunc:a}},39971:(H,C,t)=>{"use strict";t.d(C,{j:()=>a});var e=t(30003);function a(u,c,h,i){const f=e.D5U.getArrayFromDType(h,e.D5U.sizeFromShape(c));if(i&&"string"!==h){let l=0;u.forEach(o=>{const n=e.D5U.sizeFromShape(o.shape);f.set(o.vals,l),l+=n})}else{let l=0;u.forEach(o=>{const n="string"===h?e.backend_util.fromUint8ToStringArray(o.vals):o.vals;let s=0;for(let r=0;r<o.shape[0];++r){const d=r*c[1]+l;for(let p=0;p<o.shape[1];++p)f[d+p]=n[s++]}l+=o.shape[1]})}return f}},75190:(H,C,t)=>{"use strict";t.d(C,{Dg:()=>h,Kx:()=>i,tW:()=>c});var e=t(30003),a=t(89450),u=t(9642);const c=(0,a.b)((f,l)=>f===l?1:0),h=(0,u.j)(e.hdR,c,null,"bool"),i={kernelName:e.hdR,backendName:"cpu",kernelFunc:h}},622:(H,C,t)=>{"use strict";t.d(C,{Qq:()=>h,Ro:()=>c,SX:()=>i});var e=t(30003),a=t(91623),u=t(91832);const c=(0,a.a)(f=>Math.exp(f)),h=(0,u.O)(e.NEP,c,"float32"),i={kernelName:e.NEP,backendName:"cpu",kernelFunc:h}},27166:(H,C,t)=>{"use strict";t.d(C,{OF:()=>c,Vu:()=>i});var e=t(30003),a=t(91623),u=t(91832);const c=(0,a.a)(f=>Math.expm1(f)),h=(0,u.O)(e.Y0y,c),i={kernelName:e.Y0y,backendName:"cpu",kernelFunc:h}},1471:(H,C,t)=>{"use strict";t.d(C,{Ao:()=>i,r6:()=>c});var e=t(30003),a=t(91623),u=t(91832);const c=(0,a.a)(f=>Math.floor(f)),h=(0,u.O)(e.OR,c),i={kernelName:e.OR,backendName:"cpu",kernelFunc:h}},52465:(H,C,t)=>{"use strict";t.d(C,{m:()=>a});var e=t(30003);function a(u,c,h,i,f,l,o,n,s){const r=(0,e.f3b)([i,l],h);for(let d=0;d<i;d++){const p=[];let g=0;for(let _=0;_<f;_++){const v=u[d*f+_];g+=v*o[_],p.push(v)}if(g<0||g>=s/l)throw new Error(`Invalid indices: ${p} does not index into ${n}`);for(let _=0;_<l;_++)r.values[d*l+_]=c.get(...c.indexToLoc(g*l+_))}return r}},52697:(H,C,t)=>{"use strict";t.d(C,{i:()=>a});var e=t(30003);function a(u,c,h){const i=(0,e.f3b)(h,u.dtype);for(let f=0;f<i.size;++f){const o=i.indexToLoc(f).slice(),r=c.locToIndex([o[0],o[2]]);o[2]=c.values[r];const d=u.locToIndex(o);0<=d&&d<u.values.length&&(i.values[f]=u.values[d])}return i}},4730:(H,C,t)=>{"use strict";t.d(C,{Ce:()=>i,o:()=>c});var e=t(30003),a=t(89450),u=t(9642);const c=(0,a.b)((f,l)=>f>l?1:0),h=(0,u.j)(e.iZT,c,null,"bool"),i={kernelName:e.iZT,backendName:"cpu",kernelFunc:h}},47310:(H,C,t)=>{"use strict";t.d(C,{HL:()=>c,V:()=>i});var e=t(30003),a=t(89450),u=t(9642);const c=(0,a.b)((f,l)=>f>=l?1:0),h=(0,u.j)(e.Acj,c,null,"bool"),i={kernelName:e.Acj,backendName:"cpu",kernelFunc:h}},36781:(H,C,t)=>{"use strict";function a(c){const{inputs:h,backend:i}=c,{x:f}=h;return i.incRef(f.dataId),{dataId:f.dataId,shape:f.shape,dtype:f.dtype}}t.d(C,{I:()=>u,y:()=>a});const u={kernelName:t(30003).iJz,backendName:"cpu",kernelFunc:a}},2339:(H,C,t)=>{"use strict";t.d(C,{rO:()=>c,zh:()=>i});var e=t(30003),a=t(89450),u=t(9642);const c=(0,a.b)((f,l)=>f<l?1:0),h=(0,u.j)(e.vtC,c,null,"bool"),i={kernelName:e.vtC,backendName:"cpu",kernelFunc:h}},50033:(H,C,t)=>{"use strict";t.d(C,{lx:()=>c,m3:()=>i});var e=t(30003),a=t(89450),u=t(9642);const c=(0,a.b)((f,l)=>f<=l?1:0),h=(0,u.j)(e.CAk,c,null,"bool"),i={kernelName:e.CAk,backendName:"cpu",kernelFunc:h}},77142:(H,C,t)=>{"use strict";t.d(C,{b:()=>a});var e=t(30003);function a(u,c,h){const i=(c-u)/(h-1),f=e.D5U.makeZerosTypedArray(h,"float32");f[0]=u;for(let l=1;l<f.length;l++)f[l]=f[l-1]+i;return f}},46723:(H,C,t)=>{"use strict";t.d(C,{vX:()=>c,xM:()=>i});var e=t(30003),a=t(91623),u=t(91832);const c=(0,a.a)(f=>Math.log(f)),h=(0,u.O)(e.ZbH,c),i={kernelName:e.ZbH,backendName:"cpu",kernelFunc:h}},7727:(H,C,t)=>{"use strict";t.d(C,{B:()=>a});var e=t(30003);function a(u,c,h,i){const f=e.D5U.getTypedArrayFromDType(i,e.D5U.sizeFromShape(h));for(let l=0;l<f.length;++l){const o=l*c;let n=u[o];for(let s=0;s<c;++s){const r=u[o+s];(Number.isNaN(r)||r>n)&&(n=r)}f[l]=n}return f}},46160:(H,C,t)=>{"use strict";t.d(C,{eJ:()=>i,wS:()=>c});var e=t(30003),a=t(89450),u=t(9642);const c=(0,a.b)((f,l)=>Math.max(f,l)),h=(0,u.j)(e.BMI,c),i={kernelName:e.BMI,backendName:"cpu",kernelFunc:h}},28170:(H,C,t)=>{"use strict";t.d(C,{u0:()=>i,vP:()=>c});var e=t(30003),a=t(89450),u=t(9642);const c=(0,a.b)((f,l)=>Math.min(f,l)),h=(0,u.j)(e.q8u,c),i={kernelName:e.q8u,backendName:"cpu",kernelFunc:h}},37985:(H,C,t)=>{"use strict";t.d(C,{$3:()=>c,Jp:()=>i,f$:()=>f});var e=t(30003),a=t(89450),u=t(9642);const c=(0,a.b)((l,o)=>l*o),h=(0,u.H)((l,o,n,s)=>({real:l*n-o*s,imag:l*s+o*n})),i=(0,u.j)(e.wYn,c,h),f={kernelName:e.wYn,backendName:"cpu",kernelFunc:i}},19994:(H,C,t)=>{"use strict";t.d(C,{AF:()=>i,uC:()=>c});var e=t(30003),a=t(14050),u=t(37985);function c(f,l,o){const n=e.D5U.createScalarValue(-1,o);return(0,u.$3)([],l,n,f,o)}const i={kernelName:e.kuV,backendName:"cpu",kernelFunc:function h(f){const{inputs:l,backend:o}=f,{x:n}=l;(0,a.H)(n,"neg");const s=o.data.get(n.dataId).values,[r,d]=c(s,n.shape,n.dtype);return o.makeTensorInfo(d,n.dtype,r)}}},47555:(H,C,t)=>{"use strict";t.d(C,{Gj:()=>c,nP:()=>i});var e=t(30003),a=t(89450),u=t(9642);const c=(0,a.b)((f,l)=>f!==l?1:0),h=(0,u.j)(e.yQU,c,null,"bool"),i={kernelName:e.yQU,backendName:"cpu",kernelFunc:h}},12585:(H,C,t)=>{"use strict";t.d(C,{Iz:()=>i,Qg:()=>c});var e=t(30003),a=t(14050),u=t(1239);function c(f,l,o,n){const[s,r]=e.backend_util.computeOutAndReduceShapes(f,n),d=(0,e.x8V)(l,"int32"),p=e.D5U.makeZerosTypedArray(e.D5U.sizeFromShape(s),d),g=e.D5U.sizeFromShape(r);for(let _=0;_<p.length;++_){const v=_*g;let M=1;for(let T=0;T<g;++T)M*=o[v+T];p[_]=M}return{outVals:p,outShape:s,outDtype:d}}const i={kernelName:e.DlI,backendName:"cpu",kernelFunc:function h(f){const{inputs:l,backend:o,attrs:n}=f,{x:s}=l,{axis:r,keepDims:d}=n;(0,a.H)(s,"prod");const p=s.shape.length,g=e.D5U.parseAxisParam(r,s.shape),_=e.backend_util.getAxesPermutation(g,p);let v=g,M=s;const T=[];null!=_&&(M=(0,u.p)({inputs:{x:s},backend:o,attrs:{perm:_}}),T.push(M),v=e.backend_util.getInnerMostAxes(v.length,p));const S=o.data.get(M.dataId).values,{outVals:P,outShape:L,outDtype:N}=c(M.shape,M.dtype,S,v);let O=L;return d&&(O=e.backend_util.expandShapeToKeepDim(L,g)),T.forEach(b=>o.disposeIntermediateTensorInfo(b)),o.makeTensorInfo(O,N,P)}}},86134:(H,C,t)=>{"use strict";t.d(C,{c:()=>o});var e=t(30003);function i(n,s){const r=n.slice(0,s);for(;r.length<s;)r.push(1);for(let d=s;d<n.length;d++)r[s-1]*=n[d];return r}function o(n,s,r,d,p,g,_,v){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===s[0].length)throw new Error("Split tensors must not be scalars");if(function a(n,s,r){n.forEach((d,p)=>{if(d<0||d>=r){const g=e.D5U.indexToLoc(p,s.length,e.D5U.computeStrides(s)).join(",");throw new Error(`indices[${g}] = ${d} is not in [0, ${r})`)}})}(g,_,s[0][0]-1),0===d.length)throw new Error("params.rank must be nonzero");const T=d[0],{outSplits:S,valueSlices:P,numValues:L}=function c(n,s,r,d){const p=[];let g=0;const v=new Array(s.length-1+r.length).fill(null).map(()=>[0]);!function u(n,s){for(let r=0;r<n.length;++r){const d=n[r],p=r===n.length-1?s:n[r+1].length;if(0===d.length)throw new Error("Ragged splits may not be empty");if(d[0]<0)throw new Error("Ragged splits must be non-negative");if(d[d.length-1]>p)throw new Error("Ragged splits must not point past values");for(let g=1;g<d.length;++g)if(d[g-1]>d[g])throw new Error("Ragged splits must be sorted in ascending order")}}(r,d);let M=1;for(let T=0;T<s.length-1;++T){M*=s[T];const S=s[T+1];for(let P=1;P<M+1;++P)v[T].push(P*S)}for(let T=0;T<n.length;++T){let S=n[T],P=n[T]+1;for(let L=0;L<r.length;++L){const N=r[L],O=L+s.length-1;if(O>=0){const b=v[O],E=b[b.length-1]-N[S];for(let $=S;$<P;++$)v[O].push(N[$+1]+E)}S=N[S],P=N[P]}P!==S&&(p.push([S,P]),g+=P-S)}return{outSplits:v,valueSlices:p,numValues:g}}(g,_,n,T),N=function h(n){const s=[];for(let r=0;r<n.length;++r){const p=e.D5U.getArrayFromDType("int32",n[r].length);s.push(p),n[r].forEach((g,_)=>p[_]=g)}return s}(S),O=function l(n,s,r,d,p){const g=s.slice();g[0]=p;const _=e.D5U.getArrayFromDType(r,e.D5U.sizeFromShape(g)),v=n.length;return function f(n,s,r,d,p,g){const _=i(s,2)[1],v=i(g,2)[1];let M=0;for(const T of r)for(let S=T[0];S<T[1];++S){for(let P=0;P<d;++P)p[M*v+P]=n[S*_+P];++M}}(n,s,d,0===v?0:v/s[0],_,g),[_,g]}(r,d,p,P,L);return[N,O[0],O[1]]}},20832:(H,C,t)=>{"use strict";t.d(C,{S:()=>u});var e=t(30003);const a=2147483647;function u(c,h,i,f,l,o,n){if(h.length>1)throw new Error("starts must be a scalar or vector");if(l.length>1)throw new Error("limits must be a scalar or vector");if(n.length>1)throw new Error("deltas must be a scalar or vector");const s=0===h.length,r=0===l.length,d=0===n.length,p=[];s||p.push(h[0]),r||p.push(l[0]),d||p.push(n[0]);for(let S=1;S<p.length;++S)if(p[S]!==p[S-1])throw new Error("starts, limits, and deltas must have the same shape");const g=0===p.length?1:p[0],_=e.D5U.getArrayFromDType("int32",g+1);_[0]=0;for(let S=0;S<g;++S){const P=s?c[0]:c[S],L=r?f[0]:f[S],N=d?o[0]:o[S];if(0===N)throw new Error("Requires delta != 0");let O;if(N>0&&L<P||N<0&&L>P)O=0;else if(O=Math.ceil(Math.abs((L-P)/N)),O>a)throw new Error(`Requires ((limit - start) / delta) <= ${a}`);_[S+1]=_[S]+O}const M=e.D5U.getArrayFromDType(i,_[g]);let T=0;for(let S=0;S<g;++S){const P=_[S+1]-_[S];let L=s?c[0]:c[S];const N=d?o[0]:o[S];for(let O=0;O<P;++O)M[T++]=L,L+=N}return[_,M]}},50820:(H,C,t)=>{"use strict";t.d(C,{p:()=>i});var e=t(30003),a=e.backend_util.RowPartitionType;class u{constructor(l,o,n,s,r,d,p,g,_,v){this.shape=l,this.shapeShape=o,this.values=n,this.valuesShape=s,this.valuesDType=r,this.defaultValue=d,this.defaultValueShape=p,this.rowPartitionValues=g,this.rowPartitionValuesShapes=_,this.rowPartitionTypes=e.backend_util.getRowPartitionTypesHelper(v),this.raggedRank=e.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(l){return this.rowPartitionTypes[0]===a.FIRST_DIM_SIZE?this.rowPartitionTypes[l+1]:this.rowPartitionTypes[l]}getRowPartitionTensor(l){return this.rowPartitionTypes[0]===a.FIRST_DIM_SIZE?this.rowPartitionValues[l+1]:this.rowPartitionValues[l]}getMaxWidth(l){const o=this.getRowPartitionTensor(l-1);switch(this.getRowPartitionTypeByDimension(l-1)){case a.VALUE_ROWIDS:return u.getMaxWidthValueRowID(o);case a.ROW_SPLITS:return u.getMaxWidthRowSplit(o);default:throw new Error(`Cannot handle partition type ${a[this.getRowPartitionTypeByDimension(l-1)]}`)}}static getMaxWidthRowSplit(l){const o=l.length;if(0===o||1===o)return 0;let n=0;for(let s=0;s<o-1;++s){const r=l[s+1]-l[s];r>n&&(n=r)}return n}static getMaxWidthValueRowID(l){const o=l.length;if(0===o)return 0;let n=0,s=l[0],r=0;for(let d=1;d<o;++d){const p=l[d];p!==s&&(s=p,r=Math.max(d-n,r),n=d)}return Math.max(o-n,r)}tensorShapeFromTensor(l,o,n=!0){if(0===o.length){if(-1===l[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return h(l,n)}calculateOutputSize(l){const o=this.valuesShape;e.backend_util.validateDefaultValueShape(this.defaultValueShape,o);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),d=e.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,s,o);d[0]<0&&(d[0]=l);for(let p=1;p<=this.raggedRank;++p)d[p]<0&&(d[p]=this.getMaxWidth(p));return d}calculateFirstParentOutputIndex(l,o,n){const s=Math.min(l,n),r=[];let d=0;for(let p=0;p<s;++p,d+=o)r.push(d);for(let p=s;p<l;++p)r.push(-1);return e.D5U.assert(r.length===l,()=>"Final length of result must be equal to firstDimension."),r}calculateOutputIndexRowSplit(l,o,n,s){const r=l.length,d=[];for(let p=0;p<r-1;++p){const g=l[p+1]-l[p];let _=Math.min(s,g),v=o[p];-1===v&&(_=0);for(let M=0;M<_;++M)d.push(v),v+=n;for(let M=0;M<g-_;++M)d.push(-1)}if(r>0&&d.length!==l[r-1])throw new Error("Invalid row split size.");return d}calculateOutputIndexValueRowID(l,o,n,s){const r=l.length,d=[];if(0===r)return[];let p=0,g=l[0];if(g>=o.length)throw new Error(`Got currentValueRowId=${g}, which is not less than ${o.length}`);let _=o[g];d.push(_);for(let v=1;v<r;++v){const M=l[v];if(M===g)_>=0&&(++p,p<s?_+=n:_=-1);else{if(p=0,g=M,M>=o.length)throw new Error(`Got nextValueRowId=${M} which is not less than ${o.length}`);_=o[M]}d.push(_)}if(d.length!==l.length)throw new Error("Invalid row ids.");return d}calculateOutputIndex(l,o,n,s){const r=this.getRowPartitionTensor(l),d=this.getRowPartitionTypeByDimension(l);switch(d){case a.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,o,n,s);case a.ROW_SPLITS:if(r.length-1>o.length)throw new Error(`Row partition size is greater than output size: ${r.length-1} > ${o.length}`);return this.calculateOutputIndexRowSplit(r,o,n,s);default:throw new Error(`Unsupported partition type: ${a[d]}`)}}getFirstDimensionSize(){const l=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const o=this.rowPartitionTypes[0];switch(o){case a.FIRST_DIM_SIZE:return l[0];case a.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case a.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${a[o]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const o=this.getFirstDimensionSize(),n=this.calculateOutputSize(o),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let g=s.length-2;g>=0;--g)s[g]=s[g+1]*n[g+1];const r=h(n,!1),d=e.D5U.getArrayFromDType(this.valuesDType,e.D5U.sizeFromShape(r));if(s[0]*n[0]>0){let g=this.calculateFirstParentOutputIndex(o,s[0],n[0]);for(let _=1;_<=this.raggedRank;++_)g=this.calculateOutputIndex(_-1,g,s[_],n[_]);this.setOutput(this.raggedRank,g,d,r)}return[r,d]}setOutput(l,o,n,s){if(0===n.length)return;const r=this.values,d=n;let p=s.slice();p=p.slice(l+1);const g=e.D5U.sizeFromShape(p),_=o.length;let v=this.defaultValue;if(v.length!==g&&1!==v.length){const P=this.defaultValueShape;(0,e.lub)(()=>{const L=(0,e.XLQ)(v,P);v=(0,e.UFq)(L,p).dataSync()})}let M=0,T=0,S=0;for(let P=0;P<=_;++P){let L=P<_?o[P]:-1;if(L!==S){if(T<S){const N=r.subarray(M*g);c(d.subarray(T*g),N,(S-T)*g)}if(P>=_&&(L=Math.floor(n.length/g)),L>S)if(1===this.defaultValue.length)d.subarray(S*g,L*g).fill(this.defaultValue[0]),S=L;else for(;L>S;)c(d.slice(S*g),v,g),++S;L<0?(M=P+1,T=S):(M=P,T=S,S=T+1)}else++S}}}function c(f,l,o){for(let n=0;n<o;n++)f[n]=l[n]}function h(f,l){const o=[];for(let n of f){if(n<0){if(!l)throw new Error(`Dimension ${n} must be >= 0`);if(n<-1)throw new Error(`Dimension ${n} must be >= -1`);n=-1}o.push(n)}return o}function i(f,l,o,n,s,r,d,p,g,_){return new u(f,l,o,n,s,r,d,p,g,_).compute()}},26229:(H,C,t)=>{"use strict";t.d(C,{b:()=>a});var e=t(30003);function a(u,c,h,i){if(u===c||u<c&&h<0||c<u&&h>1)return e.D5U.makeZerosTypedArray(0,i);const n=Math.abs(Math.ceil((c-u)/h)),s=e.D5U.makeZerosTypedArray(n,i);c<u&&1===h&&(h=-1),s[0]=u;for(let r=1;r<s.length;r++)s[r]=s[r-1]+h;return s}},84353:(H,C,t)=>{"use strict";function a(c){const{inputs:h,backend:i}=c,{input:f}=h,l=i.data.get(f.dataId).complexTensorInfos.real,o=i.data.get(l.dataId).values;return i.makeTensorInfo(l.shape,l.dtype,o)}t.d(C,{O:()=>u,k:()=>a});const u={kernelName:t(30003).xJR,backendName:"cpu",kernelFunc:a}},41509:(H,C,t)=>{"use strict";t.d(C,{FY:()=>i,zd:()=>c});var e=t(30003),a=t(91623),u=t(91832);const c=(0,a.a)(f=>1/Math.sqrt(f)),h=(0,u.O)(e.bV0,c),i={kernelName:e.bV0,backendName:"cpu",kernelFunc:h}},32529:(H,C,t)=>{"use strict";t.d(C,{N:()=>a});var e=t(30003);function a(u,c,h,i,f,l,o,n,s,r){const d=[i/f,f],p=u.values,g=c.values;if(0===i)return(0,e.f3b)(h,c.dtype);const _=s instanceof e.YDk?s:(0,e.f3b)(d,c.dtype);"string"==typeof s||"number"==typeof s?_.values.fill(s):"boolean"==typeof s&&_.values.fill(+s);for(let v=0;v<l;v++){const M=[];let T=0;for(let S=0;S<o;S++){const P=p[v*o+S];M.push(P),T+=P*n[S]}if(T<0||T>=i/f)throw new Error(`Invalid indices: ${M} does not index into ${h}`);for(let S=0;S<f;S++)r?_.values[T*f+S]+=g[v*f+S]:_.values[T*f+S]=0===c.rank?g[0]:g[v*f+S]}return _}},42250:(H,C,t)=>{"use strict";t.d(C,{BP:()=>i,VY:()=>c,XD:()=>h});var e=t(30003),a=t(91623),u=t(91832);const c=(0,a.a)(f=>1/(1+Math.exp(-f))),h=(0,u.A)(e.a5O,f=>1/(1+Math.exp(-f))),i={kernelName:e.a5O,backendName:"cpu",kernelFunc:h}},45006:(H,C,t)=>{"use strict";t.d(C,{C6:()=>h,rT:()=>u,tP:()=>c});var e=t(30003),a=t(14050);function u(i,f,l,o,n){const s=e.kuN.isSliceContinous(o,f,l),r=e.D5U.sizeFromShape(l),d=e.D5U.computeStrides(o);if(s){const v=e.kuN.computeFlatOffset(f,d);return"string"===n?i.slice(v,v+r):i.subarray(v,v+r)}const p="string"===n?e.backend_util.fromUint8ToStringArray(i):i,g=(0,e.f3b)(o,n,p),_=(0,e.f3b)(l,n);for(let v=0;v<_.size;++v){const M=_.indexToLoc(v),T=M.map((S,P)=>S+f[P]);_.set(g.get(...T),...M)}return"string"===n?e.backend_util.fromStringArrayToUint8(_.values):_.values}function c(i){const{inputs:f,backend:l,attrs:o}=i,{x:n}=f,{begin:s,size:r}=o;(0,a.H)(n,"slice");const[d,p]=e.kuN.parseSliceParams(n,s,r);e.kuN.assertParamsValid(n,d,p);const _=u(l.data.get(n.dataId).values,d,p,n.shape,n.dtype);return l.makeTensorInfo(p,n.dtype,_)}const h={kernelName:e.p2w,backendName:"cpu",kernelFunc:c}},5483:(H,C,t)=>{"use strict";t.d(C,{c:()=>a});var e=t(30003);function a(u,c,h,i,f,l,o){const n=c[0],s=l[0],r=new Array(s),d=new Array(n),p=c[1];if(0===s){if(0!==n)throw new Error(e.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(n));return[e.D5U.getArrayFromDType(h,0),[0,p],e.D5U.getArrayFromDType(f,0),r,d]}let g=!0,_=0;const v=new Array(s).fill(0);for(let T=0;T<n;++T){const S=u[T*p];if(S<0)throw new Error(e.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(T,S));if(S>=s)throw new Error(e.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(T,S,s));++v[S],g=g&&S>=_,_=S}let M=!0;for(let T=0;T<s;++T){const S=0===v[T];r[T]=S,M=M&&!S,v[T]=Math.max(v[T],1),T>0&&(v[T]+=v[T-1])}if(M&&g){const T=u,S=i;for(let P=0;P<n;++P)d[P]=P;return[T,[n,p],S,r,d]}{const T=v[s-1],S=e.D5U.getArrayFromDType(h,T*p),P=e.D5U.getArrayFromDType(f,T),L=new Array(s).fill(0);for(let N=0;N<n;++N){const O=u[N*p],E=(0===O?0:v[O-1])+L[O];L[O]++;for(let $=0;$<p;++$)S[E*p+$]=u[N*p+$];P[E]=i[N],d[N]=E}for(let N=0;N<s;++N)if(0===L[N]){const b=0===N?0:v[N-1];S[b*p+0]=N;for(let E=1;E<p;++E)S[b*p+E]=0;P[b]=o}return[S,[T,p],P,r,d]}}},59912:(H,C,t)=>{"use strict";t.d(C,{U:()=>a});var e=t(30003);function a(u,c,h,i,f){const l=e.D5U.sizeFromShape(i),o=c[0],n=f.length,s=[];let r=1,d=-1;for(let T=0;T<n;++T){const S=f[T];if(-1===S){if(-1!==d)throw new Error(e.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(d,T));d=T,s.push(1)}else{if(S<0)throw new Error(e.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(T,S));r*=S,s.push(S)}}if(-1!==d){if(r<=0)throw new Error(e.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const T=Math.trunc(l/r);if(r*T!==l)throw new Error(e.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(i,s));s[d]=T}if(e.D5U.sizeFromShape(s)!==l)throw new Error(e.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(i,s));const g=i.length,_=[];if(g>0){_[g-1]=1;for(let T=g-2;T>=0;--T)_[T]=_[T+1]*i[T+1]}const v=[];if(n>0){v[n-1]=1;for(let T=n-2;T>=0;--T)v[T]=v[T+1]*s[T+1]}const M=e.D5U.getArrayFromDType(h,o*n);for(let T=0;T<o;++T){let S=0;for(let P=0;P<g;++P)S+=u[T*g+P]*_[P];for(let P=0;P<n;++P)M[T*n+P]=Math.trunc(S/v[P]),S%=v[P]}return[M,[o,n],s]}},80391:(H,C,t)=>{"use strict";t.d(C,{V:()=>a});var e=t(30003);function a(u,c,h,i,f,l=!1,o=0){const n=i.length,s=[c[0],u.length/c[0]],r=s[1],p=n>0?f[n-1]+1:0;if(p<0)throw new Error(e.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const g=c.slice();g[0]=p;const _=g.reduce((L,N)=>L*N,1),v=e.D5U.getArrayFromDType(h,_);if(0===n)return p>0&&v.fill(o),[v,g];if(p<=0)throw new Error(e.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let M=0,T=1,S=0,P=f[M];for(;;){let L=0;if(T<n){if(L=f[T],P===L){++T;continue}if(P>=L)throw new Error(e.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(P<0||P>=p)throw new Error(e.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(P,p));P>S&&v.fill(o,S*r,P*r);for(let N=M;N<T;++N){const O=i[N];if(O<0||O>=s[0])throw new Error(e.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(N,i[N],s[0]));for(let b=0;b<r;b++)v[P*r+b]+=u[O*r+b]}if(l)for(let N=0;N<r;N++)v[P*r+N]/=T-M;if(M=T,++T,S=P+1,P=L,T>n)break}return S<p&&v.fill(o,S*r,p*r),[v,g]}},6769:(H,C,t)=>{"use strict";t.d(C,{cz:()=>i,zT:()=>c});var e=t(30003),a=t(91623),u=t(91832);const c=(0,a.a)(f=>Math.sqrt(f)),h=(0,u.A)(e.FKq,f=>Math.sqrt(f)),i={kernelName:e.FKq,backendName:"cpu",kernelFunc:h}},26893:(H,C,t)=>{"use strict";t.d(C,{P:()=>c,j:()=>i});var e=t(30003),a=t(91623),u=t(91832);const c=(0,a.a)((f,l)=>{const{pattern:o,replaceGlobal:n,rewrite:s}=l;return f.replace(new RegExp(o,n?"g":""),s)}),h=(0,u.O)(e.e0R,c),i={kernelName:e.e0R,backendName:"cpu",kernelFunc:h}},25549:(H,C,t)=>{"use strict";t.d(C,{t:()=>a});var e=t(30003);function a(u,c,h,i){const f=(0,e.f3b)(u,c.dtype);for(let l=0;l<f.size;l++){const o=f.indexToLoc(l),n=new Array(o.length);for(let s=0;s<n.length;s++)n[s]=o[s]*h[s]+i[s];f.set(c.get(...n),...o)}return f}},23118:(H,C,t)=>{"use strict";t.d(C,{A:()=>u});var e=t(30003);class a{constructor(h,i,f,l,o,n){this.separator=e.D5U.encodeString(h),this.nGramWidths=i,this.leftPad=e.D5U.encodeString(f),this.rightPad=e.D5U.encodeString(l),this.padWidth=o,this.preserveShort=n}getPadWidth(h){return Math.min(this.padWidth<0?h-1:this.padWidth,h-1)}getNumNGrams(h,i){const f=this.getPadWidth(i);return Math.max(0,h+2*f-i+1)}createNGrams(h,i,f,l,o,n){for(let s=0;s<o;++s){const r=this.getPadWidth(n),d=Math.max(0,r-s),p=Math.max(0,r-(o-(s+1))),g=n-(d+p),_=i+(d>0?0:s-r);let v=0;v+=d*this.leftPad.length;for(let L=0;L<g;++L)v+=h[_+L].length;v+=p*this.rightPad.length,v+=(d+p+g-1)*this.separator.length,f[l+s]=new Uint8Array(v);const T=f[l+s];let S=0;const P=L=>L.forEach(N=>T[S++]=N);for(let L=0;L<d;++L)P(this.leftPad),P(this.separator);for(let L=0;L<g-1;++L)P(h[_+L]),P(this.separator);if(g>0){P(h[_+g-1]);for(let L=0;L<p;++L)P(this.separator),P(this.rightPad)}else{for(let L=0;L<p-1;++L)P(this.rightPad),P(this.separator);P(this.rightPad)}}}compute(h,i){const f=h.length,l=i.length;if(l>0){let r=i[0];if(0!==r)throw new Error(`First split value must be 0, got ${r}`);for(let d=1;d<l;++d){let p=i[d]>=r;if(p=p&&i[d]<=f,!p)throw new Error(`Invalid split value ${i[d]}, must be in [${r}, ${f}]`);r=i[d]}if(r!==f)throw new Error(`Last split value must be data size. Expected ${f}, got ${r}`)}const o=l-1,n=e.D5U.getArrayFromDType("int32",l);if(0===f||0===l){const r=new Array(f);for(let d=0;d<=o;++d)n[d]=0;return[r,n]}n[0]=0;for(let r=1;r<=o;++r){const d=i[r]-i[r-1];let p=0;this.nGramWidths.forEach(g=>{p+=this.getNumNGrams(d,g)}),this.preserveShort&&d>0&&0===p&&(p=1),n[r]=n[r-1]+p}const s=new Array(n[o]);for(let r=0;r<o;++r){const d=i[r];let p=n[r];if(this.nGramWidths.forEach(g=>{const v=this.getNumNGrams(i[r+1]-i[r],g);this.createNGrams(h,d,s,p,v,g),p+=v}),this.preserveShort&&p===n[r]){const g=i[r+1]-i[r];if(0===g)continue;this.createNGrams(h,d,s,p,1,g+2*this.padWidth)}}return[s,n]}}function u(c,h,i,f,l,o,n,s){return new a(i,f,l,o,n,s).compute(c,h)}},6482:(H,C,t)=>{"use strict";t.d(C,{Q:()=>u});var e=t(30003);function a(c,h,i,f){if(!c.length)return;if(0===h.length){for(let o=0;o<c.length;++o)f.push(c.subarray(o,o+1));return}if(1===h.length){const o=h[0];let n=c.indexOf(o);for(;-1!==n;){const s=c.subarray(0,n);(!i||0!==s.length)&&f.push(s),n=(c=c.subarray(n+1)).indexOf(o)}return void((!i||0!==c.length)&&f.push(c))}let l=0;for(let o=0;o<c.length+1;o++)if(o===c.length||-1!==h.indexOf(c[o])){const n=c.subarray(l,o);(!i||0!==n.length)&&f.push(n),l=o+1}}function u(c,h,i){const f=c.length,l=[];let o=0,n=0;const s=new Array(f);for(let _=0;_<f;++_){const v=l.length;a(c[_],h,i,l);const M=l.length-v;s[_]=M,o+=M,n=Math.max(n,M)}const r=e.D5U.getArrayFromDType("int32",2*o),d=new Array(o),p=[f,n];let g=0;for(let _=0;_<f;++_)for(let v=0;v<s[_];++v)r[2*g]=_,r[2*g+1]=v,d[g]=l[g],++g;return[r,d,p]}},74105:(H,C,t)=>{"use strict";t.d(C,{h:()=>a});var e=t(30003);function a(u,c){const h=e.D5U.getArrayFromDType("int32",u.length);for(let i=0;i<u.length;++i)h[i]=e.D5U.fingerPrint64(u[i]).modulo(c).getLowBitsUnsigned();return h}},51981:(H,C,t)=>{"use strict";t.d(C,{GR:()=>f,VY:()=>c,lu:()=>i});var e=t(30003),a=t(89450),u=t(9642);const c=(0,a.b)((l,o)=>l-o),h=(0,u.H)((l,o,n,s)=>({real:l-n,imag:o-s})),i=(0,u.j)(e.Tr8,c,h),f={kernelName:e.Tr8,backendName:"cpu",kernelFunc:i}},91692:(H,C,t)=>{"use strict";t.d(C,{R:()=>a});var e=t(30003);function a(u,c){const h=new Array(u.rank);for(let f=0;f<h.length;f++)h[f]=u.shape[f]*c[f];const i=(0,e.f3b)(h,u.dtype);for(let f=0;f<i.values.length;++f){const l=i.indexToLoc(f),o=new Array(u.rank);for(let s=0;s<o.length;s++)o[s]=l[s]%u.shape[s];const n=u.locToIndex(o);i.values[f]=u.values[n]}return i}},39942:(H,C,t)=>{"use strict";t.d(C,{W:()=>c});var e=t(30003);const a=(h,i)=>{const f=i.value-h.value;return 0===f?h.index-i.index:f};function u(h,i,f=0,l=h.length-1){for(;l>f;){if(l-f>600){const r=l-f+1,d=i-f+1,p=Math.log(r),g=.5*Math.exp(2*p/3),_=.5*Math.sqrt(p*g*(r-g)/r)*Math.sign(d-r/2);u(h,i,Math.max(f,Math.floor(i-d*g/r+_)),Math.min(l,Math.floor(i+(r-d)*g/r+_)))}const o=h[i];let n=f,s=l;for(e.D5U.swap(h,f,i),a(h[l],o)>0&&e.D5U.swap(h,f,l);n<s;){for(e.D5U.swap(h,n,s),n++,s--;a(h[n],o)<0;)n+=1;for(;a(h[s],o)>0;)s-=1}0===a(h[f],o)?e.D5U.swap(h,f,s):(s+=1,e.D5U.swap(h,s,l)),s<=i&&(f=s+1),i<=s&&(l=s-1)}}function c(h,i,f,l,o){const n=i[i.length-1],[s,r]=[h.length/n,n],d=e.D5U.getTypedArrayFromDType(f,s*l),p=e.D5U.getTypedArrayFromDType("int32",s*l);for(let _=0;_<s;_++){const v=_*r,M=h.subarray(v,v+r);let T=new Array(M.length);M.forEach((N,O)=>T[O]={value:N,index:O}),l<T.length&&(u(T,l),T=T.slice(0,l)),o&&T.sort(a);const S=_*l,P=d.subarray(S,S+l),L=p.subarray(S,S+l);for(let N=0;N<l;N++)P[N]=T[N].value,L[N]=T[N].index}const g=i.slice();return g[g.length-1]=l,[(0,e.f3b)(g,f,d),(0,e.f3b)(g,"int32",p)]}},1239:(H,C,t)=>{"use strict";t.d(C,{b:()=>h,p:()=>c});var e=t(30003),a=t(14050),u=t(8385);function c(i){const{inputs:f,attrs:l,backend:o}=i,{x:n}=f,{perm:s}=l;(0,a.H)(n,"transpose");const d=new Array(n.shape.length);for(let v=0;v<d.length;v++)d[v]=n.shape[s[v]];const p=o.data.get(n.dataId).values,g=(0,u.H)(p,n.shape,n.dtype,s,d);return{dataId:o.write(g,d,n.dtype),shape:d,dtype:n.dtype}}const h={kernelName:e.G3Y,backendName:"cpu",kernelFunc:c}},8385:(H,C,t)=>{"use strict";t.d(C,{H:()=>a});var e=t(30003);function a(u,c,h,i,f){const l=c.length,o=e.D5U.sizeFromShape(c),n=e.D5U.computeStrides(c),s=e.D5U.computeStrides(f),r=e.D5U.getTypedArrayFromDType(h,e.D5U.sizeFromShape(f));for(let d=0;d<o;++d){const p=e.D5U.indexToLoc(d,l,n),g=new Array(p.length);for(let v=0;v<g.length;v++)g[v]=p[i[v]];r[e.D5U.locToIndex(g,l,s)]=u[d]}return r}},50705:(H,C,t)=>{"use strict";t.d(C,{S:()=>a});var e=t(30003);function a(u,c,h,i){const f=e.D5U.parseAxisParam(c,h)[0],l=[1,h[0],1];for(let v=0;v<f;v++)l[0]*=h[v];l[1]=h[f];for(let v=f+1;v<h.length;v++)l[2]*=h[v];const o=new Map,n=new Int32Array(h[f]),s=new e.YDk(l,i,u),r=[],d=1===l[0]&&1===l[2];for(let v=0;v<h[f];v++){let M;if(d)M=u[v].toString();else{const S=[];for(let P=0;P<l[0];P++)for(let L=0;L<l[2];L++)S.push(s.get(P,v,L));M=S.join(",")}const T=o.get(M);if(null!=T)n[v]=T;else{const S=o.size;o.set(M,S),n[v]=S,r.push(v)}}const p=l.slice();p[1]=o.size;const g=new e.YDk(p,i);r.forEach((v,M)=>{for(let T=0;T<l[0];T++)for(let S=0;S<l[2];S++)g.set(s.get(T,v,S),T,M,S)});const _=h.slice();return _[f]=p[1],{outputValues:g.values,outputShape:_,indices:n}}},67949:(H,C,t)=>{"use strict";var e=t(30003),a=t(91832);const u=(0,a.A)(e.SX0,Q=>Q>=0?Q:Math.exp(Q)-1),c={kernelName:e.SX0,backendName:"cpu",kernelFunc:u};var h=t(36781),i=t(14050);function f(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{alpha:z}=G;(0,i.H)([y],"leakyRelu");const rt=e.D5U.sizeFromShape(y.shape),nt=A.data.get(y.dataId).values,ot=e.D5U.getTypedArrayFromDType("float32",rt);for(let tt=0;tt<nt.length;tt++)ot[tt]=nt[tt]<0?z*nt[tt]:nt[tt];return A.makeTensorInfo(y.shape,"float32",ot)}const l={kernelName:e.J$2,backendName:"cpu",kernelFunc:f};var o=t(89450);const n=(0,o.b)((Q,et)=>Q<0?et*Q:Q);function s(Q){const{inputs:et,backend:A}=Q,{x:G,alpha:y}=et;(0,i.H)([G,y],"prelu");const z=A.data.get(G.dataId).values,rt=A.data.get(y.dataId).values,[nt,ot]=n(G.shape,y.shape,z,rt,"float32");return A.makeTensorInfo(ot,"float32",nt)}const r={kernelName:e.o0g,backendName:"cpu",kernelFunc:s},d=(0,a.A)(e.qkr,Q=>Math.max(0,Q)),p={kernelName:e.qkr,backendName:"cpu",kernelFunc:d},g=(0,a.A)(e.SbG,Q=>Math.min(Math.max(0,Q),6)),_={kernelName:e.SbG,backendName:"cpu",kernelFunc:g};var v=t(42250);function M(Q,et,A,G,y){if("linear"===A)return(0,h.y)({inputs:{x:et},backend:Q});if("relu"===A)return d({inputs:{x:et},backend:Q});if("elu"===A)return u({inputs:{x:et},backend:Q});if("relu6"===A)return g({inputs:{x:et},backend:Q});if("prelu"===A)return s({inputs:{x:et,alpha:G},backend:Q});if("leakyrelu"===A)return f({inputs:{x:et},backend:Q,attrs:{alpha:y}});if("sigmoid"===A)return(0,v.XD)({inputs:{x:et},backend:Q});throw new Error(`Activation ${A} has not been implemented for the CPU backend.`)}var T=t(76931);function S(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{shape:z}=G,rt=e.D5U.sizeFromShape(y.shape),nt=e.D5U.inferFromImplicitShape(z,rt),ot=e.D5U.sizeFromShape(nt);e.D5U.assert(rt===ot,()=>`The new shape (${nt}) has ${ot} elements and the old shape (${y.shape}) has ${rt} elements. The new shape and old shape must have the same number of elements.`),A.incRef(y.dataId);const tt=A.data.get(y.dataId);if(null!=tt.complexTensorInfos){const ft=tt.complexTensorInfos.imag;tt.complexTensorInfos.real.shape=nt,ft.shape=nt}return{dataId:y.dataId,shape:nt,dtype:y.dtype}}const P={kernelName:e.HZH,backendName:"cpu",kernelFunc:S};function L(Q){const{inputs:et,backend:A,attrs:G}=Q,{a:y,b:z}=et,{transposeA:rt,transposeB:nt}=G;(0,i.H)([y,z],"matMul");const ot=y.shape.length,tt=z.shape.length,J=rt?y.shape[ot-2]:y.shape[ot-1],ft=nt?z.shape[tt-1]:z.shape[tt-2],lt=rt?y.shape[ot-1]:y.shape[ot-2],Et=nt?z.shape[tt-2]:z.shape[tt-1],Ot=y.shape.slice(0,-2),Ct=z.shape.slice(0,-2),Tt=e.D5U.sizeFromShape(Ot),At=e.D5U.sizeFromShape(Ct),Wt=e.Jyw.assertAndGetBroadcastShape(y.shape.slice(0,-2),z.shape.slice(0,-2)).concat([lt,Et]);e.D5U.assert(J===ft,()=>`Error in matMul: inner shapes (${J}) and (${ft}) of Tensors with shapes ${y.shape} and ${z.shape} and transposeA=${rt} and transposeB=${nt} must match.`);const zt=nt?[At,Et,ft]:[At,ft,Et],Yt=S({inputs:{x:y},backend:A,attrs:{shape:rt?[Tt,J,lt]:[Tt,lt,J]}}),te=S({inputs:{x:z},backend:A,attrs:{shape:zt}}),pe=rt?Yt.shape[1]:Yt.shape[2],_e=rt?Yt.shape[2]:Yt.shape[1],me=nt?te.shape[1]:te.shape[2],Ce=Math.max(Tt,At),Oe=A.data.get(Yt.dataId).values,ue=A.data.get(te.dataId).values,fe=e.D5U.computeStrides(Yt.shape),le=e.D5U.computeStrides(te.shape),[ce,ve,de]=rt?[fe[0],1,fe[1]]:[fe[0],fe[1],1],[ge,ye,Pe]=nt?[1,le[1],le[0]]:[le[1],1,le[0]],$e=_e*me,Me=(0,e.f3b)([Ce,_e,me],Yt.dtype),Le=Me.values,be=A.blockSize;for(let ke=0;ke<Ce;ke++){const Ve=ke%Tt,He=ke%At;for(let ze=0;ze<_e;ze+=be){const Ze=Math.min(ze+be,_e);for(let qe=0;qe<me;qe+=be){const un=Math.min(qe+be,me);for(let pn=0;pn<pe;pn+=be){const xn=Math.min(pn+be,pe);for(let fn=ze;fn<Ze;fn++)for(let cn=qe;cn<un;cn++){let gn=0;for(let _n=pn;_n<xn;_n++)gn+=Oe[Ve*ce+fn*ve+_n*de]*ue[_n*ge+cn*ye+He*Pe];Le[ke*$e+(fn*me+cn)]+=gn}}}}}return A.disposeIntermediateTensorInfo(Yt),A.disposeIntermediateTensorInfo(te),A.makeTensorInfo(Wt,Me.dtype,Me.values)}const N={kernelName:e.XLW,backendName:"cpu",kernelFunc:L},b={kernelName:e.usg,backendName:"cpu",kernelFunc:function O(Q){const{inputs:et,backend:A,attrs:G}=Q,{a:y,b:z,bias:rt,preluActivationWeights:nt}=et,{transposeA:ot,transposeB:tt,activation:J,leakyreluAlpha:ft}=G;let lt,Et,Ot;const Ct=[];lt=L({inputs:{a:y,b:z},attrs:{transposeA:ot,transposeB:tt},backend:A}),rt&&(Et=(0,T.IH)({inputs:{a:lt,b:rt},backend:A}),Ct.push(lt),lt=Et),J&&(Ot=M(A,lt,J,nt,ft),Ct.push(lt),lt=Ot);for(const At of Ct)A.disposeIntermediateTensorInfo(At);return lt}};var E=t(53777);const $=(0,a.A)(e.VGw,Q=>Math.acos(Q)),W={kernelName:e.VGw,backendName:"cpu",kernelFunc:$},Z=(0,a.A)(e.SpW,Q=>Math.acosh(Q)),X={kernelName:e.SpW,backendName:"cpu",kernelFunc:Z},Dt={kernelName:e.Xze,backendName:"cpu",kernelFunc:function ut(Q){const{inputs:et,backend:A}=Q,G=et;(0,i.H)(et,"addN");const y=G.map(nt=>A.data.get(nt.dataId).values),z=(0,e.f3b)(G[0].shape,G[0].dtype),rt=z.values;for(let nt=0;nt<G.length;nt++){const ot=y[nt];for(let tt=0;tt<rt.length;tt++)rt[tt]+=ot[tt]}return A.makeTensorInfo(z.shape,z.dtype,z.values)}};var Y=t(1239);const Pt={kernelName:e.oT6,backendName:"cpu",kernelFunc:function ht(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{axis:z,keepDims:rt}=G;(0,i.H)(y,"all");const nt=e.D5U.parseAxisParam(z,y.shape);let ot=nt;const tt=e.backend_util.getAxesPermutation(ot,y.shape.length);let J=y;null!=tt&&(J=(0,Y.p)({inputs:{x:y},backend:A,attrs:{perm:tt}}),ot=e.backend_util.getInnerMostAxes(ot.length,y.shape.length)),e.backend_util.assertAxesAreInnerMostDims("all",ot,J.shape.length);const[ft,lt]=e.backend_util.computeOutAndReduceShapes(J.shape,ot),Et=e.D5U.sizeFromShape(lt),Ot=e.D5U.makeZerosTypedArray(e.D5U.sizeFromShape(ft),J.dtype),Ct=A.data.get(J.dataId).values;for(let At=0;At<Ot.length;++At){const Bt=At*Et;let Wt=Ct[Bt];for(let bt=0;bt<Et;++bt)Wt=Wt&&Ct[Bt+bt];Ot[At]=Wt}null!=tt&&A.disposeIntermediateTensorInfo(J);const Tt=A.makeTensorInfo(ft,J.dtype,Ot);if(rt){const Bt=S({inputs:{x:Tt},backend:A,attrs:{shape:e.backend_util.expandShapeToKeepDim(ft,nt)}});return A.disposeIntermediateTensorInfo(Tt),Bt}return Tt}},xt={kernelName:e.IKK,backendName:"cpu",kernelFunc:function pt(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{axis:z,keepDims:rt}=G;(0,i.H)(y,"any");const nt=e.D5U.parseAxisParam(z,y.shape);let ot=nt;const tt=e.backend_util.getAxesPermutation(ot,y.shape.length);let J=y;null!=tt&&(J=(0,Y.p)({inputs:{x:y},backend:A,attrs:{perm:tt}}),ot=e.backend_util.getInnerMostAxes(ot.length,y.shape.length)),e.backend_util.assertAxesAreInnerMostDims("any",ot,J.shape.length);const[ft,lt]=e.backend_util.computeOutAndReduceShapes(J.shape,ot),Et=e.D5U.sizeFromShape(lt),Ot=e.D5U.makeZerosTypedArray(e.D5U.sizeFromShape(ft),J.dtype),Ct=A.data.get(J.dataId).values;for(let At=0;At<Ot.length;++At){const Bt=At*Et;let Wt=Ct[Bt];for(let bt=0;bt<Et;++bt)Wt=Wt||Ct[Bt+bt];Ot[At]=Wt}null!=tt&&A.disposeIntermediateTensorInfo(J);const Tt=A.makeTensorInfo(ft,J.dtype,Ot);if(rt){const Bt=S({inputs:{x:Tt},backend:A,attrs:{shape:e.backend_util.expandShapeToKeepDim(ft,nt)}});return A.disposeIntermediateTensorInfo(Tt),Bt}return Tt}},Vt={kernelName:e.sJF,backendName:"cpu",kernelFunc:function Nt(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{axis:z}=G;(0,i.H)(y,"argMax");let rt=e.D5U.parseAxisParam(z,y.shape);const nt=e.backend_util.getAxesPermutation(rt,y.shape.length);let ot=y;const tt=[];null!=nt&&(ot=(0,Y.p)({inputs:{x:y},backend:A,attrs:{perm:nt}}),tt.push(ot),rt=e.backend_util.getInnerMostAxes(rt.length,ot.shape.length)),rt=[rt[0]],e.backend_util.assertAxesAreInnerMostDims("argMax",rt,ot.shape.length);const[J,ft]=e.backend_util.computeOutAndReduceShapes(ot.shape,rt),lt=e.D5U.sizeFromShape(J),Et=e.D5U.makeZerosTypedArray(lt,"int32"),Ot=e.D5U.sizeFromShape(ft),Ct=A.data.get(ot.dataId).values;for(let Tt=0;Tt<Et.length;++Tt){const At=Tt*Ot;let Bt=Ct[At],Wt=0;for(let bt=0;bt<Ot;++bt){const zt=Ct[At+bt];zt>Bt&&(Bt=zt,Wt=bt)}Et[Tt]=Wt}return tt.forEach(Tt=>A.disposeIntermediateTensorInfo(Tt)),A.makeTensorInfo(J,"int32",Et)}},oe={kernelName:e.aJk,backendName:"cpu",kernelFunc:function Gt(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{axis:z}=G;(0,i.H)(y,"argMin");let rt=e.D5U.parseAxisParam(z,y.shape);const nt=e.backend_util.getAxesPermutation(rt,y.shape.length);let ot=y;const tt=[];null!=nt&&(ot=(0,Y.p)({inputs:{x:y},backend:A,attrs:{perm:nt}}),tt.push(ot),rt=e.backend_util.getInnerMostAxes(rt.length,ot.shape.length)),rt=[rt[0]],e.backend_util.assertAxesAreInnerMostDims("argMin",rt,ot.shape.length);const[J,ft]=e.backend_util.computeOutAndReduceShapes(ot.shape,rt),lt=e.D5U.sizeFromShape(J),Et=e.D5U.makeZerosTypedArray(lt,"int32"),Ot=e.D5U.sizeFromShape(ft),Ct=A.data.get(ot.dataId).values;for(let Tt=0;Tt<Et.length;++Tt){const At=Tt*Ot;let Bt=Ct[At],Wt=0;for(let bt=0;bt<Ot;++bt){const zt=Ct[At+bt];zt<Bt&&(Bt=zt,Wt=bt)}Et[Tt]=Wt}return tt.forEach(Tt=>A.disposeIntermediateTensorInfo(Tt)),A.makeTensorInfo(J,"int32",Et)}},Ee=(0,a.A)(e.M2y,Q=>Math.asin(Q)),Ie={kernelName:e.M2y,backendName:"cpu",kernelFunc:Ee},ie=(0,a.A)(e.qw7,Q=>Math.asinh(Q)),Zt={kernelName:e.qw7,backendName:"cpu",kernelFunc:ie},ct=(0,a.A)(e.jMg,Q=>Math.atan(Q)),It={kernelName:e.jMg,backendName:"cpu",kernelFunc:ct};var Ut=t(9642);const q=(0,o.b)((Q,et)=>Math.atan2(Q,et)),K=(0,Ut.j)(e.QCc,q),j={kernelName:e.QCc,backendName:"cpu",kernelFunc:K},at=(0,a.A)(e.Oyi,Q=>Math.atanh(Q)),dt={kernelName:e.Oyi,backendName:"cpu",kernelFunc:at};function kt(Q,et,A,G,y,z){const rt=y.strideHeight,nt=y.strideWidth,ot=y.dilationHeight,tt=y.dilationWidth,J=y.effectiveFilterHeight,ft=y.effectiveFilterWidth,lt=y.padInfo.top,Et=y.padInfo.left,Ot="max"===z?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,Ct=(0,e.f3b)(y.outShape,A),Tt=Ct.values,At=y.outShape[1]*y.outShape[2]*y.outShape[3],Bt=y.outShape[2]*y.outShape[3],Wt=y.outShape[3];for(let bt=0;bt<y.batchSize;++bt){const zt=bt*At,Yt=bt*G[0];for(let te=0;te<y.inChannels;++te)for(let pe=0;pe<y.outHeight;++pe){const _e=pe*rt-lt,me=Math.max(0,_e),Ce=Math.min(y.inHeight,J+_e),Oe=zt+pe*Bt;for(let ue=0;ue<y.outWidth;++ue){const fe=ue*nt-Et,le=Math.max(0,fe),ce=Math.min(y.inWidth,ft+fe);let ve=Ot,de=0,ge=0;for(let Pe=me;Pe<Ce;Pe+=ot){const $e=Yt+Pe*G[1];for(let Me=le;Me<ce;Me+=tt){const be=Q[$e+Me*G[2]+te];"max"===z&&be>ve?ve=be:"avg"===z&&(de+=be,ge++)}if(isNaN(ve))break}Tt[Oe+ue*Wt+te]="avg"===z?de/ge:ve}}}return Ct}function jt(Q,et,A,G,y=!1,z=!1){const rt=(0,e.f3b)(G.outShape,"int32"),nt=G.strideHeight,ot=G.strideWidth,tt=G.dilationHeight,J=G.dilationWidth,ft=G.effectiveFilterHeight,lt=G.effectiveFilterWidth,Et=G.padInfo.top,Ot=G.padInfo.left,Ct=(0,e.f3b)(et,A,Q);for(let Tt=0;Tt<G.batchSize;++Tt)for(let At=0;At<G.inChannels;++At)for(let Bt=0;Bt<G.outHeight;++Bt){const Wt=Bt*nt-Et;let bt=Wt;for(;bt<0;)bt+=tt;const zt=Math.min(G.inHeight,ft+Wt);for(let Yt=0;Yt<G.outWidth;++Yt){const te=Yt*ot-Ot;let pe=te;for(;pe<0;)pe+=J;const _e=Math.min(G.inWidth,lt+te);let me=Number.NEGATIVE_INFINITY,Ce=-1;for(let Oe=bt;Oe<zt;Oe+=tt){const ue=Oe-Wt;for(let fe=pe;fe<_e;fe+=J){const le=fe-te,ce=Ct.get(Tt,Oe,fe,At);ce>me&&(me=ce,Ce=y?z?((Tt*G.inHeight+Oe)*G.inWidth+fe)*G.inChannels+At:(Oe*G.inWidth+fe)*G.inChannels+At:ue*lt+le)}}rt.set(Ce,Tt,Bt,Yt,At)}}return rt}function Jt(Q,et,A,G,y,z){const rt=y.strideDepth,nt=y.strideHeight,ot=y.strideWidth,tt=y.dilationDepth,J=y.dilationHeight,ft=y.dilationWidth,lt=y.effectiveFilterDepth,Et=y.effectiveFilterHeight,Ot=y.effectiveFilterWidth,Ct=y.padInfo.front,Tt=y.padInfo.top,At=y.padInfo.left,Bt="max"===z?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,Wt=(0,e.f3b)(y.outShape,A),bt=Wt.values,zt=y.outShape[1]*y.outShape[2]*y.outShape[3]*y.outShape[4],Yt=y.outShape[2]*y.outShape[3]*y.outShape[4],te=y.outShape[3]*y.outShape[4],pe=y.outShape[4];for(let _e=0;_e<y.batchSize;++_e){const me=_e*zt,Ce=_e*G[0];for(let Oe=0;Oe<y.inChannels;++Oe)for(let ue=0;ue<y.outDepth;++ue){const fe=ue*rt-Ct;let le=fe;for(;le<0;)le+=tt;const ce=Math.min(y.inDepth,lt+fe),ve=me+ue*Yt;for(let de=0;de<y.outHeight;++de){const ge=de*nt-Tt;let ye=ge;for(;ye<0;)ye+=J;const Pe=Math.min(y.inHeight,Et+ge),$e=ve+de*te;for(let Me=0;Me<y.outWidth;++Me){const Le=Me*ot-At;let be=Le;for(;be<0;)be+=ft;const ke=Math.min(y.inWidth,Ot+Le),Ve=$e+Me*pe;let He=Bt,ze=0,Ze=0;for(let un=le;un<ce;un+=tt){const pn=Ce+un*G[1];for(let xn=ye;xn<Pe;xn+=J){const fn=pn+xn*G[2];for(let cn=be;cn<ke;cn+=ft){const _n=Q[fn+cn*G[3]+Oe];if("max"===z&&_n>He?He=_n:"avg"===z&&(ze+=_n,Ze++),isNaN(He))break}if(isNaN(He))break}if(isNaN(He))break}bt[Ve+Oe]="avg"===z?ze/Math.max(Ze,1):He}}}}return Wt}const Be={kernelName:e.JhU,backendName:"cpu",kernelFunc:function Re(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et;(0,i.H)(y,"avgPool");const{filterSize:z,strides:rt,pad:nt,dimRoundingMode:ot}=G;e.D5U.assert(e.backend_util.eitherStridesOrDilationsAreOne(rt,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${rt} and dilations '1'`);const J=e.backend_util.computePool2DInfo(y.shape,z,rt,1,nt,ot);let ft;if(1===J.filterWidth&&1===J.filterHeight&&e.D5U.arraysEqual(J.inShape,J.outShape))ft=(0,h.y)({inputs:{x:y},backend:A});else{const lt=A.data.get(y.dataId).values,Et=e.D5U.computeStrides(y.shape),Ot=kt(lt,0,y.dtype,Et,J,"avg");ft=A.makeTensorInfo(J.outShape,y.dtype,Ot.values)}return ft}},we={kernelName:e._k9,backendName:"cpu",kernelFunc:function Se(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{filterSize:z,strides:rt,pad:nt,dimRoundingMode:ot,dataFormat:tt}=G;(0,i.H)(y,"avgPool3d");const J=e.backend_util.computePool3DInfo(y.shape,z,rt,1,nt,ot,tt),lt=Jt(A.data.get(y.dataId).values,0,y.dtype,e.D5U.computeStrides(y.shape),J,"avg");return A.makeTensorInfo(lt.shape,"float32",lt.values)}},Te={kernelName:e.IMb,backendName:"cpu",kernelFunc:function Ae(Q){const{inputs:et,backend:A,attrs:G}=Q,{dy:y,input:z}=et,{filterSize:rt,strides:nt,pad:ot,dimRoundingMode:tt}=G;(0,i.H)([y,z],"avgPool3DGrad");const J=e.backend_util.computePool3DInfo(z.shape,rt,nt,1,ot,tt),ft=J.strideDepth,lt=J.strideHeight,Et=J.strideWidth,Ot=J.filterDepth,Ct=J.filterHeight,Tt=J.filterWidth,At=J.dilationDepth,Bt=J.dilationHeight,Wt=J.dilationWidth,bt=J.effectiveFilterDepth,zt=J.effectiveFilterHeight,Yt=J.effectiveFilterWidth,te=bt-1-J.padInfo.front,pe=Yt-1-J.padInfo.left,_e=zt-1-J.padInfo.top,me=(0,e.f3b)(z.shape,"float32"),Ce=1/(Ot*Ct*Tt),Oe=A.bufferSync(y);for(let ue=0;ue<J.batchSize;++ue)for(let fe=0;fe<J.inChannels;++fe)for(let le=0;le<J.inDepth;++le)for(let ce=0;ce<J.inHeight;++ce)for(let ve=0;ve<J.inWidth;++ve){const de=le-te,ge=ce-_e,ye=ve-pe;let Pe=0;for(let $e=0;$e<bt;$e+=At){const Me=(de+$e)/ft;if(!(Me<0||Me>=J.outDepth||Math.floor(Me)!==Me))for(let Le=0;Le<zt;Le+=Bt){const be=(ge+Le)/lt;if(!(be<0||be>=J.outHeight||Math.floor(be)!==be))for(let ke=0;ke<Yt;ke+=Wt){const Ve=(ye+ke)/Et;Ve<0||Ve>=J.outWidth||Math.floor(Ve)!==Ve||(Pe+=Oe.get(ue,Me,be,Ve,fe))}}}me.set(Pe*Ce,ue,le,ce,ve,fe)}return A.makeTensorInfo(me.shape,me.dtype,me.values)}},tn={kernelName:e.ROF,backendName:"cpu",kernelFunc:function Je(Q){const{inputs:et,backend:A,attrs:G}=Q,{dy:y,input:z}=et,rt=z;(0,i.H)([y,z],"avgPoolGrad");const{filterSize:nt,strides:ot,pad:tt}=G,J=e.backend_util.computePool2DInfo(rt.shape,nt,ot,1,tt),ft=J.strideHeight,lt=J.strideWidth,Et=J.filterHeight,Ot=J.filterWidth,Ct=J.dilationHeight,Tt=J.dilationWidth,At=J.effectiveFilterHeight,Bt=J.effectiveFilterWidth,Wt=Bt-1-J.padInfo.left,bt=At-1-J.padInfo.top,zt=(0,e.f3b)(rt.shape,"float32"),Yt=1/(Et*Ot),te=A.data.get(y.dataId).values,pe=(0,e.f3b)(y.shape,"float32",te);for(let _e=0;_e<J.batchSize;++_e)for(let me=0;me<J.inChannels;++me)for(let Ce=0;Ce<J.inHeight;++Ce)for(let Oe=0;Oe<J.inWidth;++Oe){const ue=Ce-bt,fe=Oe-Wt;let le=0;for(let ce=0;ce<At;ce+=Ct){const ve=(ue+ce)/ft;if(!(ve<0||ve>=J.outHeight||Math.floor(ve)!==ve))for(let de=0;de<Bt;de+=Tt){const ge=(fe+de)/lt;ge<0||ge>=J.outWidth||Math.floor(ge)!==ge||(le+=pe.get(_e,ve,ge,me))}}zt.set(le*Yt,_e,Ce,Oe,me)}return A.makeTensorInfo(zt.shape,zt.dtype,zt.values)}},mn={kernelName:e.sHE,backendName:"cpu",kernelFunc:function On(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,scale:z,offset:rt,mean:nt,variance:ot}=et;e.D5U.assert(nt.shape.length===ot.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),e.D5U.assert(null==rt||nt.shape.length===rt.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),e.D5U.assert(null==z||nt.shape.length===z.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),(0,i.H)([y,nt,ot,z,rt],"batchNorm");let{varianceEpsilon:tt}=G;null==tt&&(tt=.001);const J=A.data.get(y.dataId).values,ft=A.data.get(nt.dataId).values,lt=A.data.get(ot.dataId).values,Et=z?A.data.get(z.dataId).values:new Float32Array([1]),Ot=rt?A.data.get(rt.dataId).values:new Float32Array([0]),Ct=new Float32Array(J.length),Tt=Ot.length,At=Et.length,Bt=lt.length,Wt=ft.length;let bt=0,zt=0,Yt=0,te=0;for(let pe=0;pe<J.length;++pe)Ct[pe]=Ot[bt++]+(J[pe]-ft[zt++])*Et[Yt++]/Math.sqrt(lt[te++]+tt),bt>=Tt&&(bt=0),zt>=Wt&&(zt=0),Yt>=At&&(Yt=0),te>=Bt&&(te=0);return A.makeTensorInfo(y.shape,y.dtype,Ct)}};var hn=t(45006);const ns={kernelName:e.zws,backendName:"cpu",kernelFunc:function Pn(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{blockShape:z,crops:rt}=G;(0,i.H)([y],"batchToSpaceND");const nt=z.reduce((At,Bt)=>At*Bt),ot=e.backend_util.getReshaped(y.shape,z,nt),tt=e.backend_util.getPermuted(ot.length,z.length),J=e.backend_util.getReshapedPermuted(y.shape,z,nt),ft=e.backend_util.getSliceBeginCoords(rt,z.length),lt=e.backend_util.getSliceSize(J,rt,z.length),Et=S({inputs:{x:y},backend:A,attrs:{shape:ot}}),Ot=(0,Y.p)({inputs:{x:Et},backend:A,attrs:{perm:tt}}),Ct=S({inputs:{x:Ot},backend:A,attrs:{shape:J}}),Tt=(0,hn.tP)({inputs:{x:Ct},backend:A,attrs:{begin:ft,size:lt}});return A.disposeIntermediateTensorInfo(Et),A.disposeIntermediateTensorInfo(Ot),A.disposeIntermediateTensorInfo(Ct),Tt}};var Lt=t(19569);const re={kernelName:e.zvY,backendName:"cpu",kernelFunc:function ee(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,weights:z}=et,{size:rt}=G,nt=A.data.get(y.dataId).values,ot=A.data.get(z.dataId).values,tt=(0,Lt.W)(nt,ot,z.dtype,z.shape,rt);return A.makeTensorInfo([rt],z.dtype,tt)}};var Qt=t(38642);const Ue={kernelName:e.eEB,backendName:"cpu",kernelFunc:function se(Q){const{inputs:et,backend:A}=Q,{s0:G,s1:y}=et,z=A.data.get(G.dataId).values,rt=A.data.get(y.dataId).values,nt=e.backend_util.assertAndGetBroadcastShape(Array.from(z),Array.from(rt));return A.makeTensorInfo([nt.length],"int32",Int32Array.from(nt))}};var We=t(21928),rn=t(75079);const yn=(0,a.A)(e.xnO,(Q,et)=>Q>et.clipValueMax?et.clipValueMax:Q<et.clipValueMin?et.clipValueMin:Q),An={kernelName:e.xnO,backendName:"cpu",kernelFunc:yn};var vn=t(23392);const dn={kernelName:e.yj2,backendName:"cpu",kernelFunc:Q=>{const{x:et}=Q.inputs,A=Q.backend,G=new Float32Array(e.D5U.sizeFromShape(et.shape)),y=A.data.get(et.dataId),rt=y.complexTensorInfos.imag,nt=A.data.get(y.complexTensorInfos.real.dataId).values,ot=A.data.get(rt.dataId).values;for(let tt=0;tt<nt.length;tt++)G[tt]=Math.hypot(nt[tt],ot[tt]);return A.makeOutput(G,et.shape,"float32")}};var Mn=t(39971);function Ln(Q){const{inputs:et,backend:A}=Q,{input:G}=et,y=A.data.get(G.dataId).complexTensorInfos.imag,z=A.data.get(y.dataId).values;return A.makeTensorInfo(y.shape,y.dtype,z)}const cs={kernelName:e.J_u,backendName:"cpu",kernelFunc:Ln};var kn=t(84353);function wn(Q){const{inputs:et,backend:A,attrs:G}=Q,{axis:y}=G,z=e.D5U.parseAxisParam(y,et[0].shape)[0],rt=et.map(Ct=>Ct.shape);e.backend_util.assertParamsConsistent(rt,z);let nt=e.backend_util.computeOutShape(et.map(Ct=>Ct.shape),z);if(0===e.D5U.sizeFromShape(nt))return A.makeTensorInfo(nt,et[0].dtype,[]);const ot=et.filter(Ct=>e.D5U.sizeFromShape(Ct.shape)>0);if(1===ot.length)return(0,h.y)({inputs:{x:ot[0]},backend:A});if("complex64"===ot[0].dtype){const Ct=ot.map(bt=>(0,kn.k)({inputs:{input:bt},backend:A})),Tt=ot.map(bt=>Ln({inputs:{input:bt},backend:A})),At=wn({inputs:Ct,backend:A,attrs:{axis:z}}),Bt=wn({inputs:Tt,backend:A,attrs:{axis:z}}),Wt=(0,vn.P)({inputs:{real:At,imag:Bt},backend:A});return Ct.forEach(bt=>A.disposeIntermediateTensorInfo(bt)),Tt.forEach(bt=>A.disposeIntermediateTensorInfo(bt)),A.disposeIntermediateTensorInfo(At),A.disposeIntermediateTensorInfo(Bt),Wt}const tt=ot.map(Ct=>{const At=[-1,e.D5U.sizeFromShape(Ct.shape.slice(z))];return S({inputs:{x:Ct},backend:A,attrs:{shape:At}})}),J=tt.map(Ct=>({vals:A.data.get(Ct.dataId).values,shape:Ct.shape}));nt=e.backend_util.computeOutShape(tt.map(Ct=>Ct.shape),1);const lt=(0,Mn.j)(J,nt,et[0].dtype,1===tt[0].shape[0]),Et=e.backend_util.computeOutShape(ot.map(Ct=>Ct.shape),z),Ot=A.makeTensorInfo(Et,et[0].dtype,lt);return tt.forEach(Ct=>A.disposeIntermediateTensorInfo(Ct)),Ot}const ds={kernelName:e.Eh3,backendName:"cpu",kernelFunc:wn};function ss(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,filter:z}=et,{strides:rt,pad:nt,dataFormat:ot,dilations:tt,dimRoundingMode:J}=G;(0,i.H)([y,z],"conv2d");const ft=e.backend_util.convertConv2DDataFormat(ot),lt=e.backend_util.computeConv2DInfo(y.shape,z.shape,rt,tt,nt,J,!1,ft),Et=lt.filterHeight,Ot=lt.filterWidth,Ct=lt.dilationHeight,Tt=lt.dilationWidth,At=lt.padInfo.left,Bt=lt.padInfo.top,Wt="channelsLast"===lt.dataFormat,bt=new e.YDk(lt.outShape,y.dtype),zt=e.D5U.computeStrides(y.shape),Yt=e.D5U.computeStrides(z.shape),te=zt[0],pe=Wt?zt[1]:zt[2],_e=Wt?zt[2]:1,me=Wt?1:zt[1],Ce=bt.strides[0],Oe=Wt?bt.strides[1]:bt.strides[2],ue=Wt?bt.strides[2]:1,fe=Wt?1:bt.strides[1],le=A.data.get(y.dataId).values,ce=A.data.get(z.dataId).values,ve=bt.values;for(let de=0;de<lt.batchSize;++de){const ge=de*te,ye=de*Ce;for(let Pe=0;Pe<lt.outHeight;++Pe){const $e=ye+Pe*Oe,Me=Pe*lt.strideHeight-Bt;for(let Le=0;Le<Et;++Le){const be=Me+Le*Ct;if(be<0||be>=lt.inHeight)continue;const ke=Le*Yt[0],Ve=ge+be*pe;for(let He=0;He<lt.outWidth;++He){const ze=$e+He*ue,Ze=He*lt.strideWidth-At;for(let qe=0;qe<Ot;++qe){const un=Ze+qe*Tt;if(un<0||un>=lt.inWidth)continue;const xn=Ve+un*_e;let fn=ke+qe*Yt[1];for(let cn=0;cn<lt.inChannels;++cn){const gn=le[xn+cn*me];for(let _n=0;_n<lt.outChannels;++_n)ve[ze+_n*fe]+=gn*ce[fn+_n];fn+=lt.outChannels}}}}}}return A.makeTensorInfo(bt.shape,bt.dtype,ve)}const Os={kernelName:e.mhS,backendName:"cpu",kernelFunc:ss},Ms={kernelName:e.wUP,backendName:"cpu",kernelFunc:function Ps(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,dy:z}=et,{strides:rt,pad:nt,dataFormat:ot,dimRoundingMode:tt,filterShape:J}=G;(0,i.H)([y,z],"conv2dBackpropFilter");const ft=e.backend_util.convertConv2DDataFormat(ot),lt=e.backend_util.computeConv2DInfo(y.shape,J,rt,1,nt,tt,!1,ft),{strideHeight:Et,strideWidth:Ot,filterHeight:Ct,filterWidth:Tt}=lt,At="channelsLast"===lt.dataFormat,Bt=new e.YDk(lt.filterShape,"float32"),Wt=lt.padInfo.left,bt=lt.padInfo.top,zt=A.data.get(y.dataId).values,Yt=A.data.get(z.dataId).values,te=new e.YDk(y.shape,y.dtype,zt),pe=new e.YDk(z.shape,z.dtype,Yt);for(let _e=0;_e<Ct;++_e){const me=Math.max(0,Math.ceil((bt-_e)/Et)),Ce=Math.min(lt.outHeight,(lt.inHeight+bt-_e)/Et);for(let Oe=0;Oe<Tt;++Oe){const ue=Math.max(0,Math.ceil((Wt-Oe)/Ot)),fe=Math.min(lt.outWidth,(lt.inWidth+Wt-Oe)/Ot);for(let le=0;le<lt.inChannels;++le)for(let ce=0;ce<lt.outChannels;++ce){let ve=0;for(let de=0;de<lt.batchSize;++de)for(let ge=me;ge<Ce;++ge){const ye=_e+ge*Et-bt;for(let Pe=ue;Pe<fe;++Pe){const $e=Oe+Pe*Ot-Wt;ve+=At?te.get(de,ye,$e,le)*pe.get(de,ge,Pe,ce):te.get(de,le,ye,$e)*pe.get(de,ce,ge,Pe)}}Bt.set(ve,_e,Oe,le,ce)}}}return A.makeTensorInfo(Bt.shape,Bt.dtype,Bt.values)}},ys={kernelName:e.wm,backendName:"cpu",kernelFunc:function Ts(Q){const{inputs:et,backend:A,attrs:G}=Q,{dy:y,filter:z}=et,{inputShape:rt,strides:nt,pad:ot,dataFormat:tt,dimRoundingMode:J}=G;(0,i.H)([y,z],"conv2dBackpropInput");const ft=e.D5U.computeStrides(z.shape),lt=e.D5U.computeStrides(y.shape);let Et=e.backend_util.convertConv2DDataFormat(tt);const Ot=e.backend_util.computeConv2DInfo(rt,z.shape,nt,1,ot,J,!1,Et),Ct=new e.YDk(Ot.inShape,"float32"),Tt=Ct.values,At=A.data.get(y.dataId).values,Bt=A.data.get(z.dataId).values,[Wt,bt,zt]=ft,{batchSize:Yt,filterHeight:te,filterWidth:pe,inChannels:_e,inHeight:me,inWidth:Ce,outChannels:Oe,outHeight:ue,outWidth:fe,strideHeight:le,strideWidth:ce}=Ot;Et=Ot.dataFormat;const ve=te-1-Ot.padInfo.top,de=pe-1-Ot.padInfo.left,ge="channelsLast"===Et,ye=Ct.strides[0],Pe=ge?Ct.strides[1]:Ct.strides[2],$e=ge?Ct.strides[2]:1,Me=ge?1:Ct.strides[1],Le=lt[0],be=ge?lt[1]:lt[2],ke=ge?lt[2]:1,Ve=ge?1:lt[1];for(let He=0;He<Yt;++He)for(let ze=0;ze<_e;++ze)for(let Ze=0;Ze<me;++Ze){const qe=Ze-ve,un=Math.max(0,Math.ceil(qe/le)),pn=Math.min(ue,(te+qe)/le);for(let xn=0;xn<Ce;++xn){const fn=xn-de,cn=Math.max(0,Math.ceil(fn/ce)),gn=Math.min(fe,(pe+fn)/ce);let _n=0;for(let Tn=un;Tn<pn;++Tn){const Jn=Tn*le-qe;for(let Bn=cn;Bn<gn;++Bn){const Un=Le*He+be*Tn+ke*Bn,jn=Wt*(te-1-Jn)+bt*(pe-1-(Bn*ce-fn))+zt*ze;for(let qn=0;qn<Oe;++qn)_n+=At[Un+Ve*qn]*Bt[jn+qn]}}Tt[ye*He+Pe*Ze+$e*xn+Me*ze]=_n}}return A.makeTensorInfo(Ct.shape,Ct.dtype,Ct.values)}},Rs={kernelName:e.x12,backendName:"cpu",kernelFunc:function Gn(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,filter:z}=et,{strides:rt,pad:nt,dilations:ot}=G;(0,i.H)([y,z],"conv3d");const tt=e.backend_util.computeConv3DInfo(y.shape,z.shape,rt,ot,nt),{filterDepth:J,filterHeight:ft,filterWidth:lt,dilationDepth:Et,dilationHeight:Ot,dilationWidth:Ct,padInfo:Tt}=tt,At=Tt.front,Bt=Tt.left,Wt=Tt.top,bt=new e.YDk(tt.outShape,y.dtype),zt=A.data.get(y.dataId).values,Yt=A.data.get(z.dataId).values,te=bt.values,pe=e.D5U.computeStrides(y.shape),_e=e.D5U.computeStrides(z.shape);for(let me=0;me<tt.batchSize;++me){const Ce=me*pe[0],Oe=me*bt.strides[0];for(let ue=0;ue<tt.outDepth;++ue){const fe=Oe+ue*bt.strides[1],le=ue*tt.strideDepth-At;for(let ce=0;ce<J;++ce){const ve=le+ce*Et;if(ve<0||ve>=tt.inDepth)continue;const de=ce*_e[0],ge=Ce+ve*pe[1];for(let ye=0;ye<tt.outHeight;++ye){const Pe=fe+ye*bt.strides[2],$e=ye*tt.strideHeight-Wt;for(let Me=0;Me<ft;++Me){const Le=$e+Me*Ot;if(Le<0||Le>=tt.inHeight)continue;const be=de+Me*_e[1],ke=ge+Le*pe[2];for(let Ve=0;Ve<tt.outWidth;++Ve){const He=Pe+Ve*tt.outChannels,ze=Ve*tt.strideWidth-Bt;for(let Ze=0;Ze<lt;++Ze){const qe=ze+Ze*Ct;if(qe<0||qe>=tt.inWidth)continue;const pn=ke+qe*tt.inChannels;let xn=be+Ze*_e[2];for(let fn=0;fn<tt.inChannels;++fn){const cn=zt[pn+fn];for(let gn=0;gn<tt.outChannels;++gn)te[He+gn]+=cn*Yt[xn+gn];xn+=tt.outChannels}}}}}}}}return A.makeTensorInfo(bt.shape,bt.dtype,bt.values)}},Ss={kernelName:e.o2y,backendName:"cpu",kernelFunc:function As(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,dy:z}=et,{strides:rt,pad:nt,filterShape:ot}=G;(0,i.H)([y,z],"conv3dBackpropFilterV2");const tt=e.D5U.computeStrides(y.shape),J=e.D5U.computeStrides(z.shape),ft=e.backend_util.computeConv3DInfo(y.shape,ot,rt,1,nt),lt=ft.strideDepth,Et=ft.strideHeight,Ot=ft.strideWidth,Ct=ft.filterDepth,Tt=ft.filterHeight,At=ft.filterWidth,Bt=new e.YDk(ft.filterShape,"float32"),Wt=Bt.values,[bt,zt,Yt,te]=Bt.strides,pe=A.data.get(z.dataId).values,[_e,me,Ce,Oe]=J,ue=A.data.get(y.dataId).values,[fe,le,ce,ve]=tt,de=ft.padInfo.front,ge=ft.padInfo.left,ye=ft.padInfo.top;for(let Pe=0;Pe<Ct;++Pe){const $e=Math.max(0,Math.ceil((de-Pe)/lt)),Me=Math.min(ft.outDepth,(ft.inDepth+de-Pe)/lt),Le=Pe*bt;for(let be=0;be<Tt;++be){const ke=Math.max(0,Math.ceil((ye-be)/Et)),Ve=Math.min(ft.outHeight,(ft.inHeight+ye-be)/Et),He=be*zt+Le;for(let ze=0;ze<At;++ze){const Ze=Math.max(0,Math.ceil((ge-ze)/Ot)),qe=Math.min(ft.outWidth,(ft.inWidth+ge-ze)/Ot),un=ze*Yt+He;for(let pn=0;pn<ft.inChannels;++pn){const xn=pn*te+un;for(let fn=0;fn<ft.outChannels;++fn){let cn=0;for(let gn=0;gn<ft.batchSize;++gn){const _n=gn*fe,Qn=gn*_e;for(let Tn=$e;Tn<Me;++Tn){const Bn=(Pe+Tn*lt-de)*le+_n,Cs=Tn*me+Qn;for(let Un=ke;Un<Ve;++Un){const qn=(be+Un*Et-ye)*ce+Bn,us=Un*Ce+Cs;for(let ts=Ze;ts<qe;++ts)cn+=ue[(ze+ts*Ot-ge)*ve+qn+pn]*pe[ts*Oe+us+fn]}}}Wt[xn+fn]=cn}}}}}return A.makeTensorInfo(Bt.shape,Bt.dtype,Bt.values)}},$s={kernelName:e.ik2,backendName:"cpu",kernelFunc:function bs(Q){const{inputs:et,backend:A,attrs:G}=Q,{dy:y,filter:z}=et,{pad:rt,strides:nt,inputShape:ot}=G;(0,i.H)([y],"conv3dBackpropInputV2");const tt=e.D5U.computeStrides(y.shape),J=e.D5U.computeStrides(z.shape),ft=e.backend_util.computeConv3DInfo(ot,z.shape,nt,1,rt),lt=new e.YDk(ft.inShape,"float32"),Et=lt.values,[Ot,Ct,Tt,At]=lt.strides,Bt=A.data.get(y.dataId).values,[Wt,bt,zt,Yt]=tt,te=A.data.get(z.dataId).values,[pe,_e,me,Ce]=J,{batchSize:Oe,filterDepth:ue,filterHeight:fe,filterWidth:le,inChannels:ce,inDepth:ve,inHeight:de,inWidth:ge,outChannels:ye,outDepth:Pe,outHeight:$e,outWidth:Me,strideDepth:Le,strideHeight:be,strideWidth:ke}=ft,Ve=ue-1-ft.padInfo.front,He=fe-1-ft.padInfo.top,ze=le-1-ft.padInfo.left;for(let Ze=0;Ze<Oe;++Ze)for(let qe=0;qe<ce;++qe)for(let un=0;un<ve;++un){const pn=un-Ve,xn=Math.max(0,Math.ceil(pn/Le)),fn=Math.min(Pe,(ue+pn)/Le);for(let cn=0;cn<de;++cn){const gn=cn-He,_n=Math.max(0,Math.ceil(gn/be)),Qn=Math.min($e,(fe+gn)/be);for(let Tn=0;Tn<ge;++Tn){const Jn=Tn-ze,Bn=Math.max(0,Math.ceil(Jn/ke)),Cs=Math.min(Me,(le+Jn)/ke);let Un=0;for(let jn=xn;jn<fn;++jn){const qn=jn*Le-pn;for(let us=_n;us<Qn;++us){const ts=us*be-gn;for(let uo=Bn;uo<Cs;++uo){const cr=Wt*Ze+bt*jn+zt*us+Yt*uo,Li=pe*(ue-1-qn)+_e*(fe-1-ts)+me*(le-1-(uo*ke-Jn))+Ce*qe;for(let To=0;To<ye;++To)Un+=Bt[cr+To]*te[Li+To]}}}Et[Ot*Ze+Ct*un+Tt*cn+At*Tn+qe]=Un}}}return A.makeTensorInfo(lt.shape,lt.dtype,lt.values)}},Bs=(0,a.A)(e.mc4,Q=>Math.cos(Q)),Ls={kernelName:e.mc4,backendName:"cpu",kernelFunc:Bs},Hn=(0,a.A)(e.TR1,Q=>Math.cosh(Q)),Yn={kernelName:e.TR1,backendName:"cpu",kernelFunc:Hn},Ns={kernelName:e.VcC,backendName:"cpu",kernelFunc:function hs(Q){const{inputs:et,backend:A,attrs:G}=Q,{image:y,boxes:z,boxInd:rt}=et,{cropSize:nt,method:ot,extrapolationValue:tt}=G,[J,ft,lt,Et]=y.shape,Ot=z.shape[0],[Ct,Tt]=nt,At=(0,e.f3b)([Ot,Ct,Tt,Et],"float32"),Bt=A.data.get(z.dataId).values,Wt=A.data.get(rt.dataId).values,bt=A.data.get(y.dataId).values,zt=e.D5U.computeStrides(y.shape),Yt=e.D5U.computeStrides(At.shape);for(let te=0;te<Ot;te++){const pe=4*te,_e=Bt[pe],me=Bt[pe+1],Ce=Bt[pe+2],Oe=Bt[pe+3],ue=Wt[te];if(ue>=J)continue;const fe=Ct>1?(Ce-_e)*(ft-1)/(Ct-1):0,le=Tt>1?(Oe-me)*(lt-1)/(Tt-1):0;for(let ce=0;ce<Ct;ce++){const ve=Ct>1?_e*(ft-1)+ce*fe:.5*(_e+Ce)*(ft-1);if(ve<0||ve>ft-1)for(let de=0;de<Tt;de++)for(let ge=0;ge<Et;ge++)At.values[ge+de*Yt[2]+ce*Yt[1]+te*Yt[0]]=tt;else if("bilinear"===ot){const de=Math.floor(ve),ge=Math.ceil(ve),ye=ve-de;for(let Pe=0;Pe<Tt;Pe++){const $e=Tt>1?me*(lt-1)+Pe*le:.5*(me+Oe)*(lt-1);if($e<0||$e>lt-1){for(let ke=0;ke<Et;ke++)At.values[ke+Pe*Yt[2]+ce*Yt[1]+te*Yt[0]]=tt;continue}const Me=Math.floor($e),Le=Math.ceil($e),be=$e-Me;for(let ke=0;ke<Et;ke++){let Ve=ke+Me*zt[2]+de*zt[1]+ue*zt[0];const He=bt[Ve];Ve=ke+Le*zt[2]+de*zt[1]+ue*zt[0];const ze=bt[Ve];Ve=ke+Me*zt[2]+ge*zt[1]+ue*zt[0];const Ze=bt[Ve];Ve=ke+Le*zt[2]+ge*zt[1]+ue*zt[0];const qe=bt[Ve],un=He+(ze-He)*be;Ve=ke+Pe*Yt[2]+ce*Yt[1]+te*Yt[0],At.values[Ve]=un+(Ze+(qe-Ze)*be-un)*ye}}}else for(let de=0;de<Tt;++de){const ge=Tt>1?me*(lt-1)+de*le:.5*(me+Oe)*(lt-1);if(ge<0||ge>lt-1){for(let $e=0;$e<Et;$e++)At.values[$e+de*Yt[2]+ce*Yt[1]+te*Yt[0]]=tt;continue}const ye=Math.round(ge),Pe=Math.round(ve);for(let $e=0;$e<Et;$e++)At.values[$e+de*Yt[2]+ce*Yt[1]+te*Yt[0]]=bt[$e+ye*zt[2]+Pe*zt[1]+ue*zt[0]]}}}return A.makeTensorInfo(At.shape,At.dtype,At.values)}},Ws={kernelName:e.Byc,backendName:"cpu",kernelFunc:function Us(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{axis:z,exclusive:rt,reverse:nt}=G;(0,i.H)(y,"cumprod");const ot=e.backend_util.getAxesPermutation([z],y.shape.length);let tt=y;null!=ot&&(tt=(0,Y.p)({inputs:{x:y},backend:A,attrs:{perm:ot}}));const J=e.backend_util.getInnerMostAxes(1,y.shape.length)[0];if(J!==tt.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${tt.shape.length-1} but got axis=${J}`);const ft=(0,e.x8V)(tt.dtype,"int32"),lt=e.D5U.makeOnesTypedArray(e.D5U.sizeFromShape(tt.shape),ft),Et=A.data.get(tt.dataId).values,Ot=tt.shape[tt.shape.length-1],Ct=nt?(At,Bt)=>At+Ot-Bt-1:(At,Bt)=>At+Bt;for(let At=0;At<Et.length;At+=Ot)for(let Bt=0;Bt<Ot;Bt++){const Wt=Ct(At,Bt);if(0===Bt)lt[Wt]=rt?1:Et[Wt];else{const bt=Ct(At,Bt-1);lt[Wt]=rt?Et[bt]*lt[bt]:Et[Wt]*lt[bt]}}const Tt=A.makeTensorInfo(tt.shape,ft,lt);if(null!=ot){const At=e.backend_util.getUndoAxesPermutation(ot),Bt=(0,Y.p)({inputs:{x:Tt},backend:A,attrs:{perm:At}});return A.disposeIntermediateTensorInfo(Tt),A.disposeIntermediateTensorInfo(tt),Bt}return Tt}},ws={kernelName:e.iHb,backendName:"cpu",kernelFunc:function ks(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{axis:z,exclusive:rt,reverse:nt}=G;(0,i.H)(y,"cumsum");const ot=e.backend_util.getAxesPermutation([z],y.shape.length);let tt=y;null!=ot&&(tt=(0,Y.p)({inputs:{x:y},backend:A,attrs:{perm:ot}}));const J=e.backend_util.getInnerMostAxes(1,y.shape.length)[0];if(J!==tt.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${tt.shape.length-1} but got axis=${J}`);const ft=(0,e.x8V)(tt.dtype,"int32"),lt=e.D5U.makeZerosTypedArray(e.D5U.sizeFromShape(tt.shape),ft),Et=A.data.get(tt.dataId).values,Ot=tt.shape[tt.shape.length-1],Ct=nt?(At,Bt)=>At+Ot-Bt-1:(At,Bt)=>At+Bt;for(let At=0;At<Et.length;At+=Ot)for(let Bt=0;Bt<Ot;Bt++){const Wt=Ct(At,Bt);if(0===Bt)lt[Wt]=rt?0:Et[Wt];else{const bt=Ct(At,Bt-1);lt[Wt]=rt?Et[bt]+lt[bt]:Et[Wt]+lt[bt]}}const Tt=A.makeTensorInfo(tt.shape,ft,lt);if(null!=ot){const At=e.backend_util.getUndoAxesPermutation(ot),Bt=(0,Y.p)({inputs:{x:Tt},backend:A,attrs:{perm:At}});return A.disposeIntermediateTensorInfo(Tt),A.disposeIntermediateTensorInfo(tt),Bt}return Tt}},Ks={kernelName:e.QRR,backendName:"cpu",kernelFunc:function Fs(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,weights:z}=et,{size:rt,binaryOutput:nt}=G;if(1===y.shape.length){const ot=A.data.get(y.dataId).values,tt=A.data.get(z.dataId).values,J=(0,Lt.W)(ot,tt,z.dtype,z.shape,rt);return A.makeTensorInfo([rt],z.dtype,J)}if(2===y.shape.length){const ot=A.bufferSync(y),tt=A.bufferSync(z),J=(0,Lt.i)(ot,tt,rt,nt);return A.makeTensorInfo(J.shape,z.dtype,J.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${y.shape.length}.`)}},os={kernelName:e.T0n,backendName:"cpu",kernelFunc:function Vs(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{blockSize:z,dataFormat:rt}=G;e.D5U.assert("NHWC"===rt,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${rt}`);const nt=y.shape[0],ot=y.shape[1],tt=y.shape[2],J=y.shape[3],ft=ot*z,lt=tt*z,Et=J/(z*z),Ot=A.data.get(y.dataId).values,Ct=new Float32Array(nt*ft*lt*Et);let Tt=0;for(let At=0;At<nt;++At)for(let Bt=0;Bt<ft;++Bt){const Wt=Math.floor(Bt/z),bt=Bt%z;for(let zt=0;zt<lt;++zt){const Yt=Math.floor(zt/z),pe=(bt*z+zt%z)*Et;for(let _e=0;_e<Et;++_e)Ct[Tt++]=Ot[_e+pe+J*(Yt+tt*(Wt+ot*At))]}}return A.makeTensorInfo([nt,ft,lt,Et],y.dtype,Ct)}};function ps(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,filter:z}=et,{strides:rt,pad:nt,dilations:ot,dimRoundingMode:tt}=G;(0,i.H)([y,z],"depthwiseConv2DNative");const J=e.D5U.computeStrides(y.shape),ft=e.D5U.computeStrides(z.shape);let lt=ot;null==lt&&(lt=[1,1]),e.D5U.assert(e.backend_util.eitherStridesOrDilationsAreOne(rt,lt),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${rt} and dilations '${lt}'`);const Et=e.backend_util.computeConv2DInfo(y.shape,z.shape,rt,lt,nt,tt,!0),{filterHeight:Ot,filterWidth:Ct,dilationHeight:Tt,dilationWidth:At,padInfo:Bt}=Et,Wt=Bt.left,bt=Bt.top,zt=Et.outChannels/Et.inChannels,Yt=new e.YDk(Et.outShape,y.dtype),te=A.data.get(y.dataId).values,pe=A.data.get(z.dataId).values,_e=Yt.values;for(let me=0;me<Et.batchSize;++me){const Ce=me*J[0],Oe=me*Yt.strides[0];for(let ue=0;ue<Et.outHeight;++ue){const fe=Oe+ue*Yt.strides[1],le=ue*Et.strideHeight-bt;for(let ce=0;ce<Ot;++ce){const ve=le+ce*Tt;if(ve<0||ve>=Et.inHeight)continue;const de=ce*ft[0],ge=Ce+ve*J[1];for(let ye=0;ye<Et.outWidth;++ye){const Pe=fe+ye*Yt.strides[2],$e=ye*Et.strideWidth-Wt;for(let Me=0;Me<Ct;++Me){const Le=$e+Me*At;if(Le<0||Le>=Et.inWidth)continue;const ke=ge+Le*Et.inChannels;let Ve=Pe,He=de+Me*ft[1];for(let ze=0;ze<Et.inChannels;++ze){const Ze=te[ke+ze];for(let qe=0;qe<zt;++qe)_e[Ve+qe]+=Ze*pe[He+qe];Ve+=zt,He+=zt}}}}}}return A.makeTensorInfo(Yt.shape,Yt.dtype,Yt.values)}const zs={kernelName:e.cie,backendName:"cpu",kernelFunc:ps},Fn={kernelName:e.sL$,backendName:"cpu",kernelFunc:function Gs(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,dy:z}=et,{strides:rt,dilations:nt,pad:ot,dimRoundingMode:tt,filterShape:J}=G;(0,i.H)([y,z],"depthwiseConv2dNativeBackpropFilter");const ft=e.backend_util.computeConv2DInfo(y.shape,J,rt,nt,ot,tt,!0),{strideHeight:lt,strideWidth:Et,filterHeight:Ot,filterWidth:Ct}=ft,Tt=new e.YDk(ft.filterShape,"float32"),At=ft.padInfo.left,Bt=ft.padInfo.top,Wt=ft.outChannels/ft.inChannels,bt=A.data.get(y.dataId).values,zt=new e.YDk(y.shape,y.dtype,bt),Yt=A.data.get(z.dataId).values,te=new e.YDk(z.shape,z.dtype,Yt);for(let pe=0;pe<Ot;++pe){const _e=Math.max(0,Math.ceil((Bt-pe)/lt)),me=Math.min(ft.outHeight,(ft.inHeight+Bt-pe)/lt);for(let Ce=0;Ce<Ct;++Ce){const Oe=Math.max(0,Math.ceil((At-Ce)/Et)),ue=Math.min(ft.outWidth,(ft.inWidth+At-Ce)/Et);for(let fe=0;fe<ft.outChannels;++fe){const le=Math.trunc(fe/Wt),ce=fe%Wt;let ve=0;for(let de=0;de<ft.batchSize;++de)for(let ge=_e;ge<me;++ge){const ye=pe+ge*lt-Bt;for(let Pe=Oe;Pe<ue;++Pe)ve+=zt.get(de,ye,Ce+Pe*Et-At,le)*te.get(de,ge,Pe,fe)}Tt.set(ve,pe,Ce,le,ce)}}}return A.makeTensorInfo(Tt.shape,Tt.dtype,Tt.values)}},js={kernelName:e.y7R,backendName:"cpu",kernelFunc:function Hs(Q){const{inputs:et,backend:A,attrs:G}=Q,{dy:y,filter:z}=et,{strides:rt,dilations:nt,pad:ot,dimRoundingMode:tt,inputShape:J}=G;(0,i.H)([y,z],"depthwiseConv2DNativeBackpropInput");const ft=e.D5U.computeStrides(y.shape),lt=e.D5U.computeStrides(z.shape),Et=e.backend_util.computeConv2DInfo(J,z.shape,rt,nt,ot,tt,!0),Ot=new e.YDk(Et.inShape,"float32"),Ct=Ot.values,[Tt,At,Bt]=Ot.strides,Wt=A.data.get(y.dataId).values,[bt,zt,Yt]=ft,te=A.data.get(z.dataId).values,[pe,_e,me]=lt,{batchSize:Ce,filterHeight:Oe,filterWidth:ue,inChannels:fe,inHeight:le,inWidth:ce,outChannels:ve,outHeight:de,outWidth:ge,strideHeight:ye,strideWidth:Pe}=Et,$e=Oe-1-Et.padInfo.top,Me=ue-1-Et.padInfo.left,Le=ve/fe;for(let be=0;be<Ce;++be)for(let ke=0;ke<fe;++ke)for(let Ve=0;Ve<le;++Ve){const He=Ve-$e,ze=Math.max(0,Math.ceil(He/ye)),Ze=Math.min(de,(Oe+He)/ye);for(let qe=0;qe<ce;++qe){const un=qe-Me,pn=Math.max(0,Math.ceil(un/Pe)),xn=Math.min(ge,(ue+un)/Pe);let fn=0;for(let cn=ze;cn<Ze;++cn){const gn=cn*ye-He;for(let _n=pn;_n<xn;++_n){const Tn=bt*be+zt*cn+Yt*_n,Jn=pe*(Oe-1-gn)+_e*(ue-1-(_n*Pe-un))+me*ke;for(let Bn=0;Bn<Le;++Bn)fn+=Wt[Tn+(ke*Le+Bn)]*te[Jn+Bn]}}Ct[Tt*be+At*Ve+Bt*qe+ke]=fn}}return A.makeTensorInfo(Ot.shape,Ot.dtype,Ot.values)}},rs={kernelName:e.$w,backendName:"cpu",kernelFunc:function Xs(Q){const{inputs:et,backend:A}=Q,{x:G}=et,y=e.D5U.sizeFromShape(G.shape),z=A.data.get(G.dataId).values,rt=(0,e.f3b)([y,y],G.dtype),nt=rt.values;for(let tt=0;tt<z.length;tt++)nt[tt*y+tt]=z[tt];const ot=[...G.shape,...G.shape];return A.makeTensorInfo(ot,rt.dtype,rt.values)}},Ys={kernelName:e.p4S,backendName:"cpu",kernelFunc:({inputs:Q,backend:et,attrs:A})=>{const{x:G,filter:y}=Q,{strides:z,pad:rt,dilations:nt}=A,ot=et,tt=ot.data.get(G.dataId).values,J=G.shape.length,ft=ot.data.get(y.dataId).values,lt=y.shape.length,{batchSize:Et,inHeight:Ot,inWidth:Ct,inChannels:Tt,outHeight:At,outWidth:Bt,padInfo:Wt,strideHeight:bt,strideWidth:zt,filterHeight:Yt,filterWidth:te,dilationHeight:pe,dilationWidth:_e,outShape:me}=e.backend_util.computeDilation2DInfo(G.shape,y.shape,z,rt,"NHWC",nt),Ce=e.D5U.sizeFromShape(me),Oe=me.length,ue=e.D5U.getArrayFromDType(G.dtype,Ce);for(let le=0;le<Et;++le)for(let ce=0;ce<At;++ce){const ve=ce*bt-Wt.top;for(let de=0;de<Bt;++de){const ge=de*zt-Wt.left;for(let ye=0;ye<Tt;++ye){let Pe=Number.MIN_SAFE_INTEGER;for(let Me=0;Me<Yt;++Me){const Le=ve+Me*pe;if(Le>=0&&Le<Ot)for(let be=0;be<te;++be){const ke=ge+be*_e;if(ke>=0&&ke<Ct){const Ve=e.D5U.locToIndex([le,Le,ke,ye],J,e.D5U.computeStrides(G.shape)),He=e.D5U.locToIndex([Me,be,ye],lt,e.D5U.computeStrides(y.shape)),ze=tt[Ve]+ft[He];ze>Pe&&(Pe=ze)}}}ue[e.D5U.locToIndex([le,ce,de,ye],Oe,e.D5U.computeStrides(me))]=Pe}}}return{dataId:ot.write(e.D5U.toTypedArray(ue,G.dtype),me,G.dtype),shape:me,dtype:G.dtype}}},Zs={kernelName:e.Vn9,backendName:"cpu",kernelFunc:({inputs:Q,backend:et,attrs:A})=>{const{x:G,filter:y,dy:z}=Q,{strides:rt,pad:nt,dilations:ot}=A,tt=et,J=e.D5U.toNestedArray(G.shape,tt.data.get(G.dataId).values),ft=e.D5U.toNestedArray(y.shape,tt.data.get(y.dataId).values),{batchSize:lt,inHeight:Et,inWidth:Ot,inChannels:Ct,outHeight:Tt,outWidth:At,padInfo:Bt,strideHeight:Wt,strideWidth:bt,filterHeight:zt,filterWidth:Yt,dilationHeight:te,dilationWidth:pe,outShape:_e}=e.backend_util.computeDilation2DInfo(G.shape,y.shape,rt,nt,"NHWC",ot);e.D5U.assert(z.rank===_e.length,()=>`Error in ${e.Vn9}, dy must have the same rank as output ${_e.length}, but got ${z.rank}`);const me=e.D5U.toNestedArray(_e,tt.data.get(z.dataId).values),Ce=e.D5U.makeZerosNestedTypedArray(y.shape,y.dtype);for(let ue=0;ue<lt;++ue)for(let fe=0;fe<Tt;++fe){const le=fe*Wt-Bt.top;for(let ce=0;ce<At;++ce){const ve=ce*bt-Bt.left;for(let de=0;de<Ct;++de){let ge=Number.MIN_SAFE_INTEGER,ye=0,Pe=0;for(let $e=0;$e<zt;++$e){const Me=le+$e*te;if(Me>=0&&Me<Et)for(let Le=0;Le<Yt;++Le){const be=ve+Le*pe;if(be>=0&&be<Ot){const ke=J[ue][Me][be][de]+ft[$e][Le][de];ke>ge&&(ge=ke,ye=$e,Pe=Le)}}}Ce[ye][Pe][de]+=me[ue][fe][ce][de]}}}return{dataId:tt.write(e.D5U.toTypedArray(Ce,G.dtype),y.shape,y.dtype),shape:y.shape,dtype:y.dtype}}},Qs={kernelName:e.ekb,backendName:"cpu",kernelFunc:({inputs:Q,backend:et,attrs:A})=>{const{x:G,filter:y,dy:z}=Q,{strides:rt,pad:nt,dilations:ot}=A,tt=et,J=e.D5U.toNestedArray(G.shape,tt.data.get(G.dataId).values),ft=e.D5U.toNestedArray(y.shape,tt.data.get(y.dataId).values),{batchSize:lt,inHeight:Et,inWidth:Ot,inChannels:Ct,outHeight:Tt,outWidth:At,padInfo:Bt,strideHeight:Wt,strideWidth:bt,filterHeight:zt,filterWidth:Yt,dilationHeight:te,dilationWidth:pe,outShape:_e}=e.backend_util.computeDilation2DInfo(G.shape,y.shape,rt,nt,"NHWC",ot);e.D5U.assert(z.rank===_e.length,()=>`Error in ${e.ekb}, dy must have the same rank as output ${_e.length}, but got ${z.rank}`);const me=e.D5U.toNestedArray(_e,tt.data.get(z.dataId).values),Ce=e.D5U.makeZerosNestedTypedArray(G.shape,G.dtype);for(let ue=0;ue<lt;++ue)for(let fe=0;fe<Tt;++fe){const le=fe*Wt-Bt.top;for(let ce=0;ce<At;++ce){const ve=ce*bt-Bt.left;for(let de=0;de<Ct;++de){let ge=Number.MIN_SAFE_INTEGER,ye=le<0?0:le,Pe=ve<0?0:ve;for(let $e=0;$e<zt;++$e){const Me=le+$e*te;if(Me>=0&&Me<Et)for(let Le=0;Le<Yt;++Le){const be=ve+Le*pe;if(be>=0&&be<Ot){const ke=J[ue][Me][be][de]+ft[$e][Le][de];ke>ge&&(ge=ke,ye=Me,Pe=be)}}}Ce[ue][ye][Pe][de]+=me[ue][fe][ce][de]}}}return{dataId:tt.write(e.D5U.toTypedArray(Ce,G.dtype),G.shape,G.dtype),shape:G.shape,dtype:G.dtype}}},wt={kernelName:e.hGc,backendName:"cpu",kernelFunc:function Kn(Q){const{inputs:et,backend:A,attrs:G}=Q,{image:y}=et,{canvas:z,options:rt}=G,{contextOptions:nt,imageOptions:ot}=rt||{},tt=ot?.alpha||1,J=nt?.contextType||"2d";if("2d"!==J)throw new Error(`Context type ${nt.contextType} is not supported by the CPU backend.`);const ft=z.getContext(J,nt?.contextAttributes||{});if(null==ft)throw new Error(`Could not get the context with ${J} type.`);const[lt,Et]=y.shape.slice(0,2),Ot=2===y.shape.length?1:y.shape[2],Ct=A.data.get(y.dataId).values,Tt="float32"===y.dtype?255:1,At=new Uint8ClampedArray(Et*lt*4);for(let Wt=0;Wt<lt*Et;++Wt){const bt=[0,0,0,255*tt];for(let Yt=0;Yt<Ot;Yt++){const te=Ct[Wt*Ot+Yt];if("float32"===y.dtype){if(te<0||te>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${te}.`)}else if("int32"===y.dtype&&(te<0||te>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${te}.`);1===Ot?(bt[0]=te*Tt,bt[1]=te*Tt,bt[2]=te*Tt):bt[Yt]=te*Tt}const zt=4*Wt;At[zt+0]=Math.round(bt[0]),At[zt+1]=Math.round(bt[1]),At[zt+2]=Math.round(bt[2]),At[zt+3]=Math.round(bt[3])}z.width=Et,z.height=lt;const Bt=new ImageData(At,Et,lt);return ft.putImageData(Bt,0,0),y}};var xe=t(37985),Ge=t(33176);function nn(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{axis:z,keepDims:rt}=G;let nt;(0,i.H)(y,"sum"),nt="bool"===y.dtype?(0,We.pj)({inputs:{x:y},backend:A,attrs:{dtype:"int32"}}):(0,h.y)({inputs:{x:y},backend:A});const ot=nt.shape.length,tt=e.D5U.parseAxisParam(z,nt.shape),J=e.backend_util.getAxesPermutation(tt,ot);let ft=tt,lt=nt;null!=J&&(lt=(0,Y.p)({inputs:{x:nt},backend:A,attrs:{perm:J}}),ft=e.backend_util.getInnerMostAxes(ft.length,ot)),e.backend_util.assertAxesAreInnerMostDims("sum",ft,lt.shape.length);const[Et,Ot]=e.backend_util.computeOutAndReduceShapes(lt.shape,ft),Ct=e.backend_util.upcastType(lt.dtype,"int32");let Tt=(0,Ge.l)(A,Et,Ct);const At=e.D5U.sizeFromShape(Ot),Bt=A.data.get(Tt.dataId).values,Wt=A.data.get(lt.dataId).values;for(let bt=0;bt<Bt.length;++bt){const zt=bt*At;let Yt=0;for(let te=0;te<At;++te)Yt+=Wt[zt+te];Bt[bt]=Yt}if(rt){const zt=Tt;Tt=S({inputs:{x:Tt},backend:A,attrs:{shape:e.backend_util.expandShapeToKeepDim(Tt.shape,tt)}}),A.disposeIntermediateTensorInfo(zt)}return A.disposeIntermediateTensorInfo(nt),null!=J&&A.disposeIntermediateTensorInfo(lt),Tt}const En={kernelName:e.GBy,backendName:"cpu",kernelFunc:nn},Js={kernelName:e.$g6,backendName:"cpu",kernelFunc:function Rn(Q){const{inputs:et,backend:A,attrs:G}=Q,{equation:y}=G,z=et,{allDims:rt,summedDims:nt,idDims:ot}=e.backend_util.decodeEinsumEquation(y,z.length);e.backend_util.checkEinsumDimSizes(rt.length,ot,z);const{path:tt,steps:J}=e.backend_util.getEinsumComputePath(nt,ot),ft=J.length;let lt=null,Et=rt.length;const Ot=[];for(let Ct=0;Ct<ft;++Ct){for(const Tt of J[Ct]){const{permutationIndices:At,expandDims:Bt}=e.backend_util.getEinsumPermutation(Et,ot[Tt]);let Wt;e.backend_util.isIdentityPermutation(At)?Wt=z[Tt]:(Wt=(0,Y.p)({inputs:{x:z[Tt]},backend:A,attrs:{perm:At}}),Ot.push(Wt));const bt=Wt.shape.slice();for(let zt=0;zt<Bt.length;++zt)bt.splice(Bt[zt],0,1);e.D5U.arraysEqual(Wt.shape,bt)||(Wt=S({inputs:{x:Wt},backend:A,attrs:{shape:bt}}),Ot.push(Wt)),null===lt?lt=Wt:(lt=(0,xe.Jp)({inputs:{a:Wt,b:lt},backend:A}),Ot.push(lt))}Ct<ft-1&&(tt[Ct]>=0&&(lt=nn({inputs:{x:lt},backend:A,attrs:{axis:tt[Ct]-(rt.length-Et),keepDims:!1}}),Ot.push(lt)),Et--)}for(const Ct of Ot)Ct!==lt&&A.disposeIntermediateTensorInfo(Ct);return lt}},Ao={kernelName:e.HEU,backendName:"cpu",kernelFunc:function fs(Q){const{inputs:et,backend:A}=Q,{dy:G,y}=et;(0,i.H)([G,y],"eluGrad");const z=new Float32Array(e.D5U.sizeFromShape(y.shape)),rt=A.data.get(y.dataId).values,nt=A.data.get(G.dataId).values;for(let ot=0;ot<rt.length;++ot){const tt=rt[ot];z[ot]=tt>=0?nt[ot]:nt[ot]*(tt+1)}return A.makeTensorInfo(y.shape,"float32",z)}};var ho=t(75190);const So=e.backend_util.ERF_P,dr=e.backend_util.ERF_A1,po=e.backend_util.ERF_A2,bo=e.backend_util.ERF_A3,as=e.backend_util.ERF_A4,$o=e.backend_util.ERF_A5,Bo=(0,a.A)(e.Omj,Q=>{const et=Math.sign(Q),A=Math.abs(Q),G=1/(1+So*A);return et*(1-(((($o*G+as)*G+bo)*G+po)*G+dr)*G*Math.exp(-A*A))}),Lo={kernelName:e.Omj,backendName:"cpu",kernelFunc:Bo};var ms=t(622);function gs(Q){const{inputs:et,backend:A,attrs:G}=Q,{input:y}=et,{dim:z}=G,rt=y.shape.length,nt=y.shape.slice();let ot=z;return z<0&&(e.D5U.assert(-(rt+1)<=z,()=>`Axis must be in the interval [${-(rt+1)}, ${rt}]`),ot=rt+z+1),nt.splice(ot,0,1),S({inputs:{x:y},backend:A,attrs:{shape:nt}})}const fo={kernelName:e.YFo,backendName:"cpu",kernelFunc:gs};var No=t(27166);const Uo=(0,o.b)((Q,et)=>Q/et),qs=(0,Ut.j)(e.oHH,Uo),_s={kernelName:e.oHH,backendName:"cpu",kernelFunc:qs};var to=t(51981);function mo(Q,et,A){const G=Q.shape,y=G[0],z=G[1],rt=A.data.get(Q.dataId),nt=rt.complexTensorInfos.real,ot=rt.complexTensorInfos.imag,tt=[y,z],J=e.D5U.sizeFromShape(tt),ft=e.D5U.getTypedArrayFromDType("float32",J),lt=e.D5U.getTypedArrayFromDType("float32",J);for(let Tt=0;Tt<y;Tt++){const At=(0,hn.tP)({inputs:{x:nt},backend:A,attrs:{begin:[Tt,0],size:[1,z]}}),Bt=(0,hn.tP)({inputs:{x:ot},backend:A,attrs:{begin:[Tt,0],size:[1,z]}}),Wt=(0,vn.P)({inputs:{real:At,imag:Bt},backend:A}),{real:bt,imag:zt}=Wo(Wt,et,A),Yt=e.backend_util.mergeRealAndImagArrays(bt,zt);for(let te=0;te<z;te++){const pe=e.backend_util.getComplexWithIndex(Yt,te);ft[Tt*z+te]=pe.real,lt[Tt*z+te]=pe.imag}A.disposeIntermediateTensorInfo(At),A.disposeIntermediateTensorInfo(Bt),A.disposeIntermediateTensorInfo(Wt)}const Et=A.makeTensorInfo(tt,"float32",ft),Ot=A.makeTensorInfo(tt,"float32",lt),Ct=(0,vn.P)({inputs:{real:Et,imag:Ot},backend:A});return A.disposeIntermediateTensorInfo(Et),A.disposeIntermediateTensorInfo(Ot),Ct}function Wo(Q,et,A){const G=e.D5U.sizeFromShape(Q.shape),y=A.data.get(Q.dataId),z=A.data.get(y.complexTensorInfos.real.dataId).values,rt=A.data.get(y.complexTensorInfos.imag.dataId).values;if(function eo(Q){return!(Q&Q-1)}(G)){const nt=no(z,rt,G,et,A),ot=[Q.shape[0],Q.shape[1]];if(et){const tt=A.makeTensorInfo(ot,"float32",nt.real),J=A.makeTensorInfo(ot,"float32",nt.imag),ft=A.makeTensorInfo([],"float32",e.D5U.createScalarValue(G,"float32")),lt=(0,h.y)({inputs:{x:ft},backend:A}),Et=_s.kernelFunc({inputs:{a:tt,b:ft},backend:A}),Ot=_s.kernelFunc({inputs:{a:J,b:lt},backend:A}),Ct=A.data.get(Et.dataId).values,Tt=A.data.get(Ot.dataId).values;return A.disposeIntermediateTensorInfo(tt),A.disposeIntermediateTensorInfo(J),A.disposeIntermediateTensorInfo(ft),A.disposeIntermediateTensorInfo(lt),A.disposeIntermediateTensorInfo(Et),A.disposeIntermediateTensorInfo(Ot),{real:Ct,imag:Tt}}return nt}{const ot=function ko(Q,et,A){const G=new Float32Array(2*et);for(let y=0;y<et;y++){let z=0,rt=0;for(let nt=0;nt<et;nt++){const ot=e.backend_util.exponent(y*nt,et,A),tt=e.backend_util.getComplexWithIndex(Q,nt);z+=tt.real*ot.real-tt.imag*ot.imag,rt+=tt.real*ot.imag+tt.imag*ot.real}A&&(z/=et,rt/=et),e.backend_util.assignToTypedArray(G,z,rt,y)}return G}(e.backend_util.mergeRealAndImagArrays(z,rt),G,et);return e.backend_util.splitRealAndImagArrays(ot)}}function no(Q,et,A,G,y){if(1===A)return{real:Q,imag:et};const z=e.backend_util.mergeRealAndImagArrays(Q,et),rt=A/2,nt=e.backend_util.complexWithEvenIndex(z),ot=nt.real,tt=nt.imag,J=[ot.length],ft=y.makeTensorInfo(J,"float32",ot),lt=y.makeTensorInfo(J,"float32",tt),Et=(0,vn.P)({inputs:{real:ft,imag:lt},backend:y}),Ot=e.backend_util.complexWithOddIndex(z),Ct=Ot.real,Tt=Ot.imag,At=[Ct.length],Bt=y.makeTensorInfo(At,"float32",Ct),Wt=y.makeTensorInfo(At,"float32",Tt),bt=(0,vn.P)({inputs:{real:Bt,imag:Wt},backend:y}),zt=no(ot,tt,rt,G,y),Yt=zt.real,te=zt.imag,pe=[Yt.length],_e=y.makeTensorInfo(pe,"float32",Yt),me=y.makeTensorInfo(pe,"float32",te),Ce=(0,vn.P)({inputs:{real:_e,imag:me},backend:y}),Oe=no(Ct,Tt,rt,G,y),ue=Oe.real,fe=Oe.imag,le=[ue.length],ce=y.makeTensorInfo(le,"float32",ue),ve=y.makeTensorInfo(le,"float32",fe),de=(0,vn.P)({inputs:{real:ce,imag:ve},backend:y}),ge=e.backend_util.exponents(A,G),ye=[ge.real.length],Pe=y.makeTensorInfo(ye,"float32",ge.real),$e=y.makeTensorInfo(ye,"float32",ge.imag),Me=(0,vn.P)({inputs:{real:Pe,imag:$e},backend:y}),Le=(0,xe.Jp)({inputs:{a:Me,b:de},backend:y}),be=(0,T.IH)({inputs:{a:Ce,b:Le},backend:y}),ke=(0,to.lu)({inputs:{a:Ce,b:Le},backend:y}),Ve=(0,kn.k)({inputs:{input:be},backend:y}),He=(0,kn.k)({inputs:{input:ke},backend:y}),ze=Ln({inputs:{input:be},backend:y}),Ze=Ln({inputs:{input:ke},backend:y}),qe=wn({inputs:[Ve,He],backend:y,attrs:{axis:0}}),un=wn({inputs:[ze,Ze],backend:y,attrs:{axis:0}}),pn=y.data.get(qe.dataId).values,xn=y.data.get(un.dataId).values;return y.disposeIntermediateTensorInfo(ft),y.disposeIntermediateTensorInfo(lt),y.disposeIntermediateTensorInfo(Et),y.disposeIntermediateTensorInfo(Bt),y.disposeIntermediateTensorInfo(Wt),y.disposeIntermediateTensorInfo(bt),y.disposeIntermediateTensorInfo(_e),y.disposeIntermediateTensorInfo(me),y.disposeIntermediateTensorInfo(Ce),y.disposeIntermediateTensorInfo(ce),y.disposeIntermediateTensorInfo(ve),y.disposeIntermediateTensorInfo(de),y.disposeIntermediateTensorInfo(Pe),y.disposeIntermediateTensorInfo($e),y.disposeIntermediateTensorInfo(Me),y.disposeIntermediateTensorInfo(Le),y.disposeIntermediateTensorInfo(be),y.disposeIntermediateTensorInfo(ke),y.disposeIntermediateTensorInfo(Ve),y.disposeIntermediateTensorInfo(ze),y.disposeIntermediateTensorInfo(He),y.disposeIntermediateTensorInfo(Ze),y.disposeIntermediateTensorInfo(qe),y.disposeIntermediateTensorInfo(un),{real:pn,imag:xn}}const Fo={kernelName:e.vwp,backendName:"cpu",kernelFunc:function wo(Q){const{inputs:et,backend:A}=Q,{input:G}=et,y=e.D5U.sizeFromShape(G.shape),z=G.shape[G.shape.length-1],nt=S({inputs:{x:G},backend:A,attrs:{shape:[y/z,z]}}),ot=mo(nt,!1,A),tt=S({inputs:{x:ot},backend:A,attrs:{shape:G.shape}});return A.disposeIntermediateTensorInfo(nt),A.disposeIntermediateTensorInfo(ot),tt}};function Zn(Q){const{backend:et,attrs:A}=Q,{shape:G,value:y,dtype:z}=A,rt=z||e.D5U.inferDtype(y),nt=e.D5U.getArrayFromDType(rt,e.D5U.sizeFromShape(G));return function Ko(Q,et){Q.fill(et)}(nt,y),et.makeTensorInfo(G,rt,nt)}const Es={kernelName:e.deh,backendName:"cpu",kernelFunc:Zn},is={kernelName:e.Uyb,backendName:"cpu",kernelFunc:({inputs:Q,backend:A})=>{const{image:G}=Q,y=A,z=e.D5U.getTypedArrayFromDType(G.dtype,e.D5U.sizeFromShape(G.shape)),[rt,nt,ot,tt]=G.shape,J=y.data.get(G.dataId).values;for(let lt=0;lt<rt;lt++){const Et=lt*ot*nt*tt;for(let Ot=0;Ot<nt;Ot++){const Ct=Ot*(ot*tt);for(let Tt=0;Tt<ot;Tt++){const At=Tt*tt;for(let Bt=0;Bt<tt;Bt++){const Wt=Math.round(ot-Tt-1),bt=Et+Ct+At+Bt;let zt=J[bt];Wt>=0&&Wt<ot&&(zt=J[Et+Ct+Wt*tt+Bt]),z[bt]=zt}}}}return{dataId:y.write(z,G.shape,G.dtype),shape:G.shape,dtype:G.dtype}}};var Vo=t(1471),go=t(47846);const Eo={kernelName:e._V0,backendName:"cpu",kernelFunc:function _o(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,filter:z,bias:rt,preluActivationWeights:nt}=et,{strides:ot,pad:tt,dataFormat:J,dilations:ft,dimRoundingMode:lt,activation:Et,leakyreluAlpha:Ot}=G;let Ct=ss({inputs:{x:y,filter:z},backend:A,attrs:{strides:ot,pad:tt,dataFormat:J,dilations:ft,dimRoundingMode:lt}});if(rt){const Tt=Ct;if("NCHW"===J&&1===rt.shape.length&&1!==rt.shape[0]){const At=S({inputs:{x:rt},backend:A,attrs:{shape:[rt.shape[0],1,1]}});Ct=(0,T.IH)({inputs:{a:Ct,b:At},backend:A}),A.disposeIntermediateTensorInfo(At)}else Ct=(0,T.IH)({inputs:{a:Ct,b:rt},backend:A});A.disposeIntermediateTensorInfo(Tt)}if(Et){const Tt=Ct;if("NCHW"===J&&"prelu"===Et&&1===nt.shape.length&&1!==nt.shape[0]){const At=S({inputs:{x:nt},backend:A,attrs:{shape:[nt.shape[0],1,1]}});Ct=M(A,Ct,Et,At,Ot),A.disposeIntermediateTensorInfo(At)}else Ct=M(A,Ct,Et,nt,Ot);A.disposeIntermediateTensorInfo(Tt)}return Ct}},Do={kernelName:e.luS,backendName:"cpu",kernelFunc:function xo(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,filter:z,bias:rt,preluActivationWeights:nt}=et,{strides:ot,pad:tt,dataFormat:J,dilations:ft,dimRoundingMode:lt,activation:Et,leakyreluAlpha:Ot}=G;let Ct=ps({inputs:{x:y,filter:z},backend:A,attrs:{strides:ot,pad:tt,dataFormat:J,dilations:ft,dimRoundingMode:lt}});if(rt){const Tt=Ct;Ct=(0,T.IH)({inputs:{a:Ct,b:rt},backend:A}),A.disposeIntermediateTensorInfo(Tt)}if(Et){const Tt=Ct;Ct=M(A,Ct,Et,nt,Ot),A.disposeIntermediateTensorInfo(Tt)}return Ct}};var so=t(52465);const xs={kernelName:e.q1x,backendName:"cpu",kernelFunc:function zo(Q){const{inputs:et,backend:A}=Q,{params:G,indices:y}=et,z=e.D5U.sizeFromShape(G.shape),rt=y.shape,nt=rt[rt.length-1],[ot,tt,J,ft]=e.backend_util.prepareAndValidate(G,y);if(0===tt)return A.makeTensorInfo(ot,G.dtype,[]);const lt=A.data.get(y.dataId).values,Et=A.bufferSync(G),Ot=(0,so.m)(lt,Et,G.dtype,tt,nt,J,ft,G.shape,z);return A.makeTensorInfo(ot,G.dtype,Ot.values)}};var vo=t(52697);const Go={kernelName:e.qi_,backendName:"cpu",kernelFunc:function Co(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,indices:z}=et,{axis:rt,batchDims:nt}=G;(0,i.H)([y,z],"gatherV2");const ot=e.D5U.parseAxisParam(rt,y.shape)[0],tt=A.data.get(z.dataId).values,J=y.shape[ot];for(let bt=0;bt<tt.length;++bt){const zt=tt[bt];e.D5U.assert(zt<=J-1&&zt>=0,()=>`GatherV2: the index value ${zt} is not in [0, ${J-1}]`)}let ft=nt;null==nt&&(ft=0);const lt=e.D5U.sizeFromShape(z.shape),Et=e.backend_util.segment_util.collectGatherOpShapeInfo(y,z,ot,ft),Ot=S({inputs:{x:y},backend:A,attrs:{shape:[Et.batchSize,Et.outerSize,Et.dimSize,Et.sliceSize]}}),Ct=S({inputs:{x:z},backend:A,attrs:{shape:[Et.batchSize,lt/Et.batchSize]}}),Tt=[Et.batchSize,Et.outerSize,lt/Et.batchSize,Et.sliceSize],At=A.bufferSync(Ct),Bt=A.bufferSync(Ot),Wt=(0,vo.i)(Bt,At,Tt);return A.disposeIntermediateTensorInfo(Ot),A.disposeIntermediateTensorInfo(Ct),A.makeTensorInfo(Et.outputShape,Wt.dtype,Wt.values)}};var Ho=t(4730),jo=t(47310);const Yo={kernelName:e.Qg5,backendName:"cpu",kernelFunc:function Xo(Q){const{inputs:et,backend:A}=Q,{input:G}=et,y=e.D5U.sizeFromShape(G.shape),z=G.shape[G.shape.length-1],nt=S({inputs:{x:G},backend:A,attrs:{shape:[y/z,z]}}),ot=mo(nt,!0,A),tt=S({inputs:{x:ot},backend:A,attrs:{shape:G.shape}});return A.disposeIntermediateTensorInfo(nt),A.disposeIntermediateTensorInfo(ot),tt}},Zo=(0,a.A)(e.avt,Q=>Number.isFinite(Q)?1:0,"bool"),Qo={kernelName:e.avt,backendName:"cpu",kernelFunc:Zo},Jo=(0,a.A)(e.iWB,Q=>Math.abs(Q)===1/0?1:0,"bool"),qo={kernelName:e.iWB,backendName:"cpu",kernelFunc:Jo},tr=(0,a.A)(e.r7n,Q=>Number.isNaN(Q)?1:0,"bool"),er={kernelName:e.r7n,backendName:"cpu",kernelFunc:tr};var nr=t(2339),sr=t(50033),gt=t(77142);const vt={kernelName:e.e7N,backendName:"cpu",kernelFunc:function St(Q){const{backend:et,attrs:A}=Q,{start:G,stop:y,num:z}=A,rt=(0,gt.b)(G,y,z);return et.makeTensorInfo([rt.length],"float32",rt)}};var yt=t(46723);const Kt=(0,a.A)(e.kU,Q=>Math.log1p(Q)),Xt={kernelName:e.kU,backendName:"cpu",kernelFunc:Kt},ne=(0,o.b)((Q,et)=>Q&&et),Ht=(0,Ut.j)(e.PYm,ne,null,"bool"),qt={kernelName:e.PYm,backendName:"cpu",kernelFunc:Ht},Ke=(0,a.A)(e.VfG,Q=>Q?0:1,"bool"),Xe={kernelName:e.VfG,backendName:"cpu",kernelFunc:Ke},an=(0,o.b)((Q,et)=>Q||et),on=(0,Ut.j)(e.MZg,an,null,"bool"),ln={kernelName:e.MZg,backendName:"cpu",kernelFunc:on},Vn={kernelName:e.eZ0,backendName:"cpu",kernelFunc:function Sn(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{depthRadius:z,bias:rt,alpha:nt,beta:ot}=G;(0,i.H)(y,"LRN");const tt=y.shape[3],J=tt-1,ft=A.data.get(y.dataId).values,lt=e.D5U.sizeFromShape(y.shape),Et=new Float32Array(lt);function Ot(Ct){const Tt=Ct%tt;let At=Ct-Tt+Math.max(0,Tt-z);const Bt=Ct-Tt+Math.min(Tt+z,J);let Wt=0;for(;At<=Bt;At++){const bt=ft[At];Wt+=bt*bt}return Wt}for(let Ct=0;Ct<lt;Ct++){const Tt=Ot(Ct),At=ft[Ct]*Math.pow(rt+nt*Tt,-ot);Et[Ct]=At}return A.makeTensorInfo(y.shape,y.dtype,Et)}},oo={kernelName:e.Hhh,backendName:"cpu",kernelFunc:function $n(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,y:z,dy:rt}=et,{depthRadius:nt,bias:ot,alpha:tt,beta:J}=G;(0,i.H)(rt,"LRNGrad");const ft=e.D5U.sizeFromShape(rt.shape),lt=rt.shape[3],Et=A.data.get(rt.dataId).values,Ot=A.data.get(y.dataId).values,Ct=A.data.get(z.dataId).values,Tt=new Float32Array(ft),At=ft;for(let Bt=0;Bt<At;Bt++){const Wt=Bt%lt,bt=Bt-Wt+Math.max(0,Wt-nt),zt=Bt-Wt+Math.min(lt,Wt+nt+1);let Yt=0;for(let te=bt;te<zt;te++)Yt+=Math.pow(Ot[te],2);Yt=tt*Yt+ot;for(let te=bt;te<zt;te++){let pe=-2*tt*J*Ot[te]*Ct[Bt]/Yt;Bt===te&&(pe+=Math.pow(Yt,-J)),pe*=Et[Bt],Tt[te]+=pe}}return A.makeTensorInfo(rt.shape,y.dtype,Tt)}};var ro=t(7727),Io=t(8385);function Dn(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{reductionIndices:z,keepDims:rt}=G,nt=A;let ot=y.shape;const tt=ot.length,J=e.D5U.parseAxisParam(z,ot);let ft=J;const lt=e.backend_util.getAxesPermutation(ft,tt);let Et=nt.data.get(y.dataId).values;if(null!=lt){const bt=new Array(tt);for(let zt=0;zt<bt.length;zt++)bt[zt]=ot[lt[zt]];Et=(0,Io.H)(Et,ot,y.dtype,lt,bt),ft=e.backend_util.getInnerMostAxes(ft.length,tt),ot=bt}(0,i.H)(y,"max"),e.backend_util.assertAxesAreInnerMostDims("max",ft,tt);const[Ot,Ct]=e.backend_util.computeOutAndReduceShapes(ot,ft),Tt=e.D5U.sizeFromShape(Ct),At=(0,ro.B)(Et,Tt,Ot,y.dtype),Bt=nt.write(At,Ot,y.dtype);let Wt=Ot;return rt&&(Wt=e.backend_util.expandShapeToKeepDim(Ot,J)),{dataId:Bt,shape:Wt,dtype:y.dtype}}const ls={kernelName:e.YoZ,backendName:"cpu",kernelFunc:Dn};var or=t(46160);const rr={kernelName:e.mTV,backendName:"cpu",kernelFunc:function Oo(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et;(0,i.H)(y,"maxPool");const{filterSize:z,strides:rt,pad:nt,dimRoundingMode:ot}=G;e.D5U.assert(e.backend_util.eitherStridesOrDilationsAreOne(rt,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${rt} and dilations '1'`);const J=e.backend_util.computePool2DInfo(y.shape,z,rt,1,nt,ot);let ft;if(1===J.filterWidth&&1===J.filterHeight&&e.D5U.arraysEqual(J.inShape,J.outShape))ft=(0,h.y)({inputs:{x:y},backend:A});else{const lt=A.data.get(y.dataId).values,Et=e.D5U.computeStrides(y.shape),Ot=kt(lt,0,y.dtype,Et,J,"max");ft=A.makeTensorInfo(J.outShape,y.dtype,Ot.values)}return ft}},ar={kernelName:e.OAf,backendName:"cpu",kernelFunc:function ao(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{filterSize:z,strides:rt,pad:nt,dimRoundingMode:ot,dataFormat:tt}=G;(0,i.H)(y,"maxPool3d");const J=e.backend_util.computePool3DInfo(y.shape,z,rt,1,nt,ot,tt),lt=Jt(A.data.get(y.dataId).values,0,y.dtype,e.D5U.computeStrides(y.shape),J,"max");return A.makeTensorInfo(lt.shape,"float32",lt.values)}},hr={kernelName:e.OU7,backendName:"cpu",kernelFunc:function Mr(Q){const{inputs:et,backend:A,attrs:G}=Q,{dy:y,input:z}=et,{filterSize:rt,strides:nt,pad:ot,dimRoundingMode:tt}=G;(0,i.H)([y,z],"maxPool3DGrad");const J=e.backend_util.computePool3DInfo(z.shape,rt,nt,1,ot,tt),lt=function ae(Q,et){const A=(0,e.f3b)(et.outShape,"int32"),G=et.strideDepth,y=et.strideHeight,z=et.strideWidth,rt=et.dilationDepth,nt=et.dilationHeight,ot=et.dilationWidth,tt=et.effectiveFilterDepth,J=et.effectiveFilterHeight,ft=et.effectiveFilterWidth,lt=et.padInfo.front,Et=et.padInfo.top,Ot=et.padInfo.left;for(let Ct=0;Ct<et.batchSize;++Ct)for(let Tt=0;Tt<et.inChannels;++Tt)for(let At=0;At<et.outDepth;++At){const Bt=At*G-lt;let Wt=Bt;for(;Wt<0;)Wt+=rt;const bt=Math.min(et.inDepth,tt+Bt);for(let zt=0;zt<et.outHeight;++zt){const Yt=zt*y-Et;let te=Yt;for(;te<0;)te+=nt;const pe=Math.min(et.inHeight,J+Yt);for(let _e=0;_e<et.outWidth;++_e){const me=_e*z-Ot;let Ce=me;for(;Ce<0;)Ce+=ot;const Oe=Math.min(et.inWidth,ft+me);let ue=Number.NEGATIVE_INFINITY,fe=-1;for(let le=Wt;le<bt;le+=rt){const ce=le-Bt;for(let ve=te;ve<pe;ve+=nt){const de=ve-Yt;for(let ge=Ce;ge<Oe;ge+=ot){const ye=ge-me,Pe=Q.get(Ct,le,ve,ge,Tt);Pe>=ue&&(ue=Pe,fe=ce*J*ft+de*J+ye)}}}A.set(fe,Ct,At,zt,_e,Tt)}}}return A}(A.bufferSync(z),J),Et=J.strideDepth,Ot=J.strideHeight,Ct=J.strideWidth,Tt=J.dilationDepth,At=J.dilationHeight,Bt=J.dilationWidth,Wt=J.effectiveFilterDepth,bt=J.effectiveFilterHeight,zt=J.effectiveFilterWidth,Yt=Wt-1-J.padInfo.front,te=zt-1-J.padInfo.left,pe=bt-1-J.padInfo.top,_e=(0,e.f3b)(z.shape,"float32"),me=A.bufferSync(y);for(let Ce=0;Ce<J.batchSize;++Ce)for(let Oe=0;Oe<J.inChannels;++Oe)for(let ue=0;ue<J.inDepth;++ue)for(let fe=0;fe<J.inHeight;++fe)for(let le=0;le<J.inWidth;++le){const ce=ue-Yt,ve=fe-pe,de=le-te;let ge=0;for(let ye=0;ye<Wt;ye+=Tt){const Pe=(ce+ye)/Et;if(!(Pe<0||Pe>=J.outDepth||Math.floor(Pe)!==Pe))for(let $e=0;$e<bt;$e+=At){const Me=(ve+$e)/Ot;if(!(Me<0||Me>=J.outHeight||Math.floor(Me)!==Me))for(let Le=0;Le<zt;Le+=Bt){const be=(de+Le)/Ct;if(be<0||be>=J.outWidth||Math.floor(be)!==be)continue;const He=Wt*bt*zt-1-lt.get(Ce,Pe,Me,be,Oe)===ye*bt*zt+$e*zt+Le?1:0;0!==He&&(ge+=me.get(Ce,Pe,Me,be,Oe)*He)}}}_e.set(ge,Ce,ue,fe,le,Oe)}return A.makeTensorInfo(_e.shape,_e.dtype,_e.values)}},Tr={kernelName:e.OV7,backendName:"cpu",kernelFunc:function pr(Q){const{inputs:et,backend:A,attrs:G}=Q,{dy:y,input:z,output:rt}=et,nt=z;(0,i.H)([z,rt],"maxPoolGrad");const{filterSize:ot,strides:tt,pad:J,dimRoundingMode:ft}=G,lt=e.backend_util.computePool2DInfo(nt.shape,ot,tt,1,J,ft),Et=A.data.get(nt.dataId).values,Ot=(0,e.f3b)(lt.outShape,nt.dtype,jt(Et,nt.shape,nt.dtype,lt).values),Ct=lt.strideHeight,Tt=lt.strideWidth,At=lt.dilationHeight,Bt=lt.dilationWidth,Wt=lt.effectiveFilterHeight,bt=lt.effectiveFilterWidth,zt=bt-1-lt.padInfo.left,Yt=Wt-1-lt.padInfo.top,te=(0,e.f3b)(nt.shape,"float32"),pe=A.data.get(y.dataId).values,_e=(0,e.f3b)(y.shape,"float32",pe);for(let me=0;me<lt.batchSize;++me)for(let Ce=0;Ce<lt.inChannels;++Ce)for(let Oe=0;Oe<lt.inHeight;++Oe)for(let ue=0;ue<lt.inWidth;++ue){const fe=Oe-Yt,le=ue-zt;let ce=0;for(let ve=0;ve<Wt;ve+=At){const de=(fe+ve)/Ct;if(!(de<0||de>=lt.outHeight||Math.floor(de)!==de))for(let ge=0;ge<bt;ge+=Bt){const ye=(le+ge)/Tt;if(ye<0||ye>=lt.outWidth||Math.floor(ye)!==ye)continue;const Me=Wt*bt-1-Ot.get(me,de,ye,Ce)===ve*bt+ge?1:0;0!==Me&&(ce+=_e.get(me,de,ye,Ce)*Me)}}te.set(ce,me,Oe,ue,Ce)}return A.makeTensorInfo(te.shape,te.dtype,te.values)}},Rr={kernelName:e.vFR,backendName:"cpu",kernelFunc:({inputs:Q,attrs:et,backend:A})=>{const{x:G}=Q,{filterSize:y,strides:z,pad:rt,includeBatchInIndex:nt}=et,ot=A;(0,i.H)(G,"MaxPoolWithArgmax");const tt=ot.data.get(G.dataId).values,J=e.backend_util.computePool2DInfo(G.shape,y,z,[1,1],rt),[ft,lt]=function yr(Q,et,A,G,y){const rt=kt(Q,0,A,e.D5U.computeStrides(et),y,"max"),nt=jt(Q,et,A,y,!0,G);return[rt.values,nt.values]}(tt,G.shape,G.dtype,nt,J),Et=ot.write(ft,J.outShape,G.dtype),Ot=ot.write(lt,J.outShape,G.dtype);return[{dataId:Et,shape:J.outShape,dtype:G.dtype},{dataId:Ot,shape:J.outShape,dtype:"int32"}]}},Sr={kernelName:e.q2K,backendName:"cpu",kernelFunc:function Ar(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{axis:z,keepDims:rt}=G,nt=e.D5U.parseAxisParam(z,y.shape),tt=e.backend_util.computeOutAndReduceShapes(y.shape,nt)[1],J=e.D5U.sizeFromShape(tt),ft=[],lt=A.makeTensorInfo([],"float32",new Float32Array([J]));ft.push(lt);const Et=(0,We.pj)({inputs:{x:y},backend:A,attrs:{dtype:"float32"}});ft.push(Et);const Ot=qs({inputs:{a:Et,b:lt},backend:A});ft.push(Ot);const Ct=nn({inputs:{x:Ot},backend:A,attrs:{axis:z,keepDims:rt}});return ft.forEach(Tt=>A.disposeIntermediateTensorInfo(Tt)),Ct}},$r={kernelName:e.c17,backendName:"cpu",kernelFunc:function br(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{axis:z,keepDims:rt}=G;(0,i.H)(y,"min");const nt=e.D5U.parseAxisParam(z,y.shape);let ot=nt;const tt=e.backend_util.getAxesPermutation(ot,y.shape.length);let J=y;null!=tt&&(J=(0,Y.p)({inputs:{x:y},backend:A,attrs:{perm:tt}}),ot=e.backend_util.getInnerMostAxes(ot.length,y.shape.length)),e.backend_util.assertAxesAreInnerMostDims("min",ot,J.shape.length);const[ft,lt]=e.backend_util.computeOutAndReduceShapes(J.shape,ot),Et=e.D5U.sizeFromShape(lt),Ot=e.D5U.makeZerosTypedArray(e.D5U.sizeFromShape(ft),J.dtype),Ct=A.data.get(J.dataId).values;for(let At=0;At<Ot.length;++At){const Bt=At*Et;let Wt=Ct[Bt];for(let bt=0;bt<Et;++bt){const zt=Ct[Bt+bt];(Number.isNaN(zt)||zt<Wt)&&(Wt=zt)}Ot[At]=Wt}null!=tt&&A.disposeIntermediateTensorInfo(J);const Tt=A.makeTensorInfo(ft,J.dtype,Ot);if(rt){const Bt=S({inputs:{x:Tt},backend:A,attrs:{shape:e.backend_util.expandShapeToKeepDim(ft,nt)}});return A.disposeIntermediateTensorInfo(Tt),Bt}return Tt}};var Br=t(28170);const Nr={kernelName:e.jQs,backendName:"cpu",kernelFunc:function Lr(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{paddings:z,mode:rt}=G;(0,i.H)(y,"mirrorPad");const nt=z.map((Wt,bt)=>Wt[0]+y.shape[bt]+Wt[1]),ot=z.map(Wt=>Wt[0]),tt=z.map((Wt,bt)=>Wt[0]+y.shape[bt]),J="reflect"===rt?0:1,ft=A.data.get(y.dataId).values,lt=y.shape.length,Et=e.D5U.computeStrides(y.shape),Ot=e.D5U.sizeFromShape(nt),Ct=nt.length,Tt=e.D5U.computeStrides(nt),At=e.D5U.getTypedArrayFromDType(y.dtype,Ot);for(let Wt=0;Wt<Ot;Wt++){let bt=e.D5U.indexToLoc(Wt,Ct,Tt);for(let Yt=0;Yt<Ct;Yt++)bt[Yt]<ot[Yt]?bt[Yt]=2*ot[Yt]-bt[Yt]-J:bt[Yt]>=tt[Yt]&&(bt[Yt]=2*(tt[Yt]-1)-bt[Yt]+J);bt=bt.map((Yt,te)=>Yt-ot[te]);const zt=e.D5U.locToIndex(bt,lt,Et);At[Wt]=ft[zt]}return{dataId:A.write(At,nt,y.dtype),shape:nt,dtype:y.dtype}}},Ur=(0,o.b)((Q,et)=>{const A=Q%et;return Q<0&&et<0||Q>=0&&et>=0?A:(A+et)%et}),Wr=(0,Ut.j)(e.Vbg,Ur),kr={kernelName:e.Vbg,backendName:"cpu",kernelFunc:Wr};var wr=t(89128);function fr(Q){const{inputs:et,backend:A,attrs:G}=Q,{logits:y}=et,{dim:z}=G,rt=y.shape.length;let nt=z;if(-1===nt&&(nt=rt-1),nt!==rt-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${rt} and dim was ${nt}`);const ot=e.D5U.parseAxisParam([nt],y.shape),tt=Dn({inputs:{x:y},backend:A,attrs:{reductionIndices:ot,keepDims:!1}}),J=e.backend_util.expandShapeToKeepDim(tt.shape,ot),ft=S({inputs:{x:tt},backend:A,attrs:{shape:J}}),lt=(0,to.lu)({inputs:{a:y,b:ft},backend:A}),Et=(0,ms.Qq)({inputs:{x:lt},backend:A}),Ot=nn({inputs:{x:Et},backend:A,attrs:{axis:ot,keepDims:!1}}),Ct=S({inputs:{x:Ot},backend:A,attrs:{shape:J}}),Tt=qs({inputs:{a:Et,b:Ct},backend:A});return A.disposeIntermediateTensorInfo(tt),A.disposeIntermediateTensorInfo(ft),A.disposeIntermediateTensorInfo(lt),A.disposeIntermediateTensorInfo(Et),A.disposeIntermediateTensorInfo(Ot),A.disposeIntermediateTensorInfo(Ct),Tt}const Fr={kernelName:e.Gcp,backendName:"cpu",kernelFunc:fr},Ki={kernelName:e.NZg,backendName:"cpu",kernelFunc:function Fi(Q){const{inputs:et,backend:A,attrs:G}=Q,{logits:y}=et,{numSamples:z,seed:rt,normalized:nt}=G;(0,i.H)(y,"multinomial");const ot=nt?y:fr({inputs:{logits:y},backend:A,attrs:{dim:-1}}),tt=ot.shape[0],J=ot.shape[1],ft=A.data.get(ot.dataId).values,lt=[tt,z],Et=e.D5U.makeZerosTypedArray(e.D5U.sizeFromShape(lt),"int32");for(let Ot=0;Ot<tt;++Ot){const Ct=Ot*J,Tt=new Float32Array(J-1);Tt[0]=ft[Ct];for(let Wt=1;Wt<Tt.length;++Wt)Tt[Wt]=Tt[Wt-1]+ft[Ct+Wt];const At=wr.alea(rt.toString()),Bt=Ot*z;for(let Wt=0;Wt<z;++Wt){const bt=At();Et[Bt+Wt]=Tt.length;for(let zt=0;zt<Tt.length;zt++)if(bt<Tt[zt]){Et[Bt+Wt]=zt;break}}}return nt||A.disposeIntermediateTensorInfo(ot),A.makeTensorInfo(lt,"int32",Et)}};var Kr=t(19994);const Vr=e.GDt.nonMaxSuppressionV3Impl,Gr={kernelName:e.uv1,backendName:"cpu",kernelFunc:function zr(Q){const{inputs:et,backend:A,attrs:G}=Q,{boxes:y,scores:z}=et,{maxOutputSize:rt,iouThreshold:nt,scoreThreshold:ot}=G;(0,i.H)(y,"NonMaxSuppression");const tt=A.data.get(y.dataId).values,J=A.data.get(z.dataId).values,{selectedIndices:ft}=Vr(tt,J,rt,nt,ot);return A.makeTensorInfo([ft.length],"int32",new Int32Array(ft))}},Hr=e.GDt.nonMaxSuppressionV4Impl,Vi={kernelName:e.cye,backendName:"cpu",kernelFunc:function jr(Q){const{inputs:et,backend:A,attrs:G}=Q,{boxes:y,scores:z}=et,{maxOutputSize:rt,iouThreshold:nt,scoreThreshold:ot,padToMaxOutputSize:tt}=G;(0,i.H)(y,"NonMaxSuppressionPadded");const J=A.data.get(y.dataId).values,ft=A.data.get(z.dataId).values,{selectedIndices:lt,validOutputs:Et}=Hr(J,ft,rt,nt,ot,tt);return[A.makeTensorInfo([lt.length],"int32",new Int32Array(lt)),A.makeTensorInfo([],"int32",new Int32Array([Et]))]}},zi=e.GDt.nonMaxSuppressionV5Impl,Yr={kernelName:e.W0H,backendName:"cpu",kernelFunc:function Xr(Q){const{inputs:et,backend:A,attrs:G}=Q,{boxes:y,scores:z}=et,{maxOutputSize:rt,iouThreshold:nt,scoreThreshold:ot,softNmsSigma:tt}=G;(0,i.H)(y,"NonMaxSuppressionWithScore");const J=A.data.get(y.dataId).values,ft=A.data.get(z.dataId).values,lt=rt,Et=nt,Ot=ot,Ct=tt,{selectedIndices:Tt,selectedScores:At}=zi(J,ft,lt,Et,Ot,Ct);return[A.makeTensorInfo([Tt.length],"int32",new Int32Array(Tt)),A.makeTensorInfo([At.length],"float32",new Float32Array(At))]}};var Zr=t(47555);const Jr={kernelName:e.we_,backendName:"cpu",kernelFunc:function Qr(Q){const{inputs:et,backend:A,attrs:G}=Q,{indices:y}=et,{dtype:z,depth:rt,onValue:nt,offValue:ot}=G;(0,i.H)(y,"oneHot");const tt=e.D5U.sizeFromShape(y.shape),J=new Float32Array(tt*rt);J.fill(ot);const ft=A.data.get(y.dataId).values;for(let lt=0;lt<tt;++lt)ft[lt]>=0&&ft[lt]<rt&&(J[lt*rt+ft[lt]]=nt);return A.makeTensorInfo([...y.shape,rt],z,J)}};function Po(Q){const{inputs:et,backend:A}=Q,{x:G}=et;if("string"===G.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===G.dtype){const y=(0,kn.k)({inputs:{input:G},backend:A}),z=Po({inputs:{x:y},backend:A}),rt=Ln({inputs:{input:G},backend:A}),nt=Po({inputs:{x:rt},backend:A}),ot=(0,vn.P)({inputs:{real:z,imag:nt},backend:A});return A.disposeIntermediateTensorInfo(y),A.disposeIntermediateTensorInfo(z),A.disposeIntermediateTensorInfo(rt),A.disposeIntermediateTensorInfo(nt),ot}return Zn({backend:A,attrs:{shape:G.shape,value:0,dtype:G.dtype}})}const Gi={kernelName:e.RuY,backendName:"cpu",kernelFunc:Po},qr={kernelName:e.qWM,backendName:"cpu",kernelFunc:function ir(Q){const{inputs:et,backend:A}=Q,{x:G}=et;if("string"===G.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===G.dtype){const y=(0,kn.k)({inputs:{input:G},backend:A}),z=ir({inputs:{x:y},backend:A}),rt=Ln({inputs:{input:G},backend:A}),nt=Po({inputs:{x:rt},backend:A}),ot=(0,vn.P)({inputs:{real:z,imag:nt},backend:A});return A.disposeIntermediateTensorInfo(y),A.disposeIntermediateTensorInfo(z),A.disposeIntermediateTensorInfo(rt),A.disposeIntermediateTensorInfo(nt),ot}return Zn({backend:A,attrs:{shape:G.shape,value:1,dtype:G.dtype}})}};function Mo(Q){const{inputs:et,backend:A,attrs:G}=Q,{axis:y}=G;if(1===et.length)return gs({inputs:{input:et[0]},backend:A,attrs:{dim:y}});const z=et[0].shape,rt=et[0].dtype;et.forEach(J=>{e.D5U.assertShapesMatch(z,J.shape,"All tensors passed to stack must have matching shapes"),e.D5U.assert(rt===J.dtype,()=>"All tensors passed to stack must have matching dtypes")});const nt=[],tt=wn({inputs:et.map(J=>{const ft=gs({inputs:{input:J},backend:A,attrs:{dim:y}});return nt.push(ft),ft}),backend:A,attrs:{axis:y}});return nt.forEach(J=>A.disposeIntermediateTensorInfo(J)),tt}const ta={kernelName:e.QiL,backendName:"cpu",kernelFunc:Mo},gr={kernelName:e.lyA,backendName:"cpu",kernelFunc:function mr(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{paddings:z,constantValue:rt}=G;(0,i.H)(y,"pad");const nt=z.map((Bt,Wt)=>Bt[0]+y.shape[Wt]+Bt[1]),ot=z.map(Bt=>Bt[0]),tt=A.data.get(y.dataId).values,J=e.D5U.sizeFromShape(y.shape),ft=y.shape.length,lt=e.D5U.computeStrides(y.shape),Et=e.D5U.sizeFromShape(nt),Ot=nt.length,Ct=e.D5U.computeStrides(nt),Tt=e.D5U.getTypedArrayFromDType(y.dtype,Et);0!==rt&&Tt.fill(rt);for(let Bt=0;Bt<J;Bt++){const bt=e.D5U.indexToLoc(Bt,ft,lt).map((Yt,te)=>Yt+ot[te]);Tt[e.D5U.locToIndex(bt,Ot,Ct)]=tt[Bt]}return{dataId:A.write(Tt,nt,y.dtype),shape:nt,dtype:y.dtype}}},ea=(0,o.b)((Q,et)=>Math.pow(Q,et)),_r=(0,Ut.j)(e.pe_,ea),Er={kernelName:e.pe_,backendName:"cpu",kernelFunc:_r};var na=t(12585),sa=t(86134);const io={kernelName:e.dDz,backendName:"cpu",kernelFunc:function oa(Q){const{inputs:et,backend:A,attrs:G}=Q,{paramsNestedSplits:y,paramsDenseValues:z,indices:rt}=et,{outputRaggedRank:nt}=G,ot=y.map(At=>A.data.get(At.dataId).values),tt=y.map(At=>At.shape),J=A.data.get(z.dataId).values,ft=A.data.get(rt.dataId).values,[lt,Et,Ot]=(0,sa.c)(ot,tt,J,z.shape,z.dtype,ft,rt.shape,nt),Ct=lt.map(At=>A.makeTensorInfo([At.length],"int32",At)),Tt=A.makeTensorInfo(Ot,z.dtype,Et);return Ct.concat([Tt])}};var ra=t(20832);const ia={kernelName:e.CQl,backendName:"cpu",kernelFunc:function aa(Q){const{inputs:et,backend:A}=Q,{starts:G,limits:y,deltas:z}=et,rt=A.data.get(G.dataId).values,nt=A.data.get(y.dataId).values,ot=A.data.get(z.dataId).values,[tt,J]=(0,ra.S)(rt,G.shape,G.dtype,nt,y.shape,ot,z.shape);return[A.makeTensorInfo([tt.length],"int32",tt),A.makeTensorInfo([J.length],G.dtype,J)]}};var xr=t(50820);const ua={kernelName:e.BiW,backendName:"cpu",kernelFunc:function la(Q){const{inputs:et,backend:A,attrs:G}=Q,{shape:y,values:z,defaultValue:rt,rowPartitionTensors:nt}=et,{rowPartitionTypes:ot}=G,tt=A.data.get(y.dataId).values,J=A.data.get(z.dataId).values,ft=A.data.get(rt.dataId).values,lt=nt.map(Tt=>A.data.get(Tt.dataId).values),Et=nt.map(Tt=>Tt.shape),[Ot,Ct]=(0,xr.p)(tt,y.shape,J,z.shape,z.dtype,ft,rt.shape,lt,Et,ot);return A.makeTensorInfo(Ot,z.dtype,Ct)}};var Hi=t(26229);const ca={kernelName:e.e6w,backendName:"cpu",kernelFunc:function ji(Q){const{backend:et,attrs:A}=Q,{start:G,stop:y,dtype:z,step:rt}=A,nt=(0,Hi.b)(G,y,rt,z);return et.makeTensorInfo([nt.length],z,nt)}},da=(0,a.A)(e.$HU,Q=>1/Q),ha={kernelName:e.$HU,backendName:"cpu",kernelFunc:da},fa={kernelName:e._Yw,backendName:"cpu",kernelFunc:function pa(Q){const{inputs:et,backend:A,attrs:G}=Q,{images:y}=et,{alignCorners:z,halfPixelCenters:rt,size:nt}=G;(0,i.H)(y,"resizeBilinear");const ot=e.D5U.computeStrides(y.shape),[tt,J]=nt,[ft,lt,Et,Ot]=y.shape,Ct=A.data.get(y.dataId).values,Tt=new Float32Array(e.D5U.sizeFromShape([ft,tt,J,Ot])),At=[z&&tt>1?lt-1:lt,z&&J>1?Et-1:Et],Bt=[z&&tt>1?tt-1:tt,z&&J>1?J-1:J];let Wt=0;const bt=At[0]/Bt[0],zt=At[1]/Bt[1];for(let Yt=0;Yt<ft;Yt++)for(let te=0;te<tt;te++){let pe;pe=rt?bt*(te+.5)-.5:bt*te;const _e=Math.max(0,Math.floor(pe)),me=pe-_e,Ce=Math.min(lt-1,Math.ceil(pe)),Oe=Yt*ot[0]+_e*ot[1],ue=Yt*ot[0]+Ce*ot[1];for(let fe=0;fe<J;fe++){let le;le=rt?zt*(fe+.5)-.5:zt*fe;const ce=Math.max(0,Math.floor(le)),ve=le-ce,de=Math.min(Et-1,Math.ceil(le)),ge=Oe+ce*ot[2],ye=ue+ce*ot[2],Pe=Oe+de*ot[2],$e=ue+de*ot[2];for(let Me=0;Me<Ot;Me++){const Le=Ct[ge+Me],be=Ct[ye+Me],He=Le+(Ct[Pe+Me]-Le)*ve;Tt[Wt++]=He+(be+(Ct[$e+Me]-be)*ve-He)*me}}}return A.makeTensorInfo([ft,tt,J,Ot],"float32",Tt)}},Ds={kernelName:e.zbQ,backendName:"cpu",kernelFunc:function ma(Q){const{inputs:et,backend:A,attrs:G}=Q,{images:y,dy:z}=et,{alignCorners:rt}=G;(0,i.H)([z,y],"resizeBilinearGrad");const nt=e.D5U.computeStrides(y.shape),[ot,tt,J,ft]=y.shape,[,lt,Et]=z.shape,Ot=new Float32Array(ot*tt*J*ft),Ct=[rt&&lt>1?tt-1:tt,rt&&Et>1?J-1:J],Tt=[rt&&lt>1?lt-1:lt,rt&&Et>1?Et-1:Et],At=Ct[0]/Tt[0],Bt=Ct[1]/Tt[1],Wt=A.data.get(z.dataId).values;let bt=0;for(let zt=0;zt<ot;zt++){const Yt=zt*nt[0];for(let te=0;te<lt;te++){const pe=te*At,_e=Math.floor(pe),me=Math.min(Math.ceil(pe),tt-1),Ce=Yt+_e*nt[1],Oe=Yt+me*nt[1],ue=pe-_e,fe=1-ue;for(let le=0;le<Et;le++){const ce=le*Bt,ve=Math.floor(ce),de=Math.min(Math.ceil(ce),J-1),ge=ce-ve,ye=1-ge,Pe=Ce+ve*nt[2],$e=Ce+de*nt[2],Me=Oe+ve*nt[2],Le=Oe+de*nt[2],be=fe*ye,ke=fe*ge,Ve=ue*ye,He=ue*ge;for(let ze=0;ze<ft;ze++){const Ze=Wt[bt++];Ot[Pe+ze]+=Ze*be,Ot[$e+ze]+=Ze*ke,Ot[Me+ze]+=Ze*Ve,Ot[Le+ze]+=Ze*He}}}}return A.makeTensorInfo([ot,J,tt,ft],"float32",Ot)}},ga={kernelName:e.dpD,backendName:"cpu",kernelFunc:function lr(Q){const{inputs:et,backend:A,attrs:G}=Q,{images:y}=et,{alignCorners:z,halfPixelCenters:rt,size:nt}=G;(0,i.H)(y,"resizeNearestNeighbor");const ot=e.D5U.computeStrides(y.shape),[tt,J]=nt,[ft,lt,Et,Ot]=y.shape,Ct=A.data.get(y.dataId).values,Tt=new Float32Array(ft*tt*J*Ot),At=[z&&tt>1?lt-1:lt,z&&J>1?Et-1:Et],Bt=[z&&tt>1?tt-1:tt,z&&J>1?J-1:J],Wt=At[0]/Bt[0],bt=At[1]/Bt[1];let zt=0;for(let Yt=0;Yt<ft;Yt++){const te=Yt*ot[0];for(let pe=0;pe<tt;pe++){const _e=rt?Wt*(pe+.5):Wt*pe;let me=Math.min(lt-1,z?Math.round(_e):Math.floor(_e));rt&&(me=Math.max(0,me));const Ce=te+me*ot[1];for(let Oe=0;Oe<J;Oe++){const ue=rt?bt*(Oe+.5):bt*Oe;let fe=Math.min(Et-1,z?Math.round(ue):Math.floor(ue));rt&&(fe=Math.max(0,fe));const le=Ce+fe*ot[2];for(let ce=0;ce<Ot;ce++)Tt[zt++]=Ct[le+ce]}}}return A.makeTensorInfo([ft,tt,J,Ot],y.dtype,Tt)}},Ea={kernelName:e.Hmb,backendName:"cpu",kernelFunc:function _a(Q){const{inputs:et,backend:A,attrs:G}=Q,{images:y,dy:z}=et,{alignCorners:rt}=G;(0,i.H)([z,y],"resizeNearestNeighborGrad");const nt=e.D5U.computeStrides(y.shape),ot=e.D5U.computeStrides(z.shape),[tt,J,ft,lt]=y.shape,[,Et,Ot]=z.shape,Ct=new Float32Array(tt*J*ft*lt),Tt=A.data.get(z.dataId).values,At=[rt&&Et>1?J-1:J,rt&&Ot>1?ft-1:ft],Bt=[rt&&Et>1?Et-1:Et,rt&&Ot>1?Ot-1:Ot],Wt=At[0]/Bt[0],bt=At[1]/Bt[1],zt=1/Wt,Yt=1/bt,te=2*Math.ceil(zt)+2,pe=2*Math.ceil(Yt)+2;for(let _e=0;_e<tt;_e++){const me=_e*nt[0];for(let Ce=0;Ce<J;Ce++){const Oe=me+Ce*nt[1],ue=Math.floor(Ce*zt),fe=Math.floor(ue-te/2);for(let le=0;le<ft;le++){const ce=Oe+le*nt[2],ve=Math.floor(le*Yt),de=Math.floor(ve-pe/2);for(let ge=0;ge<lt;ge++){let ye=0;for(let Pe=0;Pe<te;Pe++){const $e=Pe+fe;if($e<0||$e>=Et)continue;const Me=me+$e*ot[1],Le=$e*Wt;if(Ce===Math.min(J-1,rt?Math.round(Le):Math.floor(Le)))for(let ke=0;ke<pe;ke++){const Ve=ke+de;if(Ve<0||Ve>=Ot)continue;const He=Me+Ve*ot[2],ze=Ve*bt;le===Math.min(ft-1,rt?Math.round(ze):Math.floor(ze))&&(ye+=Tt[He+ge])}}Ct[ce+ge]=ye}}}}return A.makeTensorInfo(y.shape,y.dtype,Ct)}},Da={kernelName:e.mKl,backendName:"cpu",kernelFunc:function xa(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{dims:z}=G;(0,i.H)(y,"reverse");const rt=y.shape.length,nt=e.D5U.parseAxisParam(z,y.shape);if(0===rt)return(0,h.y)({inputs:{x:y},backend:A});const ot=new e.YDk(y.shape,y.dtype),tt=A.bufferSync(y);for(let J=0;J<ot.size;J++){const ft=ot.indexToLoc(J),lt=ft.slice();nt.forEach(Et=>lt[Et]=y.shape[Et]-1-lt[Et]),ot.set(tt.get(...lt),...ft)}return A.makeTensorInfo(ot.shape,ot.dtype,ot.values)}},va={kernelName:e.b9H,backendName:"cpu",kernelFunc:({inputs:Q,attrs:et,backend:A})=>{const{image:G}=Q,{radians:y,fillValue:z,center:rt}=et,nt=A,ot=e.D5U.getTypedArrayFromDType(G.dtype,e.D5U.sizeFromShape(G.shape)),[tt,J,ft,lt]=G.shape,[Et,Ot]=e.backend_util.getImageCenter(rt,J,ft),Tt=Math.sin(y),At=Math.cos(y),Bt=nt.data.get(G.dataId).values;for(let bt=0;bt<tt;bt++){const zt=bt*ft*J*lt;for(let Yt=0;Yt<J;Yt++){const te=Yt*(ft*lt);for(let pe=0;pe<ft;pe++){const _e=pe*lt;for(let me=0;me<lt;me++){const Ce=[tt,Yt,pe,me],Oe=Ce[2],ue=Ce[1];let fe=(Oe-Et)*At-(ue-Ot)*Tt,le=(Oe-Et)*Tt+(ue-Ot)*At;fe=Math.round(fe+Et),le=Math.round(le+Ot);let ce=z;"number"!=typeof z&&(ce=3===me?255:z[me]),fe>=0&&fe<ft&&le>=0&&le<J&&(ce=Bt[zt+le*(ft*lt)+fe*lt+me]),ot[zt+te+_e+me]=ce}}}}return{dataId:nt.write(ot,G.shape,G.dtype),shape:G.shape,dtype:G.dtype}}},Ca=(0,a.A)(e.e07,Q=>{const et=Math.floor(Q);return Q-et<.5?Math.floor(Q):Q-et>.5?Math.ceil(Q):et%2==0?et:et+1}),Ia={kernelName:e.e07,backendName:"cpu",kernelFunc:Ca};var Oa=t(41509),vs=t(32529);const Pa={kernelName:e.xQA,backendName:"cpu",kernelFunc:function Dr(Q){const{inputs:et,backend:A,attrs:G}=Q,{indices:y,updates:z}=et,{shape:rt}=G,{sliceRank:nt,numUpdates:ot,sliceSize:tt,strides:J,outputSize:ft}=e.backend_util.calculateShapes(z,y,rt),Et=A.bufferSync(y),Ot=A.bufferSync(z),Ct=(0,vs.N)(Et,Ot,rt,ft,tt,ot,nt,J,0,!0);return A.makeTensorInfo(rt,Ct.dtype,Ct.values)}};function Xi(Q,et){let A=0,G=Q.length,y=0;for(;A<G;)y=Math.floor((A+G)/2),Q[y]<et?A=y+1:G=y;return G}function Yi(Q,et){let A=0,G=Q.length,y=0;for(;A<G;)y=Math.floor((A+G)/2),Q[y]<=et?A=y+1:G=y;return G}const Zi={kernelName:e.nr8,backendName:"cpu",kernelFunc:function Ta(Q){const{inputs:et,backend:A,attrs:G}=Q,{sortedSequence:y,values:z}=et,{side:rt}=G,tt=function Ma(Q,et,A,G,y,z){const rt=e.D5U.getArrayFromDType("int32",A*y);for(let nt=0;nt<A;++nt){const ot=Q.slice(nt*G,(nt+1)*G),tt=nt*y;for(let J=0;J<y;++J)rt[tt+J]="left"===z?Xi(ot,et[J+tt]):Yi(ot,et[J+tt])}return rt}(A.data.get(y.dataId).values,A.data.get(z.dataId).values,y.shape[0],y.shape[1],z.shape[1],rt);return A.makeTensorInfo(z.shape,"int32",tt)}},ya={kernelName:e.PhF,backendName:"cpu",kernelFunc:function Qi(Q){const{inputs:et,backend:A}=Q,{condition:G,t:y,e:z}=et;(0,i.H)([G,y,z],"select");const rt=G.shape.length,nt=A.data.get(G.dataId).values,ot=A.data.get(y.dataId).values,tt=A.data.get(z.dataId).values,J=(0,e.x8V)(y.dtype,z.dtype),ft=e.D5U.makeZerosTypedArray(e.D5U.sizeFromShape(y.shape),J);let lt=0;const Et=0===rt||rt>1||1===y.shape.length?1:e.D5U.sizeFromShape(y.shape.slice(1));for(let Ot=0;Ot<nt.length;Ot++)for(let Ct=0;Ct<Et;Ct++)ft[lt++]=1===nt[Ot]?ot[Ot]:tt[Ot];return A.makeTensorInfo(y.shape,J,ft)}},Ra=e.backend_util.SELU_SCALEALPHA,Aa=e.backend_util.SELU_SCALE,Sa=(0,a.A)(e.oFR,Q=>Q>=0?Aa*Q:Ra*(Math.exp(Q)-1)),Ji={kernelName:e.oFR,backendName:"cpu",kernelFunc:Sa},ba=(0,a.A)(e.i5y,Q=>Q<0?-1:Q>0?1:0),$a={kernelName:e.i5y,backendName:"cpu",kernelFunc:ba},qi=(0,a.A)(e.RQH,Q=>Math.sin(Q)),Ba={kernelName:e.RQH,backendName:"cpu",kernelFunc:qi},La=(0,a.A)(e.wYB,Q=>Math.sinh(Q)),tl={kernelName:e.wYB,backendName:"cpu",kernelFunc:La},vr=Math.log(1.1920928955078125e-7)+2,nl=(0,a.A)(e.MRv,Q=>{const et=Q>-vr,A=Q<vr,G=Math.exp(Q);let y;return y=A?G:et?Q:Math.log(1+G),y}),sl={kernelName:e.MRv,backendName:"cpu",kernelFunc:nl},Ua={kernelName:e.TQc,backendName:"cpu",kernelFunc:function Na(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{blockShape:z,paddings:rt}=G;(0,i.H)([y],"spaceToBatchND");const nt=e.D5U.sizeFromShape(z),ot=[[0,0]];ot.push(...rt);for(let Yt=1+z.length;Yt<y.shape.length;++Yt)ot.push([0,0]);const tt=gr.kernelFunc({inputs:{x:y},backend:A,attrs:{paddings:ot,constantValue:0}}),J=e.backend_util.getReshaped(tt.shape,z,nt,!1),ft=e.backend_util.getPermuted(J.length,z.length,!1),lt=e.backend_util.getReshapedPermuted(tt.shape,z,nt,!1),Ct=S({inputs:{x:tt},backend:A,attrs:{shape:J}}),Bt=(0,Y.p)({inputs:{x:Ct},backend:A,attrs:{perm:ft}}),zt=S({inputs:{x:Bt},backend:A,attrs:{shape:lt}});return A.disposeIntermediateTensorInfo(tt),A.disposeIntermediateTensorInfo(Ct),A.disposeIntermediateTensorInfo(Bt),zt}};var ol=t(5483);const Wa={kernelName:e.O3z,backendName:"cpu",kernelFunc:function rl(Q){const{inputs:et,backend:A}=Q,{indices:G,values:y,denseShape:z,defaultValue:rt}=et;if(1!==z.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${z.shape}`);if(2!==G.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${G.shape}`);if(1!==y.shape.length)throw new Error(`Values must be a vector, saw:\n        ${y.shape}`);if(0!==rt.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${rt.shape}`);const nt=A.data.get(G.dataId).values,ot=A.data.get(y.dataId).values,tt=A.data.get(z.dataId).values,J=A.data.get(rt.dataId).values[0],[ft,lt,Et,Ot,Ct]=(0,ol.c)(nt,G.shape,G.dtype,ot,y.dtype,tt,J);return[A.makeTensorInfo(lt,G.dtype,ft),A.makeTensorInfo([lt[0]],y.dtype,Et),A.makeTensorInfo([Ot.length],"bool",new Uint8Array(Ot.map(Tt=>Number(Tt)))),A.makeTensorInfo([Ct.length],G.dtype,new Int32Array(Ct))]}};var ka=t(59912);const Fa={kernelName:e.nhH,backendName:"cpu",kernelFunc:function wa(Q){const{inputs:et,backend:A}=Q,{inputIndices:G,inputShape:y,newShape:z}=et;if(2!==G.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${G.shape}`);if(1!==y.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${y.shape}`);if(1!==z.shape.length)throw new Error(`Target shape should be a vector but received shape ${z.shape}`);const rt=Array.from(A.data.get(y.dataId).values),nt=A.data.get(G.dataId).values,ot=Array.from(A.data.get(z.dataId).values),[tt,J,ft]=(0,ka.U)(nt,G.shape,G.dtype,rt,ot);return[A.makeTensorInfo(J,G.dtype,tt),A.makeTensorInfo([ft.length],z.dtype,new Int32Array(ft))]}};var Cr=t(80391);const Ka={kernelName:e.w3H,backendName:"cpu",kernelFunc:function al(Q){const{inputs:et,backend:A}=Q,{data:G,indices:y,segmentIds:z}=et;if(G.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==y.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${y.shape}`);if(1!==z.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${z.shape}`);if(y.shape[0]!==z.shape[0])throw new Error("segmentIds and indices should have same size.");const rt=A.data.get(G.dataId).values,nt=A.data.get(y.dataId).values,ot=A.data.get(z.dataId).values,[tt,J]=(0,Cr.V)(rt,G.shape,G.dtype,nt,ot,!0);return A.makeTensorInfo(J,G.dtype,tt)}},za={kernelName:e.ZjV,backendName:"cpu",kernelFunc:function Va(Q){const{inputs:et,backend:A}=Q,{data:G,indices:y,segmentIds:z}=et;if(G.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==y.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${y.shape}`);if(1!==z.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${z.shape}`);if(y.shape[0]!==z.shape[0])throw new Error("segmentIds and indices should have same size.");const rt=A.data.get(G.dataId).values,nt=A.data.get(y.dataId).values,ot=A.data.get(z.dataId).values,[tt,J]=(0,Cr.V)(rt,G.shape,G.dtype,nt,ot);return A.makeTensorInfo(J,G.dtype,tt)}},Ha={kernelName:e.D2d,backendName:"cpu",kernelFunc:function Ga(Q){const{inputs:et,backend:A,attrs:G}=Q,{sparseIndices:y,sparseValues:z,defaultValue:rt}=et,{outputShape:nt}=G,{sliceRank:ot,numUpdates:tt,sliceSize:J,strides:ft,outputSize:lt}=e.backend_util.calculateShapes(z,y,nt),Et=!1,Ot=A.bufferSync(y);let Ct;switch(z.dtype){case"bool":{const Tt=A.bufferSync(z),At=!!A.data.get(rt.dataId).values[0];Ct=(0,vs.N)(Ot,Tt,nt,lt,J,tt,ot,ft,At,Et);break}case"float32":{const Tt=A.bufferSync(z),At=A.data.get(rt.dataId).values[0];Ct=(0,vs.N)(Ot,Tt,nt,lt,J,tt,ot,ft,At,Et);break}case"int32":{const Tt=A.bufferSync(z),At=A.data.get(rt.dataId).values[0];Ct=(0,vs.N)(Ot,Tt,nt,lt,J,tt,ot,ft,At,Et);break}case"string":{const Tt=A.bufferSync(z),At=e.D5U.decodeString(A.data.get(rt.dataId).values[0]);Ct=(0,vs.N)(Ot,Tt,nt,lt,J,tt,ot,ft,At,Et);break}default:throw new Error(`Unsupported type ${z.dtype}`)}return A.makeTensorInfo(nt,Ct.dtype,Ct.values)}},ll={kernelName:e.L8s,backendName:"cpu",kernelFunc:function il(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{numOrSizeSplits:z,axis:rt}=G,nt=e.D5U.parseAxisParam(rt,y.shape)[0],ot=e.backend_util.prepareSplitSize(y,z,nt),tt=new Array(y.shape.length).fill(0),J=y.shape.slice();return ot.map(ft=>{const lt=[...J];lt[nt]=ft;const Et=(0,hn.tP)({inputs:{x:y},backend:A,attrs:{begin:tt,size:lt}});return tt[nt]+=ft,Et})}};var ja=t(6769);const Xa={kernelName:e.bK0,backendName:"cpu",kernelFunc:({inputs:Q,backend:et})=>{const{x:A}=Q,G=et;(0,i.H)(A,"square");const y=G.data.get(A.dataId).values,z=new Float32Array(y.length);for(let nt=0;nt<y.length;++nt){const ot=y[nt];z[nt]=ot*ot}return{dataId:G.write(z,A.shape,A.dtype),shape:A.shape,dtype:A.dtype}}};var ul=t(4376),Ya=t(26893);const Za=(0,a.A)(e.h8e,(Q,et)=>{const A=et;return isNaN(Q)?NaN:Q>0?1:A.alpha}),cl={kernelName:e.h8e,backendName:"cpu",kernelFunc:Za};var dl=t(25549);const Ja={kernelName:e.jQk,backendName:"cpu",kernelFunc:function Qa(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{begin:z,end:rt,strides:nt,beginMask:ot,endMask:tt,ellipsisMask:J,newAxisMask:ft,shrinkAxisMask:lt}=G;(0,i.H)(y,"stridedSlice");const{finalShapeSparse:Et,finalShape:Ot,isIdentity:Ct,sliceDim0:Tt,isSimpleSlice:At,begin:Bt,end:Wt,strides:bt}=e.kuN.sliceInfo(y.shape,z,rt,nt,ot,tt,J,ft,lt);let zt;if(Ct)zt=S({inputs:{x:y},backend:A,attrs:{shape:Ot}});else if(Tt||At){e.D5U.assert(y.shape.length>=1,()=>`Input must have rank at least 1, got: ${y.shape.length}`);const Yt=e.kuN.computeOutShape(Bt,Wt,bt),te=(0,hn.tP)({inputs:{x:y},backend:A,attrs:{begin:Bt,size:Yt}});zt=S({inputs:{x:te},backend:A,attrs:{shape:Ot}}),A.disposeIntermediateTensorInfo(te)}else{const Yt=A.bufferSync(y),te=(0,dl.t)(Et,Yt,bt,Bt);zt=A.makeTensorInfo(Ot,te.dtype,te.values)}return zt}};var qa=t(23118);const ei={kernelName:e._JP,backendName:"cpu",kernelFunc:function ti(Q){const{inputs:et,backend:A,attrs:G}=Q,{separator:y,nGramWidths:z,leftPad:rt,rightPad:nt,padWidth:ot,preserveShortSequences:tt}=G,{data:J,dataSplits:ft}=et,lt=A.data.get(J.dataId).values,Et=A.data.get(ft.dataId).values,[Ot,Ct]=(0,qa.A)(lt,Et,y,z,rt,nt,ot,tt);return[A.makeTensorInfo([Ot.length],"string",Ot),A.makeTensorInfo(ft.shape,"int32",Ct)]}};var ni=t(6482);const oi={kernelName:e.s1s,backendName:"cpu",kernelFunc:function si(Q){const{inputs:et,backend:A,attrs:G}=Q,{skipEmpty:y}=G,{input:z,delimiter:rt}=et;if("string"!==z.dtype)throw new Error("Input must be of datatype string");if(1!==z.shape.length)throw new Error(`Input must be a vector, got shape: ${z.shape}`);if(0!==rt.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${rt.shape}`);const nt=A.data.get(z.dataId).values,ot=A.data.get(rt.dataId).values[0],[tt,J,ft]=(0,ni.Q)(nt,ot,y),lt=J.length;return[A.makeTensorInfo([lt,2],"int32",tt),A.makeTensorInfo([lt],"string",J),A.makeTensorInfo([2],"int32",new Int32Array(ft))]}};var ri=t(74105);const Ir={kernelName:e.XkS,backendName:"cpu",kernelFunc:function ai(Q){const{inputs:et,backend:A,attrs:G}=Q,{numBuckets:y}=G,{input:z}=et;if("string"!==z.dtype)throw new Error("Input must be of datatype string");if(y<=0)throw new Error("Number of buckets must be at least 1");const rt=A.data.get(z.dataId).values,nt=(0,ri.h)(rt,y);return A.makeTensorInfo(z.shape,"int32",nt)}},ii=(0,a.A)(e.sEM,Q=>Math.tan(Q)),li={kernelName:e.sEM,backendName:"cpu",kernelFunc:ii},ui=(0,a.A)(e.MIZ,Q=>Math.tanh(Q)),ci={kernelName:e.MIZ,backendName:"cpu",kernelFunc:ui},hi={kernelName:e.SIB,backendName:"cpu",kernelFunc:function di(Q){const{inputs:et,backend:A}=Q,{tensor:G,indices:y,updates:z}=et,{sliceRank:rt,numUpdates:nt,sliceSize:ot,strides:tt,outputSize:J}=e.backend_util.calculateShapes(z,y,G.shape),lt=A.bufferSync(y),Et=A.bufferSync(z),Ot=A.bufferSync(G),Ct=(0,vs.N)(lt,Et,G.shape,J,ot,nt,rt,tt,Ot,!1);return A.makeTensorInfo(G.shape,Ct.dtype,Ct.values)}};var pi=t(91692);const mi={kernelName:e.n9L,backendName:"cpu",kernelFunc:function fi(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{reps:z}=G;(0,i.H)(y,"tile");const rt=(0,pi.R)(A.bufferSync(y),z);return A.makeTensorInfo(rt.shape,rt.dtype,rt.values)}};var gi=t(39942);const Ei={kernelName:e.cWu,backendName:"cpu",kernelFunc:function _i(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y}=et,{k:z,sorted:rt}=G;(0,i.H)(y,"topk");const nt=A.data.get(y.dataId).values,[ot,tt]=(0,gi.W)(nt,y.shape,y.dtype,z,rt);return[A.makeTensorInfo(ot.shape,ot.dtype,ot.values),A.makeTensorInfo(tt.shape,tt.dtype,tt.values)]}},Di={kernelName:e.wx7,backendName:"cpu",kernelFunc:function xi(Q){const{inputs:et,attrs:A,backend:G}=Q,{image:y,transforms:z}=et,{interpolation:rt,fillMode:nt,fillValue:ot,outputShape:tt}=A,[J,ft,lt,Et]=y.shape,[Ot,Ct]=tt??[ft,lt],Tt=[J,Ot,Ct,Et],At=e.D5U.computeStrides(y.shape),Bt=At[0],Wt=At[1],bt=At[2],zt=e.D5U.computeStrides(Tt),Yt=zt[0],te=zt[1],pe=zt[2],_e=e.D5U.getTypedArrayFromDType(y.dtype,e.D5U.sizeFromShape(Tt));_e.fill(ot);const me=G.data.get(y.dataId).values,Ce=G.data.get(z.dataId).values;for(let ue=0;ue<J;++ue){const fe=1===z.shape[0]?Ce:Ce.subarray(8*ue,8*ue+8);for(let le=0;le<Ot;++le)for(let ce=0;ce<Ct;++ce)for(let ve=0;ve<Et;++ve){let de;const ge=fe[6]*ce+fe[7]*le+1;if(0===ge)continue;const Pe=(fe[3]*ce+fe[4]*le+fe[5])/ge,$e=Or((fe[0]*ce+fe[1]*le+fe[2])/ge,lt,nt),Me=Or(Pe,ft,nt);switch(rt){case"nearest":de=Pi(me,ft,lt,Bt,Wt,bt,ue,Me,$e,ve,ot);break;case"bilinear":de=Mi(me,ft,lt,Bt,Wt,bt,ue,Me,$e,ve,ot);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${rt}`)}_e[ue*Yt+le*te+ce*pe+ve]=de}return G.makeTensorInfo(Tt,y.dtype,_e)}return{dataId:G.write(_e,Tt,y.dtype),shape:y.shape,dtype:y.dtype}}};function Or(Q,et,A){switch(A){case"reflect":return function vi(Q,et){let A=Q;if(A<0)if(et<=1)A=0;else{const G=2*et;A<G&&(A=G*Math.trunc(-A/G)+A),A=A<-et?A+G:-A-1}else if(A>et-1)if(et<=1)A=0;else{const G=2*et;A-=G*Math.trunc(A/G),A>=et&&(A=G-A-1)}return e.D5U.clamp(0,A,et-1)}(Q,et);case"wrap":return function Ci(Q,et){let A=Q;return A<0?et<=1?A=0:A+=et*(Math.trunc(-A/(et-1))+1):A>et-1&&(et<=1?A=0:A-=et*Math.trunc(A/(et-1))),e.D5U.clamp(0,A,et-1)}(Q,et);case"nearest":return function Oi(Q,et){return e.D5U.clamp(0,Q,et-1)}(Q,et);default:return function Ii(Q){return Q}(Q)}}function lo(Q,et,A,G,y,z,rt,nt,ot,tt,J){return 0<=nt&&nt<et&&0<=ot&&ot<A?Q[rt*G+nt*y+ot*z+tt]:J}function Pi(Q,et,A,G,y,z,rt,nt,ot,tt,J){return lo(Q,et,A,G,y,z,rt,Math.round(nt),Math.round(ot),tt,J)}function Mi(Q,et,A,G,y,z,rt,nt,ot,tt,J){const ft=Math.floor(nt),lt=Math.floor(ot),Et=ft+1,Ot=lt+1;return(Et-nt)*((Ot-ot)*lo(Q,et,A,G,y,z,rt,ft,lt,tt,J)+(ot-lt)*lo(Q,et,A,G,y,z,rt,ft,Ot,tt,J))+(nt-ft)*((Ot-ot)*lo(Q,et,A,G,y,z,rt,Et,lt,tt,J)+(ot-lt)*lo(Q,et,A,G,y,z,rt,Et,Ot,tt,J))}var Ti=t(50705);const Bi=[b,E.fC,W,X,T.j4,Dt,Pt,xt,Vt,oe,Ie,Zt,It,j,dt,Be,we,Te,tn,N,mn,ns,re,Qt.T0,Ue,We.Mq,rn.y2,An,vn.z,dn,ds,Os,Ms,ys,Rs,Ss,$s,Ls,Yn,Ns,Ws,ws,Ks,os,zs,Fn,js,rs,Ys,Zs,Qs,wt,Js,c,Ao,ho.Kx,Lo,ms.SX,fo,No.Vu,Fo,Es,is,Vo.Ao,go.EE,Eo,Do,xs,Go,Ho.Ce,jo.V,h.I,Yo,cs,Qo,qo,er,l,nr.zh,sr.m3,vt,yt.xM,Xt,qt,Xe,ln,Vn,oo,ls,or.eJ,rr,ar,hr,Tr,Rr,Sr,$r,Br.u0,Nr,kr,Ki,xe.f$,Kr.AF,Gr,Vi,Yr,Zr.nP,Jr,qr,ta,gr,Er,r,na.Iz,io,ia,ua,ca,kn.O,_s,ha,p,_,P,fa,Ds,ga,Ea,Da,va,Ia,Oa.FY,Pa,Zi,ya,Ji,v.BP,$a,Ba,tl,hn.C6,Fr,sl,Ua,Wa,Fa,Ka,za,Ha,ll,ja.cz,Xa,ul.MS,Ya.j,cl,Ja,ei,oi,Ir,to.GR,En,li,ci,hi,mi,Ei,Di,Y.b,{kernelName:e.kpP,backendName:"cpu",kernelFunc:function yi(Q){const{inputs:et,attrs:A,backend:G}=Q,{axis:y}=A,{x:z}=et;(0,i.H)(z,"unique");const rt=G.data.get(z.dataId).values,{outputValues:nt,outputShape:ot,indices:tt}=(0,Ti.S)(rt,y,z.shape,z.dtype);return[G.makeTensorInfo(ot,z.dtype,nt),G.makeTensorInfo([tt.length],"int32",tt)]}},{kernelName:e.ToN,backendName:"cpu",kernelFunc:function Ai(Q){const{inputs:et,backend:A,attrs:G}=Q,{value:y}=et;let{axis:z}=G;z<0&&(z+=y.shape.length);const rt=y.shape.length,nt=y.shape[z],ot=new Array(rt-1);let tt=0;for(let Et=0;Et<rt;Et++)Et!==z&&(ot[tt++]=y.shape[Et]);const J=new Array(rt).fill(0),ft=y.shape.slice();ft[z]=1;const lt=new Array(nt);for(let Et=0;Et<lt.length;Et++){J[z]=Et;const Ot=(0,hn.tP)({inputs:{x:y},backend:A,attrs:{begin:J,size:ft}});lt[Et]=S({inputs:{x:Ot},backend:A,attrs:{shape:ot}}),A.disposeIntermediateTensorInfo(Ot)}return lt}},{kernelName:e.Qvg,backendName:"cpu",kernelFunc:function bi(Q){const{inputs:et,backend:A,attrs:G}=Q,{x:y,segmentIds:z}=et,{numSegments:rt}=G;(0,i.H)(y,"unsortedSegmentSum");const tt=[],J=[],ft=y.shape.length-z.shape.length;let lt=z;for(let Ot=0;Ot<ft;++Ot){const Ct=gs({inputs:{input:lt},backend:A,attrs:{dim:Ot+1}});lt=Ct,J.push(Ct)}for(let Ot=0;Ot<rt;++Ot){const Ct=e.D5U.createScalarValue(Ot,"int32"),Tt=A.makeTensorInfo([],"int32",Ct),At=(0,ho.Dg)({inputs:{a:Tt,b:lt},backend:A}),Bt=(0,We.pj)({inputs:{x:At},backend:A,attrs:{dtype:"float32"}}),Wt=(0,xe.Jp)({inputs:{a:Bt,b:y},backend:A}),bt=nn({inputs:{x:Wt},backend:A,attrs:{axis:0,keepDims:!1}});tt.push(bt),J.push(Tt),J.push(At),J.push(Bt),J.push(Wt),J.push(bt)}const Et=Mo({inputs:tt,backend:A,attrs:{axis:0}});return J.forEach(Ot=>A.disposeIntermediateTensorInfo(Ot)),Et}},Gi];for(const Q of Bi)(0,e.wCN)(Q)},89450:(H,C,t)=>{"use strict";t.d(C,{b:()=>a});var e=t(30003);function a(u){return(c,h,i,f,l)=>{const o=e.backend_util.assertAndGetBroadcastShape(c,h),n=o.length,s=e.D5U.computeStrides(o),r=e.D5U.sizeFromShape(o),d=e.D5U.getTypedArrayFromDType(l,r),p=c.length,g=h.length,_=e.D5U.computeStrides(c),v=e.D5U.computeStrides(h),M=e.backend_util.getBroadcastDims(c,o),T=e.backend_util.getBroadcastDims(h,o);if(M.length+T.length===0)for(let S=0;S<d.length;++S)d[S]=u(i[S%i.length],f[S%f.length]);else for(let S=0;S<d.length;++S){const P=e.D5U.indexToLoc(S,n,s),L=P.slice(-p);M.forEach(E=>L[E]=0);const N=e.D5U.locToIndex(L,p,_),O=P.slice(-g);T.forEach(E=>O[E]=0);const b=e.D5U.locToIndex(O,g,v);d[S]=u(i[N],f[b])}return[d,o]}}},9642:(H,C,t)=>{"use strict";t.d(C,{H:()=>i,j:()=>h});var e=t(30003),a=t(14050),u=t(21928),c=t(23392);function h(f,l,o,n){return null==o?({inputs:s,backend:r})=>{const{a:d,b:p}=s,g=r;(0,a.H)([d,p],f);const _=g.data.get(d.dataId).values,v=g.data.get(p.dataId).values,M="string"===d.dtype?e.backend_util.fromUint8ToStringArray(_):_,T="string"===d.dtype?e.backend_util.fromUint8ToStringArray(v):v,S=n||d.dtype,[P,L]=l(d.shape,p.shape,M,T,S);return g.makeTensorInfo(L,S,P)}:({inputs:s,backend:r})=>{const{a:d,b:p}=s,g=r;if("complex64"===d.dtype||"complex64"===p.dtype){const _=(0,u.pj)({inputs:{x:d},backend:g,attrs:{dtype:"complex64"}}),v=g.data.get(_.dataId),T=v.complexTensorInfos.imag,S=g.data.get(v.complexTensorInfos.real.dataId).values,P=g.data.get(T.dataId).values,L=(0,u.pj)({inputs:{x:p},backend:g,attrs:{dtype:"complex64"}}),N=g.data.get(L.dataId),b=N.complexTensorInfos.imag,E=g.data.get(N.complexTensorInfos.real.dataId).values,$=g.data.get(b.dataId).values,[W,Z,X]=o(d.shape,p.shape,S,P,E,$),ut=g.makeTensorInfo(X,"float32",W),Dt=g.makeTensorInfo(X,"float32",Z),Y=(0,c.P)({inputs:{real:ut,imag:Dt},backend:g});return g.disposeIntermediateTensorInfo(_),g.disposeIntermediateTensorInfo(L),g.disposeIntermediateTensorInfo(ut),g.disposeIntermediateTensorInfo(Dt),Y}{const _=g.data.get(d.dataId).values,v=g.data.get(p.dataId).values,M=n||d.dtype,[T,S]=l(d.shape,p.shape,_,v,M);return g.makeTensorInfo(S,M,T)}}}function i(f){return(l,o,n,s,r,d)=>{const p=e.backend_util.assertAndGetBroadcastShape(l,o),g=e.D5U.sizeFromShape(p),_=p.length,v=e.D5U.computeStrides(p),M=e.D5U.getTypedArrayFromDType("float32",g),T=e.D5U.getTypedArrayFromDType("float32",g),S=e.backend_util.getBroadcastDims(l,p),P=e.backend_util.getBroadcastDims(o,p),L=e.backend_util.mergeRealAndImagArrays(n,s),N=e.backend_util.mergeRealAndImagArrays(r,d),O=l.length,b=e.D5U.computeStrides(l),E=o.length,$=e.D5U.computeStrides(o);if(S.length+P.length===0)for(let W=0;W<M.length;W++){const Z=W%L.length,X=W%N.length,ut=f(L[2*Z],L[2*Z+1],N[2*X],N[2*X+1]);M[W]=ut.real,T[W]=ut.imag}else for(let W=0;W<M.length;W++){const Z=e.D5U.indexToLoc(W,_,v),X=Z.slice(-O);S.forEach(Pt=>X[Pt]=0);const ut=e.D5U.locToIndex(X,O,b),Dt=Z.slice(-E);P.forEach(Pt=>Dt[Pt]=0);const Y=e.D5U.locToIndex(Dt,E,$),ht=f(L[2*ut],L[2*ut+1],N[2*Y],N[2*Y+1]);M[W]=ht.real,T[W]=ht.imag}return[M,T,p]}}},91623:(H,C,t)=>{"use strict";t.d(C,{a:()=>a});var e=t(30003);function a(u){return(c,h,i)=>{const f=e.D5U.getArrayFromDType(h,c.length);for(let l=0;l<c.length;++l)f[l]=u(c[l],i);return f}}},91832:(H,C,t)=>{"use strict";t.d(C,{A:()=>c,O:()=>h});var e=t(30003),a=t(14050),u=t(91623);function c(i,f,l){return h(i,(0,u.a)(f),l)}function h(i,f,l){return({inputs:o,attrs:n,backend:s})=>{const{x:r}=o;(0,a.H)(r,i);const d=s,p=d.data.get(r.dataId).values;let g;if("string"===r.dtype){if(!Array.isArray(p))throw new Error("String tensor's value was not an instance of Array");g=e.backend_util.fromUint8ToStringArray(p)}else g=p;const _=l||r.dtype,v=f(g,_,n);return d.makeTensorInfo(r.shape,_,v)}}},33176:(H,C,t)=>{"use strict";t.d(C,{l:()=>u});var e=t(30003),a=t(23392);function u(c,h,i="float32"){if("complex64"===i){const l=u(c,h,"float32"),o=u(c,h,"float32");return(0,a.P)({inputs:{real:l,imag:o},backend:c})}const f=e.D5U.makeZerosTypedArray(e.D5U.sizeFromShape(h),i);return c.makeTensorInfo(h,i,f)}},36456:(H,C,t)=>{"use strict";t.d(C,{i:()=>e});const e="4.22.0"},5926:(H,C,t)=>{"use strict";t.d(C,{QC:()=>Ee});var e=t(15861),a=t(30003),u=t(63076);const c=(0,a.OBj)();c.registerFlag("HAS_WEBGL",()=>c.getNumber("WEBGL_VERSION")>0),c.registerFlag("WEBGL_VERSION",()=>(0,u.isWebGLVersionEnabled)(2)?2:(0,u.isWebGLVersionEnabled)(1)?1:0),c.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),c.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===c.get("WEBGL_VERSION")),c.registerFlag("WEBGL_CPU_FORWARD",()=>!0),c.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),c.registerFlag("WEBGL_PACK",()=>c.getBool("HAS_WEBGL")),c.registerFlag("WEBGL_PACK_NORMALIZATION",()=>c.getBool("WEBGL_PACK")),c.registerFlag("WEBGL_PACK_CLIP",()=>c.getBool("WEBGL_PACK")),c.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>c.getBool("WEBGL_PACK")),c.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>c.getBool("WEBGL_PACK")),c.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>c.getBool("WEBGL_PACK")),c.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>c.getBool("WEBGL_PACK")),c.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>c.getBool("WEBGL_PACK")),c.registerFlag("WEBGL_PACK_REDUCE",()=>c.getBool("WEBGL_PACK")),c.registerFlag("WEBGL_LAZILY_UNPACK",()=>c.getBool("WEBGL_PACK")),c.registerFlag("WEBGL_CONV_IM2COL",()=>c.getBool("WEBGL_PACK")),c.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>c.getBool("WEBGL_PACK")),c.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>(0,u.getWebGLMaxTextureSize)(c.getNumber("WEBGL_VERSION"))),c.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>(0,u.getMaxTexturesInShader)(c.getNumber("WEBGL_VERSION"))),c.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const ie=c.getNumber("WEBGL_VERSION");return 0===ie?0:(0,u.getWebGLDisjointQueryTimerVersion)(ie)}),c.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>c.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!a.C2$.isMobile()),c.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>(0,u.isCapableOfRenderingToFloatTexture)(c.getNumber("WEBGL_VERSION"))),c.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!c.getBool("WEBGL_FORCE_F16_TEXTURES")&&c.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),c.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>(0,u.isDownloadFloatTextureEnabled)(c.getNumber("WEBGL_VERSION"))),c.registerFlag("WEBGL_FENCE_API_ENABLED",()=>(0,u.isWebGLFenceEnabled)(c.getNumber("WEBGL_VERSION"))),c.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>c.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),c.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,ie=>{if("number"!=typeof ie)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${ie}.`);if(ie<0&&-1!==ie)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${ie}.`)}),c.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>a.C2$.isMobile()?1:-1,ie=>{if("number"!=typeof ie)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${ie}.`);if(ie<0&&-1!==ie)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${ie}.`)}),c.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),c.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),c.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),c.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),c.registerFlag("WEBGL_EXP_CONV",()=>!1),c.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>c.getBool("IS_TEST")),c.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),c.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),c.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),c.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);var h=t(88377),i=t(99100),f=t(42372),l=t(83227),o=t(20215);class n{constructor(Zt){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=o.m1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const ct=(0,i.A)();this.outputShape=Zt,this.enableShapeUniforms=(0,f.C9)(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?l.Kn(["r","c","d"],Zt):l.RW(["r","c","d"],Zt)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${ct.output} = result;\n      }\n    `}}class s{constructor(Zt){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=o.m1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const ct=(0,i.A)();this.outputShape=Zt,this.enableShapeUniforms=(0,f.C9)(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?l.Kn(["r","c","d"],Zt):l.RW(["r","c","d"],Zt)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${ct.output} = result;\n      }\n    `}}class r{constructor(Zt){this.variableNames=["A"],this.outTexUsage=o.v2.DOWNLOAD;const ct=(0,i.A)();this.outputShape=Zt,this.userCode=`\n      ${l.ye}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${ct.output} = encode_float(x);\n      }\n    `}}class d{constructor(Zt){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=o.v2.DOWNLOAD;const ct=(0,i.A)();this.outputShape=Zt,this.userCode=`\n      ${l.ye}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${ct.output} = encode_float(x);\n      }\n    `}}const p={R:0,G:1,B:2,A:3};class g{constructor(Zt,ct=!1,It="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const Ut=(0,i.A)();this.outputShape=Zt,this.enableShapeUniforms=(0,f.C9)(this.outputShape.length);let q="result";ct&&(q="floor(result * 255. + 0.5)");let K="";for(let j=0;j<It.length;j++)K+=`\n          if(offset == ${j}) {\n            result = values[${p[It[j]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?l.nc():l.ku(Zt)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${It.length});\n\n        flatIndex = idiv(flatIndex, ${It.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${Ut.texture2D}(A, uv);\n          ${K}\n        }\n        ${Ut.output} = vec4(${q}, 0., 0., 0.);\n      }\n    `}}class _{constructor(Zt,ct=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const It=(0,i.A)();this.outputShape=Zt,this.enableShapeUniforms=(0,f.C9)(this.outputShape.length);let Ut="",q="result";ct&&(q="floor(result * 255. + 0.5)");for(let K=0;K<=1;K++)for(let j=0;j<=1;j++){const at=2*K+j;Ut+=`\n          localCoords = coords;\n          if(localCoords[2] + ${j} < ${this.enableShapeUniforms?"outShape[2]":`${Zt[2]}`}) {\n          localCoords[2] += ${j};\n          if (localCoords[1] + ${K} < ${this.enableShapeUniforms?"outShape[1]":`${Zt[1]}`}) {\n            localCoords[1] += ${K};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${It.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${at}] = values[0];\n            } else if (offset == 1) {\n              result[${at}] = values[1];\n            } else if (offset == 2) {\n              result[${at}] = values[2];\n            } else {\n              result[${at}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?l.nc():l.ku(Zt)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${Ut}\n\n          ${It.output} = ${q};\n        }\n    `}}var v=t(11484),M=t(7866),T=t(52265),S=t(45223);class P{constructor(Zt){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=Zt,this.rank=Zt.length,this.enableShapeUniforms=(0,f.C9)(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const ct=(0,T.Ky)("rc",this.rank),It=(0,S.kW)(this.rank),Ut=this.getOutOfBoundsCondition(ct),q=this.getSetup(ct),K=this.getOutput(ct);this.userCode=`\n        void main() {\n          ${It} rc = getOutputCoords();\n\n          if(${Ut}) {\n            setOutput(vec4(0));\n          } else {\n            ${q}\n\n            setOutput(vec4(${K}));\n          }\n        }\n      `}}getSourceCoordsArr(Zt){const ct=[];for(let It=0;It<=1;It++)for(let Ut=0;Ut<=1;Ut++){let q=`${0===It?"r":"rp1"}, ${0===Ut?"c":"cp1"}`;for(let K=2;K<this.rank;K++)q=`${Zt[Zt.length-1-K]},`+q;ct.push(q)}return ct}getOutOfBoundsCondition(Zt){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let ct="";for(let It=this.rank-2;It<this.rank;It++)ct+=`${Zt[It]} >= ${this.enableShapeUniforms?`outShape[${It}]`:this.outputShape[It]}`,It<this.rank-1&&(ct+="||");return ct}getSetup(Zt){if(1===this.rank)return"";const ct=Zt.slice(-2);return`\n      int r = ${ct[0]};\n      int c = ${ct[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(Zt){const ct=this.getSourceCoordsArr(Zt);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${ct[0]}),\n            cEdge ? 0. : getA(${ct[1]}),\n            rEdge ? 0. : getA(${ct[2]}),\n            rEdge || cEdge ? 0. : getA(${ct[3]})`}}var L=t(4074),N=t(11230);class O{constructor(Zt){this.gpgpu=Zt,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(Zt,ct,It){const Ut=Z(ct,It),q=X(Zt,Ut,It);q in this.freeTextures||(this.freeTextures[q]=[]),q in this.usedTextures||(this.usedTextures[q]=[]);const K=E(Zt,Ut,this.gpgpu.gl,this.gpgpu.textureConfig,It);if(this.freeTextures[q].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=K,this.log();const at=this.freeTextures[q].pop();return this.usedTextures[q].push(at),at}let j;return Ut===o.V9.PACKED_2X2_FLOAT32?j=this.gpgpu.createPackedMatrixTexture(Zt[0],Zt[1]):Ut===o.V9.PACKED_2X2_FLOAT16?j=this.gpgpu.createFloat16PackedMatrixTexture(Zt[0],Zt[1]):Ut===o.V9.UNPACKED_FLOAT32?j=this.gpgpu.createFloat32MatrixTexture(Zt[0],Zt[1]):Ut===o.V9.UNPACKED_FLOAT16?j=this.gpgpu.createFloat16MatrixTexture(Zt[0],Zt[1]):Ut===o.V9.PACKED_4X1_UNSIGNED_BYTE&&(j=this.gpgpu.createUnsignedBytesMatrixTexture(Zt[0],Zt[1])),this.usedTextures[q].push(j),this.numUsedTextures++,this._numBytesAllocated+=K,this.log(),j}releaseTexture(Zt,ct,It,Ut){if(null==this.freeTextures)return;const q=Z(It,Ut),K=X(ct,q,Ut);K in this.freeTextures||(this.freeTextures[K]=[]);const j=E(ct,q,this.gpgpu.gl,this.gpgpu.textureConfig,Ut),at=(0,a.OBj)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==at&&this._numBytesAllocated>at?(this.gpgpu.deleteMatrixTexture(Zt.texture),this._numBytesAllocated-=j):(this.freeTextures[K].push(Zt),this.numFreeTextures++,this._numBytesFree+=j),this.numUsedTextures--;const dt=this.usedTextures[K],kt=dt&&dt.indexOf(Zt);if(null==kt||kt<0)throw new Error("Cannot release a texture that was never provided by this texture manager");dt[kt]=dt[dt.length-1],dt.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const ct=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*ct)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const Zt in this.freeTextures)this.freeTextures[Zt].forEach(ct=>{this.gpgpu.deleteMatrixTexture(ct.texture)});for(const Zt in this.usedTextures)this.usedTextures[Zt].forEach(ct=>{this.gpgpu.deleteMatrixTexture(ct.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function E(ie,Zt,ct,It,Ut){const q=function $(ie,Zt){switch(ie){case o.V9.PACKED_2X2_FLOAT32:return(0,N.getInternalFormatForPackedMatrixTexture)(Zt);case o.V9.PACKED_2X2_FLOAT16:return(0,N.getInternalFormatForFloat16PackedMatrixTexture)(Zt);case o.V9.UNPACKED_FLOAT32:return(0,N.getInternalFormatForFloat32MatrixTexture)(Zt);case o.V9.UNPACKED_FLOAT16:return(0,N.getInternalFormatForFloat16MatrixTexture)(Zt);case o.V9.PACKED_4X1_UNSIGNED_BYTE:return(0,N.getInternalFormatForUnsignedBytesMatrixTexture)(Zt);default:throw new Error(`Unknown physical texture type ${ie}`)}}(Zt,It);let K;if(Ut){const[at,dt]=(0,o.qe)(ie[0],ie[1]);K=at*dt}else{const[at,dt]=(0,o.kk)(ie[0],ie[1]);K=at*dt}const j=function b(ie,Zt){if(Zt===ie.R32F)return 4;if(Zt===ie.R16F)return 2;if(Zt===ie.RGBA32F)return 16;if(Zt===ie.RGBA)return 16;if(Zt===ie.RGBA16F)return 8;if(Zt===ie.RGBA8)return 4;throw new Error(`Unknown internal format ${Zt}`)}(ct,q);return K*j}function Z(ie,Zt){if(ie===o.v2.UPLOAD)return o.V9.PACKED_2X2_FLOAT32;if(ie===o.v2.RENDER||null==ie)return function W(ie){return(0,a.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?ie?o.V9.PACKED_2X2_FLOAT32:o.V9.UNPACKED_FLOAT32:ie?o.V9.PACKED_2X2_FLOAT16:o.V9.UNPACKED_FLOAT16}(Zt);if(ie===o.v2.DOWNLOAD||ie===o.v2.PIXELS)return o.V9.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${ie}`)}function X(ie,Zt,ct){return`${ie[0]}_${ie[1]}_${Zt}_${ct}`}var ut=t(32398),Dt=t(807);class Y{constructor(Zt){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=Zt,this.enableShapeUniforms=(0,f.C9)(this.outputShape.length);const ct=Zt.length,It=(0,T.Ky)("rc",ct),Ut=(0,S.kW)(ct),q=(0,T.Qc)(ct,It),K=It.slice(-2),j=ct<=1?"rc":`vec2(${K.join(",")})`;this.userCode=`\n      void main() {\n        ${Ut} rc = getOutputCoords();\n        vec4 packedInput = getA(${q});\n\n        setOutput(getChannel(packedInput, ${j}));\n      }\n    `}}const ht=a.GDt.whereImpl,xt={},Vt=(0,a.OBj)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let Ee=(()=>{class ie extends a.Zuw{nextDataId(){return ie.nextDataId++}constructor(ct){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,a.OBj)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let It;if(null!=ct){if(ct instanceof v.A)It=ct;else{const Ut=(0,h.jl)((0,a.OBj)().getNumber("WEBGL_VERSION"),ct);It=new v.A(Ut)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const Ut=(0,h.jl)((0,a.OBj)().getNumber("WEBGL_VERSION"));It=new v.A(Ut),this.binaryCache=function Nt(ie){return ie in xt||(xt[ie]={}),xt[ie]}((0,a.OBj)().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=It,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new O(this.gpgpu),this.numMBBeforeWarning=function oe(){return null==(0,a.OBj)().global.screen?1024:(0,a.OBj)().global.screen.height*(0,a.OBj)().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new a.JLz(this,(0,a.SRH)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(ct,It,Ut,q,K,j){const at=this.makeTensorInfo(It,Ut),dt=this.texData.get(at.dataId);dt.isPacked=!1,dt.texture={texture:ct,texShape:[q,K]},dt.texShape=[q,K];const kt=u.getShapeAs3D(It),jt=new g(kt,!1,j),Jt=this.runWebGLProgram(jt,[at],Ut,[[q,K]]);return Jt.shape=It,dt.texture=null,this.disposeIntermediateTensorInfo(at),Jt.dataId}write(ct,It,Ut){if(((0,a.OBj)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,a.OBj)().getBool("DEBUG"))&&this.checkNumericalProblems(ct),"complex64"===Ut&&null!=ct)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const q={id:this.nextDataId()};return this.texData.set(q,{shape:It,dtype:Ut,values:ct,usage:o.v2.UPLOAD,refCount:1}),q}refCount(ct){return this.texData.has(ct)?this.texData.get(ct).refCount:0}incRef(ct){this.texData.get(ct).refCount++}decRef(ct){this.texData.has(ct)&&this.texData.get(ct).refCount--}move(ct,It,Ut,q,K){if((0,a.OBj)().getBool("DEBUG")&&this.checkNumericalProblems(It),"complex64"===q)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(ct,{shape:Ut,dtype:q,values:It,usage:o.v2.UPLOAD,refCount:K})}disposeIntermediateTensorInfo(ct){this.disposeData(ct.dataId)}readSync(ct){const It=this.texData.get(ct),{values:Ut,dtype:q,complexTensorInfos:K,slice:j,shape:at,isPacked:dt}=It;if(null!=j){let ae;ae=dt?new Dt.cc(at,ut.bl):new ut.l(at,ut.bl);const Re=this.runWebGLProgram(ae,[{dataId:ct,shape:at,dtype:q}],q),Be=this.readSync(Re.dataId);return this.disposeIntermediateTensorInfo(Re),Be}if(null!=Ut)return this.convertAndCacheOnCPU(ct);if("string"===q)return Ut;const kt=null!=this.activeTimers;let jt,Jt;if(kt&&(jt=a.D5U.now()),"complex64"===q){const ae=this.readSync(K.real.dataId),Re=this.readSync(K.imag.dataId);Jt=a.backend_util.mergeRealAndImagArrays(ae,Re)}else Jt=this.getValuesFromTexture(ct);return kt&&(this.downloadWaitMs+=a.D5U.now()-jt),this.convertAndCacheOnCPU(ct,Jt)}read(ct){var It=this;return(0,e.Z)(function*(){if(It.pendingRead.has(ct)){const Se=It.pendingRead.get(ct);return new Promise(we=>Se.push(we))}const Ut=It.texData.get(ct),{values:q,shape:K,slice:j,dtype:at,complexTensorInfos:dt,isPacked:kt}=Ut;if(null!=j){let Se;Se=kt?new Dt.cc(K,ut.bl):new ut.l(K,ut.bl);const we=It.runWebGLProgram(Se,[{dataId:ct,shape:K,dtype:at}],at),Ae=It.read(we.dataId);return It.disposeIntermediateTensorInfo(we),Ae}if(null!=q)return It.convertAndCacheOnCPU(ct);if((0,a.OBj)().getBool("DEBUG")&&!(0,a.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,a.OBj)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let Jt,ae,jt=null;if("complex64"!==at&&(0,a.OBj)().get("WEBGL_BUFFER_SUPPORTED")){Jt=It.decode(ct);const Se=It.texData.get(Jt.dataId);jt=It.gpgpu.createBufferFromTexture(Se.texture.texture,...o.Yz(K))}if(It.pendingRead.set(ct,[]),"complex64"!==at&&(yield It.gpgpu.createAndWaitForFence()),"complex64"===at){const Se=yield Promise.all([It.read(dt.real.dataId),It.read(dt.imag.dataId)]);ae=a.backend_util.mergeRealAndImagArrays(Se[0],Se[1])}else if(null==jt)ae=It.getValuesFromTexture(ct);else{const Se=a.D5U.sizeFromShape(K);ae=It.gpgpu.downloadFloat32MatrixFromBuffer(jt,Se)}if(null!=Jt&&It.disposeIntermediateTensorInfo(Jt),null!=jt){const Se=It.gpgpu.gl;u.callAndCheck(Se,()=>Se.deleteBuffer(jt))}const Re=It.convertAndCacheOnCPU(ct,ae),Be=It.pendingRead.get(ct);return It.pendingRead.delete(ct),Be.forEach(Se=>Se(Re)),It.pendingDisposal.has(ct)&&(It.pendingDisposal.delete(ct),It.disposeData(ct)&&(0,a.SRH)().removeDataId(ct,It),It.pendingDeletes--),Re})()}readToGPU(ct,It={}){const Ut=this.texData.get(ct),{values:q,shape:K,slice:j,dtype:at,isPacked:dt,texture:kt}=Ut;if("complex64"===at)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=j){let Re;Re=dt?new Dt.cc(K,ut.bl):new ut.l(K,ut.bl);const Be=this.runWebGLProgram(Re,[{dataId:ct,shape:K,dtype:at}],at),Se=this.readToGPU(Be,It);return this.disposeIntermediateTensorInfo(Be),Se}if(null==kt)throw null!=q?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const jt=this.decode(ct,It.customTexShape),Jt=(0,a.SRH)().makeTensorFromTensorInfo(jt),ae=this.texData.get(jt.dataId);return Object.assign({tensorRef:Jt},ae.texture)}bufferSync(ct){const It=this.readSync(ct.dataId);if("string"===ct.dtype)try{const Ut=It.map(q=>a.D5U.decodeString(q));return(0,a.f3b)(ct.shape,ct.dtype,Ut)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,a.f3b)(ct.shape,ct.dtype,It)}checkNumericalProblems(ct){if(null!=ct)for(let It=0;It<ct.length;It++){const Ut=ct[It];if(!u.canBeRepresented(Ut))throw(0,a.OBj)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${Ut} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${Ut} cannot be represented on this device.`)}}getValuesFromTexture(ct){const{shape:It,dtype:Ut,isPacked:q}=this.texData.get(ct),K=a.D5U.sizeFromShape(It);if((0,a.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const ae=this.decode(ct),Re=this.texData.get(ae.dataId),Be=this.gpgpu.downloadMatrixFromPackedTexture(Re.texture.texture,...o.Yz(It)).subarray(0,K);return this.disposeIntermediateTensorInfo(ae),Be}const j=(0,a.OBj)().getBool("WEBGL_PACK")&&!0===q,at=j?u.getShapeAs3D(It):It,dt=j?new d(at):new r(at),kt=this.runWebGLProgram(dt,[{shape:at,dtype:Ut,dataId:ct}],"float32"),jt=this.texData.get(kt.dataId),Jt=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(jt.texture.texture,jt.texShape[0],jt.texShape[1]).subarray(0,K);return this.disposeIntermediateTensorInfo(kt),Jt}timerAvailable(){return(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(ct){var It=this;const Ut=this.activeTimers,q=[];let K=!1;null==this.programTimersStack?(this.programTimersStack=q,K=!0):this.activeTimers.push(q),this.activeTimers=q,ct();const j=a.D5U.flatten(this.activeTimers.map(kt=>kt.query)).filter(kt=>null!=kt),at=a.D5U.flatten(this.activeTimers.map(kt=>kt.name)).filter(kt=>null!=kt);this.activeTimers=Ut,K&&(this.programTimersStack=null);const dt={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(0,e.Z)(function*(){if((0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const kt=yield Promise.all(j);dt.kernelMs=a.D5U.sum(kt),dt.getExtraProfileInfo=()=>kt.map((jt,Jt)=>({name:at[Jt],ms:jt})).map(jt=>`${jt.name}: ${jt.ms}`).join(", ")}else dt.kernelMs={error:"WebGL query timers are not supported in this environment."};return It.uploadWaitMs=0,It.downloadWaitMs=0,dt})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:a.D5U.now(),endMs:null}}endTimer(ct){return(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),ct):(ct.endMs=a.D5U.now(),ct)}getQueryTime(ct){var It=this;return(0,e.Z)(function*(){return(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?It.gpgpu.waitForQueryAndGetTime(ct):ct.endMs-ct.startMs})()}disposeData(ct,It=!1){if(this.pendingDisposal.has(ct))return!1;if(!this.texData.has(ct))return!0;if(It?this.texData.get(ct).refCount=0:this.texData.get(ct).refCount--,!It&&this.texData.get(ct).refCount>0)return!1;if(this.pendingRead.has(ct))return this.pendingDisposal.add(ct),this.pendingDeletes++,!1;this.releaseGPUData(ct);const{complexTensorInfos:Ut}=this.texData.get(ct);return null!=Ut&&(this.disposeData(Ut.real.dataId,It),this.disposeData(Ut.imag.dataId,It)),this.texData.delete(ct),!0}releaseGPUData(ct){const{texture:It,dtype:Ut,texShape:q,usage:K,isPacked:j,slice:at}=this.texData.get(ct),dt=at&&at.origDataId||ct,kt=this.dataRefCount.get(dt);kt>1?this.dataRefCount.set(dt,kt-1):(this.dataRefCount.delete(dt),null!=It&&(this.numBytesInGPU-=this.computeBytes(q,Ut),this.textureManager.releaseTexture(It,q,K,j)));const jt=this.texData.get(ct);jt.texture=null,jt.texShape=null,jt.isPacked=!1,jt.slice=null}getTexture(ct){return this.uploadToGPU(ct),this.texData.get(ct).texture.texture}getDataInfo(ct){return this.texData.get(ct)}shouldExecuteOnCPU(ct,It=Vt){return(0,a.OBj)().getBool("WEBGL_CPU_FORWARD")&&ct.every(Ut=>null==this.texData.get(Ut.dataId).texture&&a.D5U.sizeFromShape(Ut.shape)<It)}getGPGPUContext(){return this.gpgpu}where(ct){a.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const It=ct.dataSync();return ht(ct.shape,It)}packedUnaryOp(ct,It,Ut){const q=new Dt.cc(ct.shape,It),K=this.compileAndRun(q,[ct],Ut);return(0,a.SRH)().makeTensorFromTensorInfo(K)}abs(ct){if(this.shouldExecuteOnCPU([ct])&&"complex64"!==ct.dtype){const q=(0,M.CJ)(this.texData.get(ct.dataId).values);return this.makeOutput(ct.shape,ct.dtype,q)}if((0,a.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(ct,ut.Et,ct.dtype);const It=new ut.l(ct.shape,ut.Et),Ut=this.compileAndRun(It,[ct]);return(0,a.SRH)().makeTensorFromTensorInfo(Ut)}makeTensorInfo(ct,It,Ut){let q;if("string"===It&&null!=Ut&&Ut.length>0&&a.D5U.isString(Ut[0])){const K=Ut.map(j=>a.D5U.encodeString(j));q=this.write(K,ct,It)}else q=this.write(Ut,ct,It);return this.texData.get(q).usage=null,{dataId:q,shape:ct,dtype:It}}makeOutput(ct,It,Ut){return(0,a.SRH)().makeTensorFromTensorInfo(this.makeTensorInfo(ct,It,Ut),this)}unpackTensor(ct){const It=new Y(ct.shape);return this.runWebGLProgram(It,[ct],ct.dtype)}packTensor(ct){const It=new P(ct.shape);return this.runWebGLProgram(It,[ct],ct.dtype,null,!0)}packedReshape(ct,It){const Ut=[u.getBatchDim(ct.shape),...u.getRowsCols(ct.shape)],q={dtype:ct.dtype,shape:Ut,dataId:ct.dataId},K=[u.getBatchDim(It),...u.getRowsCols(It)],j=new L.v(K,Ut),kt=this.runWebGLProgram(j,[q],ct.dtype,[Ut],!0);return{dataId:kt.dataId,shape:It,dtype:kt.dtype}}decode(ct,It){const Ut=this.texData.get(ct),{isPacked:q,shape:K,dtype:j}=Ut;if(null!=It){const ae=a.D5U.sizeFromShape(K);a.D5U.assert(ae<=It[0]*It[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const at=u.getShapeAs3D(K);let dt;dt=q?new s(at):new n(at);const jt=[It??o.Yz(at)];return{dtype:j,shape:K,dataId:this.runWebGLProgram(dt,[{shape:at,dtype:j,dataId:ct}],j,jt,!0,It).dataId}}runWebGLProgram(ct,It,Ut,q,K=!1,j){const at=this.makeTensorInfo(ct.outputShape,Ut),dt=this.texData.get(at.dataId);if(ct.packedOutput&&(dt.isPacked=!0),ct.outPackingScheme===o.m1.DENSE){const Ae=j??o.Yz(ct.outputShape);dt.texShape=Ae.map(Te=>2*Te)}if(null!=ct.outTexUsage&&(dt.usage=ct.outTexUsage),0===a.D5U.sizeFromShape(at.shape))return dt.values=a.D5U.getTypedArrayFromDType(at.dtype,0),at;const kt=[],jt=It.map(Ae=>{if("complex64"===Ae.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let Te=this.texData.get(Ae.dataId);if(null==Te.texture){if(!ct.packedInputs&&a.D5U.sizeFromShape(Ae.shape)<=(0,a.OBj)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:Ae.shape,texData:null,isUniform:!0,uniformValues:Te.values};ct.packedInputs&&(Te.isPacked=!0,Te.shape=Ae.shape)}if(this.uploadToGPU(Ae.dataId),!!Te.isPacked!=!!ct.packedInputs)Ae=Te.isPacked?this.unpackTensor(Ae):this.packTensor(Ae),kt.push(Ae),Te=this.texData.get(Ae.dataId);else if(Te.isPacked&&!u.isReshapeFree(Te.shape,Ae.shape)){const Je=Ae,tn=Ae.shape;Ae.shape=Te.shape,Ae=this.packedReshape(Ae,tn),kt.push(Ae),Te=this.texData.get(Ae.dataId),Je.shape=tn}return{shape:Ae.shape,texData:Te,isUniform:!1}});this.uploadToGPU(at.dataId);const Jt={shape:at.shape,texData:dt,isUniform:!1},ae=f.mi(ct,jt,Jt),Re=this.getAndSaveBinary(ae,()=>f.IJ(this.gpgpu,ct,jt,Jt)),Be=null!=this.activeTimers;let Se;Be&&(Se=this.startTimer()),(0,a.OBj)().get("ENGINE_COMPILE_ONLY")||f._s(this.gpgpu,Re,jt,Jt,q),kt.forEach(Ae=>this.disposeIntermediateTensorInfo(Ae)),Be&&(Se=this.endTimer(Se),this.activeTimers.push({name:ct.constructor.name,query:this.getQueryTime(Se)}));const we=(0,a.OBj)().getNumber("WEBGL_FLUSH_THRESHOLD");if(we>0){const Ae=a.D5U.now();Ae-this.lastGlFlushTime>we&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=Ae)}if(!(0,a.OBj)().getBool("WEBGL_LAZILY_UNPACK")&&dt.isPacked&&!1===K){const Ae=this.unpackTensor(at);return this.disposeIntermediateTensorInfo(at),Ae}return at}compileAndRun(ct,It,Ut,q,K=!1){return this.runWebGLProgram(ct,It,Ut=Ut||It[0].dtype,q,K)}getAndSaveBinary(ct,It){return ct in this.binaryCache||(this.binaryCache[ct]=It()),this.binaryCache[ct]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,a.OBj)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(It=>{this.gpgpu.deleteProgram(this.binaryCache[It].webGLProgram),delete this.binaryCache[It]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,a.lub)(()=>{if(!(0,a.OBj)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const ct=(0,a.OBj)().getBool("DEBUG");(0,a.OBj)().set("DEBUG",!1);const It=this.abs((0,a.iD$)(1e-8)).dataSync()[0];if((0,a.OBj)().set("DEBUG",ct),It>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(ct){const It=this.texData.get(ct),{shape:Ut,dtype:q,values:K,texture:j,usage:at,isPacked:dt}=It;if(null!=j)return;const kt=null!=this.activeTimers;let jt;kt&&(jt=a.D5U.now());let Jt=It.texShape;if(null==Jt&&(Jt=u.getTextureShapeFromLogicalShape(Ut,dt),It.texShape=Jt),null!=K){const ae=u.getShapeAs3D(Ut);let Re,Be=Jt[1],Se=Jt[0];const we=K instanceof Uint8Array||K instanceof Uint8ClampedArray;(dt||!we)&&([Be,Se]=o.qe(Jt[0],Jt[1])),Re=dt?new _(ae,we):new g(ae,we);const Ae=we?[Se,Be]:Jt,Te=this.makeTensorInfo(Ae,q),Je=this.texData.get(Te.dataId);Je.usage=we?o.v2.PIXELS:o.v2.UPLOAD,Je.texShape=Ae,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(Te.dataId),Be,Se,K);const mn=this.runWebGLProgram(Re,[Te],q,[[Se,Be]],!0),hn=this.texData.get(mn.dataId);It.texShape=hn.texShape,It.isPacked=hn.isPacked,It.usage=hn.usage,(0,a.OBj)().get("ENGINE_COMPILE_ONLY")?this.disposeData(mn.dataId):(It.texture=hn.texture,It.values=null,this.texData.delete(mn.dataId)),this.disposeIntermediateTensorInfo(Te),kt&&(this.uploadWaitMs+=a.D5U.now()-jt)}else{const ae=this.acquireTexture(Jt,at,q,dt);It.texture=ae}}convertAndCacheOnCPU(ct,It){const Ut=this.texData.get(ct),{dtype:q}=Ut;return null!=It&&(Ut.values=function Ie(ie,Zt){if("float32"===Zt||"complex64"===Zt)return ie;if("int32"===Zt||"bool"===Zt){const ct="int32"===Zt?new Int32Array(ie.length):new Uint8Array(ie.length);for(let It=0;It<ct.length;++It)ct[It]=Math.round(ie[It]);return ct}throw new Error(`Unknown dtype ${Zt}`)}(It,q)),Ut.values}acquireTexture(ct,It,Ut,q){if(this.numBytesInGPU+=this.computeBytes(ct,Ut),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const K=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${K} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(ct,It,q)}computeBytes(ct,It){return ct[0]*ct[1]*a.D5U.bytesPerElement(It)}checkCompileCompletion(){for(const[,ct]of Object.entries(this.binaryCache))this.checkCompletion_(ct)}checkCompileCompletionAsync(){var ct=this;return(0,e.Z)(function*(){const It=[];if(ct.gpgpu.parallelCompilationExtension){for(const[,Ut]of Object.entries(ct.binaryCache))It.push(ct.checkCompletionAsync_(Ut));return Promise.all(It)}for(const[,Ut]of Object.entries(ct.binaryCache)){const q=new Promise(K=>{try{ct.checkCompletion_(Ut),K(!0)}catch(j){throw j}});It.push(q)}return Promise.all(It)})()}checkCompletionAsync_(ct){var It=this;return(0,e.Z)(function*(){return It.gpgpu.gl.getProgramParameter(ct.webGLProgram,It.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?It.checkCompletion_(ct):(yield(0,a.glt)(),It.checkCompletionAsync_(ct))})()}checkCompletion_(ct){if(!1===this.gpgpu.gl.getProgramParameter(ct.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(ct.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(ct.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(u.logShaderSourceAndInfoLog(ct.source,this.gpgpu.gl.getShaderInfoLog(ct.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const ct of Object.values(this.binaryCache)){this.gpgpu.buildVao(ct.webGLProgram);const{variablesLocations:It,customUniformLocations:Ut,infLoc:q,nanLoc:K,outShapeLocation:j,outShapeStridesLocation:at,outTexShapeLocation:dt}=(0,f.Yv)(this.gpgpu,ct.program,ct.webGLProgram);ct.variablesLocations=It,ct.customUniformLocations=Ut,ct.infLoc=q,ct.nanLoc=K,ct.outShapeLocation=j,ct.outShapeStridesLocation=at,ct.outTexShapeLocation=dt}}createTensorFromGPUData(ct,It,Ut){ct.channels=ct.channels||"RGBA";const{texture:q,height:K,width:j,channels:at}=ct,dt=(0,a.SRH)().backend;if(!dt.gpgpu.gl.isTexture(q))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const kt=dt.writeTexture(q,It,Ut,K,j,at);return(0,a.SRH)().makeTensorFromDataId(kt,It,Ut,dt)}}return ie.nextDataId=0,ie})()},88377:(H,C,t)=>{"use strict";t.d(C,{jl:()=>i,nd:()=>h});var e=t(30003);const a={},u={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function h(o,n){a[o]=n}function i(o,n){if(!(o in a)||null!=n){const r=function l(o,n){if(1!==o&&2!==o)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const s=n??function f(o){if(!(0,e.OBj)().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===o)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(o);return s.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete a[o]},!1),(0,e.OBj)().getBool("SOFTWARE_WEBGL_ENABLED")&&(u.failIfMajorPerformanceCaveat=!1),1===o?s.getContext("webgl",u)||s.getContext("experimental-webgl",u):s.getContext("webgl2",u)}(o,n);if(null===r)return console.log("Could not get context for WebGL version",o),null;a[o]=r}const s=a[o];return null==s||s.isContextLost()?(delete a[o],i(o)):(s.disable(s.DEPTH_TEST),s.disable(s.STENCIL_TEST),s.disable(s.BLEND),s.disable(s.DITHER),s.disable(s.POLYGON_OFFSET_FILL),s.disable(s.SAMPLE_COVERAGE),s.enable(s.SCISSOR_TEST),s.enable(s.CULL_FACE),s.cullFace(s.BACK),a[o])}},99100:(H,C,t)=>{"use strict";t.d(C,{A:()=>a});var e=t(30003);function a(){let u,c,h,i,f,l,o,n,s,r;return 2===(0,e.OBj)().getNumber("WEBGL_VERSION")?(u="#version 300 es",c="in",h="out",i="in",f="texture",l="outputColor",o="out vec4 outputColor;",n=(0,e.OBj)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",s="",r="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(u="",c="attribute",h="varying",i="varying",f="texture2D",l="gl_FragColor",o="",n="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",s="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",r="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:u,attribute:c,varyingVs:h,varyingFs:i,texture2D:f,output:l,defineOutput:o,defineSpecialNaN:n,defineSpecialInf:s,defineRound:r}}},11484:(H,C,t)=>{"use strict";t.d(C,{A:()=>f});var e=t(15861),a=t(30003),u=t(88377),c=t(11230),h=t(20215),i=t(63076);class f{constructor(n){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const s=(0,a.OBj)().getNumber("WEBGL_VERSION");if(null!=n?(this.gl=n,(0,u.nd)(s,n)):this.gl=(0,u.jl)(s),n=this.gl,2===(0,a.OBj)().getNumber("WEBGL_VERSION")){const p=n;this.createVertexArray=()=>i.callAndCheck(p,()=>p.createVertexArray()),this.bindVertexArray=g=>i.callAndCheck(p,()=>p.bindVertexArray(g)),this.deleteVertexArray=g=>i.callAndCheck(p,()=>p.deleteVertexArray(g)),this.getVertexArray=()=>i.callAndCheck(p,()=>p.getParameter(p.VERTEX_ARRAY_BINDING))}else if(null!=n){const p=n.getExtension("OES_vertex_array_object");if(null==p)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>i.callAndCheck(n,()=>p.createVertexArrayOES()),this.bindVertexArray=g=>i.callAndCheck(n,()=>p.bindVertexArrayOES(g)),this.deleteVertexArray=g=>i.callAndCheck(n,()=>p.deleteVertexArrayOES(g)),this.getVertexArray=()=>i.callAndCheck(n,()=>n.getParameter(p.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const d="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,a.OBj)().getNumber("WEBGL_VERSION")){const g="OES_texture_half_float";if(this.textureFloatExtension=i.getExtensionOrThrow(this.gl,"OES_texture_float"),i.hasExtension(this.gl,g))this.textureHalfFloatExtension=i.getExtensionOrThrow(this.gl,g);else if((0,a.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),i.hasExtension(this.gl,d))this.colorBufferHalfFloatExtension=i.getExtensionOrThrow(this.gl,d);else if((0,a.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",i.hasExtension(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!i.hasExtension(this.gl,d))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(d)}this.vertexBuffer=c.createVertexBuffer(this.gl),this.indexBuffer=c.createIndexBuffer(this.gl),this.framebuffer=i.createFramebuffer(this.gl),this.textureConfig=h.Sq(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,a.OBj)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const n=this.gl;i.callAndCheck(n,()=>n.finish()),i.callAndCheck(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),i.callAndCheck(n,()=>n.deleteFramebuffer(this.framebuffer)),i.callAndCheck(n,()=>n.bindBuffer(n.ARRAY_BUFFER,null)),i.callAndCheck(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)),i.callAndCheck(n,()=>n.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(n,s){return this.throwIfDisposed(),c.createFloat32MatrixTexture(this.gl,n,s,this.textureConfig)}createFloat16MatrixTexture(n,s){return this.throwIfDisposed(),c.createFloat16MatrixTexture(this.gl,n,s,this.textureConfig)}createUnsignedBytesMatrixTexture(n,s){return this.throwIfDisposed(),c.createUnsignedBytesMatrixTexture(this.gl,n,s,this.textureConfig)}uploadPixelDataToTexture(n,s){this.throwIfDisposed(),c.uploadPixelDataToTexture(this.gl,n,s)}uploadDenseMatrixToTexture(n,s,r,d){this.throwIfDisposed(),c.uploadDenseMatrixToTexture(this.gl,n,s,r,d,this.textureConfig)}createFloat16PackedMatrixTexture(n,s){return this.throwIfDisposed(),c.createFloat16PackedMatrixTexture(this.gl,n,s,this.textureConfig)}createPackedMatrixTexture(n,s){return this.throwIfDisposed(),c.createPackedMatrixTexture(this.gl,n,s,this.textureConfig)}deleteMatrixTexture(n){this.throwIfDisposed(),this.outputTexture===n&&(i.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),i.callAndCheck(this.gl,()=>this.gl.deleteTexture(n))}downloadByteEncodedFloatMatrixFromOutputTexture(n,s,r){return this.downloadMatrixDriver(n,()=>c.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl,s,r,this.textureConfig))}downloadPackedMatrixFromBuffer(n,s,r,d,p,g){return c.downloadPackedMatrixFromBuffer(this.gl,n,s,r,d,p,g,this.textureConfig)}downloadFloat32MatrixFromBuffer(n,s){return c.downloadFloat32MatrixFromBuffer(this.gl,n,s)}createBufferFromTexture(n,s,r){this.bindTextureToFrameBuffer(n);const d=c.createBufferFromOutputTexture(this.gl,s,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),d}createAndWaitForFence(){const n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let s,r;if((0,a.OBj)().getBool("WEBGL_FENCE_API_ENABLED")){const d=n,p=d.fenceSync(d.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush(),r=()=>{const g=d.clientWaitSync(p,0,0);return g===d.ALREADY_SIGNALED||g===d.CONDITION_SATISFIED},s=p}else(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(s=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(s,(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:s,isFencePassed:r}}downloadMatrixFromPackedTexture(n,s,r){return this.downloadMatrixDriver(n,()=>c.downloadMatrixFromPackedOutputTexture(this.gl,s,r))}createProgram(n){this.throwIfDisposed();const s=this.gl;null==this.vertexShader&&(this.vertexShader=c.createVertexShader(s));const r=i.createProgram(s);i.callAndCheck(s,()=>s.attachShader(r,this.vertexShader)),i.callAndCheck(s,()=>s.attachShader(r,n)),i.linkProgram(s,r);const d=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&i.validateProgram(s,d),d}buildVao(n){this.setProgram(n),this.bindVertexArray(n.vao);const s=this.gl;i.callAndCheck(s,()=>s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),c.bindVertexProgramAttributeStreams(s,n,this.vertexBuffer)}deleteProgram(n){this.throwIfDisposed(),n===this.program&&(this.program=null),null!=n&&(i.callAndCheck(this.gl,()=>this.gl.deleteProgram(n)),this.deleteVertexArray(n.vao))}setProgram(n){this.throwIfDisposed(),this.program=n,null!=this.program&&this.debug&&i.validateProgram(this.gl,this.program),i.callAndCheck(this.gl,()=>this.gl.useProgram(n))}getUniformLocation(n,s,r=!0){return this.throwIfDisposed(),r?i.getProgramUniformLocationOrThrow(this.gl,n,s):i.getProgramUniformLocation(this.gl,n,s)}getAttributeLocation(n,s){return this.throwIfDisposed(),i.callAndCheck(this.gl,()=>this.gl.getAttribLocation(n,s))}getUniformLocationNoThrow(n,s){return this.throwIfDisposed(),this.gl.getUniformLocation(n,s)}setInputMatrixTexture(n,s,r){this.throwIfDisposed(),this.throwIfNoProgram(),i.bindTextureToProgramUniformSampler(this.gl,n,s,r)}setOutputMatrixTexture(n,s,r){this.setOutputMatrixTextureDriver(n,r,s)}setOutputPackedMatrixTexture(n,s,r){this.throwIfDisposed();const[d,p]=h.qe(s,r);this.setOutputMatrixTextureDriver(n,d,p)}setOutputMatrixWriteRegion(n,s,r,d){this.setOutputMatrixWriteRegionDriver(r,n,d,s)}setOutputPackedMatrixWriteRegion(n,s,r,d){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&i.validateProgram(this.gl,this.program),i.validateFramebuffer(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const n=this.gl;if(this.debug){const s=this.getVertexArray();console.assert(s===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}i.callAndCheck(n,()=>n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),i.callAndCheck(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=i.getExtensionOrThrow(this.gl,2===(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,d=this.getQueryTimerExtensionWebGL2(),p=r.createQuery();return r.beginQuery(d.TIME_ELAPSED_EXT,p),p}const n=this.getQueryTimerExtensionWebGL1(),s=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,s),s}endQuery(){if(2===(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const s=this.gl,r=this.getQueryTimerExtensionWebGL2();return void s.endQuery(r.TIME_ELAPSED_EXT)}const n=this.getQueryTimerExtensionWebGL1();n.endQueryEXT(n.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(n){var s=this;return(0,e.Z)(function*(){return yield a.D5U.repeatedTry(()=>s.disposed||s.isQueryAvailable(n,(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),s.getQueryTime(n,(0,a.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(n,s){if(0===s)return null;if(2===s){const r=this.gl;return r.getQueryParameter(n,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(n,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(n,s){if(0===s)return!0;if(2===s){const r=this.gl,d=this.getQueryTimerExtensionWebGL2(),p=r.getQueryParameter(n,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(d.GPU_DISJOINT_EXT)),p&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),d=r.getQueryObjectEXT(n,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),d&&!this.disjoint}}pollFence(n){return new Promise(s=>{this.addItemToPoll(()=>n.isFencePassed(),()=>s())})}pollItems(){const n=function l(o){let n=0;for(;n<o.length&&o[n]();++n);return n-1}(this.itemsToPoll.map(s=>s.isDoneFn));for(let s=0;s<=n;++s){const{resolveFn:r}=this.itemsToPoll[s];r()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}addItemToPoll(n,s){if(this.itemsToPoll.push({isDoneFn:n,resolveFn:s}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in(0,a.OBj)().platform&&(r=(0,a.OBj)().platform.setTimeoutCustom.bind((0,a.OBj)().platform)),a.D5U.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(n){this.throwIfDisposed(),i.bindColorTextureToFramebuffer(this.gl,n,this.framebuffer),this.debug&&i.validateFramebuffer(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(i.bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.debug&&i.validateFramebuffer(this.gl)):i.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)}downloadMatrixDriver(n,s){this.bindTextureToFrameBuffer(n);const r=s();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(n,s,r){this.throwIfDisposed();const d=this.gl;i.bindColorTextureToFramebuffer(d,n,this.framebuffer),this.debug&&i.validateFramebuffer(d),this.outputTexture=n,i.callAndCheck(d,()=>d.viewport(0,0,s,r)),i.callAndCheck(d,()=>d.scissor(0,0,s,r))}setOutputMatrixWriteRegionDriver(n,s,r,d){this.throwIfDisposed(),i.callAndCheck(this.gl,()=>this.gl.scissor(n,s,r,d))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}},42372:(H,C,t)=>{"use strict";t.d(C,{C9:()=>o,IJ:()=>c,Yv:()=>h,_s:()=>f,mi:()=>l});var e=t(30003),a=t(45223),u=t(63076);function c(n,s,r,d){const p=r.map((S,P)=>{const L={logicalShape:S.shape,texShape:S.isUniform?null:S.texData.texShape,isUniform:S.isUniform,isPacked:!S.isUniform&&S.texData.isPacked,flatOffset:null};return null!=S.texData&&null!=S.texData.slice&&S.texData.slice.flatOffset>0&&(L.flatOffset=S.texData.slice.flatOffset),{name:s.variableNames[P],shapeInfo:L}}),g=p.map(S=>S.shapeInfo),_={logicalShape:d.shape,texShape:d.texData.texShape,isUniform:!1,isPacked:d.texData.isPacked,flatOffset:null},v=a.Vm(p,_,s),M=(0,u.createFragmentShader)(n.gl,v),T=n.createProgram(M);return(0,e.OBj)().get("ENGINE_COMPILE_ONLY")?{program:s,fragmentShader:M,source:v,webGLProgram:T,inShapeInfos:g,outShapeInfo:_,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(T),Object.assign({program:s,fragmentShader:M,source:v,webGLProgram:T,inShapeInfos:g,outShapeInfo:_},h(n,s,T)))}function h(n,s,r){const d=[],p=[];let g,_,v,M=null,T=null;T=n.getUniformLocation(r,"NAN",!1),1===(0,e.OBj)().getNumber("WEBGL_VERSION")&&(M=n.getUniformLocation(r,"INFINITY",!1));const S=!1;for(const P of s.variableNames){const L={name:P,uniform:n.getUniformLocation(r,P,S),offset:n.getUniformLocation(r,`offset${P}`,S)};s.enableShapeUniforms&&(L.shape=n.getUniformLocation(r,`${P}Shape`,S),L.texShape=n.getUniformLocation(r,`${P}TexShape`,S)),d.push(L)}if(s.enableShapeUniforms&&(g=n.getUniformLocation(r,"outShape",S),v=n.getUniformLocation(r,"outShapeStrides",S),_=n.getUniformLocation(r,"outTexShape",S)),s.customUniforms)for(const P of s.customUniforms)p.push(n.getUniformLocation(r,P.name,S));return{variablesLocations:d,customUniformLocations:p,infLoc:M,nanLoc:T,outShapeLocation:g,outShapeStridesLocation:v,outTexShapeLocation:_}}function i(n,s){if(n.length!==s.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${s.length} inputs`);n.forEach((r,d)=>{const p=r.logicalShape,g=s[d],_=g.shape;if(!e.D5U.arraysEqual(p,_))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${p} and ${_} must match`);if(r.isUniform&&g.isUniform)return;const v=r.texShape,M=g.isUniform?null:g.texData.texShape;if(!e.D5U.arraysEqual(v,M))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${v} and ${M} must match`)})}function f(n,s,r,d,p){s.program.enableShapeUniforms||(i(s.inShapeInfos,r),i([s.outShapeInfo],[d]));const g=d.texData.texture,_=d.texData.texShape;d.texData.isPacked?n.setOutputPackedMatrixTexture(g.texture,_[0],_[1]):n.setOutputMatrixTexture(g.texture,_[0],_[1]),n.setProgram(s.webGLProgram),n.bindVertexArray(s.webGLProgram.vao),1===(0,e.OBj)().getNumber("WEBGL_VERSION")&&null!==s.infLoc&&n.gl.uniform1f(s.infLoc,1/0),null!==s.nanLoc&&n.gl.uniform1f(s.nanLoc,NaN);for(let M=0;M<r.length;++M){const T=r[M],{uniform:S,offset:P,shape:L,texShape:N}=s.variablesLocations[M];if(L){const{uniformShape:O}=a.Tt(s.program.packedInputs,T.shape,T.texData.texShape);switch(O.length){case 1:n.gl.uniform1iv(L,new Int32Array(O));break;case 2:n.gl.uniform2iv(L,new Int32Array(O));break;case 3:n.gl.uniform3iv(L,new Int32Array(O));break;case 4:n.gl.uniform4iv(L,new Int32Array(O))}}if(N&&n.gl.uniform2i(N,T.texData.texShape[0],T.texData.texShape[1]),null!=S){if(T.isUniform){if(e.D5U.sizeFromShape(T.shape)<2)n.gl.uniform1f(S,T.uniformValues[0]);else{let O=T.uniformValues;O instanceof Float32Array||(O=new Float32Array(O)),n.gl.uniform1fv(S,O)}continue}null!=T.texData.slice&&null!=P&&n.gl.uniform1i(P,T.texData.slice.flatOffset),n.setInputMatrixTexture(T.texData.texture.texture,S,M)}}const v=s.outShapeLocation;if(v)switch(d.shape.length){case 1:n.gl.uniform1iv(v,new Int32Array(d.shape));break;case 2:n.gl.uniform2iv(v,new Int32Array(d.shape));break;case 3:n.gl.uniform3iv(v,new Int32Array(d.shape));break;case 4:n.gl.uniform4iv(v,new Int32Array(d.shape))}if(s.outShapeStridesLocation){const M=e.D5U.computeStrides(d.shape);switch(d.shape.length){case 2:n.gl.uniform1iv(s.outShapeStridesLocation,new Int32Array(M));break;case 3:n.gl.uniform2iv(s.outShapeStridesLocation,new Int32Array(M));break;case 4:n.gl.uniform3iv(s.outShapeStridesLocation,new Int32Array(M))}}if(s.outTexShapeLocation&&n.gl.uniform2i(s.outTexShapeLocation,d.texData.texShape[0],d.texData.texShape[1]),s.program.customUniforms&&p)for(let M=0;M<s.program.customUniforms.length;++M){const T=s.program.customUniforms[M],S=s.customUniformLocations[M],P=p[M];if("float"===T.type)n.gl.uniform1fv(S,P);else if("vec2"===T.type)n.gl.uniform2fv(S,P);else if("vec3"===T.type)n.gl.uniform3fv(S,P);else if("vec4"===T.type)n.gl.uniform4fv(S,P);else if("int"===T.type)n.gl.uniform1iv(S,P);else if("ivec2"===T.type)n.gl.uniform2iv(S,P);else if("ivec3"===T.type)n.gl.uniform3iv(S,P);else{if("ivec4"!==T.type)throw Error(`uniform type ${T.type} is not supported yet.`);n.gl.uniform4iv(S,P)}}n.executeProgram()}function l(n,s,r){let d="";s.concat(r).forEach(_=>{const v=null!=_.texData&&null!=_.texData.slice&&_.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!_.isUniform){const M=_.texData.texShape,{useSqueezeShape:T,uniformShape:S,keptDims:P}=a.Tt(n.packedInputs,_.shape,M);let L="",N="",O="";if(1===S.length&&n.packedInputs){const ut=[Math.ceil(M[0]/2),Math.ceil(M[1]/2)];L=`${ut[0]>1}_${ut[1]>1}`}else if(2!==S.length||n.packedInputs){if(S.length>2&&!n.packedInputs){const ut=e.D5U.computeStrides(S);O=`${ut[0]===M[1]}_${ut[ut.length-1]===M[1]}`}}else N=`${S[0]>1}_${S[1]>1}`;const b=_.shape.length,E=2===S.length&&e.D5U.arraysEqual(_.shape,M),$=1===e.D5U.sizeFromShape(_.shape),W=e.backend_util.getBroadcastDims(_.shape,r.shape),Z=!n.packedInputs&&b===r.shape.length&&e.D5U.arraysEqual(M,r.texData.texShape);d+=`${b}_${Z}_${T?P:""}_${S.length}_${$}_${W}_${E}_${L}_${N}_${O}_${n.packedInputs||S.length>2?"":`${M[0]>1}_${M[1]>1}`}_${v}`}else d+=`${_.shape}_${_.isUniform?"uniform":_.texData.texShape}_${v}`});let g=n.constructor.name;return g+="_"+d+"_"+n.userCode+`${(0,e.OBj)().getNumber("WEBGL_VERSION")}`,g}function o(n){return(0,e.OBj)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}},7866:(H,C,t)=>{"use strict";t.d(C,{$O:()=>P,$j:()=>Ie,$u:()=>Ee,A0:()=>ie,AR:()=>Vt,B_:()=>g,Bk:()=>Gt,Bo:()=>b,CJ:()=>Pt,CV:()=>K,F1:()=>oe,Fv:()=>q,KX:()=>It,LS:()=>Nt,M8:()=>Z,MZ:()=>r,PQ:()=>T,Qs:()=>W,Rn:()=>M,Sd:()=>S,St:()=>Dt,TD:()=>d,Tg:()=>$,Th:()=>O,UN:()=>ht,X8:()=>xt,XM:()=>h,Y1:()=>Y,_9:()=>Zt,aX:()=>n,cK:()=>a,cZ:()=>E,cm:()=>i,cx:()=>c,fy:()=>X,gv:()=>o,hO:()=>ut,ji:()=>_,kI:()=>ct,kY:()=>v,m$:()=>p,n7:()=>l,nL:()=>L,nT:()=>pt,oC:()=>Ut,pk:()=>f,qO:()=>u,r:()=>N,tx:()=>s});var e=t(98669);const{addImpl:a,bincountImpl:u,bincountReduceImpl:c,bitwiseAndImpl:h,castImpl:i,ceilImpl:f,concatImpl:l,equalImpl:o,expImpl:n,expm1Impl:s,floorImpl:r,gatherNdImpl:d,gatherV2Impl:p,greaterImpl:g,greaterEqualImpl:_,lessImpl:v,lessEqualImpl:M,linSpaceImpl:T,logImpl:S,maxImpl:P,maximumImpl:L,minimumImpl:N,multiplyImpl:O,negImpl:b,notEqualImpl:E,prodImpl:$,raggedGatherImpl:W,raggedRangeImpl:Z,raggedTensorToTensorImpl:X,rangeImpl:ut,rsqrtImpl:Dt,scatterImpl:Y,sigmoidImpl:ht,simpleAbsImpl:Pt,sliceImpl:pt,sparseFillEmptyRowsImpl:xt,sparseReshapeImpl:Nt,sparseSegmentReductionImpl:Vt,sqrtImpl:Gt,staticRegexReplaceImpl:oe,stridedSliceImpl:Ee,stringNGramsImpl:Ie,stringSplitImpl:ie,stringToHashBucketFastImpl:Zt,subImpl:ct,tileImpl:It,topKImpl:Ut,transposeImpl:q,uniqueImpl:K}=e},52265:(H,C,t)=>{"use strict";function e(c,h){return["x","y","z","w","u","v"].slice(0,h).map(i=>`${c}.${i}`)}function a(c,h){return 1===h?[c]:e(c,h)}function u(c,h){if(1===c)return"rc";let i="";for(let f=0;f<c;f++)i+=h[f],f<c-1&&(i+=",");return i}t.d(C,{Ky:()=>a,Qc:()=>u,k6:()=>e})},17161:(H,C,t)=>{"use strict";var e=t(30003),a=t(42372);const u="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class h{constructor(x,m,I){this.variableNames=["A","B"],this.outputShape=e.backend_util.assertAndGetBroadcastShape(m,I),this.enableShapeUniforms=(0,a.C9)(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${x}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}var i=t(52265),f=t(45223);const l="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class s{constructor(x,m,I,D=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.backend_util.assertAndGetBroadcastShape(m,I);const R=this.outputShape.length;this.enableShapeUniforms=(0,a.C9)(R);let B="";if(D)if(0===R||1===e.D5U.sizeFromShape(this.outputShape))B="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(B=`\n          ${(0,f.kW)(R)} coords = getOutputCoords();\n        `,1===R)B+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const U=(0,i.Ky)("coords",R);B+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${U[R-2]} + 1) >= outShape[${R} - 2];\n            bool nextColOutOfBounds =\n              (${U[R-1]} + 1) >= outShape[${R} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${U[R-2]} + 1) >= ${this.outputShape[R-2]};\n            bool nextColOutOfBounds =\n              (${U[R-1]} + 1) >= ${this.outputShape[R-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${x}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${B}\n\n        setOutput(result);\n      }\n    `}}function r(w){const{inputs:x,backend:m}=w,{x:I}=x;return m.incRef(I.dataId),{dataId:I.dataId,shape:I.shape,dtype:I.dtype}}const d={kernelName:e.iJz,backendName:"webgl",kernelFunc:r};function p(w){const{inputs:x,backend:m}=w,{real:I,imag:D}=x,R=m.makeTensorInfo(I.shape,"complex64"),B=m.texData.get(R.dataId),k=r({inputs:{x:I},backend:m}),U=r({inputs:{x:D},backend:m});return B.complexTensorInfos={real:k,imag:U},R}const g={kernelName:e.Zz9,backendName:"webgl",kernelFunc:p},_="return (a < 0.) ? b * a : a;",v="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",T={kernelName:e.J$2,backendName:"webgl",kernelFunc:function M(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{alpha:R}=I,B=m.makeTensorInfo([],"float32",e.D5U.createScalarValue(R,"float32")),k=(0,e.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new s(v,D.shape,B.shape):new h(_,D.shape,B.shape),U=m.runWebGLProgram(k,[D,B],"float32");return m.disposeIntermediateTensorInfo(B),U}},S="return (a < 0.) ? b * a : a;",P="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",N={kernelName:e.o0g,backendName:"webgl",kernelFunc:function L(w){const{inputs:x,backend:m}=w,{x:I,alpha:D}=x,R=(0,e.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new s(P,I.shape,D.shape):new h(S,I.shape,D.shape);return m.runWebGLProgram(R,[I,D],"float32")}};var O=t(32398),b=t(807);const E="if (isnan(x)) return x;";function $({opSnippet:w,packedOpSnippet:x,cpuKernelImpl:m,dtype:I}){return({inputs:D,backend:R})=>{const{x:B}=D,k=R,U=I||B.dtype;if(k.shouldExecuteOnCPU([B])&&null!=m){const st=k.texData.get(B.dataId),it=m(st.values,U);return k.makeTensorInfo(B.shape,U,it)}let V;return V=(0,e.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=x?new b.cc(B.shape,x):new O.l(B.shape,w),k.runWebGLProgram(V,[B],U)}}function W({opSnippet:w,packedOpSnippet:x,checkOutOfBounds:m=!1,supportsComplex:I=!1,cpuKernelImpl:D,dtype:R}){return({inputs:B,backend:k})=>{const{a:U,b:F}=B,V=k;if(I&&"complex64"===U.dtype){const _t=V.texData.get(U.dataId),Rt=V.texData.get(F.dataId),[$t,Mt]=[[_t.complexTensorInfos.real,Rt.complexTensorInfos.real],[_t.complexTensorInfos.imag,Rt.complexTensorInfos.imag]].map(De=>{const[he,Ne]=De,Ye={dataId:he.dataId,dtype:he.dtype,shape:U.shape},je={dataId:Ne.dataId,dtype:Ne.dtype,shape:F.shape},Fe=new h(w,U.shape,F.shape);return V.runWebGLProgram(Fe,[Ye,je],(0,e.x8V)(he.dtype,Ne.dtype))}),Ft=p({inputs:{real:$t,imag:Mt},backend:V});return V.disposeIntermediateTensorInfo($t),V.disposeIntermediateTensorInfo(Mt),Ft}const st=R||(0,e.x8V)(U.dtype,F.dtype);if(("string"===U.dtype||"string"===F.dtype||V.shouldExecuteOnCPU([U,F]))&&null!=D){const _t=V.texData.get(U.dataId).values,Rt=V.texData.get(F.dataId).values,$t="string"===U.dtype?e.backend_util.fromUint8ToStringArray(_t):_t,Mt="string"===U.dtype?e.backend_util.fromUint8ToStringArray(Rt):Rt,[Ft,De]=D(U.shape,F.shape,$t,Mt,st),he=V.makeTensorInfo(De,st);return V.texData.get(he.dataId).values=Ft,he}let mt;return mt=(0,e.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=x?new s(x,U.shape,F.shape,m):new h(w,U.shape,F.shape),V.runWebGLProgram(mt,[U,F],st)}}function Z(w,x=!1){if("linear"===w)return x?b.t$:O.t$;if("relu"===w)return x?b.RX:O.RX;if("elu"===w)return x?b.Cv:O.Cv;if("relu6"===w)return x?b.eW:O.eW;if("prelu"===w)return x?P:S;if("leakyrelu"===w)return x?v:_;if("sigmoid"===w)return x?b.Tq:O.Tq;throw new Error(`Activation ${w} has not been implemented for the WebGL backend.`)}class X{constructor(x,m,I,D=!1,R=!1,B=!1,k=null,U=!1,F=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=I,this.enableShapeUniforms=(0,a.C9)(this.outputShape.length);const st=Math.ceil((D?x[1]:x[2])/2),it=D?"i * 2, rc.y":"rc.y, i * 2",mt=R?"rc.z, i * 2":"i * 2, rc.z",_t=D?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],Rt=R?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let $t="",Mt="";k&&($t=U?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${k}\n        }`:F?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${k}\n        }`:`vec4 activation(vec4 x) {\n          ${k}\n        }`,Mt="result = activation(result);");const Ft=B?"result += getBiasAtOutCoords();":"";B&&this.variableNames.push("bias"),U&&this.variableNames.push("preluActivationWeights"),F&&this.variableNames.push("leakyreluAlpha");let De="rc.x",he="rc.x";x[0]<m[0]?De=`imod(rc.x, ${x[0]})`:m[0]<x[0]&&(he=`imod(rc.x, ${m[0]})`),this.userCode=`\n      ${$t}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${st}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${De};\n        int batchB = ${he};\n        for (int i = 0; i < ${st}; i++) {\n          vec4 a = getMatrixA(batchA, ${it});\n          vec4 b = getMatrixB(batchB, ${mt});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${_t[0]} * ${Rt[0]});\n          result += (${_t[1]} * ${Rt[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${Ft}\n\n        ${Mt}\n\n        setOutput(result);\n      }\n    `}}class Dt{constructor(x,m,I){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=e.backend_util.assertAndGetBroadcastShape(m,I),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${x}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}var Y=t(7866);const ht="return a * b;";function Pt(w){const{inputs:x,backend:m}=w,{a:I,b:D}=x,R=e.backend_util.upcastType(I.dtype,D.dtype);if("complex64"===I.dtype){const k=m.texData.get(I.dataId),U=m.texData.get(D.dataId),F=new Dt("return areal * breal - aimag * bimag;",I.shape,D.shape),V=new Dt("return areal * bimag + aimag * breal;",I.shape,D.shape),st=[{dataId:k.complexTensorInfos.real.dataId,dtype:k.complexTensorInfos.real.dtype,shape:I.shape},{dataId:k.complexTensorInfos.imag.dataId,dtype:k.complexTensorInfos.imag.dtype,shape:I.shape},{dataId:U.complexTensorInfos.real.dataId,dtype:U.complexTensorInfos.real.dtype,shape:D.shape},{dataId:U.complexTensorInfos.imag.dataId,dtype:U.complexTensorInfos.imag.dtype,shape:D.shape}],it=m.runWebGLProgram(F,st,"float32"),mt=m.runWebGLProgram(V,st,"float32"),_t=p({inputs:{real:it,imag:mt},backend:m});return m.disposeIntermediateTensorInfo(it),m.disposeIntermediateTensorInfo(mt),_t}if(m.shouldExecuteOnCPU([I,D])){const k=m.texData.get(I.dataId),U=m.texData.get(D.dataId),[F,V]=(0,Y.Th)(I.shape,D.shape,k.values,U.values,R),st=m.makeTensorInfo(V,R);return m.texData.get(st.dataId).values=F,st}let B;return B=(0,e.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new s(ht,I.shape,D.shape):new h(ht,I.shape,D.shape),m.runWebGLProgram(B,[I,D],R)}const pt={kernelName:e.wYn,backendName:"webgl",kernelFunc:Pt};var xt=t(4074),Nt=t(63076);function Gt(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{shape:R}=I,B=m,k=e.D5U.sizeFromShape(D.shape),U=e.D5U.inferFromImplicitShape(R,k),F=e.D5U.sizeFromShape(U);e.D5U.assert(k===F,()=>`The new shape (${U}) has ${F} elements and the old shape (${D.shape}) has ${k} elements. The new shape and old shape must have the same number of elements.`);const V=B.texData.get(D.dataId);return!V.isPacked||(0,Nt.isReshapeFree)(D.shape,U)||null!==V.texture&&(0,Nt.isReshapeFree)(V.shape,U)?(B.incRef(D.dataId),{dataId:D.dataId,shape:U,dtype:D.dtype}):function Vt(w,x,m){const I=[(0,Nt.getBatchDim)(w.shape),...(0,Nt.getRowsCols)(w.shape)],D={dtype:w.dtype,shape:I,dataId:w.dataId},R=[(0,Nt.getBatchDim)(x),...(0,Nt.getRowsCols)(x)],B=new xt.v(R,I),F=m.runWebGLProgram(B,[D],w.dtype,[I],!0);return{dataId:F.dataId,shape:x,dtype:F.dtype}}(D,U,B)}const oe={kernelName:e.HZH,backendName:"webgl",kernelFunc:Gt};class Ee{constructor(x,m){this.variableNames=["x"];const{windowSize:I,batchSize:D,inSize:R,outSize:B}=x;this.outputShape=[D,B];const k=4*Math.floor(I/4),U=I%4;let F="sumValue += dot(values, ones);";if(null!=m){const st=1/m;F=`sumValue += dot(values * ${e.D5U.isInt(st)?st.toPrecision(2):st}, ones);`}let V="";R%I>0&&(V=`\n        if (inIdx < 0 || inIdx >= ${R}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${V}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${I};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${k}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${F}\n        }\n\n        int inIdx = inOffset + ${k};\n        if (${1===U}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${F}\n        } else if (${2===U}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${F}\n        } else if (${3===U}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${F}\n        }\n        setOutput(sumValue);\n      }\n    `}}class Ie{constructor(x,m){this.variableNames=["x"];const{windowSize:I,batchSize:D,inSize:R,outSize:B}=x;this.outputShape=[D,B];let k="0.0",U="";"prod"===m?k="1.0":"min"===m?(k="1.0 / 1e-20",U="min"):"max"===m&&(k="-1.0 / 1e-20",U="max");let F=`${m}(${m}(${m}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===m?F="sumValue":"prod"===m?F="prodValue":"all"===m?F="allValue":"any"===m&&(F="anyValue");const V=4*Math.floor(I/4),st=I%4;let it=`\n      if (${"sum"===m}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===m}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${U}(values, minMaxValue);\n        if (${"min"===m} || ${"max"===m}) {\n          minMaxValue = ${U}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,mt="vec4";"all"===m?(k="1.0",it="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",mt="bvec4"):"any"===m&&(k="0.0",it="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",mt="bvec4");let _t="";R%I>0&&(_t=`\n        if (inIdx < 0 || inIdx >= ${R}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${k};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${_t}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${I};\n\n        vec4 minMaxValue = vec4(${k});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${V}; i += 4) {\n          int inIdx = inOffset + i;\n          ${mt} values = ${mt}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${it}\n        }\n\n        int inIdx = inOffset + ${V};\n        if (${1===st}) {\n          ${mt} values = ${mt}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${it}\n        } else if (${2===st}) {\n          ${mt} values = ${mt}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${it}\n        } else if (${3===st}) {\n          ${mt} values = ${mt}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${it}\n        }\n        setOutput(${F});\n      }\n    `}}function Zt(w,x,m,I){const D=function ie(w){const x=[];for(;0===x.length||1!==x[x.length-1].outSize;){const m=x.length?x[x.length-1].outSize:w[1],I=e.backend_util.computeOptimalWindowSize(m);x.push({inSize:m,windowSize:I,outSize:Math.ceil(m/I)})}return x}(w.shape);let R=w;for(let B=0;B<D.length;B++){const{inSize:k,windowSize:U,outSize:F}=D[B];let V,st;V="mean"===m?0===B?new Ee({windowSize:U,inSize:k,batchSize:w.shape[0],outSize:F},k):new Ee({windowSize:U,inSize:k,batchSize:w.shape[0],outSize:F}):new Ie({windowSize:U,inSize:k,batchSize:w.shape[0],outSize:F},m),st=R,R=I.runWebGLProgram(V,[R],x),st.dataId!==w.dataId&&I.disposeIntermediateTensorInfo(st)}return R}class ct{constructor(x,m){this.variableNames=["A"];const I=new Array(x.length);for(let B=0;B<I.length;B++)I[B]=x[m[B]];this.outputShape=I,this.rank=I.length;const D=(0,f.kW)(this.rank),R=function It(w){const x=w.length;if(x>6)throw Error(`Transpose for rank ${x} is not yet supported`);const m=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],I=new Array(x);for(let D=0;D<w.length;D++)I[w[D]]=m[D];return I.join()}(m);this.userCode=`\n    void main() {\n      ${D} resRC = getOutputCoords();\n      setOutput(getA(${R}));\n    }\n    `}}class Ut{constructor(x,m){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const I=new Array(x.length);for(let V=0;V<I.length;V++)I[V]=x[m[V]];if(this.outputShape=I,this.rank=I.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const D=(0,f.kW)(this.rank),R=(0,i.k6)("rc",this.rank),B=new Array(this.rank);for(let V=0;V<m.length;V++)B[m[V]]=R[V];const k=`vec2(${B.slice(-2).join()})`,U=`++${R[this.rank-1]} < ${I[this.rank-1]}`,F=`getChannel(getA(${B.join()}), ${k})`;this.userCode=`\n    void main() {\n      ${D} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${F};\n      if(${U}) {\n        result[1] = ${F};\n      }\n      --${R[this.rank-1]};\n      if(++${R[this.rank-2]} < ${I[this.rank-2]}) {\n        result[2] = ${F};\n        if(${U}) {\n          result[3] = ${F};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function q(w,x,m){const I=(0,e.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ut(w.shape,x):new ct(w.shape,x);return m.runWebGLProgram(I,[w],w.dtype)}function j(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{axis:R,keepDims:B}=I;return function K(w,x,m,I){const R=w.shape.length,B=e.D5U.parseAxisParam(x,w.shape);let k=B;const U=e.backend_util.getAxesPermutation(k,R),F=null!=U;let V=w;F&&(V=q(w,U,I),k=e.backend_util.getInnerMostAxes(k.length,R)),e.backend_util.assertAxesAreInnerMostDims("sum",k,R);const[st,it]=e.backend_util.computeOutAndReduceShapes(V.shape,k);let mt=st;m&&(mt=e.backend_util.expandShapeToKeepDim(st,B));const _t=e.D5U.sizeFromShape(it),Mt=Gt({inputs:{x:V},attrs:{shape:[e.D5U.sizeFromShape(w.shape)/_t,_t]},backend:I}),De=Zt(Mt,(0,e.z4k)(w.dtype),"sum",I),he=Gt({inputs:{x:De},attrs:{shape:mt},backend:I});return I.disposeIntermediateTensorInfo(Mt),I.disposeIntermediateTensorInfo(De),F&&I.disposeIntermediateTensorInfo(V),he}(D,R,B,m)}const at={kernelName:e.GBy,backendName:"webgl",kernelFunc:j};function dt(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{perm:R}=I,B=m,U=new Array(D.shape.length);for(let V=0;V<U.length;V++)U[V]=D.shape[R[V]];let F;if(B.shouldExecuteOnCPU([D])){const st=B.texData.get(D.dataId).values,it=(0,Y.Fv)(st,D.shape,D.dtype,R,U);F=B.makeTensorInfo(U,D.dtype),B.texData.get(F.dataId).values=it}else F=q(D,R,B);return F}const kt={kernelName:e.G3Y,backendName:"webgl",kernelFunc:dt};function Jt({a:w,b:x,transposeA:m,transposeB:I,backend:D,bias:R=null,preluActivationWeights:B=null,leakyreluAlpha:k=0,activation:U=null}){const F=w.shape.length,V=x.shape.length,st=m?w.shape[F-2]:w.shape[F-1],it=I?x.shape[V-1]:x.shape[V-2],mt=m?w.shape[F-1]:w.shape[F-2],_t=I?x.shape[V-2]:x.shape[V-1],Rt=w.shape.slice(0,-2),$t=x.shape.slice(0,-2),Mt=e.D5U.sizeFromShape(Rt),Ft=e.D5U.sizeFromShape($t),he=e.Jyw.assertAndGetBroadcastShape(w.shape.slice(0,-2),x.shape.slice(0,-2)).concat([mt,_t]);e.D5U.assert(st===it,()=>`Error in matMul: inner shapes (${st}) and (${it}) of Tensors with shapes ${w.shape} and ${x.shape} and transposeA=${m} and transposeB=${I} must match.`);const Ne=m?[Mt,st,mt]:[Mt,mt,st],Ye=I?[Ft,_t,it]:[Ft,it,_t],je=Gt({inputs:{x:w},backend:D,attrs:{shape:Ne}}),Fe=Gt({inputs:{x},backend:D,attrs:{shape:Ye}}),sn=[je,Fe],Qe=Math.max(Mt,Ft),Cn=m?je.shape[1]:je.shape[2],In=null!=R,es=null!=B,Nn="leakyrelu"===U,Wn=null!=U?Z(U,!0):null;let Xn;if((1===mt||1===_t)&&Cn>1e3&&!1===(In||es||Nn||null!=Wn)){let Is=je,yo=Fe;m&&(Is=dt({inputs:{x:je},backend:D,attrs:{perm:[0,2,1]}}),sn.push(Is)),I&&(yo=dt({inputs:{x:Fe},backend:D,attrs:{perm:[0,2,1]}}),sn.push(yo));const Pr=1===_t;let ki=Is;1!==_t&&(ki=Gt({inputs:{x:Is},backend:D,attrs:{shape:[Qe,Cn,1]}}),sn.push(ki));const uc=1===_t?2:1;let wi=yo;Pr&&(wi=Gt({inputs:{x:yo},backend:D,attrs:{shape:[Qe,1,Cn]}}),sn.push(wi));const gl=Pt({inputs:{a:ki,b:wi},backend:D});Xn=j({inputs:{x:gl},backend:D,attrs:{axis:uc,keepDims:!0}}),sn.push(gl)}else{const Is=(0,e.x8V)(w.dtype,x.dtype),yo=new X(Ne,Ye,[Qe,mt,_t],m,I,In,Wn,es,Nn),Ro=[je,Fe];if(null!=R&&Ro.push(R),es&&Ro.push(B),Nn){const Pr=D.makeTensorInfo([],"float32",e.D5U.createScalarValue(k,"float32"));Ro.push(Pr),sn.push(Pr)}Xn=D.runWebGLProgram(yo,Ro,Is)}const bn=Gt({inputs:{x:Xn},backend:D,attrs:{shape:he}});sn.push(Xn);for(const Is of sn)D.disposeIntermediateTensorInfo(Is);return bn}const Re={kernelName:e.usg,backendName:"webgl",kernelFunc:function ae(w){const{inputs:x,backend:m,attrs:I}=w,{a:D,b:R,bias:B,preluActivationWeights:k}=x,{transposeA:U,transposeB:F,activation:V,leakyreluAlpha:st}=I;return Jt({a:D,b:R,transposeA:U,transposeB:F,backend:m,bias:B,preluActivationWeights:k,leakyreluAlpha:st,activation:V})}},Be="return abs(x);",we={kernelName:e.SYM,backendName:"webgl",kernelFunc:function Se(w){const{inputs:x,backend:m}=w,{x:I}=x;if(m.shouldExecuteOnCPU([I])&&"complex64"!==I.dtype){const R=m.texData.get(I.dataId),B=(0,Y.CJ)(R.values);return m.makeTensorInfo(I.shape,I.dtype,B)}let D;return D=(0,e.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new b.cc(I.shape,Be):new O.l(I.shape,Be),m.runWebGLProgram(D,[I],I.dtype)}},Te=$({opSnippet:O.D1+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Je={kernelName:e.VGw,backendName:"webgl",kernelFunc:Te},On=$({opSnippet:O.D1+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),mn={kernelName:e.SpW,backendName:"webgl",kernelFunc:On},hn="return a + b;",Pn=W({opSnippet:hn,packedOpSnippet:hn,supportsComplex:!0,cpuKernelImpl:Y.cK}),ns={kernelName:e.mm_,backendName:"webgl",kernelFunc:Pn};class Lt{constructor(x,m){this.outputShape=[],this.outputShape=x,this.variableNames=m.map((R,B)=>`T${B}`);const I=[];this.variableNames.forEach(R=>{I.push(`float v${R} = get${R}AtOutCoords();`)});const D=this.variableNames.map(R=>`v${R}`).join(" + ");this.userCode=`\n      void main() {\n        ${I.join("\n        ")}\n\n        float result = ${D};\n        setOutput(result);\n      }\n    `}}class ee{constructor(x,m){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=x,this.variableNames=m.map((R,B)=>`T${B}`);const I=[];this.variableNames.forEach(R=>{I.push(`vec4 v${R} = get${R}AtOutCoords();`)});const D=this.variableNames.map(R=>`v${R}`).join(" + ");this.userCode=`\n      void main() {\n        ${I.join("\n        ")}\n\n        vec4 result = ${D};\n        setOutput(result);\n      }\n    `}}const Qt={kernelName:e.Xze,backendName:"webgl",kernelFunc:function re(w){const{inputs:x,backend:m}=w,I=x;if(1===I.length)return r({inputs:{x:I[0]},backend:m});if(I.length>(0,e.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const U=Math.floor(I.length/2),F=re({inputs:I.slice(0,U),backend:m}),V=re({inputs:I.slice(U),backend:m});return re({inputs:[F,V],backend:m})}const D=I.map(U=>U.dtype).reduce((U,F)=>(0,e.x8V)(U,F)),R=I.map(U=>U.shape),k=(0,e.OBj)().getBool("WEBGL_PACK")?new ee(I[0].shape,R):new Lt(I[0].shape,R);return m.runWebGLProgram(k,I,D)}},Ue={kernelName:e.oT6,backendName:"webgl",kernelFunc:function se(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{axis:R,keepDims:B}=I,k=D.shape.length,U=e.D5U.parseAxisParam(R,D.shape);let F=U;const V=e.backend_util.getAxesPermutation(F,k);let st=D;null!=V&&(st=dt({inputs:{x:D},backend:m,attrs:{perm:V}}),F=e.backend_util.getInnerMostAxes(F.length,k)),e.backend_util.assertAxesAreInnerMostDims("all",F,k);const[it,mt]=e.backend_util.computeOutAndReduceShapes(st.shape,F),Rt=Gt({inputs:{x:st},backend:m,attrs:{shape:[-1,e.D5U.sizeFromShape(mt)]}}),$t=Zt(Rt,Rt.dtype,"all",m);let Mt;return Mt=Gt(B?{inputs:{x:$t},backend:m,attrs:{shape:e.backend_util.expandShapeToKeepDim(it,U)}}:{inputs:{x:$t},backend:m,attrs:{shape:it}}),m.disposeIntermediateTensorInfo(Rt),m.disposeIntermediateTensorInfo($t),null!=V&&m.disposeIntermediateTensorInfo(st),Mt}},rn={kernelName:e.IKK,backendName:"webgl",kernelFunc:function We(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{axis:R,keepDims:B}=I,k=D.shape.length,U=e.D5U.parseAxisParam(R,D.shape);let F=U;const V=e.backend_util.getAxesPermutation(F,k);let st=D;null!=V&&(st=dt({inputs:{x:D},backend:m,attrs:{perm:V}}),F=e.backend_util.getInnerMostAxes(F.length,k)),e.backend_util.assertAxesAreInnerMostDims("any",F,k);const[it,mt]=e.backend_util.computeOutAndReduceShapes(st.shape,F),Rt=Gt({inputs:{x:st},backend:m,attrs:{shape:[-1,e.D5U.sizeFromShape(mt)]}}),$t=Zt(Rt,Rt.dtype,"any",m);let Mt;return Mt=Gt(B?{inputs:{x:$t},backend:m,attrs:{shape:e.backend_util.expandShapeToKeepDim(it,U)}}:{inputs:{x:$t},backend:m,attrs:{shape:it}}),m.disposeIntermediateTensorInfo(Rt),m.disposeIntermediateTensorInfo($t),null!=V&&m.disposeIntermediateTensorInfo(st),Mt}};class yn{constructor(x,m,I){this.variableNames=["A"];const{windowSize:D,batchSize:R,outSize:B}=x;I||this.variableNames.push("bestIndicesA"),this.outputShape=[R,B],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${D};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${D}; i++) {\n          int inIdx = ${I?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===m?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class An{constructor(x,m,I,D){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,e.D5U.assert(x.length>2,()=>`Packed arg${I.charAt(0).toUpperCase()+I.slice(1)} supports only inputs with rank above 2.`);const B=Math.ceil(x[x.length-1]/m);this.outputShape=x.slice(0,-1),B>1&&this.outputShape.push(B),D||this.variableNames.push("bestIndicesA");const k=this.outputShape,U=k.length,F=(0,f.kW)(U),V=(0,i.Ky)("coords",U);let st,it;if(1===B){it=U+1;const Fe=(0,f.kW)(it);st=`\n        ${Fe} sourceLocR = ${Fe}(${V.join()}, 0);\n        ++${V[U-1]};\n        ${Fe} sourceLocG = ${Fe}(${V.join()}, 0);\n        ++${V[U-2]};\n        ${Fe} sourceLocA = ${Fe}(${V.join()}, 0);\n        --${V[U-1]};\n        ${Fe} sourceLocB = ${Fe}(${V.join()}, 0);\n        --${V[U-2]};`}else it=U,st=`\n        ${F} sourceLocR = coords;\n        ++${V[U-1]};\n        ${F} sourceLocG = coords;\n        ++${V[U-2]};\n        ${F} sourceLocA = coords;\n        --${V[U-1]};\n        ${F} sourceLocB = coords;\n        --${V[U-2]};`;const mt=["x","y","z","w","u","v"].slice(0,it),_t="."+mt[it-1],Rt=mt.map(Fe=>"int "+Fe),$t=(0,i.Ky)("sourceLocR",it-1).concat("inIdx.r"),Mt=(0,i.Ky)("sourceLocG",it-1).concat("inIdx.g"),Ft=(0,i.Ky)("sourceLocB",it-1).concat("inIdx.b"),De=(0,i.Ky)("sourceLocA",it-1).concat("inIdx.a"),he="max"===I?"greaterThan":"lessThan",Ne=D?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${$t.join()}),\n                             getBestIndicesAChannel(${Mt.join()}),\n                             getBestIndicesAChannel(${Ft.join()}),\n                             getBestIndicesAChannel(${De.join()})));`,Ye=`vec4(\n            getAChannel(${$t.join()}),\n            hasNextCol ? getAChannel(${Mt.join()}) : 0.,\n            hasNextRow ? getAChannel(${Ft.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${De.join()}) : 0.)`,je=D?"":`\n      float getBestIndicesAChannel(${Rt.join()}) {\n        return getChannel(getBestIndicesA(${mt.join()}),\n                                          vec2(${mt.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${Rt.join()}) {\n        return getChannel(getA(${mt.join()}),\n                               vec2(${mt.slice(-2).join()}));\n      }\n      ${je}\n      void main() {\n        ${F} coords = getOutputCoords();\n        bool hasNextCol = ${V[U-1]} < ${k[U-1]-1};\n        bool hasNextRow = ${V[U-2]} < ${k[U-2]-1};\n        ${st}\n        ivec4 srcIdx = ivec4(sourceLocR${_t}, sourceLocG${_t},\n          sourceLocB${_t}, sourceLocA${_t}) * ${m};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${Ye};\n\n        for (int i = 0; i < ${m}; i++) {\n          inIdx = srcIdx;\n          ${Ne}\n          vec4 candidate = ${Ye};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${he}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function vn(w,x,m,I=null){let D=x.shape[0],R=x.shape[1];null!=I&&(D=I.shape[0],R=I.shape[1]);const B=e.backend_util.computeOptimalWindowSize(R),k={windowSize:B,inSize:R,batchSize:D,outSize:Math.ceil(R/B)},U=new yn(k,m,null==I),F=[x];null!=I&&F.push(I);const V=w.runWebGLProgram(U,F,"int32");if(1===V.shape[1])return V;const st=vn(w,x,m,V);return w.disposeIntermediateTensorInfo(V),st}function en(w,x,m,I=null){const D=null!=I?I.shape:x.shape,B=e.backend_util.computeOptimalWindowSize(D[D.length-1]),k=new An(D,B,m,null==I),F=w.runWebGLProgram(k,null==I?[x]:[x,I],"int32");if(F.shape.length===x.shape.length){const V=en(w,x,m,F);return w.disposeIntermediateTensorInfo(F),V}return F}function dn(w,x,m,I){const D=[m];if(e.backend_util.assertAxesAreInnerMostDims("arg"+I.charAt(0).toUpperCase()+I.slice(1),D,x.shape.length),!(0,e.OBj)().getBool("WEBGL_PACK_REDUCE")||x.shape.length<=2){const R=[],B=w.texData.get(x.dataId);let U=x;null!==B&&B.isPacked&&(U=w.unpackTensor(x),R.push(U));const[F,V]=e.backend_util.computeOutAndReduceShapes(U.shape,D),st=e.D5U.sizeFromShape(V),it=Gt({inputs:{x:U},backend:w,attrs:{shape:[-1,st]}});R.push(it);const mt=vn(w,it,I);R.push(mt);const _t=Gt({inputs:{x:mt},backend:w,attrs:{shape:F}});return R.forEach(Rt=>w.disposeIntermediateTensorInfo(Rt)),_t}return en(w,x,I)}const Ln={kernelName:e.sJF,backendName:"webgl",kernelFunc:function Mn(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{axis:R}=I;let B=e.D5U.parseAxisParam(R,D.shape);const k=e.backend_util.getAxesPermutation(B,D.shape.length);let U=D;const F=[];null!=k&&(U=dt({inputs:{x:D},backend:m,attrs:{perm:k}}),F.push(U),B=e.backend_util.getInnerMostAxes(B.length,U.shape.length)),e.backend_util.assertAxesAreInnerMostDims("argMax",[B[0]],U.shape.length);const V=dn(m,U,B[0],"max");return F.forEach(st=>m.disposeIntermediateTensorInfo(st)),V}},kn={kernelName:e.aJk,backendName:"webgl",kernelFunc:function cs(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{axis:R}=I;let B=e.D5U.parseAxisParam(R,D.shape);const k=e.backend_util.getAxesPermutation(B,D.shape.length);let U=D;const F=[];null!=k&&(U=dt({inputs:{x:D},backend:m,attrs:{perm:k}}),F.push(U),B=e.backend_util.getInnerMostAxes(B.length,U.shape.length)),e.backend_util.assertAxesAreInnerMostDims("argMin",[B[0]],U.shape.length);const V=dn(m,U,B[0],"min");return F.forEach(st=>m.disposeIntermediateTensorInfo(st)),V}},ds=$({opSnippet:O.D1+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),ss={kernelName:e.M2y,backendName:"webgl",kernelFunc:ds},Ps=$({opSnippet:O.D1+"return log(x + sqrt(x * x + 1.0));"}),Ms={kernelName:e.qw7,backendName:"webgl",kernelFunc:Ps},ys=$({opSnippet:O.D1+"\n  return atan(x);\n"}),Gn={kernelName:e.jMg,backendName:"webgl",kernelFunc:ys},Ss=W({opSnippet:u+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+l+"\n  return result;\n"}),bs={kernelName:e.QCc,backendName:"webgl",kernelFunc:Ss},Bs=$({opSnippet:O.D1+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Ls={kernelName:e.Oyi,backendName:"webgl",kernelFunc:Bs};class Hn{constructor(x,m,I,D=!1,R=!1){if(this.variableNames=["x"],"avg"===m&&I)throw new Error("Cannot compute positions for average pool.");const B=x.filterWidth,k=x.strideHeight,U=x.strideWidth,F=x.dilationHeight,V=x.dilationWidth,st=x.effectiveFilterHeight,it=x.effectiveFilterWidth,mt=x.padInfo.top,_t=x.padInfo.left;this.outputShape=x.outShape;const Rt="avg"===m;let Ft="0.0";if(Rt||(Ft="-1.0 / 1e-20"),I)return void(this.userCode=`\n        const ivec2 strides = ivec2(${k}, ${U});\n        const ivec2 pads = ivec2(${mt}, ${_t});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${st};\n              wR += ${F}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${x.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${it};\n                wC += ${V}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${x.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${D?R?`((batch  * ${x.inHeight} + xR) * ${x.inWidth} + xC) * ${x.inChannels} + d`:`(xR * ${x.inWidth} + xC) * ${x.inChannels} + d`:`wR * ${it} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let he=`${m}(${m}(${m}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===m&&(he="avgValue / max(count, 1.0)");const Ne=4*Math.floor(B/4),Ye=B%4,je=`\n      if (${Rt}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${k}, ${U});\n      const ivec2 pads = ivec2(${mt}, ${_t});\n      const float initializationValue = ${Ft};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${x.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${Ft});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${st};\n            wR += ${F}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${x.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${Ne}; wC += 4) {\n            int xC = xCCorner + wC * ${V};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${V}, d),\n              getValue(batch, xR, xC + 2 * ${V}, d),\n              getValue(batch, xR, xC + 3 * ${V}, d)\n            );\n\n            ${je}\n          }\n\n          int xC = xCCorner + ${Ne};\n          if (${1===Ye}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${je}\n          } else if (${2===Ye}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${V}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${je}\n          } else if (${3===Ye}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${V}, d),\n              getValue(batch, xR, xC + 2 * ${V}, d),\n              initializationValue\n            );\n\n            ${je}\n          }\n        }\n        setOutput(${he});\n      }\n    `}}class Yn{constructor(x,m,I,D=!1,R=!1){if(this.variableNames=["x"],"avg"===m&&I)throw new Error("Cannot compute positions for average pool.");const B=x.filterWidth,k=x.strideDepth,U=x.strideHeight,F=x.strideWidth,V=x.dilationDepth,st=x.dilationHeight,it=x.dilationWidth,mt=x.effectiveFilterDepth,_t=x.effectiveFilterHeight,Rt=x.effectiveFilterWidth,$t=x.padInfo.front,Mt=x.padInfo.top,Ft=x.padInfo.left;this.outputShape=x.outShape;const De="avg"===m;let he="0.0";if(De||(he="-1.0 / 1e-20"),I)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${k}, ${U}, ${F});\n        const ivec3 pads = ivec3(${$t}, ${Mt}, ${Ft});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${mt};\n              wD += ${V}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${x.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${_t};\n                wR += ${st}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${x.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${Rt};\n                  wC += ${it}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${x.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${D?R?`(((batch * ${x.inDepth} + xD) * ${x.inHeight} + xR) * ${x.inWidth} + xC) * ${x.inChannels} + ch`:`((xD * ${x.inHeight} + xR) * ${x.inWidth} + xC) * ${x.inChannels} + ch`:`wD * ${_t} * ${Rt} +\n                      wR * ${Rt} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let Ye=`${m}(${m}(${m}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===m&&(Ye="avgValue / max(count, 1.0)");const je=4*Math.floor(B/4),Fe=B%4,sn=`\n      if (${De}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${k}, ${U}, ${F});\n      const ivec3 pads = ivec3(${$t}, ${Mt}, ${Ft});\n      const float initializationValue = ${he};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${x.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${he});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${mt};\n            wD += ${V}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${x.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${_t};\n            wR += ${st}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${x.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${je}; wC += 4) {\n              int xC = xCCorner + wC * ${it};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${it}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${it}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${it}, ch)\n              );\n\n              ${sn}\n            }\n\n            int xC = xCCorner + ${je};\n            if (${1===Fe}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${sn}\n            } else if (${2===Fe}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${it}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${sn}\n            } else if (${3===Fe}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${it}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${it}, ch),\n                initializationValue\n              );\n\n              ${sn}\n            }\n          }\n        }\n        setOutput(${Ye});\n      }\n    `}}const Ns={kernelName:e.JhU,backendName:"webgl",kernelFunc:function hs(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x;(0,Nt.assertNotComplex)(D,"avgPool");const{filterSize:R,strides:B,pad:k,dimRoundingMode:U}=I;e.D5U.assert(e.backend_util.eitherStridesOrDilationsAreOne(B,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${B} and dilations '1'`);const V=e.backend_util.computePool2DInfo(D.shape,R,B,1,k,U);if(1===V.filterWidth&&1===V.filterHeight&&e.D5U.arraysEqual(V.inShape,V.outShape))return r({inputs:{x:D},backend:m});const st=new Hn(V,"avg",!1);return m.runWebGLProgram(st,[D],"float32")}},Ws={kernelName:e._k9,backendName:"webgl",kernelFunc:function Us(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{filterSize:R,strides:B,pad:k,dimRoundingMode:U,dataFormat:F}=I,st=e.backend_util.computePool3DInfo(D.shape,R,B,[1,1,1],k,U,F),it=new Yn(st,"avg",!1);return m.runWebGLProgram(it,[D],"float32")}};class ks{constructor(x){this.variableNames=["dy"],this.outputShape=x.inShape;const U=x.effectiveFilterHeight,F=x.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${U-1-x.padInfo.top}, ${F-1-x.padInfo.left});\n      const float avgMultiplier = float(${1/(x.filterHeight*x.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${U};\n            wR += ${x.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${x.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${x.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${F};\n            wC+= ${x.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${x.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${x.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ws{constructor(x){this.variableNames=["dy"],this.outputShape=x.inShape;const st=x.effectiveFilterDepth,it=x.effectiveFilterHeight,mt=x.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${st-1-x.padInfo.front}, ${it-1-x.padInfo.top}, ${mt-1-x.padInfo.left});\n      const float avgMultiplier = float(${1/(x.filterDepth*x.filterHeight*x.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${st};\n            wD += ${x.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${x.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${x.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${it};\n              wR += ${x.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${x.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${x.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${mt};\n                wC += ${x.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${x.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${x.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Ks={kernelName:e.IMb,backendName:"webgl",kernelFunc:function Fs(w){const{inputs:x,backend:m,attrs:I}=w,{dy:D,input:R}=x,B=R,{filterSize:k,strides:U,pad:F,dimRoundingMode:V}=I,it=e.backend_util.computePool3DInfo(B.shape,k,U,[1,1,1],F,V),mt=new ws(it);return m.runWebGLProgram(mt,[D],B.dtype)}},os={kernelName:e.ROF,backendName:"webgl",kernelFunc:function Vs(w){const{inputs:x,backend:m,attrs:I}=w,{dy:D,input:R}=x,B=R;(0,Nt.assertNotComplex)([D,R],"avgPoolGrad");const{filterSize:k,strides:U,pad:F}=I,V=e.backend_util.computePool2DInfo(B.shape,k,U,1,F),st=new ks(V);return m.runWebGLProgram(st,[D],B.dtype)}},zs={kernelName:e.XLW,backendName:"webgl",kernelFunc:function ps(w){const{inputs:x,backend:m,attrs:I}=w,{a:D,b:R}=x,{transposeA:B,transposeB:k}=I;return Jt({a:D,b:R,transposeA:B,transposeB:k,backend:m})}};class Gs{constructor(x,m,I,D,R,B){this.outputShape=[],this.variableNames=["x","mean","variance"],e.backend_util.assertAndGetBroadcastShape(x,m),e.backend_util.assertAndGetBroadcastShape(x,I);let k="0.0";null!=D&&(e.backend_util.assertAndGetBroadcastShape(x,D),this.variableNames.push("offset"),k="getOffsetAtOutCoords()");let U="1.0";null!=R&&(e.backend_util.assertAndGetBroadcastShape(x,R),this.variableNames.push("scale"),U="getScaleAtOutCoords()"),this.outputShape=x,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${k};\n        float scale = ${U};\n        float inv = scale * inversesqrt(variance + float(${B}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Fn{constructor(x,m,I,D,R,B){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],e.backend_util.assertAndGetBroadcastShape(x,m),e.backend_util.assertAndGetBroadcastShape(x,I);let k="vec4(0.0)";null!=D&&(e.backend_util.assertAndGetBroadcastShape(x,D),this.variableNames.push("offset"),k="getOffsetAtOutCoords()");let U="vec4(1.0)";null!=R&&(e.backend_util.assertAndGetBroadcastShape(x,R),this.variableNames.push("scale"),U="getScaleAtOutCoords()"),this.outputShape=x,this.userCode=`\n      void main() {\n        vec4 offset = ${k};\n        vec4 scale = ${U};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${B}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const js={kernelName:e.sHE,backendName:"webgl",kernelFunc:({inputs:w,backend:x,attrs:m})=>{const{x:I,mean:D,variance:R,offset:B,scale:k}=w;e.D5U.assert(D.shape.length===R.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),e.D5U.assert(null==B||D.shape.length===B.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),e.D5U.assert(null==k||D.shape.length===k.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:U}=m;null==U&&(U=.001);const F=[I,D,R];let V=null;null!=B&&(V=B.shape,F.push(B));let st=null;null!=k&&(st=k.shape,F.push(k));const it=(0,e.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new Fn(I.shape,D.shape,R.shape,V,st,U):new Gs(I.shape,D.shape,R.shape,V,st,U);return x.runWebGLProgram(it,F,F[0].dtype)}};class Xs{constructor(x){this.variableNames=["source"],this.outputShape=x,this.rank=x.length;const m=(0,f.kW)(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const I=function Ys(w){if(1===w)return"sourceLoc";if(w<=6)return rs.slice(0,w).map(x=>"sourceLoc."+x).join(",");throw Error(`Slicing for rank ${w} is not yet supported`)}(this.rank);let D;D=`\n        ${m} sourceLoc;\n        ${m} coords = getOutputCoords();\n        ${x.map((B,k)=>`sourceLoc.${rs[k]} = start[${k}] + coords.${rs[k]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${D}\n        setOutput(getSource(${I}));\n      }\n    `}}const rs=["x","y","z","w","u","v"];class Zs{constructor(x){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=x,this.rank=x.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const m=(0,f.kW)(this.rank),I=(0,i.Ky)("coords",this.rank),D=(0,i.Ky)("sourceLoc",this.rank),R=1===this.rank?"sourceLoc":`vec2(${D.slice(-2).join()})`,B=`getChannel(getSource(${D.join()}), ${R})`,k=`\n      result.x = ${B};\n      if (++${I[this.rank-1]} < ${x[this.rank-1]}) {\n        ++${D[this.rank-1]};\n        result.y = ${B};\n        --${D[this.rank-1]};\n      }\n    `,U=1===this.rank?"":`\n      --${I[this.rank-1]};\n      if (++${I[this.rank-2]} < ${x[this.rank-2]}) {\n        ++${D[this.rank-2]};\n        result.z = ${B};\n        if (++${I[this.rank-1]} < ${x[this.rank-1]}) {\n          ++${D[this.rank-1]};\n          result.w = ${B};\n        }\n      }\n    `,F=this.rank<=4?`sourceLoc = coords +\n            ${m}(${x.map((V,st)=>`start[${st}]`).join()});`:x.map((V,st)=>`${D[st]} = ${I[st]} + start[${st}];`).join("\n");this.userCode=`\n      void main() {\n        ${m} coords = getOutputCoords();\n        ${m} sourceLoc;\n        ${F}\n        vec4 result = vec4(0.);\n        ${k}\n        ${U}\n        setOutput(result);\n      }\n    `}}function Kn(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{begin:R,size:B}=I,[k,U]=e.kuN.parseSliceParams(D,R,B);if(e.kuN.assertParamsValid(D,k,U),0===e.D5U.sizeFromShape(U))return m.makeTensorInfo(U,D.dtype,[]);if(m.shouldExecuteOnCPU([D])||"string"===D.dtype){const st=m.texData.get(D.dataId),it=(0,Y.nT)(st.values,k,U,D.shape,D.dtype);return m.makeTensorInfo(U,D.dtype,it)}const{isPacked:F}=m.texData.get(D.dataId),V=e.kuN.isSliceContinous(D.shape,k,U);if(F||!V){const st=(0,e.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Zs(U):new Xs(U);return m.runWebGLProgram(st,[D],D.dtype,[k])}return m.uploadToGPU(D.dataId),function Qs(w,x,m,I){const D=I.texData.get(w.dataId),R=I.makeTensorInfo(m,w.dtype),B=I.texData.get(R.dataId);Object.assign(B,D),B.refCount=1,B.shape=m,B.dtype=w.dtype;let k=e.kuN.computeFlatOffset(x,e.D5U.computeStrides(w.shape));D.slice&&(k+=D.slice.flatOffset),B.slice={flatOffset:k,origDataId:D.slice&&D.slice.origDataId||w.dataId};const U=I.dataRefCount.get(B.slice.origDataId)||1;return I.dataRefCount.set(B.slice.origDataId,U+1),R}(D,k,U,m)}const wt={kernelName:e.p2w,backendName:"webgl",kernelFunc:Kn},Ge={kernelName:e.zws,backendName:"webgl",kernelFunc:w=>{const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{blockShape:R,crops:B}=I;e.D5U.assert(D.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const k=R.reduce((Ft,De)=>Ft*De),U=e.backend_util.getReshaped(D.shape,R,k),F=e.backend_util.getPermuted(U.length,R.length),V=e.backend_util.getReshapedPermuted(D.shape,R,k),st=e.backend_util.getSliceBeginCoords(B,R.length),it=e.backend_util.getSliceSize(V,B,R.length),mt=[],_t=Gt({inputs:{x:D},backend:m,attrs:{shape:U}}),Rt=dt({inputs:{x:_t},backend:m,attrs:{perm:F}}),$t=Gt({inputs:{x:Rt},backend:m,attrs:{shape:V}}),Mt=Kn({inputs:{x:$t},backend:m,attrs:{begin:st,size:it}});return mt.push(_t),mt.push(Rt),mt.push($t),mt.forEach(Ft=>m.disposeIntermediateTensorInfo(Ft)),Mt}},En={kernelName:e.zvY,backendName:"webgl",kernelFunc:function nn(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,weights:R}=x,{size:B}=I,k=m.readSync(D.dataId),U=m.readSync(R.dataId),F=(0,Y.qO)(k,U,R.dtype,R.shape,B);return m.makeTensorInfo([B],R.dtype,F)}},Ao={kernelName:e.hCO,backendName:"webgl",kernelFunc:function fs(w){const{inputs:x,backend:m}=w,{a:I,b:D}=x,R=(0,e.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),B=(0,e.OBj)().getNumber("WEBGL_VERSION");if(m.shouldExecuteOnCPU([I,D])||1===B){const U=m.texData.get(I.dataId).values,F=m.texData.get(D.dataId).values,[V,st]=(0,Y.XM)(I.shape,D.shape,U,F,I.dtype),it=m.makeTensorInfo(st,I.dtype);return m.texData.get(it.dataId).values=V,it}let k;return k=R?new s("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",I.shape,D.shape,!1):new h("\n  return float(int(a.r) & int(b.r));\n",I.shape,D.shape),m.runWebGLProgram(k,[I,D],I.dtype)}},So={kernelName:e.eEB,backendName:"webgl",kernelFunc:function ho(w){const{inputs:x,backend:m}=w,{s0:I,s1:D}=x,R=m.readSync(I.dataId),B=m.readSync(D.dataId),k=e.backend_util.assertAndGetBroadcastShape(Array.from(R),Array.from(B));return m.makeTensorInfo([k.length],"int32",Int32Array.from(k))}},po=W({opSnippet:"return float(a != b);",cpuKernelImpl:Y.cZ,dtype:"bool"}),bo={kernelName:e.yQU,backendName:"webgl",kernelFunc:po};function as(w){const{inputs:x,backend:m}=w,{input:I}=x;return r({inputs:{x:m.texData.get(I.dataId).complexTensorInfos.real},backend:m})}const $o={kernelName:e.xJR,backendName:"webgl",kernelFunc:as},gs={kernelName:e.RFZ,backendName:"webgl",kernelFunc:function ms(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{dtype:R}=I;if("complex64"===R){if("complex64"===D.dtype)return r({inputs:{x:D},backend:m});const B=e.lls(D.shape),k=ms({inputs:{x:D},backend:m,attrs:{dtype:"float32"}}),U=p({inputs:{real:k,imag:B},backend:m});return B.dispose(),m.disposeIntermediateTensorInfo(k),U}if("complex64"===D.dtype){const B=as({inputs:{input:D},backend:m}),k=ms({inputs:{x:B},backend:m,attrs:{dtype:R}});return m.disposeIntermediateTensorInfo(B),k}if(!e.D5U.hasEncodingLoss(D.dtype,R)){const B=r({inputs:{x:D},backend:m});return{dataId:B.dataId,shape:B.shape,dtype:R}}if(m.shouldExecuteOnCPU([D])){const B=m.texData.get(D.dataId).values,[k,U,F]=(0,Y.cm)(B,D.shape,D.dtype,R);return m.makeTensorInfo(k,U,F)}if("int32"===R)return function Lo(w,x){const m=new O.l(w.shape,"return float(int(x));"),I=x.runWebGLProgram(m,[w],"int32");return{dataId:I.dataId,shape:I.shape,dtype:I.dtype}}(D,m);if("bool"===R){const B=m.makeTensorInfo([],"bool",e.D5U.getTypedArrayFromDType("bool",1)),U=po({inputs:{a:D,b:B},backend:m});return m.disposeIntermediateTensorInfo(B),U}throw new Error(`Error in Cast: failed to cast ${D.dtype} to ${R}`)}},fo="return ceil(x);",No=$({opSnippet:fo,packedOpSnippet:fo,cpuKernelImpl:Y.pk}),Uo={kernelName:e.gJX,backendName:"webgl",kernelFunc:No};class qs{constructor(x){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=x,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class _s{constructor(x){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=x,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const mo={kernelName:e.xnO,backendName:"webgl",kernelFunc:function to(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{clipValueMin:R,clipValueMax:B}=I;let k;return k=(0,e.OBj)().getBool("WEBGL_PACK_CLIP")?new _s(D.shape):new qs(D.shape),m.runWebGLProgram(k,[D],D.dtype,[[R],[B]])}};class Wo{constructor(x){this.variableNames=["real","imag"],this.outputShape=x,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function eo(w,x){return{dataId:x.dataId,dtype:x.dtype,shape:w.shape}}const ko={kernelName:e.yj2,backendName:"webgl",kernelFunc:function no(w){const{inputs:x,backend:m}=w,{x:I}=x,D=m.texData.get(I.dataId),R=new Wo(I.shape),B=[eo(I,D.complexTensorInfos.real),eo(I,D.complexTensorInfos.imag)];return m.runWebGLProgram(R,B,B[0].dtype)}};class wo{constructor(x){this.outputShape=[],this.outputShape=e.backend_util.computeOutShape(x,1),this.variableNames=x.map((B,k)=>`T${k}`);const m=new Array(x.length-1);m[0]=x[0][1];for(let B=1;B<m.length;B++)m[B]=m[B-1]+x[B][1];const I=[`if (yC < ${m[0]}) setOutput(getT0(yR, yC));`];for(let B=1;B<m.length;B++)I.push(`else if (yC < ${m[B]}) setOutput(getT${B}(yR, yC-${m[B-1]}));`);I.push(`else setOutput(getT${m.length}(yR, yC-${m[m.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${I.join("\n        ")}\n      }\n    `}}class Fo{constructor(x,m){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=e.backend_util.computeOutShape(x,m);const I=this.outputShape,D=I.length,R=(0,f.kW)(D),B=(0,i.Ky)("coords",D),k=["x","y","z","w","u","v"].slice(0,D);this.variableNames=x.map((Rt,$t)=>`T${$t}`);const U=new Array(x.length-1);U[0]=x[0][m];for(let Rt=1;Rt<U.length;Rt++)U[Rt]=U[Rt-1]+x[Rt][m];const F=k[m],V=k.slice(-2),st=k.join();let it=`if (${F} < ${U[0]}) {\n        return getChannel(\n            getT0(${st}), vec2(${V.join()}));\n        }`;for(let Rt=1;Rt<U.length;Rt++){const $t=U[Rt-1];it+=`\n        if (${F} < ${U[Rt]}  && ${F} >= ${U[Rt-1]}) {\n          return getChannel(\n            getT${Rt}(${Zn(k,F,$t)}),\n            vec2(${Zn(V,F,$t)}));\n        }`}const _t=U[U.length-1];it+=`\n        return getChannel(\n          getT${U.length}(${Zn(k,F,_t)}),\n          vec2(${Zn(V,F,_t)}));`,this.userCode=`\n      float getValue(${k.map(Rt=>"int "+Rt)}) {\n        ${it}\n      }\n\n      void main() {\n        ${R} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${B}), 0., 0., 0.);\n\n        ${B[D-1]} = ${B[D-1]} + 1;\n        if (${B[D-1]} < ${I[D-1]}) {\n          result.g = getValue(${B});\n        }\n\n        ${B[D-2]} = ${B[D-2]} + 1;\n        if (${B[D-2]} < ${I[D-2]}) {\n          result.a = getValue(${B});\n        }\n\n        ${B[D-1]} = ${B[D-1]} - 1;\n        if (${B[D-2]} < ${I[D-2]} &&\n            ${B[D-1]} < ${I[D-1]}) {\n          result.b = getValue(${B});\n        }\n        setOutput(result);\n      }\n    `}}function Zn(w,x,m){const I=w.indexOf(x);return w.map((R,B)=>B===I?`${R} - ${m}`:R).join()}function Es(w){const{inputs:x,backend:m}=w,{input:I}=x;return r({inputs:{x:m.texData.get(I.dataId).complexTensorInfos.imag},backend:m})}const Ko={kernelName:e.J_u,backendName:"webgl",kernelFunc:Es};function is(w,x,m){const I=w[0].dtype;if("complex64"===I){const mt=w.map(Ft=>as({inputs:{input:Ft},backend:m})),_t=w.map(Ft=>Es({inputs:{input:Ft},backend:m})),Rt=is(mt,x,m),$t=is(_t,x,m),Mt=p({inputs:{real:Rt,imag:$t},backend:m});return mt.forEach(Ft=>m.disposeIntermediateTensorInfo(Ft)),_t.forEach(Ft=>m.disposeIntermediateTensorInfo(Ft)),m.disposeIntermediateTensorInfo(Rt),m.disposeIntermediateTensorInfo($t),Mt}let D=m.shouldExecuteOnCPU(w);if("string"===I&&(D=!0),D){const mt=w.map(he=>{const Ye=[-1,e.D5U.sizeFromShape(he.shape.slice(x))];return Gt({inputs:{x:he},backend:m,attrs:{shape:Ye}})}),_t=mt.map(he=>({vals:m.readSync(he.dataId),shape:he.shape})),Rt=e.backend_util.computeOutShape(mt.map(he=>he.shape),1),Mt=(0,Y.n7)(_t,Rt,I,1===mt[0].shape[0]),Ft=e.backend_util.computeOutShape(w.map(he=>he.shape),x),De=m.makeTensorInfo(Ft,I,Mt);return mt.forEach(he=>m.disposeIntermediateTensorInfo(he)),De}const R=w.filter(mt=>e.D5U.sizeFromShape(mt.shape)>0),B=(0,e.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&R[0].shape.length>1;if(1===R.length){const mt=B?new O.l(w[0].shape,O.bl):new b.cc(w[0].shape,O.bl);return m.runWebGLProgram(mt,w,I)}const k=(0,e.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(R.length>k){const mt=[];for(let Rt=0;Rt<R.length;Rt+=k){const $t=R.slice(Rt,Rt+k);mt.push(is($t,x,m))}const _t=is(mt,x,m);for(const Rt of mt)m.disposeIntermediateTensorInfo(Rt);return _t}if(B){const mt=new Fo(R.map(_t=>_t.shape),x);return m.runWebGLProgram(mt,R,I)}const{tensors2D:U,outShape:F}=function Vo(w,x,m){const I=e.backend_util.computeOutShape(w.map(R=>R.shape),x);return{tensors2D:w.map(R=>Gt({inputs:{x:R},attrs:{shape:[-1,e.D5U.sizeFromShape(R.shape.slice(x))]},backend:m})),outShape:I}}(R,x,m),V=new wo(U.map(mt=>mt.shape)),st=m.runWebGLProgram(V,U,I);U.forEach(mt=>m.disposeIntermediateTensorInfo(mt));const it=Gt({inputs:{x:st},attrs:{shape:F},backend:m});return m.disposeIntermediateTensorInfo(st),it}function go(w){const{inputs:x,backend:m,attrs:I}=w,{axis:D}=I,R=e.D5U.parseAxisParam(D,x[0].shape)[0],B=x.map(F=>F.shape);e.backend_util.assertParamsConsistent(B,R);const k=e.backend_util.computeOutShape(x.map(F=>F.shape),R);if(0===e.D5U.sizeFromShape(k))return m.makeTensorInfo(k,x[0].dtype,[]);const U=x.filter(F=>e.D5U.sizeFromShape(F.shape)>0);return 1===U.length?r({inputs:{x:U[0]},backend:m}):is(U,R,m)}const _o={kernelName:e.Eh3,backendName:"webgl",kernelFunc:go};class Eo{constructor(x,m=!1,I=null,D=!1,R=!1){this.variableNames=["x","W"],this.outputShape=x.outShape;const B=x.padInfo.top,k=x.padInfo.left,U=x.strideHeight,F=x.strideWidth,V=x.dilationHeight,st=x.dilationWidth,it=x.filterHeight,mt=x.filterWidth,_t=4*Math.floor(x.inChannels/4),Rt=x.inChannels%4,$t="channelsLast"===x.dataFormat,Mt=$t?1:2,Ft=$t?2:3,De=$t?3:1;let he="",Ne="";I&&(he=D?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${I}\n        }`:R?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${I}\n        }`:`\n          float activation(float x) {\n            ${I}\n          }\n        `,Ne="result = activation(result);");const Ye=m?"result += getBiasAtOutCoords();":"";m&&this.variableNames.push("bias"),D&&this.variableNames.push("preluActivationWeights"),R&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${he}\n\n      const ivec2 strides = ivec2(${U}, ${F});\n      const ivec2 pads = ivec2(${B}, ${k});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${De}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${Mt}], coords[${Ft}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${it}; wR++) {\n          int xR = xRCorner + wR * ${V};\n\n          if (xR < 0 || xR >= ${x.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${mt}; wC++) {\n            int xC = xCCorner + wC * ${st};\n\n            if (xC < 0 || xC >= ${x.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${_t}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${$t}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===Rt}) {\n\n              if (${$t}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${_t}) *\n                    getW(wR, wC, ${_t}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${_t}, xR, xC) *\n                    getW(wR, wC, ${_t}, d2);\n              }\n\n            } else if (${2===Rt}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${_t}, d2),\n                getW(wR, wC, ${_t} + 1, d2)\n              );\n\n              if (${$t}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${_t}),\n                  getX(batch, xR, xC, ${_t} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${_t}, xR, xC),\n                  getX(batch, ${_t} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===Rt}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${_t}, d2),\n                getW(wR, wC, ${_t} + 1, d2),\n                getW(wR, wC, ${_t} + 2, d2)\n              );\n\n              if (${$t}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${_t}),\n                  getX(batch, xR, xC, ${_t} + 1),\n                  getX(batch, xR, xC, ${_t} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${_t}, xR, xC),\n                  getX(batch, ${_t} + 1, xR, xC),\n                  getX(batch, ${_t} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${Ye}\n        ${Ne}\n        setOutput(result);\n      }\n    `}}class xo{constructor(x){this.variableNames=["x","W"],this.outputShape=x.outShape;const m=x.padInfo.front,I=x.padInfo.top,D=x.padInfo.left,R=x.strideDepth,B=x.strideHeight,k=x.strideWidth,U=x.dilationDepth,F=x.dilationHeight,V=x.dilationWidth,st=x.filterDepth,it=x.filterHeight,mt=x.filterWidth,_t=4*Math.floor(x.inChannels/4),Rt=x.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${R}, ${B}, ${k});\n      const ivec3 pads = ivec3(${m}, ${I}, ${D});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${st}; wF++) {\n          int xF = xFCorner + wF * ${U};\n\n          if (xF < 0 || xF >= ${x.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${it}; wR++) {\n            int xR = xRCorner + wR * ${F};\n\n            if (xR < 0 || xR >= ${x.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${mt}; wC++) {\n              int xC = xCCorner + wC * ${V};\n\n              if (xC < 0 || xC >= ${x.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${_t}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===Rt}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${_t}) *\n                  getW(wF, wR, wC, ${_t}, d2);\n              } else if (${2===Rt}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${_t}),\n                  getX(batch, xF, xR, xC, ${_t} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${_t}, d2),\n                  getW(wF, wR, wC, ${_t} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===Rt}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${_t}),\n                  getX(batch, xF, xR, xC, ${_t} + 1),\n                  getX(batch, xF, xR, xC, ${_t} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${_t}, d2),\n                  getW(wF, wR, wC, ${_t} + 1, d2),\n                  getW(wF, wR, wC, ${_t} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Do{constructor(x,m=!1,I=null,D=!1,R=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=x.outShape,this.enableShapeUniforms=(0,a.C9)(this.outputShape.length);const B=x.padInfo.left,k=x.strideWidth,U=x.dilationWidth,F=x.filterHeight,V=x.filterWidth,st=V;let it="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let $t=0;$t<V;$t++)it+=`\n           vec4 xTexelC${2*$t};\n           int xTexelC${2*$t}Ready;\n           vec4 xTexelC${2*$t+1};\n           int xTexelC${2*$t+1}Ready;\n           vec4 xC${$t};`;it+=`\n     for (int r = 0; r < ${F}; r++) {\n      for (int d1 = 0; d1 < ${x.inChannels}; d1 += 2) {\n       `;for(let $t=0;$t<V;$t++)it+=`\n           xTexelC${2*$t} = vec4(0.0);\n           xTexelC${2*$t}Ready = 0;\n           xTexelC${2*$t+1} = vec4(0.0);\n           xTexelC${2*$t+1}Ready = 0;\n           xC${$t} = vec4(0.0);`;it+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let $t=0;$t<(st+1)/2;$t++){const Mt=2*$t;if(it+=`\n           xC = xCCorner + ${Mt*U};\n           `,1===k){if(Mt<V&&(B%2==1?(it+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Mt}Ready == 0) {\n                   xTexelC${Mt} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${Mt}.zw = vec2(0.0);\n                   }\n                   xTexelC${Mt}Ready = 1;\n                 }\n               `,it+=1===U&&Mt>0?`\n                 xC${Mt} = vec4(xTexelC${Mt-2}.zw, xTexelC${Mt}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${Mt} = vec4(previous.zw, xTexelC${Mt}.xy);\n                   } else {\n                     xC${Mt} = vec4(0.0, 0.0, xTexelC${Mt}.xy);\n                   }\n                   `):it+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${Mt}Ready == 0) {\n                   xTexelC${Mt} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${Mt}.zw = vec2(0.0);\n                   }\n                   xTexelC${Mt}Ready = 1;\n                 }\n\n                 xC${Mt} = xTexelC${Mt};\n                 `,Mt+1<V)){const Ft=B%2==0?e.D5U.nearestLargerEven(U):U;U%2==0&&B%2==1||U%2!=0&&B%2!=1?(it+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${Ft};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Mt+1}Ready == 0) {\n                     xTexelC${Mt+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${Mt+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${Mt+1}Ready = 1;\n                   }\n                   `,it+=U>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${Mt+1} = vec4(previous.zw, xTexelC${Mt+1}.xy);\n                     } else {\n                      xC${Mt+1} = vec4(0.0, 0.0, xTexelC${Mt+1}.xy);\n                     }\n                     `:`\n                     xC${Mt+1} = vec4(xTexelC${Mt}.zw, xTexelC${Mt+1}.xy);\n                     `):it+=1===Ft?`\n                     xC${Mt+1} = xTexelC${Mt};\n                     `:`\n                     xCOffset = xC + ${Ft};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Mt+1}Ready == 0) {\n                       xTexelC${Mt+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${Mt+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${Mt+1}Ready = 1;\n                     }\n\n                     xC${Mt+1} = xTexelC${Mt+1};\n                     `}}else Mt<V&&(B%2==1?(it+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Mt}Ready == 0) {\n                   xTexelC${Mt} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${Mt}.zw = vec2(0.0);\n                   }\n                   xTexelC${Mt}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${Mt+1}Ready == 0) {\n                   xTexelC${Mt+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${Mt+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${Mt+1}Ready = 1;\n                 }\n\n                 xC${Mt} = vec4(xTexelC${Mt}.zw, xTexelC${Mt+1}.zw);\n               `,Mt+1<V&&(it+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${Mt+1} = vec4(xTexelC${Mt+1}.xy, final.xy);\n                 `)):(it+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${Mt}Ready == 0) {\n                   xTexelC${Mt} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${Mt}.zw = vec2(0.0);\n                   }\n                   xTexelC${Mt}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Mt+1}Ready == 0) {\n                   xTexelC${Mt+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${Mt+1}.zw = vec2(0.);\n                   }\n                   xTexelC${Mt+1}Ready = 1;\n                 }\n\n                 xC${Mt} = vec4(\n                   xTexelC${Mt}.xy, xTexelC${Mt+1}.xy);\n               `,Mt+1<V&&(it+=`\n                   xC${Mt+1} = vec4(xTexelC${Mt}.zw, xTexelC${Mt+1}.zw);\n                 `)));Mt<V&&(it+=`\n             wTexel = getW(r, ${Mt}, d1, d2);\n             dotProd += xC${Mt}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${x.inChannels}) {\n               dotProd += xC${Mt}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,Mt+1<V&&(it+=`\n               wTexel = getW(r, ${Mt+1}, d1, d2);\n               dotProd += xC${Mt+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${x.inChannels}) {\n                 dotProd += xC${Mt+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}it+="\n     }\n   ",it+="\n     }\n   ",it+="\n     }\n   ";let mt="",_t="";I&&(mt=D?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${I}\n         }`:R?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${I}\n         }`:`vec4 activation(vec4 x) {\n           ${I}\n         }`,_t="result = activation(result);");const Rt=m?"result += getBiasAtOutCoords();":"";m&&this.variableNames.push("bias"),D&&this.variableNames.push("preluActivationWeights"),R&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${mt}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${it}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${Rt}\n         ${_t}\n         setOutput(result);\n       }\n     `}}var so=t(99100);class zo{constructor(x,m){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=x,this.enableShapeUniforms=(0,a.C9)(this.outputShape.length);const{dataFormat:I}=m,D=(0,so.A)(),R="channelsLast"===I,B=R?1:2,k=R?2:3,U=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${x[2]} && pos < ${x[1]}) {`;let F="";for(let V=0;V<=1;V++)for(let st=0;st<=1;st++)F+=`\n          blockIndex = rc.z + ${st};\n          pos = rc.y + ${V};\n\n          ${U}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${B}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${k}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${R}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*V+st}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*V+st}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${F}\n\n        ${D.output} = result;\n      }\n    `}}function xs(w,x){const m=w.length;return m>=3?x?[...w.slice(0,-3),w[m-3]*w[m-2],w[m-1]]:[...w.slice(0,-3),w[m-3],w[m-2]*w[m-1]]:!x&&1===m&&w[0]>1?[w[0],1]:null}function vo({x:w,filter:x,convInfo:m,backend:I,bias:D=null,preluActivationWeights:R=null,leakyreluAlpha:B=0,activation:k=null}){const U=w.shape,F=I.texData.get(w.dataId),V=m.inChannels,st=U[0]*U[1]*U[2],it=m.outChannels,mt="channelsLast"===m.dataFormat;let $t;const Mt=[];if(null!=R){const he=xs(R.shape,mt);null!=he&&(R=Gt({inputs:{x:R},backend:I,attrs:{shape:he}}),Mt.push(R))}if(null!=D){const he=xs(D.shape,mt);null!=he&&(D=Gt({inputs:{x:D},backend:I,attrs:{shape:he}}),Mt.push(D))}if((1!==st&&1!==it||!(V>1e3))&&F.isPacked&&mt&&null!=F.texture&&U[2]%2!=0&&e.D5U.arraysEqual(F.shape.slice(-3),U.slice(-3))){const Ne={dataId:w.dataId,shape:[1,U[0]*U[1]*(U[2]+1),m.inChannels],dtype:w.dtype},Ye=F.shape;F.shape=F.shape.slice(),F.shape[F.shape.length-2]++,e.D5U.assert(Nt.isReshapeFree(F.shape,Ne.shape),()=>`packed reshape ${F.shape} to ${Ne.shape} isn't free`);const je=Gt({inputs:{x},backend:I,attrs:{shape:[1,m.inChannels,m.outChannels]}});Mt.push(je);const Fe=Jt({a:Ne,b:je,backend:I,transposeA:!1,transposeB:!1,bias:D,activation:k,preluActivationWeights:R,leakyreluAlpha:B}),sn=I.texData.get(Fe.dataId);e.D5U.assert(sn.isPacked,()=>"batchMatMul result is expected to be packed"),F.shape=Ye,sn.shape=m.outShape,$t=r({inputs:{x:Fe},backend:I}),$t.shape=m.outShape,Mt.push(Fe)}else{const he=m.outHeight*m.outWidth,Ne=Gt({inputs:{x:w},backend:I,attrs:{shape:mt?[m.batchSize,he,m.inChannels]:[m.batchSize,m.inChannels,he]}}),Ye=Gt({inputs:{x},backend:I,attrs:{shape:[1,m.inChannels,m.outChannels]}}),je=Jt({a:mt?Ne:Ye,b:mt?Ye:Ne,transposeA:!mt,transposeB:!1,backend:I,bias:D,activation:k,preluActivationWeights:R,leakyreluAlpha:B});$t=Gt({inputs:{x:je},backend:I,attrs:{shape:m.outShape}}),Mt.push(Ne),Mt.push(Ye),Mt.push(je)}for(const he of Mt)I.disposeIntermediateTensorInfo(he);return $t}function Co({x:w,filter:x,convInfo:m,backend:I,bias:D=null,preluActivationWeights:R=null,leakyreluAlpha:B=0,activation:k=null}){const{filterWidth:U,filterHeight:F,inChannels:V,outWidth:st,outHeight:it,dataFormat:mt}=m,_t="channelsLast"===mt,Rt=U*F*V,$t=it*st,Mt=[m.batchSize,Rt,$t],he=[];if(null!=R){const bn=xs(R.shape,_t);null!=bn&&(R=Gt({inputs:{x:R},backend:I,attrs:{shape:bn}}),he.push(R))}if(null!=D){const bn=xs(D.shape,_t);null!=bn&&(D=Gt({inputs:{x:D},backend:I,attrs:{shape:bn}}),he.push(D))}const Ne=Gt({inputs:{x},backend:I,attrs:{shape:[1,Rt,e.D5U.sizeFromShape(x.shape)/Rt]}});he.push(Ne);const Ye=new zo(Mt,m),Fe=I.runWebGLProgram(Ye,[w],"float32",[w.shape,[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inChannels],[m.filterWidth*m.inChannels],[m.outWidth]]),sn=Gt({inputs:{x:Fe},backend:I,attrs:{shape:Mt}});he.push(Fe),he.push(sn);const Qe=null!=D,Cn=null!=R,In="leakyrelu"===k,es=k?Z(k,!0):null,Nn=new X(_t?sn.shape:Ne.shape,_t?Ne.shape:sn.shape,_t?[m.batchSize,$t,m.outChannels]:[m.batchSize,m.outChannels,$t],!0,!1,Qe,es,Cn,In),Wn=_t?[sn,Ne]:[Ne,sn];if(D&&Wn.push(D),Cn&&Wn.push(R),In){const bn=I.makeTensorInfo([],"float32",e.D5U.createScalarValue(B,"float32"));Wn.push(bn),he.push(bn)}const zn=I.runWebGLProgram(Nn,Wn,"float32"),Xn=Gt({inputs:{x:zn},backend:I,attrs:{shape:m.outShape}});he.push(zn);for(const bn of he)I.disposeIntermediateTensorInfo(bn);return Xn}const Ho={kernelName:e.mhS,backendName:"webgl",kernelFunc:function Go(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,filter:R}=x,{strides:B,pad:k,dataFormat:U,dilations:F,dimRoundingMode:V}=I,st=e.backend_util.convertConv2DDataFormat(U),it=e.backend_util.computeConv2DInfo(D.shape,R.shape,B,F,k,V,!1,st);let mt;if(1!==it.filterHeight||1!==it.filterWidth||1!==it.dilationHeight||1!==it.dilationWidth||1!==it.strideHeight||1!==it.strideWidth||"SAME"!==it.padInfo.type&&"VALID"!==it.padInfo.type)if(it.strideWidth<=2&&"channelsLast"===st&&(0,e.OBj)().getBool("WEBGL_EXP_CONV")){const Rt=new Do(it);mt=m.runWebGLProgram(Rt,[D,R],"float32",[[it.padInfo.top,it.padInfo.left],[it.strideHeight,it.strideWidth],[it.dilationHeight,it.dilationWidth],[it.inHeight,it.inWidth]])}else if((0,e.OBj)().getBool("WEBGL_CONV_IM2COL"))mt=Co({x:D,filter:R,convInfo:it,backend:m});else{const Rt=new Eo(it);mt=m.runWebGLProgram(Rt,[D,R],"float32")}else mt=vo({x:D,filter:R,convInfo:it,backend:m});const _t=Gt({inputs:{x:mt},backend:m,attrs:{shape:it.outShape}});return m.disposeIntermediateTensorInfo(mt),_t}};class jo{constructor(x){this.variableNames=["x","dy"],this.outputShape=x.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${x.batchSize}; b++) {\n          for (int yR = 0; yR < ${x.outHeight}; yR++) {\n            int xR = wR + yR * ${x.strideHeight} - ${x.padInfo.top};\n\n            if (xR < 0 || xR >= ${x.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${x.outWidth}; yC++) {\n              int xC = wC + yC * ${x.strideWidth} - ${x.padInfo.left};\n\n              if (xC < 0 || xC >= ${x.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===x.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Xo{constructor(x){this.variableNames=["dy","W"],this.outputShape=x.inShape;const m=x.filterHeight,I=x.filterWidth,B="channelsLast"===x.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${m-1-x.padInfo.top}, ${I-1-x.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${B?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${B?1:2}], coords[${B?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${m}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${x.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${x.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${m} - 1 - wR;\n\n          for (int wC = 0; wC < ${I}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${x.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${x.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${I} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${x.outChannels}; d2++) {\n\n              if (${B}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Yo{constructor(x){this.variableNames=["x","dy"],this.outputShape=x.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${x.batchSize}; b++) {\n          for (int yF = 0; yF < ${x.outDepth}; yF++) {\n            int xF = wF + yF * ${x.strideDepth} - ${x.padInfo.front};\n\n            if (xF < 0 || xF >= ${x.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${x.outHeight}; yR++) {\n              int xR = wR + yR * ${x.strideHeight} - ${x.padInfo.top};\n\n              if (xR < 0 || xR >= ${x.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${x.outWidth}; yC++) {\n                int xC = wC + yC * ${x.strideWidth} - ${x.padInfo.left};\n\n                if (xC < 0 || xC >= ${x.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Zo{constructor(x){this.variableNames=["dy","W"],this.outputShape=x.inShape;const m=x.filterDepth,I=x.filterHeight,D=x.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${m-1-x.padInfo.front}, ${I-1-x.padInfo.top}, ${D-1-x.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${m}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${x.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${x.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${m} - 1 - wF;\n\n          for (int wR = 0; wR < ${I}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${x.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${x.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${I} - 1 - wR;\n\n            for (int wC = 0; wC < ${D}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${x.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${x.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${D} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${x.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Jo={kernelName:e.wUP,backendName:"webgl",kernelFunc:function Qo(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,dy:R}=x,{strides:B,pad:k,dataFormat:U,dimRoundingMode:F,filterShape:V}=I,st=e.backend_util.convertConv2DDataFormat(U),it=e.backend_util.computeConv2DInfo(D.shape,V,B,1,k,F,!1,st),mt=new jo(it);return m.runWebGLProgram(mt,[D,R],"float32")}};class qo{constructor(x){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=x.inShape,this.enableShapeUniforms=(0,a.C9)(this.outputShape.length);const m=x.filterHeight,I=x.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${m-1-x.padInfo.top}, ${I-1-x.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${m}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${x.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${m} - 1 - wR;\n\n          for (int wC = 0; wC < ${I}; wC++) {\n            int wCPerm = ${I} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${x.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${x.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${x.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${x.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${x.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const er={kernelName:e.wm,backendName:"webgl",kernelFunc:function tr(w){const{inputs:x,backend:m,attrs:I}=w,{dy:D,filter:R}=x,{inputShape:B,strides:k,pad:U,dataFormat:F,dimRoundingMode:V}=I,st=e.backend_util.convertConv2DDataFormat(F),it=e.backend_util.computeConv2DInfo(B,R.shape,k,1,U,V,!1,st);if((0,e.OBj)().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===st){const mt=[[it.strideHeight,it.strideWidth]],_t=new qo(it);return m.runWebGLProgram(_t,[D,R],"float32",mt)}{const mt=new Xo(it);return m.runWebGLProgram(mt,[D,R],"float32")}}},sr={kernelName:e.x12,backendName:"webgl",kernelFunc:function nr(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,filter:R}=x,{strides:B,pad:k,dilations:U}=I,F=e.backend_util.computeConv3DInfo(D.shape,R.shape,B,U,k),V=new xo(F);return m.runWebGLProgram(V,[D,R],"float32")}},St={kernelName:e.o2y,backendName:"webgl",kernelFunc:function gt(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,dy:R}=x,{strides:B,pad:k,filterShape:U}=I,F=e.backend_util.computeConv3DInfo(D.shape,U,B,1,k),V=new Yo(F);return m.runWebGLProgram(V,[D,R],"float32")}},yt={kernelName:e.ik2,backendName:"webgl",kernelFunc:function vt(w){const{inputs:x,backend:m,attrs:I}=w,{dy:D,filter:R}=x,{pad:B,strides:k,inputShape:U}=I,F=e.backend_util.computeConv3DInfo(U,R.shape,k,1,B),V=new Zo(F);return m.runWebGLProgram(V,[D,R],"float32")}},ne=$({opSnippet:E+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${l}\n  return result;\n`}),Ht={kernelName:e.mc4,backendName:"webgl",kernelFunc:ne},Ke=$({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Xe={kernelName:e.TR1,backendName:"webgl",kernelFunc:Ke};class an{constructor(x,m,I,D,R){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[B,k,U,F]=x,[V]=m,[st,it]=I;this.outputShape=[V,st,it,F];const mt="bilinear"===D?1:0,[_t,Rt]=[k-1+".0",U-1+".0"],[$t,Mt,Ft]=st>1?[""+(k-1)/(st-1),"(y2-y1) * height_ratio",`y1*${_t} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${_t}`],[De,he,Ne]=it>1?[""+(U-1)/(it-1),"(x2-x1) * width_ratio",`x1*${Rt} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${Rt}`];this.userCode=`\n      const float height_ratio = float(${$t});\n      const float width_ratio = float(${De});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${B}) {\n          return;\n        }\n\n        float height_scale = ${Mt};\n        float width_scale = ${he};\n\n        float in_y = ${Ft};\n        if( in_y < 0.0 || in_y > ${_t} ) {\n          setOutput(float(${R}));\n          return;\n        }\n        float in_x = ${Ne};\n        if( in_x < 0.0 || in_x > ${Rt} ) {\n          setOutput(float(${R}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${mt} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const ln={kernelName:e.VcC,backendName:"webgl",kernelFunc:w=>{const{inputs:x,backend:m,attrs:I}=w,{image:D,boxes:R,boxInd:B}=x,{cropSize:k,method:U,extrapolationValue:F}=I,V=new an(D.shape,R.shape,k,U,F);return m.runWebGLProgram(V,[D,R,B],"float32")}};var Sn=function(w){return w.Prod="*",w.Sum="+",w}(Sn||{});class Vn{constructor(x,m,I,D){this.op=x,this.outputShape=m,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const R=this.outputShape.length,k=I?this.op===Sn.Prod?"1.0":"0.0":`getX(${$n(R,"coords",this.op)})`,U=this.outputShape[this.outputShape.length-1];let F="",V="";I?(F=D?"end != "+(U-1):"end != 0",V=D?"end + 1":"end - 1"):(F=D?`end + pow2 < ${U}`:"end >= pow2",V=D?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${(0,f.kW)(R)} coords = getOutputCoords();\n        int end = ${oo(R,"coords",this.op)};\n        float val = ${k};\n        int pow2 = int(pow(2.0, index));\n        if (${F}) {\n          int idx = ${V};\n          ${oo(R,"coords",this.op)} = idx;\n          val ${this.op}= getX(${$n(R,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function $n(w,x,m){if(1===w)return`${x}`;if(2===w)return`${x}.x, ${x}.y`;if(3===w)return`${x}.x, ${x}.y, ${x}.z`;if(4===w)return`${x}.x, ${x}.y, ${x}.z, ${x}.w`;throw new Error(`Cumulative ${m} for rank ${w} is not yet supported`)}function oo(w,x,m){if(1===w)return`${x}`;if(2===w)return`${x}.y`;if(3===w)return`${x}.z`;if(4===w)return`${x}.w`;throw new Error(`Cumulative ${m} for rank ${w} is not yet supported`)}function ro(w,x,m,I,D,R){const B=x.shape.length,k=e.backend_util.getAxesPermutation([I],B);let U=x;null!=k&&(U=dt({inputs:{x},backend:m,attrs:{perm:k}}));const F=e.backend_util.getInnerMostAxes(1,B)[0];if(F!==B-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${x.shape.length-1} but got axis=${I}`);const V=U.shape[F];let st=r({inputs:{x:U},backend:m});for(let it=0;it<=Math.ceil(Math.log2(V))-1;it++){const mt=new Vn(w,U.shape,!1,R),Rt=st;st=m.runWebGLProgram(mt,[st],st.dtype,[[it]]),m.disposeIntermediateTensorInfo(Rt)}if(D){const it=new Vn(w,U.shape,D,R),mt=st;st=m.runWebGLProgram(it,[st],st.dtype),m.disposeIntermediateTensorInfo(mt)}if(null!=k){const mt=dt({inputs:{x:st},backend:m,attrs:{perm:e.backend_util.getUndoAxesPermutation(k)}});return m.disposeIntermediateTensorInfo(st),m.disposeIntermediateTensorInfo(U),mt}return st}const Dn={kernelName:e.Byc,backendName:"webgl",kernelFunc:function Io(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{axis:R,exclusive:B,reverse:k}=I;return ro(Sn.Prod,D,m,R,B,k)}},or={kernelName:e.iHb,backendName:"webgl",kernelFunc:function ls(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{axis:R,exclusive:B,reverse:k}=I;return ro(Sn.Sum,D,m,R,B,k)}},rr={kernelName:e.QRR,backendName:"webgl",kernelFunc:function Oo(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,weights:R}=x,{size:B,binaryOutput:k}=I;if(1===D.shape.length){const U=m.readSync(D.dataId),F=m.readSync(R.dataId),V=(0,Y.qO)(U,F,R.dtype,R.shape,B);return m.makeTensorInfo([B],R.dtype,V)}if(2===D.shape.length){const U=m.bufferSync(D),F=m.bufferSync(R),V=(0,Y.cx)(U,F,B,k);return m.makeTensorInfo(V.shape,R.dtype,V.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${D.shape.length}.`)}};class ao{constructor(x,m,I){this.variableNames=["x"],this.outputShape=[],this.outputShape=x,this.blockSize=m,this.dataFormat=I,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${m};\n      int offset_h = imod(h, ${m});\n      int in_w = w / ${m};\n      int offset_w = imod(w, ${m});\n      int offset_d = (offset_h * ${m} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Mr={kernelName:e.T0n,backendName:"webgl",kernelFunc:function ar(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{blockSize:R,dataFormat:B}=I,k=D.shape[0],st=("NHWC"===B?D.shape[1]:D.shape[2])*R,it=("NHWC"===B?D.shape[2]:D.shape[3])*R,mt=("NHWC"===B?D.shape[3]:D.shape[1])/(R*R),Rt=new ao("NHWC"===B?[k,st,it,mt]:[k,mt,st,it],R,B);return m.runWebGLProgram(Rt,[D],D.dtype)}};class hr{constructor(x,m=!1,I=null,D=!1,R=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=x.outShape,this.enableShapeUniforms=(0,a.C9)(this.outputShape.length);const B=x.filterHeight,k=x.filterWidth,U=x.outChannels/x.inChannels;let F="",V="";I&&(F=D?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${I}\n        }`:R?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${I}\n        }`:`\n          float activation(float x) {\n            ${I}\n          }\n        `,V="result = activation(result);");const st=m?"result += getBiasAtOutCoords();":"";m&&this.variableNames.push("bias"),D&&this.variableNames.push("preluActivationWeights"),R&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${F}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${U};\n        int q = d2 - d1 * ${U};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${B}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${k}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${st}\n        ${V}\n        setOutput(result);\n      }\n    `}}class pr{constructor(x,m=!1,I=null,D=!1,R=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=x.outShape,this.enableShapeUniforms=(0,a.C9)(this.outputShape.length);const B=x.outChannels/x.inChannels,k=x.padInfo.left,U=x.strideWidth,F=x.dilationWidth,V=x.filterHeight,st=x.filterWidth,it=st;let mt="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let Mt=0;Mt<st;Mt++)mt+=`\n          vec4 xTexelC${2*Mt};\n          int xTexelC${2*Mt}Ready;\n          vec4 xTexelC${2*Mt+1};\n          int xTexelC${2*Mt+1}Ready;\n          vec4 xC${Mt};`;mt+=`\n    for (int r = 0; r < ${V}; r++) {\n      `;for(let Mt=0;Mt<st;Mt++)mt+=`\n          xTexelC${2*Mt} = vec4(0.0);\n          xTexelC${2*Mt}Ready = 0;\n          xTexelC${2*Mt+1} = vec4(0.0);\n          xTexelC${2*Mt+1}Ready = 0;\n          xC${Mt} = vec4(0.0);`;mt+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let Mt=0;Mt<(it+1)/2;Mt++){const Ft=2*Mt;if(mt+=`\n          xC = xCCorner + ${Ft*F};\n          `,1===U){if(Ft<st&&(k%2==1?(mt+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ft}Ready == 0) {\n                  xTexelC${Ft} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${Ft}.zw = vec2(0.0);\n                  }\n                  xTexelC${Ft}Ready = 1;\n                }\n              `,mt+=1===F&&Ft>0?`\n                xC${Ft} = vec4(xTexelC${Ft-2}.zw, xTexelC${Ft}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${Ft} = vec4(previous.zw, xTexelC${Ft}.xy);\n                  } else {\n                    xC${Ft} = vec4(0.0, 0.0, xTexelC${Ft}.xy);\n                  }\n                  `):mt+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${Ft}Ready == 0) {\n                  xTexelC${Ft} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${Ft}.zw = vec2(0.0);\n                  }\n                  xTexelC${Ft}Ready = 1;\n                }\n\n                xC${Ft} = xTexelC${Ft};\n                `,Ft+1<st)){const De=k%2==0?e.D5U.nearestLargerEven(F):F;F%2==0&&k%2==1||F%2!=0&&k%2!=1?(mt+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${De};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ft+1}Ready == 0) {\n                    xTexelC${Ft+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${Ft+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${Ft+1}Ready = 1;\n                  }\n                  `,mt+=F>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${Ft+1} = vec4(previous.zw, xTexelC${Ft+1}.xy);\n                    } else {\n                     xC${Ft+1} = vec4(0.0, 0.0, xTexelC${Ft+1}.xy);\n                    }\n                    `:`\n                    xC${Ft+1} = vec4(xTexelC${Ft}.zw, xTexelC${Ft+1}.xy);\n                    `):mt+=1===De?`\n                    xC${Ft+1} = xTexelC${Ft};\n                    `:`\n                    xCOffset = xC + ${De};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ft+1}Ready == 0) {\n                      xTexelC${Ft+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${Ft+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${Ft+1}Ready = 1;\n                    }\n\n                    xC${Ft+1} = xTexelC${Ft+1};\n                    `}}else Ft<st&&(k%2==1?(mt+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ft}Ready == 0) {\n                  xTexelC${Ft} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${Ft}.zw = vec2(0.0);\n                  }\n                  xTexelC${Ft}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${Ft+1}Ready == 0) {\n                  xTexelC${Ft+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${Ft+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${Ft+1}Ready = 1;\n                }\n\n                xC${Ft} = vec4(xTexelC${Ft}.zw, xTexelC${Ft+1}.zw);\n              `,Ft+1<st&&(mt+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${Ft+1} = vec4(xTexelC${Ft+1}.xy, final.xy);\n                `)):(mt+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${Ft}Ready == 0) {\n                  xTexelC${Ft} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${Ft}.zw = vec2(0.0);\n                  }\n                  xTexelC${Ft}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ft+1}Ready == 0) {\n                  xTexelC${Ft+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${Ft+1}.zw = vec2(0.);\n                  }\n                  xTexelC${Ft+1}Ready = 1;\n                }\n\n                xC${Ft} = vec4(\n                  xTexelC${Ft}.xy, xTexelC${Ft+1}.xy);\n              `,Ft+1<st&&(mt+=`\n                  xC${Ft+1} = vec4(xTexelC${Ft}.zw, xTexelC${Ft+1}.zw);\n                `)));Ft<st&&(mt+=`\n            wTexel = getW(r, ${Ft}, d1, q);\n            dotProd += xC${Ft} * vec4(wTexel.xz, wTexel.xz);\n          `,Ft+1<st&&(mt+=`\n              wTexel = getW(r, ${Ft+1}, d1, q);\n              dotProd += xC${Ft+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}mt+="\n    }\n  ",mt+="\n      }\n    ";let _t="",Rt="";I&&(_t=D?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${I}\n        }`:R?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${I}\n        }`:`vec4 activation(vec4 x) {\n          ${I}\n        }`,Rt="result = activation(result);");const $t=m?"result += getBiasAtOutCoords();":"";m&&this.variableNames.push("bias"),D&&this.variableNames.push("preluActivationWeights"),R&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${_t}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${B};\n        int q = d2 - d1 * ${B};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${mt}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${$t}\n        ${Rt}\n        setOutput(result);\n      }\n    `}}const yr={kernelName:e.cie,backendName:"webgl",kernelFunc:function Tr(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,filter:R}=x,{strides:B,pad:k,dilations:U,dimRoundingMode:F}=I;let V=U;null==V&&(V=[1,1]),e.D5U.assert(e.backend_util.eitherStridesOrDilationsAreOne(B,V),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${B} and dilations '${V}'`);const st=e.backend_util.computeConv2DInfo(D.shape,R.shape,B,V,k,F,!0);let it;return it=(0,e.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&st.strideWidth<=2&&st.outChannels/st.inChannels==1?new pr(st):new hr(st),m.runWebGLProgram(it,[D,R],"float32",[[st.padInfo.top,st.padInfo.left],[st.strideHeight,st.strideWidth],[st.dilationHeight,st.dilationWidth],[st.inHeight,st.inWidth]])}};class Rr{constructor(x){this.variableNames=["x","dy"],this.outputShape=x.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${x.outChannels/x.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${x.batchSize}; b++) {\n          for (int yR = 0; yR < ${x.outHeight}; yR++) {\n            int xR = wR + yR * ${x.strideHeight} - ${x.padInfo.top};\n\n            if (xR < 0 || xR >= ${x.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${x.outWidth}; yC++) {\n              int xC = wC + yC * ${x.strideWidth} - ${x.padInfo.left};\n\n              if (xC < 0 || xC >= ${x.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ar{constructor(x){this.variableNames=["dy","W"],this.outputShape=x.inShape;const m=x.filterHeight,I=x.filterWidth,U=x.outChannels/x.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${m-1-x.padInfo.top}, ${I-1-x.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${m}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${x.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${x.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${m} - 1 - wR;\n\n          for (int wC = 0; wC < ${I}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${x.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${x.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${I} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${U}; dm++) {\n              int d2 = d1 * ${U} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const br={kernelName:e.sL$,backendName:"webgl",kernelFunc:function Sr(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,dy:R}=x,{strides:B,dilations:k,pad:U,dimRoundingMode:F,filterShape:V}=I,st=e.backend_util.computeConv2DInfo(D.shape,V,B,k,U,F,!0),it=new Rr(st);return m.runWebGLProgram(it,[D,R],"float32")}},Br={kernelName:e.y7R,backendName:"webgl",kernelFunc:function $r(w){const{inputs:x,backend:m,attrs:I}=w,{dy:D,filter:R}=x,{strides:B,dilations:k,pad:U,dimRoundingMode:F,inputShape:V}=I,st=e.backend_util.computeConv2DInfo(V,R.shape,B,k,U,F,!0),it=new Ar(st);return m.runWebGLProgram(it,[D,R],"float32")}};class Lr{constructor(x){this.variableNames=["X"],this.outputShape=[x,x],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Ur={kernelName:e.$w,backendName:"webgl",kernelFunc:function Nr(w){const{inputs:x,backend:m}=w,{x:I}=x,D=[...I.shape,...I.shape],R=e.D5U.sizeFromShape(I.shape),B=Gt({inputs:{x:I},backend:m,attrs:{shape:[R]}}),k=new Lr(R),U=m.runWebGLProgram(k,[B],B.dtype),F=Gt({inputs:{x:U},backend:m,attrs:{shape:D}});return m.disposeIntermediateTensorInfo(B),m.disposeIntermediateTensorInfo(U),F}};class Wr{constructor(x){this.variableNames=["x","W"],this.outputShape=x.outShape;const{inHeight:m,inWidth:I,padInfo:D,strideHeight:R,strideWidth:B,filterHeight:k,filterWidth:U,dilationHeight:F,dilationWidth:V}=x,{top:st,left:it}=D;this.userCode=`\n      const ivec2 strides = ivec2(${R}, ${B});\n      const ivec2 pads = ivec2(${st}, ${it});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${k}; h++) {\n          int hIn = hBeg + h * ${F};\n\n          if (hIn >= 0 && hIn < ${m}) {\n            for (int w = 0; w < ${U}; w++) {\n              int wIn = wBeg + w * ${V};\n\n              if (wIn >= 0 && wIn < ${I}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const wr={kernelName:e.p4S,backendName:"webgl",kernelFunc:function kr(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,filter:R}=x,{strides:B,pad:k,dilations:U}=I,F=e.backend_util.computeDilation2DInfo(D.shape,R.shape,B,k,"NHWC",U);let V;const st=new Wr(F);V=m.runWebGLProgram(st,[D,R],"float32");const it=Gt({inputs:{x:V},backend:m,attrs:{shape:F.outShape}});return m.disposeIntermediateTensorInfo(V),it}},Fr={kernelName:e.$g6,backendName:"webgl",kernelFunc:function fr(w){const{inputs:x,backend:m,attrs:I}=w,{equation:D}=I,R=x,{allDims:B,summedDims:k,idDims:U}=e.backend_util.decodeEinsumEquation(D,R.length);e.backend_util.checkEinsumDimSizes(B.length,U,R);const{path:F,steps:V}=e.backend_util.getEinsumComputePath(k,U),st=V.length;let it=null,mt=B.length;const _t=[];for(let Rt=0;Rt<st;++Rt){for(const $t of V[Rt]){const{permutationIndices:Mt,expandDims:Ft}=e.backend_util.getEinsumPermutation(mt,U[$t]);let De;e.backend_util.isIdentityPermutation(Mt)?De=R[$t]:(De=dt({inputs:{x:R[$t]},backend:m,attrs:{perm:Mt}}),_t.push(De));const he=De.shape.slice();for(let Ne=0;Ne<Ft.length;++Ne)he.splice(Ft[Ne],0,1);e.D5U.arraysEqual(De.shape,he)||(De=Gt({inputs:{x:De},backend:m,attrs:{shape:he}}),_t.push(De)),null===it?it=De:(it=Pt({inputs:{a:De,b:it},backend:m}),_t.push(it))}Rt<st-1&&(F[Rt]>=0&&(it=j({inputs:{x:it},backend:m,attrs:{axis:F[Rt]-(B.length-mt),keepDims:!1}}),_t.push(it)),mt--)}for(const Rt of _t)Rt!==it&&m.disposeIntermediateTensorInfo(Rt);return it}},Kr=$({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Vr={kernelName:e.SX0,backendName:"webgl",kernelFunc:Kr},jr={kernelName:e.HEU,backendName:"webgl",kernelFunc:w=>{const{inputs:x,backend:m}=w,{dy:I,y:D}=x,R=(0,e.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new s("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",I.shape,D.shape):new h("return (b >= 0.0) ? a : a * (b + 1.0);",I.shape,D.shape);return m.runWebGLProgram(R,[I,D],I.dtype)}},Xr=W({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Y.gv}),Yr={kernelName:e.hdR,backendName:"webgl",kernelFunc:Xr},Qr=$({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${e.backend_util.ERF_P};\n  float a1 = ${e.backend_util.ERF_A1};\n  float a2 = ${e.backend_util.ERF_A2};\n  float a3 = ${e.backend_util.ERF_A3};\n  float a4 = ${e.backend_util.ERF_A4};\n  float a5 = ${e.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),Jr={kernelName:e.Omj,backendName:"webgl",kernelFunc:Qr},ir=$({opSnippet:E+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Y.aX,dtype:"float32"}),qr={kernelName:e.NEP,backendName:"webgl",kernelFunc:ir};function Mo(w){const{inputs:x,attrs:m,backend:I}=w,{dim:D}=m,{input:R}=x,B=R.shape.length,k=R.shape.slice();let U=D;return D<0&&(e.D5U.assert(-(B+1)<=D,()=>`Axis must be in the interval [${-(B+1)}, ${B}]`),U=B+D+1),k.splice(U,0,1),Gt({inputs:{x:R},backend:I,attrs:{shape:k}})}const ta={kernelName:e.YFo,backendName:"webgl",kernelFunc:Mo},mr="return exp(x) - 1.0;",gr=$({opSnippet:mr,packedOpSnippet:mr,cpuKernelImpl:Y.tx}),ea={kernelName:e.Y0y,backendName:"webgl",kernelFunc:gr};class _r{constructor(x,m,I){this.variableNames=["real","imag"];const D=m[1];this.outputShape=m;const R=I?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,B=I?`${D}.0`:"1.0";let k;if("real"===x)k="return real * expR - imag * expI;";else{if("imag"!==x)throw new Error(`FFT component must be either "real" or "imag", got ${x}.`);k="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${R};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${k}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${D});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${D}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${B};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Er(w,x,m){const I=m.texData.get(w.dataId),D=e.D5U.sizeFromShape(w.shape),R=w.shape[w.shape.length-1],k=Gt({inputs:{x:w},backend:m,attrs:{shape:[D/R,R]}}),U=k.shape,F=new _r("real",U,x),V=new _r("imag",U,x),st=[{dataId:I.complexTensorInfos.real.dataId,dtype:I.complexTensorInfos.real.dtype,shape:U},{dataId:I.complexTensorInfos.imag.dataId,dtype:I.complexTensorInfos.imag.dtype,shape:U}],it=m.runWebGLProgram(F,st,"float32"),mt=m.runWebGLProgram(V,st,"float32"),_t=p({inputs:{real:it,imag:mt},backend:m});m.disposeIntermediateTensorInfo(it),m.disposeIntermediateTensorInfo(mt);const Rt=Gt({inputs:{x:_t},backend:m,attrs:{shape:w.shape}});return m.disposeIntermediateTensorInfo(k),m.disposeIntermediateTensorInfo(_t),Rt}const sa={kernelName:e.vwp,backendName:"webgl",kernelFunc:function na(w){const{inputs:x,backend:m}=w,{input:I}=x;return Er(I,!1,m)}};class oa{constructor(x,m){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=x,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function io(w){const{backend:x,attrs:m}=w,{shape:I,value:D}=m;let{dtype:R}=m;if(R=R||e.D5U.inferDtype(D),"string"===R){const B=e.D5U.getArrayFromDType(R,e.D5U.sizeFromShape(I));return B.fill(D),x.makeTensorInfo(I,R,B)}{const B=new oa(I,D);return x.runWebGLProgram(B,[],R,[[D]])}}const ra={kernelName:e.deh,backendName:"webgl",kernelFunc:io};class aa{constructor(x){this.variableNames=["Image"],this.outputShape=[];const m=x[2];this.outputShape=x,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${m} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${m}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const ia={kernelName:e.Uyb,backendName:"webgl",kernelFunc:({inputs:w,backend:x})=>{const{image:m}=w,I=x,D=new aa(m.shape);return I.runWebGLProgram(D,[m],m.dtype)}},xr="return floor(x);",la=$({opSnippet:xr,packedOpSnippet:xr,cpuKernelImpl:Y.MZ}),ua={kernelName:e.OR,backendName:"webgl",kernelFunc:la},ca=W({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),da={kernelName:e.jeX,backendName:"webgl",kernelFunc:ca};var ha=t(20215);class pa{constructor(x){this.variableNames=["A"];const m=(0,so.A)(),[I,D]=x;this.outputShape=x,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${D}.0, ${I}.0);\n\n        vec4 values = ${m.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class fa{constructor(x){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const m=(0,so.A)(),[I,D]=x;this.outputShape=x,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${D}.0, ${I}.0);\n            vec4 values = ${m.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${m.output} = result;\n      }\n    `}}const ma={kernelName:e.eBW,backendName:"webgl",kernelFunc:function ga(w){const{inputs:x,backend:m,attrs:I}=w;let{pixels:D}=x;const{numChannels:R}=I,B=typeof HTMLVideoElement<"u"&&D instanceof HTMLVideoElement,k=typeof HTMLImageElement<"u"&&D instanceof HTMLImageElement,[U,F]=B?[D.videoWidth,D.videoHeight]:[D.width,D.height],V=[F,U],st=[F,U,R];if(k||B){const Rt=(0,e.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Ds||Rt!==lr)&&(lr=Rt,Ds=document.createElement("canvas").getContext("2d",{willReadFrequently:lr})),Ds.canvas.width=U,Ds.canvas.height=F,Ds.drawImage(D,0,0,U,F),D=Ds.canvas}const it=m.makeTensorInfo(V,"int32");m.texData.get(it.dataId).usage=ha.v2.PIXELS,m.gpgpu.uploadPixelDataToTexture(m.getTexture(it.dataId),D);const mt=(0,e.OBj)().getBool("WEBGL_PACK")?new fa(st):new pa(st),_t=m.runWebGLProgram(mt,[it],"int32");return m.disposeData(it.dataId),_t}};let Ds,lr=(0,e.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const Ea={kernelName:e._V0,backendName:"webgl",kernelFunc:function _a(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,filter:R,bias:B,preluActivationWeights:k}=x,{strides:U,pad:F,dataFormat:V,dilations:st,dimRoundingMode:it,activation:mt,leakyreluAlpha:_t}=I,Rt=e.backend_util.convertConv2DDataFormat(V),$t=e.backend_util.computeConv2DInfo(D.shape,R.shape,U,st,F,it,!1,Rt);let Mt;const Ft=[],De=null!=B,he=null!=k,Ne="leakyrelu"===mt,Ye=()=>{const Fe=[D,R],sn=(Qe,Cn)=>{if("NCHW"===Cn&&1===Qe.shape.length&&1!==Qe.shape[0]){const In=Gt({inputs:{x:Qe},backend:m,attrs:{shape:[Qe.shape[0],1,1]}});return Ft.push(In),In}return Qe};if(De&&Fe.push(sn(B,V)),he&&Fe.push(sn(k,V)),Ne){const Qe=m.makeTensorInfo([],"float32",e.D5U.createScalarValue(_t,"float32"));Fe.push(Qe),Ft.push(Qe)}return Fe};if(1!==$t.filterHeight||1!==$t.filterWidth||1!==$t.dilationHeight||1!==$t.dilationWidth||1!==$t.strideHeight||1!==$t.strideWidth||"SAME"!==$t.padInfo.type&&"VALID"!==$t.padInfo.type)if($t.strideWidth<=2&&"channelsLast"===Rt&&(0,e.OBj)().getBool("WEBGL_EXP_CONV")){const Fe=mt?Z(mt,!0):null,sn=new Do($t,De,Fe,he,Ne),Qe=[[$t.padInfo.top,$t.padInfo.left],[$t.strideHeight,$t.strideWidth],[$t.dilationHeight,$t.dilationWidth],[$t.inHeight,$t.inWidth]],Cn=Ye();Mt=m.runWebGLProgram(sn,Cn,"float32",Qe)}else if((0,e.OBj)().getBool("WEBGL_CONV_IM2COL"))Mt=Co({x:D,filter:R,convInfo:$t,backend:m,bias:B,activation:mt,preluActivationWeights:k,leakyreluAlpha:_t});else{const Fe=mt?Z(mt,!1):null,sn=new Eo($t,De,Fe,he,Ne),Qe=Ye();Mt=m.runWebGLProgram(sn,Qe,"float32")}else Mt=vo({x:D,filter:R,convInfo:$t,backend:m,bias:B,activation:mt,preluActivationWeights:k,leakyreluAlpha:_t});const je=Gt({inputs:{x:Mt},backend:m,attrs:{shape:$t.outShape}});return Ft.push(Mt),Ft.forEach(Fe=>m.disposeIntermediateTensorInfo(Fe)),je}},Da={kernelName:e.luS,backendName:"webgl",kernelFunc:function xa(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,filter:R,bias:B,preluActivationWeights:k}=x,{strides:U,pad:F,dilations:V,dimRoundingMode:st,activation:it,leakyreluAlpha:mt}=I,_t=[];let Rt=V;null==Rt&&(Rt=[1,1]),e.D5U.assert(e.backend_util.eitherStridesOrDilationsAreOne(U,Rt),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${U} and dilations '${Rt}'`);const $t=e.backend_util.computeConv2DInfo(D.shape,R.shape,U,Rt,F,st,!0),Mt=(0,e.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&$t.strideWidth<=2&&$t.outChannels/$t.inChannels==1,Ft=it?Z(it,Mt):null,De=[D,R],he=null!=B,Ne=null!=k,Ye="leakyrelu"===it;if(he&&De.push(B),Ne&&De.push(k),Ye){const Qe=m.makeTensorInfo([],"float32",e.D5U.createScalarValue(mt,"float32"));De.push(Qe),_t.push(Qe)}let je;je=Mt?new pr($t,he,Ft,Ne,Ye):new hr($t,he,Ft,Ne,Ye);const sn=m.runWebGLProgram(je,De,"float32",[[$t.padInfo.top,$t.padInfo.left],[$t.strideHeight,$t.strideWidth],[$t.dilationHeight,$t.dilationWidth],[$t.inHeight,$t.inWidth]]);return _t.forEach(Qe=>m.disposeIntermediateTensorInfo(Qe)),sn}};class va{constructor(x,m,I,D){this.sliceDim=x,this.strides=m,this.paramsShape=D,this.variableNames=["x","indices"],this.outputShape=I;const R=(0,f.kW)(I.length);let B="\n    int index;";for(let k=0;k<this.sliceDim;k++)B+=`\n          index = round(getIndices(coords[0], ${k}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[k]};\n          flattenIndex += index * ${this.strides[k]};`;this.userCode=`\n         void main() {\n          ${R} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${B}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const Ia={kernelName:e.q1x,backendName:"webgl",kernelFunc:function Ca(w){const{inputs:x,backend:m}=w,{params:I,indices:D}=x,R=D.shape,B=R[R.length-1],k=e.D5U.sizeFromShape(I.shape),[U,F,V,st]=e.backend_util.prepareAndValidate(I,D),it=Gt({inputs:{x:D},backend:m,attrs:{shape:[F,B]}}),mt=Gt({inputs:{x:I},backend:m,attrs:{shape:[e.D5U.sizeFromShape(I.shape)/V,V]}});if(m.shouldExecuteOnCPU([I,D])||"string"===I.dtype){const Mt=m.readSync(D.dataId),Ft=m.bufferSync(I),De=(0,Y.TD)(Mt,Ft,I.dtype,F,B,V,st,I.shape,k);return m.makeTensorInfo(U,I.dtype,De.values)}const _t=new va(B,st,[F,V],I.shape),Rt=m.runWebGLProgram(_t,[mt,it],mt.dtype),$t=Gt({inputs:{x:Rt},backend:m,attrs:{shape:U}});return m.disposeIntermediateTensorInfo(it),m.disposeIntermediateTensorInfo(mt),m.disposeIntermediateTensorInfo(Rt),$t}};class Oa{constructor(x,m){this.variableNames=["A","indices"],this.outputShape=m,this.rank=m.length;const I=(0,f.kW)(this.rank),D=function vs(w){const m=["resRC.x","resRC.y","resRC.z","resRC.w"],I=[];for(let D=0;D<w.length;D++)I.push(2===D?"index":`${m[D]}`);return I.join()}(x);this.userCode=`\n      void main() {\n        ${I} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${x[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${D}));\n      }\n    `}}function Dr(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,indices:R}=x,{axis:B,batchDims:k}=I,U=e.D5U.parseAxisParam(B,D.shape)[0];if((0,e.OBj)().get("DEBUG")){const Ft=m.readSync(R.dataId),De=D.shape[U];for(let he=0;he<Ft.length;++he){const Ne=Ft[he];e.D5U.assert(Ne<=De-1&&Ne>=0,()=>`GatherV2: the index value ${Ne} is not in [0, ${De-1}]`)}}const F=e.backend_util.segment_util.collectGatherOpShapeInfo(D,R,U,k),V=e.D5U.sizeFromShape(R.shape),st=[],it=Gt({inputs:{x:D},backend:m,attrs:{shape:[F.batchSize,F.outerSize,F.dimSize,F.sliceSize]}}),mt=Gt({inputs:{x:R},backend:m,attrs:{shape:[F.batchSize,V/F.batchSize]}});st.push(it),st.push(mt);const _t=[F.batchSize,F.outerSize,V/F.batchSize,F.sliceSize];if(m.shouldExecuteOnCPU([D,R])||"string"===D.dtype){const Ft=m.bufferSync(mt),De=m.bufferSync(it),he=(0,Y.m$)(De,Ft,_t);return st.forEach(Ne=>m.disposeIntermediateTensorInfo(Ne)),m.makeTensorInfo(F.outputShape,he.dtype,he.values)}const Rt=new Oa(it.shape,_t),$t=m.runWebGLProgram(Rt,[it,mt],it.dtype);st.push($t);const Mt=Gt({inputs:{x:$t},backend:m,attrs:{shape:F.outputShape}});return st.forEach(Ft=>m.disposeIntermediateTensorInfo(Ft)),Mt}const Pa={kernelName:e.qi_,backendName:"webgl",kernelFunc:Dr},Ma=W({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Y.B_,dtype:"bool"}),Ta={kernelName:e.iZT,backendName:"webgl",kernelFunc:Ma},ya=W({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Y.ji}),Ra={kernelName:e.Acj,backendName:"webgl",kernelFunc:ya},Sa={kernelName:e.Qg5,backendName:"webgl",kernelFunc:function Aa(w){const{inputs:x,backend:m}=w,{input:I}=x;return Er(I,!0,m)}},ba=$({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),$a={kernelName:e.avt,backendName:"webgl",kernelFunc:ba},Ba=$({opSnippet:"return float(isinf(x));",dtype:"bool"}),La={kernelName:e.iWB,backendName:"webgl",kernelFunc:Ba},el=$({opSnippet:"return float(isnan(x));",dtype:"bool"}),vr={kernelName:e.r7n,backendName:"webgl",kernelFunc:el},Na=W({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Y.kY,dtype:"bool"}),Ua={kernelName:e.vtC,backendName:"webgl",kernelFunc:Na},Wa=W({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Y.Rn,dtype:"bool"}),ka={kernelName:e.CAk,backendName:"webgl",kernelFunc:Wa},Fa={kernelName:e.e7N,backendName:"webgl",kernelFunc:function wa(w){const{backend:x,attrs:m}=w,{start:I,stop:D,num:R}=m,B=(0,Y.PQ)(I,D,R);return x.makeTensorInfo([B.length],"float32",B)}},Ka=$({opSnippet:E+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Y.Sd}),Va={kernelName:e.ZbH,backendName:"webgl",kernelFunc:Ka},Ga=$({opSnippet:E+"\n  return log(1.0 + x);\n"}),Ha={kernelName:e.kU,backendName:"webgl",kernelFunc:Ga},ja=W({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Xa={kernelName:e.PYm,backendName:"webgl",kernelFunc:ja},Ya=$({opSnippet:"return float(!(x >= 1.0));"}),Za={kernelName:e.VfG,backendName:"webgl",kernelFunc:Ya},Qa=W({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Ja={kernelName:e.MZg,backendName:"webgl",kernelFunc:Qa};class qa{constructor(x,m,I,D,R){this.variableNames=["x"],this.outputShape=[];const B=m,k=x[3]-1;let U;this.outputShape=x;const F=`float(${I}) + float(${D}) * sum`;U=.5===R?`inversesqrt(${F})`:1===R?`1.0/(${F})`:`exp(log(${F}) * float(-${R}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${B}; j <= ${B}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${k}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${U};\n        setOutput(val);\n      }\n    `}}class ti{constructor(x,m,I,D,R){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const B=m,k=x[3]-1;let U;this.outputShape=x;const F=`float(${I}) + float(${D}) * sum`;U=.5===R?`inversesqrt(${F})`:1===R?`1.0/(${F})`:`exp(log(${F}) * float(-${R}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${B};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${B}; j <= ${B}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${k}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${U};\n        setOutput(result);\n      }\n    `}}const ni={kernelName:e.eZ0,backendName:"webgl",kernelFunc:w=>{const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{depthRadius:R,bias:B,alpha:k,beta:U}=I,F=(0,e.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new ti(D.shape,R,B,k,U):new qa(D.shape,R,B,k,U);return m.runWebGLProgram(F,[D],D.dtype)}};class si{constructor(x,m,I,D,R){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=x,this.depth=x[3],this.depthRadius=m,this.bias=I,this.alpha=D,this.beta=R,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${m})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${m} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${D}) * norm + float(${I});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${D})\n                * float(${R})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${R});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const ri={kernelName:e.Hhh,backendName:"webgl",kernelFunc:w=>{const{inputs:x,backend:m,attrs:I}=w,{x:D,y:R,dy:B}=x,{depthRadius:k,bias:U,alpha:F,beta:V}=I,st=new si(D.shape,k,U,F,V);return m.runWebGLProgram(st,[D,R,B],D.dtype)}};function Ir(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{reductionIndices:R,keepDims:B}=I,k=D.shape.length,U=e.D5U.parseAxisParam(R,D.shape);let F=U;const V=e.backend_util.getAxesPermutation(F,k),st=null!=V,it=m.shouldExecuteOnCPU([D]);let mt=D;if(st){if(it){const De=m.texData.get(mt.dataId).values,he=new Array(k);for(let je=0;je<he.length;je++)he[je]=D.shape[V[je]];const Ne=(0,Y.Fv)(De,D.shape,D.dtype,V,he);mt=m.makeTensorInfo(he,D.dtype),m.texData.get(mt.dataId).values=Ne}else mt=q(D,V,m);F=e.backend_util.getInnerMostAxes(F.length,k)}e.backend_util.assertAxesAreInnerMostDims("max",F,k);const[_t,Rt]=e.backend_util.computeOutAndReduceShapes(mt.shape,F);let Mt,$t=_t;if(B&&($t=e.backend_util.expandShapeToKeepDim(_t,U)),it){const De=m.texData.get(mt.dataId).values,he=(0,Y.$O)(De,e.D5U.sizeFromShape(Rt),$t,D.dtype);Mt=m.makeTensorInfo($t,D.dtype),m.texData.get(Mt.dataId).values=he}else Mt=function ai(w,x,m,I){const D=e.D5U.sizeFromShape(x),k=Gt({inputs:{x:w},attrs:{shape:[e.D5U.sizeFromShape(w.shape)/D,D]},backend:I}),U=Zt(k,w.dtype,"max",I),F=Gt({inputs:{x:U},attrs:{shape:m},backend:I});return I.disposeIntermediateTensorInfo(k),I.disposeIntermediateTensorInfo(U),F}(mt,Rt,$t,m);return st&&m.disposeIntermediateTensorInfo(mt),Mt}const ii={kernelName:e.YoZ,backendName:"webgl",kernelFunc:Ir},ci=W({opSnippet:u+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+l+"\n  return result;\n",cpuKernelImpl:Y.nL}),di={kernelName:e.BMI,backendName:"webgl",kernelFunc:ci},pi={kernelName:e.mTV,backendName:"webgl",kernelFunc:function hi(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x;(0,Nt.assertNotComplex)(D,"maxPool");const{filterSize:R,strides:B,pad:k,dimRoundingMode:U}=I;e.D5U.assert(e.backend_util.eitherStridesOrDilationsAreOne(B,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${B} and dilations '1'`);const V=e.backend_util.computePool2DInfo(D.shape,R,B,1,k,U);if(1===V.filterWidth&&1===V.filterHeight&&e.D5U.arraysEqual(V.inShape,V.outShape))return r({inputs:{x:D},backend:m});const st=new Hn(V,"max",!1);return m.runWebGLProgram(st,[D],D.dtype)}},mi={kernelName:e.OAf,backendName:"webgl",kernelFunc:function fi(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{filterSize:R,strides:B,pad:k,dataFormat:U,dimRoundingMode:F}=I,st=e.backend_util.computePool3DInfo(D.shape,R,B,[1,1,1],k,F,U),it=new Yn(st,"max",!1);return m.runWebGLProgram(it,[D],D.dtype)}};class gi{constructor(x){this.variableNames=["dy","maxPos"],this.outputShape=x.inShape;const R=x.effectiveFilterHeight,B=x.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${R-1-x.padInfo.top}, ${B-1-x.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${R};\n          wR += ${x.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${x.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${x.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${B}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${x.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${x.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${R*B-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${B} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _i{constructor(x){this.variableNames=["dy","maxPos"],this.outputShape=x.inShape;const U=x.effectiveFilterDepth,F=x.effectiveFilterHeight,V=x.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${U-1-x.padInfo.front}, ${F-1-x.padInfo.top}, ${V-1-x.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${U};\n           wD += ${x.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${x.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${x.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${F};\n              wR += ${x.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${x.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${x.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${V};\n                wC += ${x.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${x.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${x.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${U*F*V-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${F} * ${V} +\n                  wR * ${V} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const xi={kernelName:e.OU7,backendName:"webgl",kernelFunc:function Ei(w){const{inputs:x,backend:m,attrs:I}=w,{dy:D,input:R}=x,B=R,{filterSize:k,strides:U,pad:F,dimRoundingMode:V}=I,it=e.backend_util.computePool3DInfo(B.shape,k,U,[1,1,1],F,V),mt=new Yn(it,"max",!0),_t=m.runWebGLProgram(mt,[B],B.dtype),Rt=new _i(it),$t=m.runWebGLProgram(Rt,[D,_t],B.dtype);return m.disposeIntermediateTensorInfo(_t),$t}},Or={kernelName:e.OV7,backendName:"webgl",kernelFunc:function Di(w){const{inputs:x,backend:m,attrs:I}=w,{dy:D,input:R,output:B}=x,k=R;(0,Nt.assertNotComplex)([R,B],"maxPoolGrad");const{filterSize:U,strides:F,pad:V,dimRoundingMode:st}=I,it=e.backend_util.computePool2DInfo(k.shape,U,F,1,V,st),_t=new Hn(it,"max",!0),Rt=m.runWebGLProgram(_t,[k],k.dtype),$t=new gi(it),Mt=m.runWebGLProgram($t,[D,Rt],k.dtype);return m.disposeIntermediateTensorInfo(Rt),Mt}},Ci={kernelName:e.vFR,backendName:"webgl",kernelFunc:({inputs:w,attrs:x,backend:m})=>{const{x:I}=w,{filterSize:D,strides:R,pad:B,includeBatchInIndex:k}=x,U=m;e.D5U.assert(4===I.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${I.shape.length}.`);const F=[1,1];e.D5U.assert(e.backend_util.eitherStridesOrDilationsAreOne(R,F),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${R} and dilations '${F}'`);const V=e.backend_util.computePool2DInfo(I.shape,D,R,F,B),[st,it]=function vi(w,x,m,I){let D=new Hn(m,"max",!1);const R=I.runWebGLProgram(D,[w],"float32");return D=new Hn(m,"max",!0,!0,x),[R,I.runWebGLProgram(D,[w],"float32")]}(I,k,V,U);return[st,it]}},Oi={kernelName:e.q2K,backendName:"webgl",kernelFunc:({inputs:w,attrs:x,backend:m})=>{const{x:I}=w,{keepDims:D,axis:R}=x,B=m,k=I.shape.length,U=e.D5U.parseAxisParam(R,I.shape);let F=U;const V=e.backend_util.getAxesPermutation(F,k),st=null!=V,it=B.shouldExecuteOnCPU([I]),mt=[];let _t=I;if(st){if(it){const he=B.texData.get(_t.dataId).values,Ne=new Array(k);for(let Fe=0;Fe<Ne.length;Fe++)Ne[Fe]=I.shape[V[Fe]];const Ye=(0,Y.Fv)(he,I.shape,I.dtype,V,Ne);_t=B.makeTensorInfo(Ne,I.dtype),B.texData.get(_t.dataId).values=Ye}else _t=q(I,V,B);mt.push(_t),F=e.backend_util.getInnerMostAxes(F.length,k)}e.backend_util.assertAxesAreInnerMostDims("sum",F,k);const[Rt,$t]=e.backend_util.computeOutAndReduceShapes(_t.shape,F);let Mt=Rt;D&&(Mt=e.backend_util.expandShapeToKeepDim(Rt,U));const Ft=function Ii(w,x,m,I){const D=e.D5U.sizeFromShape(x),k=Gt({inputs:{x:w},attrs:{shape:[e.D5U.sizeFromShape(w.shape)/D,D]},backend:I}),U=Zt(k,"float32","mean",I),F=Gt({inputs:{x:U},attrs:{shape:m},backend:I});return I.disposeIntermediateTensorInfo(k),I.disposeIntermediateTensorInfo(U),F}(_t,$t,Mt,B);for(const De of mt)B.disposeIntermediateTensorInfo(De);return Ft}},Pi={kernelName:e.c17,backendName:"webgl",kernelFunc:function lo(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{axis:R,keepDims:B}=I,k=D.shape.length,U=e.D5U.parseAxisParam(R,D.shape);let F=U;const V=e.backend_util.getAxesPermutation(F,k);let st=D;null!=V&&(st=dt({inputs:{x:D},backend:m,attrs:{perm:V}}),F=e.backend_util.getInnerMostAxes(F.length,D.shape.length)),e.backend_util.assertAxesAreInnerMostDims("min",F,k);const[it,mt]=e.backend_util.computeOutAndReduceShapes(st.shape,F),Rt=Gt({inputs:{x:st},backend:m,attrs:{shape:[-1,e.D5U.sizeFromShape(mt)]}}),$t=Zt(Rt,Rt.dtype,"min",m);let Mt;return Mt=Gt(B?{inputs:{x:$t},backend:m,attrs:{shape:e.backend_util.expandShapeToKeepDim(it,U)}}:{inputs:{x:$t},backend:m,attrs:{shape:it}}),m.disposeIntermediateTensorInfo(Rt),m.disposeIntermediateTensorInfo($t),null!=V&&m.disposeIntermediateTensorInfo(st),Mt}},yi=W({opSnippet:u+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+l+"\n  return result;\n",cpuKernelImpl:Y.r}),Ri={kernelName:e.q8u,backendName:"webgl",kernelFunc:yi};class Ai{constructor(x,m,I){this.variableNames=["x"],this.outputShape=m.map((V,st)=>V[0]+x[st]+V[1]);const D=x.length,R=(0,f.kW)(D),B=m.map(V=>V[0]).join(","),k=m.map((V,st)=>V[0]+x[st]).join(","),U=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,D),F="reflect"===I?0:1;this.userCode=1!==D?`\n      ${R} start = ${R}(${B});\n      ${R} end = ${R}(${k});\n\n      void main() {\n        ${R} outC = getOutputCoords();\n        for (int i = 0; i < ${D}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${F};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${F};\n          }\n        }\n        ${R} coords = outC - start;\n        setOutput(getX(${U}));\n      }\n    `:`\n        int start = ${B};\n        int end = ${k};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${F};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${F};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Si{constructor(x,m,I){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=m.map((_t,Rt)=>_t[0]+x[Rt]+_t[1]);const D=x.length,R=(0,f.kW)(D),B=m.map(_t=>_t[0]).join(","),k=m.map((_t,Rt)=>_t[0]+x[Rt]).join(","),U=(0,i.Ky)("rc",D),F=(0,i.Ky)("source",D),V=`${U[D-1]} < ${this.outputShape[D-1]}`,st=1===D?"source":`vec2(${F.slice(-2).join()})`,it="reflect"===I?0:1;let mt="";if(1===D){const _t=`\n        ${R} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${it};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${it};\n        }\n        source -= start;\n      `;mt=`\n        ${R} rc = outputLoc;\n        ${_t}\n        result[0] = getChannel(getX(${F.join()}), ${st});\n        ${U[D-1]} += 1;\n        if(${V}) {\n          ${_t}\n          result[1] = getChannel(getX(${F.join()}), ${st});\n        }\n      `}else{const _t=`\n        ${R} source = rc;\n        ${R} lt = ${R}(lessThan(source, start));\n        ${R} gte = ${R}(greaterThanEqual(source, end));\n        ${R} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${it}) +\n                gte * ((end - 1) * 2 - source + ${it});\n        source -= start;\n      `;mt=`\n        ${R} rc = outputLoc;\n        ${_t}\n        result[0] = getChannel(getX(${F.join()}), ${st});\n        ${U[D-1]} += 1;\n        if(${V}) {\n          ${_t}\n          result[1] = getChannel(getX(${F.join()}), ${st});\n        }\n        rc = outputLoc;\n        ${U[D-2]} += 1;\n        if(${U[D-2]} < ${this.outputShape[D-2]}) {\n          ${_t}\n          result[2] = getChannel(getX(${F.join()}), ${st});\n          ${U[D-1]} += 1;\n          if(${V}) {\n            ${_t}\n            result[3] = getChannel(getX(${F.join()}), ${st});\n          }\n        }\n      `}this.userCode=`\n      const ${R} start = ${R}(${B});\n      const ${R} end = ${R}(${k});\n\n      void main() {\n        ${R} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mt}\n        setOutput(result);\n      }\n    `}}const $i={kernelName:e.jQs,backendName:"webgl",kernelFunc:({inputs:w,backend:x,attrs:m})=>{const{x:I}=w,{paddings:D,mode:R}=m,B=(0,e.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Si(I.shape,D,R):new Ai(I.shape,D,R);return x.runWebGLProgram(B,[I],I.dtype)}},et=W({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+l+"\n  return result;\n"}),A={kernelName:e.Vbg,backendName:"webgl",kernelFunc:et};class G{constructor(x,m,I){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[x,I],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${m-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${m-1}));\n      }\n    `}}const rt=W({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),nt={kernelName:e.oHH,backendName:"webgl",kernelFunc:rt},ot="return a - b;",tt=W({opSnippet:ot,packedOpSnippet:ot,supportsComplex:!0,cpuKernelImpl:Y.kI}),J={kernelName:e.Tr8,backendName:"webgl",kernelFunc:tt};function ft(w){const{inputs:x,backend:m,attrs:I}=w,{logits:D}=x,{dim:R}=I,B=e.D5U.parseAxisParam([R],D.shape),k=Ir({inputs:{x:D},backend:m,attrs:{reductionIndices:B,keepDims:!1}}),U=e.backend_util.expandShapeToKeepDim(k.shape,B),F=Gt({inputs:{x:k},backend:m,attrs:{shape:U}}),V=tt({inputs:{a:D,b:F},backend:m}),st=ir({inputs:{x:V},backend:m}),it=j({inputs:{x:st},backend:m,attrs:{axis:B,keepDims:!1}}),mt=Gt({inputs:{x:it},backend:m,attrs:{shape:U}}),_t=rt({inputs:{a:st,b:mt},backend:m});return m.disposeIntermediateTensorInfo(k),m.disposeIntermediateTensorInfo(F),m.disposeIntermediateTensorInfo(V),m.disposeIntermediateTensorInfo(st),m.disposeIntermediateTensorInfo(it),m.disposeIntermediateTensorInfo(mt),_t}const lt={kernelName:e.Gcp,backendName:"webgl",kernelFunc:ft},Ot={kernelName:e.NZg,backendName:"webgl",kernelFunc:function Et(w){const{inputs:x,backend:m,attrs:I}=w,{logits:D}=x,{numSamples:R,seed:B,normalized:k}=I,U=k?D:ft({inputs:{logits:D},backend:m,attrs:{dim:D.shape.length-1}}),st=new G(U.shape[0],U.shape[1],R),mt=m.runWebGLProgram(st,[U],"int32",[[B]]);return k||m.disposeIntermediateTensorInfo(U),mt}},Ct=O.D1+"\n  return -x;\n",Bt={kernelName:e.kuV,backendName:"webgl",kernelFunc:function At(w){const{inputs:x,backend:m}=w,{x:I}=x;if(m.shouldExecuteOnCPU([I])){const R=m.texData.get(I.dataId),[B,k]=(0,Y.Bo)(R.values,I.shape,I.dtype);return m.makeTensorInfo(k,I.dtype,B)}let D;return D=(0,e.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new b.cc(I.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new O.l(I.shape,Ct),m.runWebGLProgram(D,[I],I.dtype)}},Wt=e.GDt.nonMaxSuppressionV3Impl,zt={kernelName:e.uv1,backendName:"webgl",kernelFunc:function bt(w){e.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:x,backend:m,attrs:I}=w,{boxes:D,scores:R}=x,{maxOutputSize:B,iouThreshold:k,scoreThreshold:U}=I,F=m.readSync(D.dataId),V=m.readSync(R.dataId),{selectedIndices:st}=Wt(F,V,B,k,U);return m.makeTensorInfo([st.length],"int32",new Int32Array(st))}},Yt=e.GDt.nonMaxSuppressionV4Impl,pe={kernelName:e.cye,backendName:"webgl",kernelFunc:function te(w){e.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:x,backend:m,attrs:I}=w,{boxes:D,scores:R}=x,{maxOutputSize:B,iouThreshold:k,scoreThreshold:U,padToMaxOutputSize:F}=I,V=m.readSync(D.dataId),st=m.readSync(R.dataId),{selectedIndices:it,validOutputs:mt}=Yt(V,st,B,k,U,F);return[m.makeTensorInfo([it.length],"int32",new Int32Array(it)),m.makeTensorInfo([],"int32",new Int32Array([mt]))]}},_e=e.GDt.nonMaxSuppressionV5Impl,Ce={kernelName:e.W0H,backendName:"webgl",kernelFunc:function me(w){e.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:x,backend:m,attrs:I}=w,{boxes:D,scores:R}=x,{maxOutputSize:B,iouThreshold:k,scoreThreshold:U,softNmsSigma:F}=I,V=m.readSync(D.dataId),st=m.readSync(R.dataId),it=B,mt=k,_t=U,Rt=F,{selectedIndices:$t,selectedScores:Mt}=_e(V,st,it,mt,_t,Rt);return[m.makeTensorInfo([$t.length],"int32",new Int32Array($t)),m.makeTensorInfo([Mt.length],"float32",new Float32Array(Mt))]}};class Oe{constructor(x,m,I,D){this.variableNames=["indices"],this.outputShape=[x,m],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${D}), float(${I}),\n                      float(index == coords.y)));\n      }\n    `}}const fe={kernelName:e.we_,backendName:"webgl",kernelFunc:w=>{const{inputs:x,backend:m,attrs:I}=w,{indices:D}=x,{dtype:R,depth:B,onValue:k,offValue:U}=I,F=e.D5U.sizeFromShape(D.shape),V=new Oe(F,B,k,U),st=Gt({inputs:{x:D},backend:m,attrs:{shape:[F]}}),it=m.runWebGLProgram(V,[st],R);m.disposeIntermediateTensorInfo(st);const _t=Gt({inputs:{x:it},backend:m,attrs:{shape:[...D.shape,B]}});return m.disposeIntermediateTensorInfo(it),_t}};function le(w){const{inputs:x,backend:m}=w,{x:I}=x;if("complex64"===I.dtype){const D=as({inputs:{input:I},backend:m}),R=le({inputs:{x:D},backend:m}),B=Es({inputs:{input:I},backend:m}),k=le({inputs:{x:B},backend:m}),U=p({inputs:{real:R,imag:k},backend:m});return m.disposeIntermediateTensorInfo(D),m.disposeIntermediateTensorInfo(R),m.disposeIntermediateTensorInfo(B),m.disposeIntermediateTensorInfo(k),U}return io({attrs:{shape:I.shape,dtype:I.dtype,value:"string"===I.dtype?"":0},backend:m})}const ce={kernelName:e.RuY,backendName:"webgl",kernelFunc:le},de={kernelName:e.qWM,backendName:"webgl",kernelFunc:function ve(w){const{inputs:x,backend:m}=w,{x:I}=x;if("string"===I.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===I.dtype){const D=as({inputs:{input:I},backend:m}),R=ve({inputs:{x:D},backend:m}),B=Es({inputs:{input:I},backend:m}),k=le({inputs:{x:B},backend:m}),U=p({inputs:{real:R,imag:k},backend:m});return m.disposeIntermediateTensorInfo(D),m.disposeIntermediateTensorInfo(R),m.disposeIntermediateTensorInfo(B),m.disposeIntermediateTensorInfo(k),U}return io({attrs:{shape:I.shape,dtype:I.dtype,value:1},backend:m})}},ye={kernelName:e.QiL,backendName:"webgl",kernelFunc:function ge(w){const{inputs:x,backend:m,attrs:I}=w,{axis:D}=I;if(1===x.length)return Mo({inputs:{input:x[0]},backend:m,attrs:{dim:D}});const R=x[0].shape,B=x[0].dtype;x.forEach(V=>{e.D5U.assertShapesMatch(R,V.shape,"All tensors passed to stack must have matching shapes"),e.D5U.assert(B===V.dtype,()=>"All tensors passed to stack must have matching dtypes")});const k=[],F=go({inputs:x.map(V=>{const st=Mo({inputs:{input:V},backend:m,attrs:{dim:D}});return k.push(st),st}),backend:m,attrs:{axis:D}});return k.forEach(V=>m.disposeIntermediateTensorInfo(V)),F}};class Pe{constructor(x,m,I){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=m.map((F,V)=>F[0]+x[V]+F[1]);const D=x.length,R=(0,f.kW)(D),B=m.map(F=>F[0]).join(","),k=m.map((F,V)=>F[0]+x[V]).join(","),U=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,D);this.userCode=1!==D?`\n      ${R} start = ${R}(${B});\n      ${R} end = ${R}(${k});\n\n      void main() {\n        ${R} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${R} coords = outC - start;\n          setOutput(getX(${U}));\n        }\n      }\n    `:`\n        int start = ${B};\n        int end = ${k};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class $e{constructor(x,m,I){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=m.map((Rt,$t)=>Rt[0]+x[$t]+Rt[1]);const D=x.length,R=(0,f.kW)(D),B=m.map(Rt=>Rt[0]).join(","),k=m.map((Rt,$t)=>Rt[0]+x[$t]).join(","),U=(0,i.Ky)("rc",D),F=(0,i.Ky)("source",D),V=`${U[D-1]} < ${this.outputShape[D-1]}`,st=1===D?"source":`vec2(${F.slice(-2).join()})`,it=[`${R} rc = outputLoc;`,`${U[D-1]} += 1;\n       if(${V}) {\n      `,1===D?"":`}\n       rc = outputLoc;\n       ${U[D-2]} += 1;\n       if(${U[D-2]} < ${this.outputShape[D-2]}) {`,1===D?"":`  ${U[D-1]} += 1;\n         if(${V}) {`],mt=1===D?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let _t="";for(let Rt=0,$t=1===D?2:4;Rt<$t;Rt++)_t+=`\n        ${it[Rt]}\n        if (${mt}) {\n          result[${Rt}] = float(value);\n        } else {\n          ${R} source = rc - start;\n          result[${Rt}] = getChannel(getX(${F.join()}), ${st});\n        }\n      `;_t+=1===D?"} ":"}}",this.userCode=`\n      const ${R} start = ${R}(${B});\n      const ${R} end = ${R}(${k});\n\n      void main() {\n        ${R} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${_t}\n        setOutput(result);\n      }\n    `}}const Me=w=>{const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{paddings:R,constantValue:B}=I;if(0===e.D5U.sizeFromShape(D.shape))return io({backend:m,attrs:{shape:R.map((V,st)=>V[0]+D.shape[st]+V[1]),value:B,dtype:D.dtype}});const k=(0,e.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $e(D.shape,R,B):new Pe(D.shape,R,B);return m.runWebGLProgram(k,[D],D.dtype,[[B]])},Le={kernelName:e.lyA,backendName:"webgl",kernelFunc:Me},Ve=W({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+l+"\n  return result;\n"}),He={kernelName:e.pe_,backendName:"webgl",kernelFunc:Ve},Ze={kernelName:e.DlI,backendName:"webgl",kernelFunc:function ze(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{axis:R,keepDims:B}=I,k=D.shape.length,U=[],F=e.D5U.parseAxisParam(R,D.shape);let V=F;const st=e.backend_util.getAxesPermutation(V,k);let mt,it=D;if(null!=st&&(it=dt({inputs:{x:D},backend:m,attrs:{perm:st}}),V=e.backend_util.getInnerMostAxes(V.length,k),U.push(it)),e.backend_util.assertAxesAreInnerMostDims("prod",V,k),m.shouldExecuteOnCPU([it])){const _t=m.texData.get(it.dataId).values,{outVals:Rt,outShape:$t,outDtype:Mt}=(0,Y.Tg)(it.shape,it.dtype,_t,V);mt=m.makeTensorInfo($t,Mt,Rt)}else{const[_t,Rt]=e.backend_util.computeOutAndReduceShapes(it.shape,V),$t=e.D5U.sizeFromShape(Rt),Mt=Gt({inputs:{x:it},backend:m,attrs:{shape:[-1,$t]}}),De=Zt(Mt,(0,e.z4k)(D.dtype),"prod",m);mt=Gt({inputs:{x:De},backend:m,attrs:{shape:_t}}),U.push(Mt),U.push(De)}if(B){U.push(mt);const _t=e.backend_util.expandShapeToKeepDim(mt.shape,F);mt=Gt({inputs:{x:mt},backend:m,attrs:{shape:_t}})}return U.forEach(_t=>m.disposeIntermediateTensorInfo(_t)),mt}},un={kernelName:e.dDz,backendName:"webgl",kernelFunc:function qe(w){const{inputs:x,backend:m,attrs:I}=w,{paramsNestedSplits:D,paramsDenseValues:R,indices:B}=x,{outputRaggedRank:k}=I,U=D.map(Mt=>m.readSync(Mt.dataId)),F=D.map(Mt=>Mt.shape),V=m.readSync(R.dataId),st=m.readSync(B.dataId),[it,mt,_t]=(0,Y.Qs)(U,F,V,R.shape,R.dtype,st,B.shape,k),Rt=it.map(Mt=>m.makeTensorInfo([Mt.length],"int32",Mt)),$t=m.makeTensorInfo(_t,R.dtype,mt);return Rt.concat([$t])}},xn={kernelName:e.CQl,backendName:"webgl",kernelFunc:function pn(w){const{inputs:x,backend:m}=w,{starts:I,limits:D,deltas:R}=x,B=m.readSync(I.dataId),k=m.readSync(D.dataId),U=m.readSync(R.dataId),[F,V]=(0,Y.M8)(B,I.shape,I.dtype,k,D.shape,U,R.shape);return[m.makeTensorInfo([F.length],"int32",F),m.makeTensorInfo([V.length],I.dtype,V)]}},cn={kernelName:e.BiW,backendName:"webgl",kernelFunc:function fn(w){const{inputs:x,backend:m,attrs:I}=w,{shape:D,values:R,defaultValue:B,rowPartitionTensors:k}=x,{rowPartitionTypes:U}=I,F=m.readSync(D.dataId),V=m.readSync(R.dataId),st=m.readSync(B.dataId),it=k.map($t=>m.readSync($t.dataId)),mt=k.map($t=>$t.shape),[_t,Rt]=(0,Y.fy)(F,D.shape,V,R.shape,R.dtype,st,B.shape,it,mt,U);return m.makeTensorInfo(_t,R.dtype,Rt)}},gn=w=>{const{backend:x,attrs:m}=w,{start:I,stop:D,step:R,dtype:B}=m,k=(0,Y.hO)(I,D,R,B);return x.makeTensorInfo([k.length],B,k)},_n={kernelName:e.e6w,backendName:"webgl",kernelFunc:gn},Tn=$({opSnippet:"return 1.0 / x;"}),Jn={kernelName:e.$HU,backendName:"webgl",kernelFunc:Tn},Un=$({opSnippet:O.D1+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),jn={kernelName:e.qkr,backendName:"webgl",kernelFunc:Un},ts=$({opSnippet:O.D1+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),uo={kernelName:e.SbG,backendName:"webgl",kernelFunc:ts};class ur{constructor(x,m,I,D,R){this.variableNames=["A"],this.outputShape=[];const[B,k,U,F]=x;this.outputShape=[B,m,I,F];const V=[D&&m>1?k-1:k,D&&I>1?U-1:U],st=[D&&m>1?m-1:m,D&&I>1?I-1:I];let it;it=R?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${V[0]/st[0]},\n          ${V[1]/st[1]});\n      const vec2 inputShapeRC = vec2(${k}.0, ${U}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${it};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class cr{constructor(x,m,I,D,R){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[B,k,U,F]=x;this.outputShape=[B,m,I,F];const V=[D&&m>1?k-1:k,D&&I>1?U-1:U],st=[D&&m>1?m-1:m,D&&I>1?I-1:I];let it;it=R?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${V[0]/st[0]},\n          ${V[1]/st[1]},\n          ${V[1]/st[1]});\n      const vec3 inputShapeRC = vec3(${k}.0, ${U}.0,\n                                     ${U}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${it};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${F-1};\n        bool hasNextRow = coords.z < ${I-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const To={kernelName:e._Yw,backendName:"webgl",kernelFunc:function Li(w){const{inputs:x,backend:m,attrs:I}=w,{images:D}=x,{alignCorners:R,halfPixelCenters:B,size:k}=I,[U,F]=k,V=(0,e.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new cr(D.shape,U,F,R,B):new ur(D.shape,U,F,R,B);return m.runWebGLProgram(V,[D],"float32")}};class Ni{constructor(x,m,I){this.variableNames=["dy"],this.outputShape=[],this.outputShape=m;const[,D,R]=m,[,B,k]=x,U=[I&&B>1?D-1:D,I&&k>1?R-1:R],F=[I&&B>1?B-1:B,I&&k>1?k-1:k],V=U[0]/F[0],st=U[1]/F[1],it=1/V,mt=1/st,_t=2*Math.ceil(it)+2,Rt=2*Math.ceil(mt)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${V});\n        const float widthScale = float(${st});\n\n        const float invHeightScale = float(${it});\n        const float invWidthScale = float(${mt});\n\n        const int winHeight = int(${_t});\n        const int winWidth = int(${Rt});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${B}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${k}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${D-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${R-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const _l={kernelName:e.zbQ,backendName:"webgl",kernelFunc:function Ui(w){const{inputs:x,backend:m,attrs:I}=w,{images:D,dy:R}=x,{alignCorners:B}=I,k=new Ni(R.shape,D.shape,B);return m.runWebGLProgram(k,[R],R.dtype)}};class El{constructor(x,m,I,D,R){this.variableNames=["A"],this.outputShape=[];const[B,k,U,F]=x;this.outputShape=[B,m,I,F];const V=[D&&m>1?k-1:k,D&&I>1?U-1:U],st=[D&&m>1?m-1:m,D&&I>1?I-1:I];let mt;mt=R?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${V[0]/st[0]},\n          ${V[1]/st[1]});\n      const vec2 inputShapeRC = vec2(${k}.0, ${U}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${mt};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${D?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class xl{constructor(x,m,I,D,R){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[B,k,U,F]=x;this.outputShape=[B,m,I,F];const V=[D&&m>1?k-1:k,D&&I>1?U-1:U],st=[D&&m>1?m-1:m,D&&I>1?I-1:I];let mt;mt=R?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${V[0]/st[0]},\n          ${V[1]/st[1]},\n          ${V[1]/st[1]});\n      const vec3 inputShapeRC = vec3(${k}.0, ${U}.0,\n                                     ${U}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${mt};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${D?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${F-1};\n        bool hasNextRow = coords.z < ${I-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const vl={kernelName:e.dpD,backendName:"webgl",kernelFunc:function Dl(w){const{inputs:x,backend:m,attrs:I}=w,{images:D}=x,{alignCorners:R,halfPixelCenters:B,size:k}=I,[U,F]=k,V=(0,e.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new xl(D.shape,U,F,R,B):new El(D.shape,U,F,R,B);return m.runWebGLProgram(V,[D],D.dtype)}};class Cl{constructor(x,m,I){this.variableNames=["dy"],this.outputShape=[],this.outputShape=m;const[,D,R]=m,[,B,k]=x,U=[I&&B>1?D-1:D,I&&k>1?R-1:R],F=[I&&B>1?B-1:B,I&&k>1?k-1:k],V=U[0]/F[0],st=U[1]/F[1],it=1/V,mt=1/st,_t=2*Math.ceil(it)+2,Rt=2*Math.ceil(mt)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${V});\n        const float widthScale = float(${st});\n\n        const float invHeightScale = float(${it});\n        const float invWidthScale = float(${mt});\n\n        const int winHeight = int(${_t});\n        const int winWidth = int(${Rt});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${B}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${k}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${U[0]}) *\n                (float(dyR) / float(${F[0]}));\n\n            float sourceFracCol =\n                float(${U[1]}) *\n                  (float(dyC) / float(${F[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${D}) - 1),\n                ${I} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${R}) - 1),\n                ${I} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Ol={kernelName:e.Hmb,backendName:"webgl",kernelFunc:function Il(w){const{inputs:x,backend:m,attrs:I}=w,{images:D,dy:R}=x,{alignCorners:B}=I,k=new Cl(R.shape,D.shape,B);return m.runWebGLProgram(k,[R],R.dtype)}};class Pl{constructor(x,m){this.variableNames=["x"];const I=x.length;if(I>4)throw new Error(`WebGL backend: Reverse of rank-${I} tensor is not yet supported`);if(this.outputShape=x,1===I)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${x[0]} - coord - 1));\n        }\n      `);const R=x.map((k,U)=>(k=>-1!==m.indexOf(k)&&1!==x[k]?`${x[k]} - coords[${k}] - 1`:`coords[${k}]`)(U)).join(","),B=(0,f.kW)(I);this.userCode=`\n      void main() {\n        ${B} coords = getOutputCoords();\n        setOutput(getX(${R}));\n      }\n    `}}class Ml{constructor(x,m){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const I=x.length;if(I>4)throw new Error(`WebGL backend: Reverse of rank-${I} tensor is not yet supported`);this.outputShape=x;const D=(0,i.Ky)("rc",I),R=`${D[I-1]} + 1 < ${this.outputShape[I-1]}`,B=`${D[I-2]} + 1 < ${this.outputShape[I-2]}`,k=(0,f.kW)(I);function it(_t){const Rt=x.map((Ft,De)=>function mt(_t,Rt){return-1!==m.indexOf(_t)&&1!==x[_t]?`${x[_t]} - ${Rt[_t]} - 1`:`${Rt[_t]}`}(De,_t));return`getChannel(getX(${Rt.join(",")}), vec2(${Rt.slice(-2).join(",")}))`}this.userCode=1===I?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${x[0]} - rc - 1),\n            ${x[0]} - rc - 1);\n          if(${R}){\n              result.g = getChannel(getX(${x[0]} - (rc  + 1) - 1),\n                ${x[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${k} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function U(_t){return it(_t)}(D.slice())};\n          if(${R}){\n            result.g = ${function F(_t){return _t[I-1]="("+_t[I-1]+" + 1)",it(_t)}(D.slice())};\n          }\n          if(${B}) {\n            result.b = ${function V(_t){return _t[I-2]="("+_t[I-2]+" + 1)",it(_t)}(D.slice())};\n            if(${R}) {\n              result.a = ${function st(_t){return _t[I-1]="("+_t[I-1]+" + 1)",_t[I-2]="("+_t[I-2]+" + 1)",it(_t)}(D.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const yl={kernelName:e.mKl,backendName:"webgl",kernelFunc:function Tl(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{dims:R}=I,B=D.shape.length,k=e.D5U.parseAxisParam(R,D.shape);if(0===B)return r({inputs:{x:D},backend:m});const U=(0,e.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ml(D.shape,k):new Pl(D.shape,k);return m.runWebGLProgram(U,[D],D.dtype)}};class Rl{constructor(x,m){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const I=x[1],D=x[2];this.outputShape=x;let R="";R="number"==typeof m?`float outputValue = ${m.toFixed(2)};`:`\n        vec3 fill = vec3(${m.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${R}\n          if(coordX >= 0 && coordX < ${D} && coordY >= 0 && coordY < ${I}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Al={kernelName:e.b9H,backendName:"webgl",kernelFunc:({inputs:w,attrs:x,backend:m})=>{const{image:I}=w,{radians:D,fillValue:R,center:B}=x,k=m,U=new Rl(I.shape,R),[F,V]=e.backend_util.getImageCenter(B,I.shape[1],I.shape[2]),st=[[F,V,Math.sin(D),Math.cos(D)]];return k.runWebGLProgram(U,[I],I.dtype,st)}},Sl=$({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),bl={kernelName:e.e07,backendName:"webgl",kernelFunc:Sl},$l=$({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Y.St}),Bl={kernelName:e.bV0,backendName:"webgl",kernelFunc:$l};class Wi{constructor(x,m,I,D,R,B,k=!0,U=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=B;const F=(0,f.kW)(R.length),V=(0,f.kW)(B.length);let st="";1===I?st="i":2===I&&(st="i, j");let mt="";1===D?mt="i":2===D&&(mt="i, coords[1]");let Rt="";U&&(Rt="coords[0], coords[1]"),this.userCode=`\n        ${F} strides = ${F}(${R});\n\n        void main() {\n          ${V} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${x}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${m}; j++) {\n              int index = round(getIndices(${st}));\n              flattenedIndex += index * ${m>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${mt});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${Rt}), sum, float(found)));\n        }\n      `}}class Ll{constructor(x,m,I,D,R,B,k=!0,U=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=B;const F=(0,f.kW)(R.length),V=(0,f.kW)(B.length);let st="";1===I?st="i":2===I&&(st="i, j");let mt="";1===D?mt="i":2===D&&(mt="i, coords[1]");let Rt="";U&&(Rt="coords[0], coords[1]"),this.userCode=`\n        ${F} strides = ${F}(${R});\n\n        void main() {\n          ${V} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${x}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${m}; j+=2) {\n              ivec4 index = round(getIndices(${st}));\n              flattenedIndex += index.xz * ${m>1?"strides[j]":"strides"};\n              if (j + 1 < ${m}) {\n                flattenedIndex += index.yw * ${m>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${mt});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${Rt}), sum, found));\n        }\n      `}}const Ul={kernelName:e.xQA,backendName:"webgl",kernelFunc:function Nl(w){const{inputs:x,backend:m,attrs:I}=w,{indices:D,updates:R}=x,{shape:B}=I,{sliceRank:k,numUpdates:U,sliceSize:F,strides:V,outputSize:st}=e.backend_util.calculateShapes(R,D,B),it=[st/F,F];if(0===st)return m.makeTensorInfo(B,D.dtype);const mt=Gt({inputs:{x:D},backend:m,attrs:{shape:[U,k]}}),_t=Gt({inputs:{x:R},backend:m,attrs:{shape:[U,F]}}),Rt=m.makeTensorInfo([],"float32",new Float32Array([0]));let $t;$t=(0,e.OBj)().getBool("WEBGL_PACK")?new Ll(U,k,mt.shape.length,_t.shape.length,V,it):new Wi(U,k,mt.shape.length,_t.shape.length,V,it);const Mt=m.runWebGLProgram($t,[_t,mt,Rt],_t.dtype),Ft=Gt({inputs:{x:Mt},backend:m,attrs:{shape:B}});return m.disposeIntermediateTensorInfo(mt),m.disposeIntermediateTensorInfo(_t),m.disposeIntermediateTensorInfo(Mt),m.disposeIntermediateTensorInfo(Rt),Ft}};class Wl{constructor(x,m,I,D){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[x,I];const B=`for (int i = 0; i < ${Math.ceil(Math.log2(m+1))}; ++i) { if (left >= right) break;`,k=2===(0,e.OBj)().getNumber("WEBGL_VERSION")?"while (left < right) {":B;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${k}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===D?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const wl={kernelName:e.nr8,backendName:"webgl",kernelFunc:function kl(w){const{inputs:x,backend:m,attrs:I}=w,{sortedSequence:D,values:R}=x,{side:B}=I,k=new Wl(D.shape[0],D.shape[1],R.shape[1],B);return m.runWebGLProgram(k,[D,R],"int32",[[D.shape[1]]])}};class Fl{constructor(x,m,I){let D,R;if(this.variableNames=["c","a","b"],this.outputShape=m,I>4)throw Error(`Where for rank ${I} is not yet supported`);if(1===I)R="resRC",D="resRC";else{const k=["resRC.x","resRC.y","resRC.z","resRC.w"],U=[],F=[];for(let V=0;V<m.length;V++)F.push(`${k[V]}`),V<x&&U.push(`${k[V]}`);D=U.join(),R=F.join()}const B=(0,f.kW)(I);this.userCode=`\n      void main() {\n        ${B} resRC = getOutputCoords();\n        float cVal = getC(${D});\n        if (cVal >= 1.0) {\n          setOutput(getA(${R}));\n        } else {\n          setOutput(getB(${R}));\n        }\n      }\n    `}}const Vl={kernelName:e.PhF,backendName:"webgl",kernelFunc:function Kl(w){const{inputs:x,backend:m}=w,{condition:I,t:D,e:R}=x,B=new Fl(I.shape.length,D.shape,D.shape.length);return m.runWebGLProgram(B,[I,D,R],(0,e.x8V)(D.dtype,R.dtype))}},Gl=$({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${e.backend_util.SELU_SCALEALPHA};\n  float scale = ${e.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),Hl={kernelName:e.oFR,backendName:"webgl",kernelFunc:Gl},Xl=$({opSnippet:E+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Y.UN}),Yl={kernelName:e.a5O,backendName:"webgl",kernelFunc:Xl},Zl=$({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Ql={kernelName:e.i5y,backendName:"webgl",kernelFunc:Zl},tu=$({opSnippet:E+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${l}\n  return result;\n`}),eu={kernelName:e.RQH,backendName:"webgl",kernelFunc:tu},nu=$({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),su={kernelName:e.wYB,backendName:"webgl",kernelFunc:nu},ou=$({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),ru={kernelName:e.MRv,backendName:"webgl",kernelFunc:ou},iu={kernelName:e.TQc,backendName:"webgl",kernelFunc:w=>{const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{blockShape:R,paddings:B}=I;e.D5U.assert(D.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const k=R.reduce((Mt,Ft)=>Mt*Ft),U=[[0,0]];U.push(...B);for(let Mt=1+R.length;Mt<D.shape.length;++Mt)U.push([0,0]);const F=[],V=Me({inputs:{x:D},backend:m,attrs:{paddings:U,constantValue:0}}),st=e.backend_util.getReshaped(V.shape,R,k,!1),it=e.backend_util.getPermuted(st.length,R.length,!1),mt=e.backend_util.getReshapedPermuted(V.shape,R,k,!1),_t=Gt({inputs:{x:V},backend:m,attrs:{shape:st}}),Rt=dt({inputs:{x:_t},backend:m,attrs:{perm:it}}),$t=Gt({inputs:{x:Rt},backend:m,attrs:{shape:mt}});return F.push(V),F.push(_t),F.push(Rt),F.forEach(Mt=>m.disposeIntermediateTensorInfo(Mt)),$t}},uu={kernelName:e.O3z,backendName:"webgl",kernelFunc:function lu(w){const{inputs:x,backend:m}=w,{indices:I,values:D,denseShape:R,defaultValue:B}=x;if(1!==R.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${R.shape}`);if(2!==I.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${I.shape}`);if(1!==D.shape.length)throw new Error(`Values must be a vector, saw:\n         ${D.shape}`);if(0!==B.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${B.shape}`);const k=m.readSync(I.dataId),U=m.readSync(D.dataId),F=m.readSync(R.dataId),V=m.readSync(B.dataId)[0],[st,it,mt,_t,Rt]=(0,Y.X8)(k,I.shape,I.dtype,U,D.dtype,F,V);return[m.makeTensorInfo(it,I.dtype,st),m.makeTensorInfo([it[0]],D.dtype,mt),m.makeTensorInfo([_t.length],"bool",new Uint8Array(_t.map($t=>Number($t)))),m.makeTensorInfo([Rt.length],I.dtype,new Int32Array(Rt))]}},du={kernelName:e.nhH,backendName:"webgl",kernelFunc:function cu(w){const{inputs:x,backend:m}=w,{inputIndices:I,inputShape:D,newShape:R}=x;if(2!==I.shape.length)throw new Error(`Input indices should be a matrix but received shape ${I.shape}`);if(1!==D.shape.length)throw new Error(`Input shape should be a vector but received shape ${D.shape}`);if(1!==R.shape.length)throw new Error(`Target shape should be a vector but received shape ${R.shape}`);const B=Array.from(m.readSync(D.dataId)),k=m.readSync(I.dataId),U=Array.from(m.readSync(R.dataId)),[F,V,st]=(0,Y.LS)(k,I.shape,I.dtype,B,U);return[m.makeTensorInfo(V,I.dtype,F),m.makeTensorInfo([st.length],R.dtype,new Int32Array(st))]}},pu={kernelName:e.w3H,backendName:"webgl",kernelFunc:function hu(w){const{inputs:x,backend:m}=w,{data:I,indices:D,segmentIds:R}=x;if(I.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==D.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${D.shape}`);if(1!==R.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${R.shape}`);const B=m.readSync(I.dataId),k=m.readSync(D.dataId),U=m.readSync(R.dataId),[F,V]=(0,Y.AR)(B,I.shape,I.dtype,k,U,!0);return m.makeTensorInfo(V,I.dtype,F)}},mu={kernelName:e.ZjV,backendName:"webgl",kernelFunc:function fu(w){const{inputs:x,backend:m}=w,{data:I,indices:D,segmentIds:R}=x;if(I.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==D.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${D.shape}`);if(1!==R.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${R.shape}`);const B=m.readSync(I.dataId),k=m.readSync(D.dataId),U=m.readSync(R.dataId),[F,V]=(0,Y.AR)(B,I.shape,I.dtype,k,U);return m.makeTensorInfo(V,I.dtype,F)}},_u={kernelName:e.D2d,backendName:"webgl",kernelFunc:function gu(w){const{inputs:x,backend:m,attrs:I}=w,{sparseIndices:D,sparseValues:R,defaultValue:B}=x,{outputShape:k}=I,{sliceRank:U,numUpdates:F,sliceSize:V,strides:st,outputSize:it}=e.backend_util.calculateShapes(R,D,k);if("string"===R.dtype){const Mt=m.bufferSync(D),Ft=m.bufferSync(R),De=e.D5U.decodeString(m.readSync(B.dataId)[0]),he=(0,Y.Y1)(Mt,Ft,k,it,V,F,U,st,De,!1);return m.makeTensorInfo(k,he.dtype,he.values)}const _t=new Wi(F,U,D.shape.length,R.shape.length,st,[it,1],!1),Rt=m.runWebGLProgram(_t,[R,D,B],R.dtype),$t=Gt({inputs:{x:Rt},backend:m,attrs:{shape:k}});return m.disposeIntermediateTensorInfo(Rt),$t}},xu={kernelName:e.L8s,backendName:"webgl",kernelFunc:function Eu(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{numOrSizeSplits:R,axis:B}=I,k=e.D5U.parseAxisParam(B,D.shape)[0],U=e.backend_util.prepareSplitSize(D,R,k),V=new Array(D.shape.length).fill(0),st=D.shape.slice();return U.map(it=>{const mt=[...st];mt[k]=it;const _t=Kn({inputs:{x:D},backend:m,attrs:{begin:V,size:mt}});return V[k]+=it,_t})}},hl="return sqrt(x);",Du=$({opSnippet:hl,packedOpSnippet:hl,cpuKernelImpl:Y.Bk}),vu={kernelName:e.FKq,backendName:"webgl",kernelFunc:Du},Cu=$({opSnippet:"return x * x;"}),Iu={kernelName:e.bK0,backendName:"webgl",kernelFunc:Cu},pl="return (a - b) * (a - b);",Ou=W({opSnippet:pl,packedOpSnippet:pl}),Pu={kernelName:e._tC,backendName:"webgl",kernelFunc:Ou},Tu={kernelName:e.e0R,backendName:"webgl",kernelFunc:function Mu(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x;if("string"!==D.dtype)throw new Error("Input must be of datatype string");const R=m.readSync(D.dataId),B=e.backend_util.fromUint8ToStringArray(R),k=(0,Y.F1)(B,"string",I);return m.makeTensorInfo(D.shape,"string",k)}},Ru={kernelName:e.h8e,backendName:"webgl",kernelFunc:function yu({inputs:w,attrs:x,backend:m}){const{x:I}=w,R=new O.l(I.shape,O.D1+`\n    return x > 0.0 ? 1.0 : float(${x.alpha});\n  `);return m.runWebGLProgram(R,[I],I.dtype)}};class Au{constructor(x,m,I){this.variableNames=["x"],this.outputShape=I;const D=I.length,R=(0,f.kW)(I.length),B=(0,f.kW)(I.length);let k="";if(1===D)k="coords * strides + begin";else{let U=0;k=I.map((F,V)=>(U++,1===I.length?`coords * strides[${V}] + begin[${V}]`:`coords[${U-1}] * strides[${V}] + begin[${V}]`)).join(",")}this.userCode=`\n      ${R} begin = ${R}(${x});\n      ${R} strides = ${R}(${m});\n\n      void main() {\n        ${B} coords = getOutputCoords();\n        setOutput(getX(${k}));\n      }\n    `}}const bu={kernelName:e.jQk,backendName:"webgl",kernelFunc:function Su(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{begin:R,end:B,strides:k,beginMask:U,endMask:F,ellipsisMask:V,newAxisMask:st,shrinkAxisMask:it}=I,{finalShapeSparse:mt,finalShape:_t,isIdentity:Rt,sliceDim0:$t,isSimpleSlice:Mt,begin:Ft,end:De,strides:he}=e.kuN.sliceInfo(D.shape,R,B,k,U,F,V,st,it);let Ne;if(Rt)Ne=Gt({inputs:{x:D},backend:m,attrs:{shape:_t}});else if($t||Mt){e.D5U.assert(D.shape.length>=1,()=>`Input must have rank at least 1, got: ${D.shape.length}`);const je=e.kuN.computeOutShape(Ft,De,he),Fe=Kn({inputs:{x:D},backend:m,attrs:{begin:Ft,size:je}});Ne=Gt({inputs:{x:Fe},backend:m,attrs:{shape:_t}}),m.disposeIntermediateTensorInfo(Fe)}else if(m.shouldExecuteOnCPU([D])){const Fe=m.readSync(D.dataId),sn=(0,e.f3b)(D.shape,D.dtype,Fe),Qe=(0,Y.$u)(mt,sn,he,Ft);Ne=m.makeTensorInfo(_t,D.dtype,Qe.values)}else{const Fe=new Au(Ft,he,mt);Ne=m.runWebGLProgram(Fe,[D],D.dtype)}const Ye=Gt({inputs:{x:Ne},backend:m,attrs:{shape:_t}});return m.disposeIntermediateTensorInfo(Ne),Ye}},Bu={kernelName:e._JP,backendName:"webgl",kernelFunc:function $u(w){const{inputs:x,backend:m,attrs:I}=w,{separator:D,nGramWidths:R,leftPad:B,rightPad:k,padWidth:U,preserveShortSequences:F}=I,{data:V,dataSplits:st}=x,it=m.readSync(V.dataId),mt=m.readSync(st.dataId),[_t,Rt]=(0,Y.$j)(it,mt,D,R,B,k,U,F);return[m.makeTensorInfo([_t.length],"string",_t),m.makeTensorInfo(st.shape,"int32",Rt)]}},Nu={kernelName:e.s1s,backendName:"webgl",kernelFunc:function Lu(w){const{inputs:x,backend:m,attrs:I}=w,{skipEmpty:D}=I,{input:R,delimiter:B}=x;if("string"!==R.dtype)throw new Error("Input must be of datatype string");if(1!==R.shape.length)throw new Error(`Input must be a vector, got shape: ${R.shape}`);if(0!==B.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${B.shape}`);const k=m.readSync(R.dataId),U=m.readSync(B.dataId)[0],[F,V,st]=(0,Y.A0)(k,U,D),it=V.length;return[m.makeTensorInfo([it,2],"int32",F),m.makeTensorInfo([it],"string",V),m.makeTensorInfo([2],"int32",new Int32Array(st))]}},Wu={kernelName:e.XkS,backendName:"webgl",kernelFunc:function Uu(w){const{inputs:x,backend:m,attrs:I}=w,{numBuckets:D}=I,{input:R}=x;if("string"!==R.dtype)throw new Error("Input must be of datatype string");if(D<=0)throw new Error("Number of buckets must be at least 1");const B=m.readSync(R.dataId),k=(0,Y._9)(B,D);return m.makeTensorInfo(R.shape,"int32",k)}},ku=$({opSnippet:"return tan(x);"}),wu={kernelName:e.sEM,backendName:"webgl",kernelFunc:ku},Fu=$({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Ku={kernelName:e.MIZ,backendName:"webgl",kernelFunc:Fu},zu={kernelName:e.SIB,backendName:"webgl",kernelFunc:function Vu(w){const{inputs:x,backend:m}=w,{tensor:D,indices:R,updates:B}=x,{sliceRank:k,numUpdates:U,sliceSize:F,strides:V,outputSize:st}=e.backend_util.calculateShapes(B,R,D.shape),it=[st/F,F];if(0===st)return m.makeTensorInfo(D.shape,R.dtype);const mt=Gt({inputs:{x:R},backend:m,attrs:{shape:[U,k]}}),_t=Gt({inputs:{x:B},backend:m,attrs:{shape:[U,F]}}),Rt=Gt({inputs:{x:D},backend:m,attrs:{shape:it}}),$t=new Wi(U,k,mt.shape.length,_t.shape.length,V,it,!1,!0),Mt=m.runWebGLProgram($t,[_t,mt,Rt],Rt.dtype),Ft=Gt({inputs:{x:Mt},backend:m,attrs:{shape:D.shape}});return m.disposeIntermediateTensorInfo(mt),m.disposeIntermediateTensorInfo(_t),m.disposeIntermediateTensorInfo(Rt),m.disposeIntermediateTensorInfo(Mt),Ft}};class Gu{constructor(x,m){this.variableNames=["A"];const I=new Array(x.length);for(let B=0;B<I.length;B++)I[B]=x[B]*m[B];this.outputShape=I,this.rank=I.length;const D=(0,f.kW)(this.rank),R=function Hu(w){const x=w.length;if(x>5)throw Error(`Tile for rank ${x} is not yet supported`);if(1===x)return`imod(resRC, ${w[0]})`;const m=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],I=[];for(let D=0;D<w.length;D++)I.push(`imod(${m[D]}, ${w[D]})`);return I.join()}(x);this.userCode=`\n      void main() {\n        ${D} resRC = getOutputCoords();\n        setOutput(getA(${R}));\n      }\n    `}}function fl(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{reps:R}=I;if("string"===D.dtype||D.shape.length>5){const U=m.readSync(D.dataId),F="string"===D.dtype?U.map(it=>e.D5U.decodeString(it)):U,V=(0,e.f3b)(D.shape,D.dtype,F),st=(0,Y.KX)(V,R);return m.makeTensorInfo(st.shape,st.dtype,st.values)}const B=new Gu(D.shape,R);return m.runWebGLProgram(B,[D],D.dtype)}const ju={kernelName:e.n9L,backendName:"webgl",kernelFunc:fl};class Xu{constructor(x){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=x,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Yu{constructor(x){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=x,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function co(w,x){null!==x&&w.disposeIntermediateTensorInfo(x)}function ml(w){let x=1;for(;x<w;)x*=2;return x}const Qu={kernelName:e.cWu,backendName:"webgl",kernelFunc:function Zu(w){const{inputs:x,backend:m,attrs:I}=w,{x:D}=x,{k:R,sorted:B}=I,k=(0,e.OBj)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),U=(0,e.OBj)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),F=D.shape,V=F[F.length-1];if(m.shouldExecuteOnCPU([D])||V<k||R>U){const Qe=m.readSync(D.dataId),[Cn,In]=(0,Y.oC)(Qe,F,D.dtype,R,B);return[m.makeTensorInfo(Cn.shape,Cn.dtype,Cn.values),m.makeTensorInfo(In.shape,In.dtype,In.values)]}if(0===R)return F[F.length-1]=0,[m.makeTensorInfo(F,D.dtype,[]),m.makeTensorInfo(F,"int32",[])];if(1===V)return[D,io({attrs:{shape:F,dtype:"int32",value:0},backend:m})];const st=m.texData.get(D.dataId),it=null!==st&&st.isPacked,mt=it?m.unpackTensor(D):D,Rt=e.D5U.sizeFromShape(F)/V,$t=Gt({inputs:{x:mt},attrs:{shape:[Rt,V]},backend:m});it&&co(m,mt);const Mt=ml(R),Ft=ml(V);let De=null;const he=()=>null===De?[$t,$t]:[$t,De],Ne=(Qe,Cn,In)=>{const es=he(),Nn=new Xu(In),Xn=De;De=m.runWebGLProgram(Nn,es,"int32",[[V],[null===De?1:0],[Number.NEGATIVE_INFINITY],[Qe],[Cn]]),co(m,Xn)};for(let Qe=1;Qe<Mt;Qe*=2){const Cn=2*Qe;for(let In=Qe;In>=1;In/=2)Ne(Cn,In,[Rt,Ft])}for(let Qe=Ft;Qe>Mt;Qe/=2){const Cn=he(),In=new Yu([Rt,Qe/2]),Wn=De;De=m.runWebGLProgram(In,Cn,"int32",[[V],[null===De?1:0],[Mt]]),co(m,Wn);const zn=Mt/2,Xn=2*zn;for(let bn=zn;bn>=1;bn/=2)Ne(Xn,bn,De.shape)}let Ye=De;De=Kn({inputs:{x:De},backend:m,attrs:{begin:0,size:[Rt,R]}}),co(m,Ye);let je=Dr({inputs:{x:$t,indices:De},backend:m,attrs:{axis:1,batchDims:1}});co(m,$t);const Fe=F.slice(0,-1);Fe.push(R),Ye=De,De=Gt({inputs:{x:De},attrs:{shape:Fe},backend:m}),co(m,Ye);const sn=je;return je=Gt({inputs:{x:je},attrs:{shape:Fe},backend:m}),co(m,sn),[je,De]}};class Ju{constructor(x,m,I,D,R,B){this.variableNames=["Image","Transforms"],this.outputShape=B;const k="nearest"===I?1:2;let U;switch(D){case"constant":default:U=1;break;case"reflect":U=2;break;case"wrap":U=3;break;case"nearest":U=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${U} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${U} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${U} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${x} && 0 <= coordX && coordX < ${m}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${R});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${R});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${m}));\n                float mapY = mapCoord(inY, float(${x}));\n\n                if (${k} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const tc={kernelName:e.wx7,backendName:"webgl",kernelFunc:function qu(w){const{inputs:x,backend:m,attrs:I}=w,{image:D,transforms:R}=x,{interpolation:B,fillMode:k,fillValue:U,outputShape:F}=I,[V,st,it,mt]=D.shape,[_t,Rt]=F??[st,it],Mt=new Ju(st,it,B,k,U,[V,_t,Rt,mt]);return m.runWebGLProgram(Mt,[D,R],"float32")}},nc={kernelName:e.kpP,backendName:"webgl",kernelFunc:function ec(w){const{inputs:x,attrs:m,backend:I}=w,{axis:D}=m,{x:R}=x;(0,Nt.assertNotComplex)(R,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const B=I.readSync(R.dataId),{outputValues:k,outputShape:U,indices:F}=(0,Y.CV)(B,D,R.shape,R.dtype);return[I.makeTensorInfo(U,R.dtype,k),I.makeTensorInfo([F.length],"int32",F)]}},oc={kernelName:e.ToN,backendName:"webgl",kernelFunc:function sc(w){const{inputs:x,backend:m,attrs:I}=w,{value:D}=x;let{axis:R}=I;R<0&&(R+=D.shape.length);const B=D,k=B.shape.length,U=D.shape[R],F=new Array(k-1);let V=0;for(let Rt=0;Rt<k;Rt++)Rt!==R&&(F[V++]=B.shape[Rt]);const st=[],it=new Array(k).fill(0),mt=B.shape.slice();mt[R]=1;const _t=new Array(U);for(let Rt=0;Rt<_t.length;Rt++){it[R]=Rt;const $t=Kn({inputs:{x:B},backend:m,attrs:{begin:it,size:mt}}),Mt=Gt({inputs:{x:$t},backend:m,attrs:{shape:F}});_t[Rt]=Mt,st.push($t)}return st.forEach(Rt=>m.disposeIntermediateTensorInfo(Rt)),_t}};class rc{constructor(x,m){this.variableNames=["x","segmentIds"];const I=x.windowSize,D=x.batchSize,R=x.inSize,B=x.numSegments,k=B*Math.ceil(R/I);this.outputShape=[D,k];const V=4*Math.floor(I/4),st=I%4,it="\n        sumValue += dot(values, segFilter);\n    ";let mt="";R%I>0&&(mt=`\n        if (inIdx < 0 || inIdx >= ${R}) {\n          return initializationValue;\n        }\n      `);let _t="";R%I>0&&(_t=`\n        if (inIdx < 0 || inIdx >= ${R}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${mt}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${_t}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${B})) * float(${I}));\n        int currentSeg = int(mod(float(outIdx), float(${B})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${V}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${it}\n        }\n\n        int inIdx = inOffset + ${V};\n        if (${1===st}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${it}\n        } else if (${2===st}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${it}\n        } else if (${3===st}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${it}\n        }\n        setOutput(sumValue);\n      }\n    `}}const lc=[Re,we,Je,mn,ns,Qt,Ue,rn,Ln,kn,ss,Ms,Gn,bs,Ls,Ns,Ws,Ks,os,zs,js,Ge,En,Ao,So,gs,Uo,mo,g,ko,_o,Ho,Jo,er,sr,St,yt,Ht,Xe,ln,Dn,or,rr,Mr,yr,br,Br,Ur,wr,Fr,Vr,jr,Yr,Jr,qr,ta,ea,sa,ra,ia,ua,da,ma,Ea,Da,Ia,Pa,Ta,Ra,d,Sa,Ko,$a,La,vr,T,Ua,ka,Fa,Va,Ha,Xa,Za,Ja,ni,ri,ii,di,pi,mi,xi,Or,Ci,Oi,Pi,Ri,$i,A,Ot,pt,Bt,zt,pe,Ce,bo,fe,de,ye,Le,He,N,Ze,un,xn,cn,_n,$o,nt,Jn,jn,uo,oe,To,_l,vl,Ol,yl,Al,bl,Bl,Ul,wl,Vl,Hl,Yl,Ql,eu,su,wt,lt,ru,iu,uu,du,pu,mu,_u,xu,vu,Iu,Pu,Tu,Ru,bu,Bu,Nu,Wu,J,at,wu,Ku,zu,ju,Qu,tc,kt,nc,oc,{kernelName:e.Qvg,backendName:"webgl",kernelFunc:function ac(w){const{inputs:x,backend:m,attrs:I}=w,{x:D,segmentIds:R}=x,{numSegments:B}=I,k=D.shape.length,U=[];let F=0;const V=e.backend_util.getAxesPermutation([F],k);let st=D;null!=V&&(st=dt({inputs:{x:D},backend:m,attrs:{perm:V}}),U.push(st),F=e.backend_util.getInnerMostAxes(1,k)[0]);const it=e.backend_util.segment_util.computeOutShape(st.shape,F,B),mt=e.D5U.sizeFromShape([st.shape[F]]),_t=Gt({inputs:{x:st},backend:m,attrs:{shape:[-1,mt]}});U.push(_t);const Rt=(0,e.z4k)(D.dtype),$t=(he,Ne,Ye,je,Fe)=>{const sn=he.shape[0],Qe=he.shape[1],Cn=e.backend_util.segment_util.segOpComputeOptimalWindowSize(Qe,Fe),es=new rc({windowSize:Cn,inSize:Qe,batchSize:sn,numSegments:Fe},Ne),Nn=m.compileAndRun(es,[he,Ye],je);if(U.push(Nn),Nn.shape[1]===Fe)return Nn;const Wn=gn({backend:m,attrs:{start:0,stop:Fe,step:1,dtype:"float32"}}),zn=fl({inputs:{x:Wn},backend:m,attrs:{reps:[Qe/Cn]}});return U.push(Wn),U.push(zn),$t(Nn,Ne,zn,je,Fe)},Ft=Gt({inputs:{x:$t(_t,"unsortedSegmentSum",R,Rt,B)},backend:m,attrs:{shape:it}});let De=Ft;if(null!=V){U.push(Ft);const he=e.backend_util.getUndoAxesPermutation(V);De=dt({inputs:{x:De},backend:m,attrs:{perm:he}})}return U.forEach(he=>m.disposeIntermediateTensorInfo(he)),De}},ce];for(const w of lc)(0,e.wCN)(w)},4074:(H,C,t)=>{"use strict";t.d(C,{v:()=>u});var e=t(42372),a=t(83227);class u{constructor(i,f){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=i,this.enableShapeUniforms=(0,e.C9)(this.outputShape.length);let l="";for(let o=0;o<4;o++){let n="thisRC = rc;";o%2==1&&(n+="thisRC.z += 1;"),o>1&&(n+="thisRC.y += 1;"),l+=`\n        ${n}\n        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${o}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${o>0?"}":""}\n      `}this.userCode=`\n      ${function c(h,i){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${i?a.al(["r","c","d"],"inputShape"):a.RW(["r","c","d"],h)}\n      return ivec3(r, c, d);\n    }\n  `}(f,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?a.nc():a.ku(i)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":i[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":i[2]};\n\n        ${l}\n\n        setOutput(result);\n      }\n    `}}},45223:(H,C,t)=>{"use strict";t.d(C,{Tt:()=>It,Vm:()=>h,kW:()=>ct});var e=t(30003),a=t(99100),u=t(83227);const{getBroadcastDims:c}=e.backend_util;function h(K,j,at){const dt=[];if(K.forEach(Te=>{const Je=e.D5U.sizeFromShape(Te.shapeInfo.logicalShape);if(Te.shapeInfo.isUniform?dt.push(`uniform float ${Te.name}${Je>1?`[${Je}]`:""};`):(dt.push(`uniform sampler2D ${Te.name};`),dt.push(`uniform int offset${Te.name};`)),at.enableShapeUniforms){const{uniformShape:tn}=It(at.packedInputs,Te.shapeInfo.logicalShape,Te.shapeInfo.texShape);switch(tn.length){case 1:dt.push(`uniform int ${Te.name}Shape;`);break;case 2:dt.push(`uniform ivec2 ${Te.name}Shape;`);break;case 3:dt.push(`uniform ivec3 ${Te.name}Shape;`);break;case 4:dt.push(`uniform ivec4 ${Te.name}Shape;`)}dt.push(`uniform ivec2 ${Te.name}TexShape;`)}}),at.enableShapeUniforms){switch(j.logicalShape.length){case 1:dt.push("uniform int outShape;");break;case 2:dt.push("uniform ivec2 outShape;"),dt.push("uniform int outShapeStrides;");break;case 3:dt.push("uniform ivec3 outShape;"),dt.push("uniform ivec2 outShapeStrides;");break;case 4:dt.push("uniform ivec4 outShape;"),dt.push("uniform ivec3 outShapeStrides;")}dt.push("uniform ivec2 outTexShape;")}at.customUniforms&&at.customUniforms.forEach(Te=>{dt.push(`uniform ${Te.type} ${Te.name}${Te.arrayIndex?`[${Te.arrayIndex}]`:""};`)});const kt=dt.join("\n"),jt=K.map(Te=>function l(K,j,at=!1,dt){let kt="";kt+=at?f(K,dt):i(K,dt);return K.shapeInfo.logicalShape.length<=j.logicalShape.length&&(kt+=at?function ie(K,j){const at=K.name,dt=at.charAt(0).toUpperCase()+at.slice(1),kt="get"+dt+"AtOutCoords",jt=K.shapeInfo.logicalShape.length,Jt=j.logicalShape.length,ae=c(K.shapeInfo.logicalShape,j.logicalShape),Re=ct(Jt),Be=Jt-jt;let Se;const we=["x","y","z","w","u","v"];Se=0===jt?"":Jt<2&&ae.length>=1?"coords = 0;":ae.map(hn=>`coords.${we[hn+Be]} = 0;`).join("\n");let Ae="";Ae=Jt<2&&jt>0?"coords":K.shapeInfo.logicalShape.map((hn,Pn)=>`coords.${we[Pn+Be]}`).join(", ");let Te="return outputValue;";const tn=1===e.D5U.sizeFromShape(K.shapeInfo.logicalShape),mn=1===e.D5U.sizeFromShape(j.logicalShape);if(1!==jt||tn||mn){if(tn&&!mn)Te=1===Jt?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(ae.length){const hn=jt-2,Pn=jt-1;ae.indexOf(hn)>-1&&ae.indexOf(Pn)>-1?Te="return vec4(outputValue.x);":ae.indexOf(hn)>-1?Te="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":ae.indexOf(Pn)>-1&&(Te="return vec4(outputValue.xx, outputValue.zz);")}}else Te="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${kt}() {\n      ${Re} coords = getOutputCoords();\n      ${Se}\n      vec4 outputValue = get${dt}(${Ae});\n      ${Te}\n    }\n  `}(K,j):function Zt(K,j){const at=K.name,dt=at.charAt(0).toUpperCase()+at.slice(1),kt="get"+dt+"AtOutCoords",ae=K.shapeInfo.logicalShape.length,Re=j.logicalShape.length;if(!K.shapeInfo.isUniform&&ae===Re&&null==K.shapeInfo.flatOffset&&e.D5U.arraysEqual(K.shapeInfo.texShape,j.texShape))return`\n      float ${kt}() {\n        return sampleTexture(${at}, resultUV);\n      }\n    `;const Be=ct(Re),Se=c(K.shapeInfo.logicalShape,j.logicalShape),we=Re-ae;let Ae;const Te=["x","y","z","w","u","v"];Ae=0===ae?"":Re<2&&Se.length>=1?"coords = 0;":Se.map(tn=>`coords.${Te[tn+we]} = 0;`).join("\n");let Je="";return Je=Re<2&&ae>0?"coords":K.shapeInfo.logicalShape.map((tn,On)=>`coords.${Te[On+we]}`).join(", "),`\n    float ${kt}() {\n      ${Be} coords = getOutputCoords();\n      ${Ae}\n      return get${dt}(${Je});\n    }\n  `}(K,j)),kt}(Te,j,at.packedInputs,at.enableShapeUniforms)).join("\n"),Jt=j.texShape,ae=(0,a.A)(),Re=function s(K){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${K.texture2D}(textureSampler, uv).r;\n    }\n  `}(ae);let Be,Se,we=function p(K){return`${K.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${K.varyingFs} vec2 resultUV;\n    ${K.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${K.defineSpecialNaN}\n    ${K.defineSpecialInf}\n    ${K.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${g}\n    ${_}\n    ${v}\n  `}(ae);return j.isPacked?(Be=function o(K,j,at){switch(K.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function S(K,j,at){const dt=[Math.ceil(j[0]/2),Math.ceil(j[1]/2)];return 1===dt[0]?at?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${dt[1]}.0);\n      }\n    `:1===dt[1]?at?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${dt[0]}.0);\n      }\n    `:at?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${dt[0]}, ${dt[1]}));\n      return 2 * (resTexRC.x * ${dt[1]} + resTexRC.y);\n    }\n  `}(0,j,at);case 2:return function W(K,j,at){const dt=[Math.ceil(j[0]/2),Math.ceil(j[1]/2)];if(e.D5U.arraysEqual(K,j))return at?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${dt[0]}, ${dt[1]}));\n      }\n    `;const kt=Math.ceil(K[1]/2);return at?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${dt[0]}, ${dt[1]}));\n\n      int index = resTexRC.x * ${dt[1]} + resTexRC.y;\n      int r = 2 * (index / ${kt});\n      int c = imod(index, ${kt}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(K,j,at);case 3:return function L(K,j,at){if(at)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const dt=[Math.ceil(j[0]/2),Math.ceil(j[1]/2)],kt=Math.ceil(K[2]/2),jt=kt*Math.ceil(K[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${dt[0]}, ${dt[1]}));\n      int index = resTexRC.x * ${dt[1]} + resTexRC.y;\n\n      int b = index / ${jt};\n      index -= b * ${jt};\n\n      int r = 2 * (index / ${kt});\n      int c = imod(index, ${kt}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(K,j,at);default:return function O(K,j,at){if(at)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const dt=[Math.ceil(j[0]/2),Math.ceil(j[1]/2)],kt=Math.ceil(K[K.length-1]/2),jt=kt*Math.ceil(K[K.length-2]/2);let Jt=jt,ae="",Re="b, r, c";for(let Be=2;Be<K.length-1;Be++)Jt*=K[K.length-Be-1],ae=`\n      int b${Be} = index / ${Jt};\n      index -= b${Be} * ${Jt};\n    `+ae,Re=`b${Be}, `+Re;return`\n    ivec${K.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${dt[0]}, ${dt[1]}));\n      int index = resTexRC.x * ${dt[1]} + resTexRC.y;\n\n      ${ae}\n\n      int b = index / ${jt};\n      index -= b * ${jt};\n\n      int r = 2 * (index / ${kt});\n      int c = imod(index, ${kt}) * 2;\n\n      return ivec${K.length}(${Re});\n    }\n  `}(K,j,at)}}(j.logicalShape,Jt,at.enableShapeUniforms),Se=function d(K){return`\n    void setOutput(vec4 val) {\n      ${K.output} = val;\n    }\n  `}(ae)):(Be=function n(K,j,at){switch(K.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function P(K,j,at){return 1===j[0]?at?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${j[1]}.0);\n      }\n    `:1===j[1]?at?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${j[0]}.0);\n      }\n    `:at?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${j[0]}, ${j[1]}));\n      return resTexRC.x * ${j[1]} + resTexRC.y;\n    }\n  `}(0,j,at);case 2:return function Z(K,j,at){return e.D5U.arraysEqual(K,j)?at?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${j[0]}, ${j[1]}));\n      }\n    `:1===K[1]?at?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${j[0]}, ${j[1]}));\n        int index = resTexRC.x * ${j[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===K[0]?at?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${j[0]}, ${j[1]}));\n        int index = resTexRC.x * ${j[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:at?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${j[0]}, ${j[1]}));\n      int index = resTexRC.x * ${j[1]} + resTexRC.y;\n      int r = index / ${K[1]};\n      int c = index - r * ${K[1]};\n      return ivec2(r, c);\n    }\n  `}(K,j,at);case 3:return function N(K,j,at){if(at)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${u.Kn(["r","c","d"],K)}\n    return ivec3(r, c, d);\n  }\n`;const dt=u.RW(["r","c","d"],K);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${j[0]}, ${j[1]}));\n      int index = resTexRC.x * ${j[1]} + resTexRC.y;\n      ${dt}\n      return ivec3(r, c, d);\n    }\n  `}(K,j,at);case 4:return function b(K,j,at){if(at)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${u.Kn(["r","c","d","d2"],K)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const dt=u.RW(["r","c","d","d2"],K);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${j[0]}, ${j[1]}));\n      int index = resTexRC.x * ${j[1]} + resTexRC.y;\n      ${dt}\n      return ivec4(r, c, d, d2);\n    }\n  `}(K,j,at);case 5:return function E(K,j){const at=u.RW(["r","c","d","d2","d3"],K);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${j[0]},\n                             ${j[1]}));\n\n      int index = resTexRC.x * ${j[1]} + resTexRC.y;\n\n      ${at}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(K,j);case 6:return function $(K,j){const at=u.RW(["r","c","d","d2","d3","d4"],K);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${j[0]}, ${j[1]}));\n      int index = resTexRC.x * ${j[1]} + resTexRC.y;\n\n      ${at}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(K,j);default:throw new Error(`${K.length}-D output sampling is not yet supported`)}}(j.logicalShape,Jt,at.enableShapeUniforms),Se=function r(K){return`\n    void setOutput(float val) {\n      ${K.output} = vec4(val, 0, 0, 0);\n    }\n  `}(ae)),at.packedInputs&&(we+=M),[we,Re,Se,kt,Be,jt,at.userCode].join("\n")}function i(K,j=!1){const at=K.shapeInfo.logicalShape;switch(at.length){case 0:return function Dt(K,j){const at=K.name,dt="get"+at.charAt(0).toUpperCase()+at.slice(1);if(K.shapeInfo.isUniform)return`float ${dt}() {return ${at};}`;const[kt,jt]=K.shapeInfo.texShape;if(1===kt&&1===jt)return`\n      float ${dt}() {\n        return sampleTexture(${at}, halfCR);\n      }\n    `;const Jt=X(at);if(j)return`\n    float ${dt}() {\n      vec2 uv = uvFromFlat(${at}TexShape[0], ${at}TexShape[1], ${Jt});\n      return sampleTexture(${at}, uv);\n    }\n  `;const[ae,Re]=K.shapeInfo.texShape;return`\n    float ${dt}() {\n      vec2 uv = uvFromFlat(${ae}, ${Re}, ${Jt});\n      return sampleTexture(${at}, uv);\n    }\n  `}(K,j);case 1:return function ht(K,j){const at=K.name,dt="get"+at.charAt(0).toUpperCase()+at.slice(1);if(K.shapeInfo.isUniform)return`\n      float ${dt}(int index) {\n        ${Ie(K)}\n      }\n    `;const kt=K.shapeInfo.texShape,jt=kt[0],Jt=kt[1];if(1===Jt&&1===jt)return`\n      float ${dt}(int index) {\n        return sampleTexture(${at}, halfCR);\n      }\n    `;const ae=X(at);return 1===Jt?j?`\n      float ${dt}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${ae}) + 0.5) / float(${at}TexShape[0]));\n        return sampleTexture(${at}, uv);\n      }\n    `:`\n      float ${dt}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${ae}) + 0.5) / ${jt}.0);\n        return sampleTexture(${at}, uv);\n      }\n    `:1===jt?j?`\n      float ${dt}(int index) {\n        vec2 uv = vec2((float(index + ${ae}) + 0.5) / float(${at}TexShape[1]), 0.5);\n        return sampleTexture(${at}, uv);\n      }\n    `:`\n      float ${dt}(int index) {\n        vec2 uv = vec2((float(index + ${ae}) + 0.5) / ${Jt}.0, 0.5);\n        return sampleTexture(${at}, uv);\n      }\n    `:j?`\n    float ${dt}(int index) {\n      vec2 uv = uvFromFlat(${at}TexShape[0], ${at}TexShape[1], index + ${ae});\n      return sampleTexture(${at}, uv);\n    }\n  `:`\n    float ${dt}(int index) {\n      vec2 uv = uvFromFlat(${jt}, ${Jt}, index + ${ae});\n      return sampleTexture(${at}, uv);\n    }\n  `}(K,j);case 2:return function pt(K,j){const at=K.shapeInfo.logicalShape,dt=K.name,kt="get"+dt.charAt(0).toUpperCase()+dt.slice(1),jt=K.shapeInfo.texShape;if(null!=jt&&e.D5U.arraysEqual(at,jt))return j?`\n      float ${kt}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${dt}TexShape[1], ${dt}TexShape[0]);\n        return sampleTexture(${dt}, uv);\n      }\n    `:`\n    float ${kt}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${jt[1]}.0, ${jt[0]}.0);\n      return sampleTexture(${dt}, uv);\n    }\n  `;const{newShape:Jt,keptDims:ae}=e.D5U.squeezeShape(at);if(Jt.length<at.length){const Te=["row","col"];return`\n      ${i(Ut(K,Jt),j)}\n      float ${kt}(int row, int col) {\n        return ${kt}(${q(Te,ae)});\n      }\n    `}if(K.shapeInfo.isUniform)return`\n      float ${kt}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${at[1]}, 1)));\n        ${Ie(K)}\n      }\n    `;const Be=jt[0],Se=jt[1],we=X(dt);return 1===Se?j?`\n      float ${kt}(int row, int col) {\n        float index = dot(vec3(row, col, ${we}), vec3(${dt}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${dt}TexShape[0]));\n        return sampleTexture(${dt}, uv);\n      }\n    `:`\n    float ${kt}(int row, int col) {\n      float index = dot(vec3(row, col, ${we}), vec3(${at[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${Be}.0);\n      return sampleTexture(${dt}, uv);\n    }\n  `:1===Be?j?`\n      float ${kt}(int row, int col) {\n        float index = dot(vec3(row, col, ${we}), vec3(${dt}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${dt}TexShape[1]), 0.5);\n        return sampleTexture(${dt}, uv);\n      }\n    `:`\n    float ${kt}(int row, int col) {\n      float index = dot(vec3(row, col, ${we}), vec3(${at[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${Se}.0, 0.5);\n      return sampleTexture(${dt}, uv);\n    }\n  `:j?`\n      float ${kt}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${dt}Shape[1] + col + ${we};\n        vec2 uv = uvFromFlat(${dt}TexShape[0], ${dt}TexShape[1], index);\n        return sampleTexture(${dt}, uv);\n      }\n    `:`\n  float ${kt}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${at[1]} + col + ${we};\n    vec2 uv = uvFromFlat(${Be}, ${Se}, index);\n    return sampleTexture(${dt}, uv);\n  }\n`}(K,j);case 3:return function Nt(K,j){const at=K.shapeInfo.logicalShape,dt=K.name,kt="get"+dt.charAt(0).toUpperCase()+dt.slice(1),jt=at[1]*at[2],Jt=at[2],{newShape:ae,keptDims:Re}=e.D5U.squeezeShape(at);if(ae.length<at.length){const On=["row","col","depth"];return`\n        ${i(Ut(K,ae),j)}\n        float ${kt}(int row, int col, int depth) {\n          return ${kt}(${q(On,Re)});\n        }\n      `}if(K.shapeInfo.isUniform)return`\n      float ${kt}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${jt}, ${Jt}, 1)));\n        ${Ie(K)}\n      }\n    `;const Se=K.shapeInfo.texShape,we=Se[0],Ae=Se[1],Te=K.shapeInfo.flatOffset;if(Ae===jt&&null==Te)return j?`\n      float ${kt}(int row, int col, int depth) {\n        int stride1 = ${dt}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${dt}TexShape[1], ${dt}TexShape[0]);\n        return sampleTexture(${dt}, uv);\n      }\n    `:`\n        float ${kt}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${Jt}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${Ae}.0, ${we}.0);\n          return sampleTexture(${dt}, uv);\n        }\n      `;if(Ae===Jt&&null==Te)return j?`\n      float ${kt}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${dt}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${dt}TexShape[1], ${dt}TexShape[0]);\n        return sampleTexture(${dt}, uv);\n      }\n    `:`\n    float ${kt}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${at[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${Ae}.0, ${we}.0);\n      return sampleTexture(${dt}, uv);\n    }\n  `;const Je=X(dt);return j?`\n    float ${kt}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${dt}Shape[1] * ${dt}Shape[2];\n      int stride1 = ${dt}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${Je};\n      vec2 uv = uvFromFlat(${dt}TexShape[0], ${dt}TexShape[1], index);\n      return sampleTexture(${dt}, uv);\n    }\n    `:`\n      float ${kt}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${jt} + col * ${Jt} + depth + ${Je};\n        vec2 uv = uvFromFlat(${we}, ${Ae}, index);\n        return sampleTexture(${dt}, uv);\n      }\n  `}(K,j);case 4:return function Gt(K,j){const at=K.shapeInfo.logicalShape,dt=K.name,kt="get"+dt.charAt(0).toUpperCase()+dt.slice(1),jt=at[3],Jt=at[2]*jt,ae=at[1]*Jt,{newShape:Re,keptDims:Be}=e.D5U.squeezeShape(at);if(Re.length<at.length){const Pn=["row","col","depth","depth2"];return`\n      ${i(Ut(K,Re),j)}\n      float ${kt}(int row, int col, int depth, int depth2) {\n        return ${kt}(${q(Pn,Be)});\n      }\n    `}if(K.shapeInfo.isUniform)return`\n      float ${kt}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${ae}, ${Jt}, ${jt}, 1)));\n        ${Ie(K)}\n      }\n    `;const Se=K.shapeInfo.flatOffset,we=K.shapeInfo.texShape,Ae=we[0],Te=we[1],Je=`int stride2 = ${dt}Shape[3];`,tn=`int stride1 = ${dt}Shape[2] * stride2;`,On=`int stride0 = ${dt}Shape[1] * stride1;`;if(Te===ae&&null==Se)return j?`\n      float ${kt}(int row, int col, int depth, int depth2) {\n        ${Je}\n        ${tn}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${dt}TexShape[1], ${dt}TexShape[0]);\n        return sampleTexture(${dt}, uv);\n      }\n    `:`\n      float ${kt}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${Jt}, ${jt}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${Te}.0, ${Ae}.0);\n        return sampleTexture(${dt}, uv);\n      }\n    `;if(Te===jt&&null==Se)return j?`\n      float ${kt}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${dt}Shape[1] * ${dt}Shape[2], ${dt}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${dt}TexShape[1], ${dt}TexShape[0]);\n        return sampleTexture(${dt}, uv);\n      }\n    `:`\n      float ${kt}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${at[1]*at[2]}, ${at[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${Te}.0, ${Ae}.0);\n        return sampleTexture(${dt}, uv);\n      }\n    `;const mn=X(dt);return j?`\n    float ${kt}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${Je}\n      ${tn}\n      ${On}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${dt}TexShape[0], ${dt}TexShape[1], index + ${mn});\n      return sampleTexture(${dt}, uv);\n    }\n  `:`\n    float ${kt}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${ae} + col * ${Jt} +\n          depth * ${jt} + depth2;\n      vec2 uv = uvFromFlat(${Ae}, ${Te}, index + ${mn});\n      return sampleTexture(${dt}, uv);\n    }\n  `}(K,j);case 5:return function oe(K){const j=K.shapeInfo.logicalShape,at=K.name,dt="get"+at.charAt(0).toUpperCase()+at.slice(1),kt=j[4],jt=j[3]*kt,Jt=j[2]*jt,ae=j[1]*Jt,{newShape:Re,keptDims:Be}=e.D5U.squeezeShape(j);if(Re.length<j.length){const On=["row","col","depth","depth2","depth3"];return`\n      ${i(Ut(K,Re))}\n      float ${dt}(int row, int col, int depth, int depth2, int depth3) {\n        return ${dt}(${q(On,Be)});\n      }\n    `}if(K.shapeInfo.isUniform)return`\n      float ${dt}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${ae}, ${Jt}, ${jt}, ${kt})) +\n          depth3;\n        ${Ie(K)}\n      }\n    `;const Se=K.shapeInfo.flatOffset,we=K.shapeInfo.texShape,Ae=we[0],Te=we[1];if(Te===ae&&null==Se)return`\n      float ${dt}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${Jt}, ${jt}, ${kt}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${Te}.0, ${Ae}.0);\n        return sampleTexture(${at}, uv);\n      }\n    `;if(Te===kt&&null==Se)return`\n      float ${dt}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${j[1]*j[2]*j[3]},\n               ${j[2]*j[3]}, ${j[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${Te}.0, ${Ae}.0);\n        return sampleTexture(${at}, uv);\n      }\n    `;return`\n    float ${dt}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${ae} + col * ${Jt} + depth * ${jt} +\n          depth2 * ${kt} + depth3 + ${X(at)};\n      vec2 uv = uvFromFlat(${Ae}, ${Te}, index);\n      return sampleTexture(${at}, uv);\n    }\n  `}(K);case 6:return function Ee(K){const j=K.shapeInfo.logicalShape,at=K.name,dt="get"+at.charAt(0).toUpperCase()+at.slice(1),{newShape:kt,keptDims:jt}=e.D5U.squeezeShape(j);if(kt.length<j.length){const mn=["row","col","depth","depth2","depth3","depth4"];return`\n      ${i(Ut(K,kt))}\n      float ${dt}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${dt}(${q(mn,jt)});\n      }\n    `}const Jt=j[5],ae=j[4]*Jt,Re=j[3]*ae,Be=j[2]*Re,Se=j[1]*Be;if(K.shapeInfo.isUniform)return`\n      float ${dt}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${Se}, ${Be}, ${Re}, ${ae})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${Jt}, 1)));\n        ${Ie(K)}\n      }\n    `;const we=K.shapeInfo.flatOffset,Ae=K.shapeInfo.texShape,Te=Ae[0],Je=Ae[1];if(Je===Se&&null==we)return`\n      float ${dt}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${Be}, ${Re}, ${ae}, ${Jt})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${Je}.0, ${Te}.0);\n        return sampleTexture(${at}, uv);\n      }\n    `;if(Je===Jt&&null==we)return`\n      float ${dt}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${j[1]*j[2]*j[3]*j[4]},\n               ${j[2]*j[3]*j[4]},\n               ${j[3]*j[4]},\n               ${j[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${Je}.0, ${Te}.0);\n        return sampleTexture(${at}, uv);\n      }\n    `;return`\n    float ${dt}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${Se} + col * ${Be} + depth * ${Re} +\n          depth2 * ${ae} + depth3 * ${Jt} + depth4 + ${X(at)};\n      vec2 uv = uvFromFlat(${Te}, ${Je}, index);\n      return sampleTexture(${at}, uv);\n    }\n  `}(K);default:throw new Error(`${at.length}-D input sampling is not yet supported`)}}function f(K,j){switch(K.shapeInfo.logicalShape.length){case 0:return function ut(K){const j=K.name;return`\n    vec4 ${"get"+j.charAt(0).toUpperCase()+j.slice(1)}() {\n      return ${(0,a.A)().texture2D}(${j}, halfCR);\n    }\n  `}(K);case 1:return function Y(K,j){const at=K.name,dt="get"+at.charAt(0).toUpperCase()+at.slice(1),kt=K.shapeInfo.texShape,jt=(0,a.A)();if(j)return`\n    vec4 ${dt}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${at}TexShape[0]) / 2.0), ceil(float(${at}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${jt.texture2D}(${at}, uv);\n    }\n  `;const Jt=[Math.ceil(kt[0]/2),Math.ceil(kt[1]/2)];return`\n    vec4 ${dt}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${Jt[0]}, ${Jt[1]}, index);\n      return ${jt.texture2D}(${at}, uv);\n    }\n  `}(K,j);case 2:return function Pt(K,j){const at=K.shapeInfo.logicalShape,dt=K.name,kt="get"+dt.charAt(0).toUpperCase()+dt.slice(1),jt=K.shapeInfo.texShape,Jt=jt[0],ae=jt[1],Re=(0,a.A)();if(null!=jt&&e.D5U.arraysEqual(at,jt))return j?`\n      vec4 ${kt}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${dt}TexShape[1], ${dt}TexShape[0]);\n\n        return ${Re.texture2D}(${dt}, uv);\n      }\n    `:`\n      vec4 ${kt}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${ae}.0, ${Jt}.0);\n\n        return ${Re.texture2D}(${dt}, uv);\n      }\n    `;if(j)return`\n    vec4 ${kt}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${dt}TexShape[0]) / 2.0), ceil(float(${dt}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${dt}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${Re.texture2D}(${dt}, uv);\n    }\n  `;const Be=[Math.ceil(jt[0]/2),Math.ceil(jt[1]/2)];return`\n    vec4 ${kt}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(at[1]/2)}, ${Be[0]}, ${Be[1]}, row, col);\n      return ${Re.texture2D}(${dt}, uv);\n    }\n  `}(K,j);case 3:return function xt(K,j){const at=K.shapeInfo.logicalShape,dt=K.name,kt="get"+dt.charAt(0).toUpperCase()+dt.slice(1),jt=K.shapeInfo.texShape,Jt=[Math.ceil(jt[0]/2),Math.ceil(jt[1]/2)];if(1===at[0]){const Te=[1,2],tn=["b","row","col"];return`\n        ${f(Ut(K,at.slice(1)),j)}\n        vec4 ${kt}(int b, int row, int col) {\n          return ${kt}(${q(tn,Te)});\n        }\n      `}const ae=(0,a.A)();if(j)return`\n    vec4 ${kt}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${dt}TexShape[0]) / 2.0), ceil(float(${dt}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${dt}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${dt}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${ae.texture2D}(${dt}, uv);\n    }\n  `;const Re=Jt[0],Be=Jt[1],Se=Math.ceil(at[2]/2);return`\n    vec4 ${kt}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${Re}, ${Be}, ${Se*Math.ceil(at[1]/2)}, ${Se}, b, row, col);\n      return ${ae.texture2D}(${dt}, uv);\n    }\n  `}(K,j);default:return function Vt(K,j){const at=K.name,dt="get"+at.charAt(0).toUpperCase()+at.slice(1),kt=(0,a.A)();if(j)return`\n    vec4 ${dt}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${at}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${at}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${at}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${at}TexShape[0]) / 2.0), ceil(float(${at}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${kt.texture2D}(${at}, uv);\n    }\n  `;const jt=K.shapeInfo.logicalShape,Jt=jt.length,ae=K.shapeInfo.texShape,Re=[Math.ceil(ae[0]/2),Math.ceil(ae[1]/2)],Be=Re[0],Se=Re[1],we=Math.ceil(jt[Jt-1]/2);let Ae=we*Math.ceil(jt[Jt-2]/2),Te="int b, int row, int col",Je=`b * ${Ae} + (row / 2) * ${we} + (col / 2)`;for(let tn=2;tn<Jt-1;tn++)Te=`int b${tn}, `+Te,Ae*=jt[Jt-tn-1],Je=`b${tn} * ${Ae} + `+Je;return`\n    vec4 ${dt}(${Te}) {\n      int index = ${Je};\n      int texR = index / ${Se};\n      int texC = index - texR * ${Se};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${Se}, ${Be});\n      return ${kt.texture2D}(${at}, uv);\n    }\n  `}(K,j)}}const g="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",_="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",v="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",M="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function X(K){return`offset${K}`}function Ie(K){const j=K.name,at=e.D5U.sizeFromShape(K.shapeInfo.logicalShape);return at<2?`return ${j};`:`\n    for (int i = 0; i < ${at}; i++) {\n      if (i == index) {\n        return ${j}[i];\n      }\n    }\n  `}function ct(K){if(K<=1)return"int";if(2===K)return"ivec2";if(3===K)return"ivec3";if(4===K)return"ivec4";if(5===K)return"ivec5";if(6===K)return"ivec6";throw Error(`GPU for rank ${K} is not yet supported`)}function It(K,j,at){const{newShape:dt,keptDims:kt}=e.D5U.squeezeShape(j),jt=j.length,Jt=K&&3===jt&&1===j[0],ae=Jt?j.slice(1):dt,Re=!K&&jt>1&&!e.D5U.arraysEqual(j,at)&&dt.length<jt||Jt;return{useSqueezeShape:Re,uniformShape:Re?ae:j,keptDims:kt}}function Ut(K,j){const at=JSON.parse(JSON.stringify(K));return at.shapeInfo.logicalShape=j,at}function q(K,j){return j.map(at=>K[at]).join(", ")}},83227:(H,C,t)=>{"use strict";t.d(C,{Kn:()=>u,RW:()=>a,al:()=>h,ku:()=>l,nc:()=>o,ye:()=>n});var e=t(30003);function a(s,r,d="index"){const p=e.D5U.computeStrides(r);return p.map((g,_)=>`int ${s[_]} = ${d} / ${g}; ${_===p.length-1?`int ${s[_+1]} = ${d} - ${s[_]} * ${g}`:`index -= ${s[_]} * ${g}`};`).join("")}function u(s,r,d="index"){const p=e.D5U.computeStrides(r);return p.map((g,_)=>`int ${s[_]} = ${d} / outShapeStrides[${_}]; ${_===p.length-1?`int ${s[_+1]} = ${d} - ${s[_]} * outShapeStrides[${_}]`:`index -= ${s[_]} * outShapeStrides[${_}]`};`).join("")}function h(s,r,d="index"){const g=function c(s,r){const d=s.length,p=s.map(_=>`${r}[${_}]`),g=new Array(d-1);g[d-2]=p[d-1];for(let _=d-3;_>=0;--_)g[_]=`(${g[_+1]} * ${p[_+1]})`;return g}(s.map((_,v)=>v),r);return g.map((_,v)=>`int ${s[v]} = ${d} / ${g[v]}; ${v===g.length-1?`int ${s[v+1]} = ${d} - ${s[v]} * ${g[v]}`:`index -= ${s[v]} * ${g[v]}`};`).join("")}function l(s){const r=e.D5U.computeStrides(s).map(d=>d.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${r[0]} + coords.y * ${r[1]} + coords.z;\n  }\n`}function o(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}const n="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n"},20215:(H,C,t)=>{"use strict";t.d(C,{Se:()=>r,Sq:()=>d,V9:()=>c,Yz:()=>l,kk:()=>h,m1:()=>a,qe:()=>s,v2:()=>u,yb:()=>i});var e=t(30003),a=function(p){return p[p.DENSE=0]="DENSE",p[p.SHARED_BATCH=1]="SHARED_BATCH",p}(a||{}),u=function(p){return p[p.RENDER=0]="RENDER",p[p.UPLOAD=1]="UPLOAD",p[p.PIXELS=2]="PIXELS",p[p.DOWNLOAD=3]="DOWNLOAD",p}(u||{}),c=function(p){return p[p.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",p[p.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",p[p.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",p[p.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",p[p.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",p}(c||{});function h(p,g){return[g,p]}function i(p,g){return p*g}function l(p){const g=e.D5U.sizeFromShape(p),_=Math.ceil(g/4);return e.D5U.sizeToSquarishShape(_)}function s(p,g){return[Math.max(1,Math.ceil(g/2)),Math.max(1,Math.ceil(p/2))]}function r(p,g){const[_,v]=s(p,g);return _*v*4}function d(p,g){const _=p;let v,M,T,S,P,L,N,O,b,E;return 2===(0,e.OBj)().getNumber("WEBGL_VERSION")?(v=_.R32F,M=_.R16F,T=_.RGBA16F,S=_.RGBA32F,P=_.RED,N=4,O=1,b=_.HALF_FLOAT,E=_.FLOAT,L=_.RGBA8):(v=p.RGBA,M=p.RGBA,T=p.RGBA,S=_.RGBA,P=p.RGBA,N=4,O=4,b=null!=g?g.HALF_FLOAT_OES:null,E=p.FLOAT,L=p.RGBA),{internalFormatFloat:v,internalFormatHalfFloat:M,internalFormatPackedHalfFloat:T,internalFormatPackedFloat:S,textureFormatFloat:P,downloadTextureFormat:L,downloadUnpackNumChannels:N,defaultNumChannels:O,textureTypeHalfFloat:b,textureTypeFloat:E}}},32398:(H,C,t)=>{"use strict";t.d(C,{Cv:()=>f,D1:()=>u,Et:()=>h,RX:()=>l,Tq:()=>s,bl:()=>n,eW:()=>o,l:()=>a,t$:()=>c});var e=t(42372);class a{constructor(d,p){this.variableNames=["A"],this.outputShape=d,this.enableShapeUniforms=(0,e.C9)(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${p}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const u="if (isnan(x)) return x;",c="return x;",h="return abs(x);",f="return (x >= 0.0) ? x : (exp(x) - 1.0);",l=u+"\n  return (x < 0.0) ? 0.0 : x;\n",o=u+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",n="return x;",s="return 1.0 / (1.0 + exp(-1.0 * x));"},807:(H,C,t)=>{"use strict";t.d(C,{Cv:()=>u,RX:()=>c,Tq:()=>i,cc:()=>f,eW:()=>h,t$:()=>a});var e=t(42372);const a="return x;",u="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",c="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",h="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",i="return 1.0 / (1.0 + exp(-1.0 * x));";class f{constructor(o,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o,this.enableShapeUniforms=(0,e.C9)(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${n}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}},91883:(H,C,t)=>{"use strict";t.d(C,{i:()=>e});const e="4.22.0"},38891:(H,C,t)=>{"use strict";(0,t(30003).OBj)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,u=>{u&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})},64254:(H,C,t)=>{"use strict";t.d(C,{i:()=>e});const e="4.22.0"},67173:(H,C,t)=>{"use strict";t.d(C,{JL:()=>u,Zu:()=>c});class u{constructor(f,l){this.backend=f,this.dataMover=l,this.data=new WeakMap,this.dataIdsCount=0}get(f){return this.data.has(f)||this.dataMover.moveData(this.backend,f),this.data.get(f)}set(f,l){this.dataIdsCount++,this.data.set(f,l)}has(f){return this.data.has(f)}delete(f){return this.dataIdsCount--,this.data.delete(f)}numDataIds(){return this.dataIdsCount}}class c{refCount(f){return h("refCount")}incRef(f){return h("incRef")}timerAvailable(){return!0}time(f){return h("time")}read(f){return h("read")}readSync(f){return h("readSync")}readToGPU(f,l){return h("readToGPU")}numDataIds(){return h("numDataIds")}disposeData(f,l){return h("disposeData")}write(f,l,o){return h("write")}move(f,l,o,n,s){return h("move")}createTensorFromGPUData(f,l,o){return h("createTensorFromGPUData")}memory(){return h("memory")}floatPrecision(){return h("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return h("dispose")}}function h(i){throw new Error(`'${i}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},73099:(H,C,t)=>{"use strict";t.r(C),t.d(C,{ERF_A1:()=>Z,ERF_A2:()=>X,ERF_A3:()=>ut,ERF_A4:()=>Dt,ERF_A5:()=>Y,ERF_P:()=>W,PARALLELIZE_THRESHOLD:()=>g,RowPartitionType:()=>n,SELU_SCALE:()=>$.$,SELU_SCALEALPHA:()=>$.y,applyActivation:()=>o.QH,assertAndGetBroadcastShape:()=>c.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>u.lB,assertParamsConsistent:()=>i,assignToTypedArray:()=>Gt,axesAreInnerMostDims:()=>u.YB,calculateShapes:()=>E.calculateShapes,checkEinsumDimSizes:()=>q,checkPadOnDimRoundingMode:()=>l.m,combineLocations:()=>u.Vh,combineRaggedTensorToTensorShapes:()=>s,complexWithEvenIndex:()=>xt,complexWithOddIndex:()=>Nt,computeConv2DInfo:()=>l.Ix,computeConv3DInfo:()=>l.jw,computeDefaultPad:()=>l.aO,computeDilation2DInfo:()=>l.Rf,computeOptimalWindowSize:()=>_,computeOutAndReduceShapes:()=>u.kz,computeOutShape:()=>f,computePool2DInfo:()=>l.Xw,computePool3DInfo:()=>l.pl,convertConv2DDataFormat:()=>l.sl,decodeEinsumEquation:()=>It,eitherStridesOrDilationsAreOne:()=>l.jT,expandShapeToKeepDim:()=>u.rv,exponent:()=>Ee,exponents:()=>oe,fromStringArrayToUint8:()=>ns,fromUint8ToStringArray:()=>Pn,getAxesPermutation:()=>u.Q3,getBroadcastDims:()=>c.getBroadcastDims,getComplexWithIndex:()=>Vt,getEinsumComputePath:()=>K,getEinsumPermutation:()=>Ut,getFusedBiasGradient:()=>o.pf,getFusedDyActivation:()=>o.Fr,getImageCenter:()=>T,getInnerMostAxes:()=>u.sY,getPermuted:()=>P,getRaggedRank:()=>d,getReductionAxes:()=>c.getReductionAxes,getReshaped:()=>S,getReshapedPermuted:()=>L,getRowPartitionTypesHelper:()=>r,getSliceBeginCoords:()=>N,getSliceSize:()=>O,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>kt,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>jt,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Jt,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Be,getSparseReshapeInputOutputMismatchErrorMessage:()=>we,getSparseReshapeInputOutputMultipleErrorMessage:()=>Se,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>ae,getSparseReshapeNegativeOutputDimErrorMessage:()=>Re,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>tn,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Ae,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Te,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Je,getUndoAxesPermutation:()=>u.LJ,isIdentityPermutation:()=>j,log:()=>ht.c,mergeRealAndImagArrays:()=>Pt,prepareAndValidate:()=>b.prepareAndValidate,prepareSplitSize:()=>dt,segment_util:()=>e,shouldFuse:()=>o.uy,slice_util:()=>v,splitRealAndImagArrays:()=>pt,stridesOrDilationsArePositive:()=>l.U3,tupleValuesAreOne:()=>l.I0,upcastType:()=>M.x8,validateDefaultValueShape:()=>p,validateInput:()=>E.validateInput,validateUpdateShape:()=>E.validateUpdateShape,warn:()=>ht.Z});var e={};t.r(e),t.d(e,{collectGatherOpShapeInfo:()=>hn,computeOutShape:()=>mn,segOpComputeOptimalWindowSize:()=>On});var a=t(49823),u=t(30929),c=t(93239),h=t(45359);function i(Lt,ee){const re=Lt[0].length;Lt.forEach((se,Ue)=>{h.hu(se.length===re,()=>`Error in concat${re}D: rank of tensors[${Ue}] must be the same as the rank of the rest (${re})`)}),h.hu(ee>=0&&ee<re,()=>`Error in concat${re}D: axis must be between 0 and ${re-1}.`);const Qt=Lt[0];Lt.forEach((se,Ue)=>{for(let We=0;We<re;We++)h.hu(We===ee||se[We]===Qt[We],()=>`Error in concat${re}D: Shape of tensors[${Ue}] (${se}) does not match the shape of the rest (${Qt}) along the non-concatenated axis ${Ue}.`)})}function f(Lt,ee){const re=Lt[0].slice();for(let Qt=1;Qt<Lt.length;Qt++)re[ee]+=Lt[Qt][ee];return re}var l=t(5551),o=t(16254),n=function(Lt){return Lt[Lt.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",Lt[Lt.VALUE_ROWIDS=1]="VALUE_ROWIDS",Lt[Lt.ROW_LENGTHS=2]="ROW_LENGTHS",Lt[Lt.ROW_SPLITS=3]="ROW_SPLITS",Lt[Lt.ROW_LIMITS=4]="ROW_LIMITS",Lt[Lt.ROW_STARTS=5]="ROW_STARTS",Lt}(n||{});function s(Lt,ee,re){let Qt=new Array;if(null==re&&null==ee)return Qt;if(null==ee)for(;Qt.length<Lt+re.length;)Qt.push(-1);else Qt=ee.slice();if(null==re)return Qt;if(Lt+re.length!==Qt.length)throw new Error(`rt input.shape and shape=${ee} are incompatible: rt input.rank = ${Lt+re.length}, but shape.rank = ${Qt.length}`);for(let se=1;se<re.length;++se){const Ue=re[se],We=Qt[Qt.length-re.length+se],rn=Qt[We];if(Ue>=0)if(rn>=0){if(rn!==Ue)throw new Error(`rt input.shape and shape=${ee} are incompatible: rt input.shape[${se+Lt}] = ${Ue} but shape[${se+Lt}] = ${rn}`)}else Qt[We]=Ue}return Qt}function r(Lt){const ee={FIRST_DIM_SIZE:n.FIRST_DIM_SIZE,VALUE_ROWIDS:n.VALUE_ROWIDS,ROW_LENGTHS:n.ROW_LENGTHS,ROW_SPLITS:n.ROW_SPLITS,ROW_LIMITS:n.ROW_LIMITS,ROW_STARTS:n.ROW_STARTS},re=[];for(const Qt of Lt){if(!(Qt in ee))break;re.push(ee[Qt])}return re}function d(Lt){return 0===Lt.length?0:Lt[0]===n.FIRST_DIM_SIZE?Lt.length-1:Lt.length}function p(Lt,ee){if(null==Lt||null==ee)return;const re=Lt.length,Qt=ee.length;if(re>=Qt)throw new Error(`defaultValue.shape=${Lt} and ragged tensor flatValues.shape=${ee}, are incompatible: defaultValue.rank = ${re} must be less than ragged tensor input flatValues.rank = ${Qt})`);for(let se=0;se<Math.min(re,Qt-1);++se){const Ue=Lt[se],We=ee[se+1];if(Ue>=0&&We>=0&&1!==Ue&&Ue!==We)throw new Error(`defaultValue.shape=${Lt}, and ragged tensor input flatValues.shape=${ee} are incompatible: defaultValue.shape[${se-Lt.length}] = ${Ue} but ragged tensor input.flatValues.shape[${se-Lt.length}] = ${We}`)}}const g=30;function _(Lt){return Lt<=g?Lt:(0,h.jP)(Lt,Math.floor(Math.sqrt(Lt)))}var v=t(22320),M=t(1216);function T(Lt,ee,re){return[re*("number"==typeof Lt?Lt:Lt[0]),ee*("number"==typeof Lt?Lt:Lt[1])]}function S(Lt,ee,re,Qt=!0){let se=[];if(Qt)se=se.concat(ee.slice(0)),se.push(Lt[0]/re),se=se.concat(Lt.slice(1));else{se=se.concat(Lt[0]);const Ue=ee.length;for(let We=0;We<Ue;++We)se=se.concat([Lt[We+1]/ee[We],ee[We]]);se=se.concat(Lt.slice(Ue+1))}return se}function P(Lt,ee,re=!0){const Qt=[];if(re){Qt.push(ee);for(let se=ee+1;se<Lt;++se)se<=2*ee?(Qt.push(se),Qt.push(se-(ee+1))):Qt.push(se)}else{const se=[],Ue=[];for(let We=1;We<Lt;++We)We>=2*ee+1||We%2==1?Ue.push(We):se.push(We);Qt.push(...se),Qt.push(0),Qt.push(...Ue)}return Qt}function L(Lt,ee,re,Qt=!0){const se=[];se.push(Qt?Lt[0]/re:Lt[0]*re);for(let Ue=1;Ue<Lt.length;++Ue)se.push(Ue<=ee.length?Qt?ee[Ue-1]*Lt[Ue]:Lt[Ue]/ee[Ue-1]:Lt[Ue]);return se}function N(Lt,ee){const re=[0];for(let Qt=0;Qt<ee;++Qt)re.push(Lt[Qt][0]);return re}function O(Lt,ee,re){const Qt=Lt.slice(0,1);for(let se=0;se<re;++se)Qt.push(Lt[se+1]-ee[se][0]-ee[se][1]);return Qt}var b=t(39859),E=t(1876),$=t(42152);const W=.3275911,Z=.254829592,X=-.284496736,ut=1.421413741,Dt=-1.453152027,Y=1.061405429;var ht=t(12932);function Pt(Lt,ee){if(Lt.length!==ee.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${Lt.length}, imag: ${ee.length}.`);const re=new Float32Array(2*Lt.length);for(let Qt=0;Qt<re.length;Qt+=2)re[Qt]=Lt[Qt/2],re[Qt+1]=ee[Qt/2];return re}function pt(Lt){const ee=new Float32Array(Lt.length/2),re=new Float32Array(Lt.length/2);for(let Qt=0;Qt<Lt.length;Qt+=2)ee[Qt/2]=Lt[Qt],re[Qt/2]=Lt[Qt+1];return{real:ee,imag:re}}function xt(Lt){const ee=Math.ceil(Lt.length/4),re=new Float32Array(ee),Qt=new Float32Array(ee);for(let se=0;se<Lt.length;se+=4)re[Math.floor(se/4)]=Lt[se],Qt[Math.floor(se/4)]=Lt[se+1];return{real:re,imag:Qt}}function Nt(Lt){const ee=Math.floor(Lt.length/4),re=new Float32Array(ee),Qt=new Float32Array(ee);for(let se=2;se<Lt.length;se+=4)re[Math.floor(se/4)]=Lt[se],Qt[Math.floor(se/4)]=Lt[se+1];return{real:re,imag:Qt}}function Vt(Lt,ee){return{real:Lt[2*ee],imag:Lt[2*ee+1]}}function Gt(Lt,ee,re,Qt){Lt[2*Qt]=ee,Lt[2*Qt+1]=re}function oe(Lt,ee){const re=new Float32Array(Lt/2),Qt=new Float32Array(Lt/2);for(let se=0;se<Math.ceil(Lt/2);se++){const Ue=(ee?2:-2)*Math.PI*(se/Lt);re[se]=Math.cos(Ue),Qt[se]=Math.sin(Ue)}return{real:re,imag:Qt}}function Ee(Lt,ee,re){const Qt=(re?2:-2)*Math.PI*(Lt/ee);return{real:Math.cos(Qt),imag:Math.sin(Qt)}}const Ie="->",ie=/->/g,Zt=",",ct="...";function It(Lt,ee){const re=((Lt=Lt.replace(/\s/g,"")).length-Lt.replace(ie,"").length)/Ie.length;if(re<1)throw new Error("Equations without an arrow are not supported.");if(re>1)throw new Error(`Equation must contain exactly one arrow ("${Ie}").`);const[Qt,se]=Lt.split(Ie);(0,h.hu)(-1===Qt.indexOf(ct),()=>`The ellipsis notation ("${ct}") is not supported yet.`);const Ue=Qt.split(Zt),We=Ue.length;if(ee!==We)throw new Error(`Expected ${We} input tensors, received ${ee}`);if(We>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const rn=[];for(let dn=0;dn<se.length;++dn){const Mn=se[dn];if(!Ue.some(Ln=>-1!==Ln.indexOf(Mn)))throw new Error(`Output subscripts contain the label ${Mn} not present in the input subscripts.`);-1===rn.indexOf(Mn)&&rn.push(Mn)}for(let dn=0;dn<Qt.length;++dn){const Mn=Qt[dn];-1===rn.indexOf(Mn)&&Mn!==Zt&&rn.push(Mn)}const yn=new Array(Ue.length);for(let dn=0;dn<We;++dn){if(new Set(Ue[dn].split("")).size!==Ue[dn].length)throw new Error(`Found duplicate axes in input component ${Ue[dn]}. Support for duplicate axes in input is not implemented yet.`);yn[dn]=[];for(let Mn=0;Mn<Ue[dn].length;++Mn)yn[dn].push(rn.indexOf(Ue[dn][Mn]))}const An=rn.length,en=[];for(let dn=se.length;dn<An;++dn)en.push(dn);return{allDims:rn,summedDims:en,idDims:yn}}function Ut(Lt,ee){let re=new Array(Lt);re.fill(-1);for(let se=0;se<ee.length;++se)re[ee[se]]=se;const Qt=[];for(let se=0;se<Lt;++se)-1===re[se]&&Qt.push(se);return re=re.filter(se=>-1!==se),{permutationIndices:re,expandDims:Qt}}function q(Lt,ee,re){const Qt=new Array(Lt);for(let se=0;se<re.length;++se){const Ue=re[se].shape;for(let We=0;We<ee[se].length;++We)void 0===Qt[ee[se][We]]?Qt[ee[se][We]]=Ue[We]:(0,h.hu)(Qt[ee[se][We]]===Ue[We],()=>`Expected dimension ${Qt[ee[se][We]]} at axis ${We} of input shaped ${JSON.stringify(Ue)}, but got dimension ${Ue[We]}`)}}function K(Lt,ee){const re=Lt,Qt=[];let se=0;0===Lt.length&&re.push(-1),se=Lt.length+1;for(let We=0;We<se;++We)Qt.push([]);const Ue=[];for(let We=0;We<re.length;++We){const yn=at(ee,re[We]);for(const An of yn)-1===Ue.indexOf(An)&&(Qt[We].push(An),Ue.push(An))}return{path:re,steps:Qt}}function j(Lt){return Lt.every((ee,re)=>ee===re)}function at(Lt,ee){const re=[];for(let Qt=0;Qt<Lt.length;++Qt)(0===Lt[Qt].length||-1!==Lt[Qt].indexOf(ee)||-1===ee)&&re.push(Qt);return re}function dt(Lt,ee,re=0){let Qt=[];if("number"==typeof ee)(0,h.hu)(Lt.shape[re]%ee==0,()=>"Number of splits must evenly divide the axis."),Qt=new Array(ee).fill(Lt.shape[re]/ee);else{const se=ee.reduce((We,rn)=>(-1===rn&&(We+=1),We),0);(0,h.hu)(se<=1,()=>"There should be only one negative value in split array.");const Ue=ee.indexOf(-1);if(-1!==Ue){const We=ee.reduce((rn,yn)=>yn>0?rn+yn:rn);ee[Ue]=Lt.shape[re]-We}(0,h.hu)(Lt.shape[re]===ee.reduce((We,rn)=>We+rn),()=>"The sum of sizes must match the size of the axis dimension."),Qt=ee}return Qt}function kt(Lt){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${Lt}`}function jt(Lt,ee){return`indices(${Lt}, 0) is invalid: ${ee} < 0`}function Jt(Lt,ee,re){return`indices(${Lt}, 0) is invalid: ${ee} >= ${re}`}function ae(Lt,ee){return`only one output dimension may be -1, not both ${Lt} and ${ee}`}function Re(Lt,ee){return`size ${Lt} must be non-negative, not ${ee}`}function Be(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Se(Lt,ee){return`Input to reshape is a SparseTensor with ${(0,h.NA)(Lt)}\n  dense values, but the requested shape requires a multiple of ${(0,h.NA)(ee)}. inputShape=${Lt} outputShape= ${ee}`}function we(Lt,ee){return`Input to reshape is a tensor with ${(0,h.NA)(Lt)} dense values, but the requested shape has ${(0,h.NA)(ee)}. inputShape=${Lt} outputShape=${ee}`}function Ae(){return"segment ids must be >= 0"}function Te(){return"segment ids are not increasing"}function Je(Lt,ee){return`Segment id ${Lt} out of range [0, ${ee}), possibly because segmentIds input is not sorted.`}function tn(Lt,ee,re){return`Bad: indices[${Lt}] == ${ee} out of range [0, ${re})`}function On(Lt,ee){let Qt,re=!1;for(Lt<=g?(Qt=Lt,re=!0):Qt=(0,h.jP)(Lt,Math.floor(Math.sqrt(Lt)));!re;)Qt>ee||Qt===Lt?re=!0:Qt=(0,h.jP)(Lt,Qt+1);return Qt}function mn(Lt,ee,re){const Qt=[],se=Lt.length;for(let Ue=0;Ue<se;Ue++)Qt.push(Ue!==ee?Lt[Ue]:re);return Qt}function hn(Lt,ee,re,Qt){const se=ee.shape.length,Ue=Lt.shape.length;if(0!==Qt&&(Qt<-se||Qt>se))throw new Error(`Expect batchDims in the range of [-${se}, ${se}], but got ${Qt}`);if(Qt<0&&(Qt+=se),Qt>Ue)throw new Error(`batchDims (${Qt}) must be less than rank(x) (\n    ${Ue}).`);if(re<Qt)throw new Error(`batchDims (${Qt}) must be less than or equal to axis (${re}).`);for(let en=0;en<Qt;++en)if(Lt.shape[en]!==ee.shape[en])throw new Error(`x.shape[${en}]: ${Lt.shape[en]} should be equal to indices.shape[${en}]: ${ee.shape[en]}.`);const We=Lt.shape[re],rn=[];let yn=1,An=1,vn=1;for(let en=0;en<Qt;++en)rn.push(Lt.shape[en]),yn*=Lt.shape[en];for(let en=Qt;en<re;en++)rn.push(Lt.shape[en]),An*=Lt.shape[en];for(let en=Qt;en<se;en++)rn.push(ee.shape[en]);for(let en=re+1;en<Ue;en++)rn.push(Lt.shape[en]),vn*=Lt.shape[en];return{batchSize:yn,sliceSize:vn,outerSize:An,dimSize:We,outputShape:rn}}function Pn(Lt){try{return Lt.map(ee=>(0,a.decodeString)(ee))}catch(ee){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${ee}`)}}function ns(Lt){return Lt.map(ee=>(0,a.encodeString)(ee))}},97228:(H,C,t)=>{"use strict";function e(r,d,p){const g=function a(r,d,p){return function c(r,d,p){let g=0,_=r.length,v=0,M=!1;for(;g<_;){v=g+(_-g>>>1);const T=p(d,r[v]);T>0?g=v+1:(_=v,M=!T)}return M?g:-g-1}(r,d,p||u)}(r,d,p);r.splice(g<0?-(g+1):g,0,d)}function u(r,d){return r>d?1:r<d?-1:0}function h(r,d,p,g,_){return l(r,d,p,g,_,0)}function i(r,d,p,g,_,v){return l(r,d,p,g,_,0,!1,v,!0)}function f(r,d,p,g,_,v){return l(r,d,p,g,_,v,!0)}function l(r,d,p,g,_,v,M=!1,T=!1,S=!1){const P=[];for(let W=0;W<d.length;W++)d[W]>_&&P.push({score:d[W],boxIndex:W,suppressBeginIndex:0});P.sort(s);const L=v>0?-.5/v:0,N=[],O=[];for(;N.length<p&&P.length>0;){const W=P.pop(),{score:Z,boxIndex:X,suppressBeginIndex:ut}=W;if(Z<_)break;let Dt=!1;for(let Y=N.length-1;Y>=ut;--Y){const ht=o(r,X,N[Y]);if(ht>=g){Dt=!0;break}if(W.score=W.score*n(g,L,ht),W.score<=_)break}W.suppressBeginIndex=N.length,Dt||(W.score===Z?(N.push(X),O.push(W.score)):W.score>_&&e(P,W,s))}const b=N.length,E=p-b;T&&E>0&&(N.push(...new Array(E).fill(0)),O.push(...new Array(E).fill(0)));const $={selectedIndices:N};return M&&($.selectedScores=O),S&&($.validOutputs=b),$}function o(r,d,p){const g=r.subarray(4*d,4*d+4),_=r.subarray(4*p,4*p+4),v=Math.min(g[0],g[2]),M=Math.min(g[1],g[3]),T=Math.max(g[0],g[2]),S=Math.max(g[1],g[3]),P=Math.min(_[0],_[2]),L=Math.min(_[1],_[3]),N=Math.max(_[0],_[2]),O=Math.max(_[1],_[3]),b=(T-v)*(S-M),E=(N-P)*(O-L);if(b<=0||E<=0)return 0;const $=Math.max(v,P),W=Math.max(M,L),Z=Math.min(T,N),X=Math.min(S,O),ut=Math.max(Z-$,0)*Math.max(X-W,0);return ut/(b+E-ut)}function n(r,d,p){const g=Math.exp(d*p*p);return p<=r?g:0}function s(r,d){return r.score-d.score||r.score===d.score&&d.boxIndex-r.boxIndex}t.d(C,{GP:()=>h,qP:()=>i,pA:()=>f})},57349:(H,C,t)=>{"use strict";t.d(C,{Z:()=>a});var e=t(80582);function a(u,c){const h=[];for(let l=0;l<c.length;l++)c[l]&&h.push(l);const i=(0,e.f)(u,"int32"),f=(0,e.f)([h.length,u.length],"int32");for(let l=0;l<h.length;l++){const o=i.indexToLoc(h[l]);f.values.set(o,l*u.length)}return f.toTensor()}},3311:(H,C,t)=>{"use strict";var e=t(40687),u=(t(881),t(5527)),c=t(51462),h=t(83187),i=t(20320),f=t(94705);class l{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(L,N){return fetch(L,N)}now(){return performance.now()}encode(L,N){if("utf-8"!==N&&"utf8"!==N)throw new Error(`Browser's encoder only supports utf-8, but got ${N}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(L)}decode(L,N){return new TextDecoder(N).decode(L)}setTimeoutCustom(L,N){typeof window>"u"||!(0,u.OB)().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(L,N):(this.functionRefs.push(L),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},N),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",O=>{O.source===window&&O.data.name===this.messageName&&(O.stopPropagation(),(0,this.functionRefs[O.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(L){return(0,f.j)(L)}}if((0,u.OB)().get("IS_BROWSER")){(0,u.OB)().setPlatform("browser",new l);try{i.xQ.registerManager(h.Ew.URL_SCHEME,new h.JL)}catch{}try{i.xQ.registerManager(c.ns.URL_SCHEME,new c.y$)}catch{}}let n;(0,u.OB)().get("IS_NODE")&&!(0,u.OB)().get("IS_BROWSER")&&(0,u.OB)().setPlatform("node",new class p{constructor(){this.util=t(48628),this.textEncoder=new this.util.TextEncoder}fetch(L,N){return null!=(0,u.OB)().global.fetch?(0,u.OB)().global.fetch(L,N):(null==n&&(n=t(75410)),n(L,N))}now(){const L=process.hrtime();return 1e3*L[0]+L[1]/1e6}encode(L,N){if("utf-8"!==N&&"utf8"!==N)throw new Error(`Node built-in encoder only supports utf-8, but got ${N}`);return this.textEncoder.encode(L)}decode(L,N){return 0===L.length?"":new this.util.TextDecoder(N).decode(L)}isTypedArray(L){return this.util.types.isFloat32Array(L)||this.util.types.isInt32Array(L)||this.util.types.isUint8Array(L)||this.util.types.isUint8ClampedArray(L)}});var g=t(80582),_=t(3062),v=t(87315),M=t(43006),T=t(4296);(0,e.wv)(),(0,T.Vp)({buffer:g.f,cast:_.p,clone:v.d,print:M.S})},75524:(H,C,t)=>{"use strict";t.d(C,{g:()=>a});const e=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:u=>u();function a(){return new Promise(u=>e(()=>u()))}},90322:(H,C,t)=>{"use strict";let a;function u(i){a=i}function c(i){if(void 0!==a)return a;if(i||function e(){return typeof navigator<"u"&&null!=navigator}()){if(i||(i=navigator),"ReactNative"===i.product)return!0;const f=i.userAgent||i.vendor||(typeof window<"u"?window.opera:"");return f?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(f)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(f.substr(0,4)):i.userAgentData&&i.userAgentData.mobile}return!1}function h(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}t.r(C),t.d(C,{isBrowser:()=>h,isMobile:()=>c,mockIsMobile:()=>u})},40687:(H,C,t)=>{"use strict";t.d(C,{BV:()=>L,wv:()=>P});var e=t(15861),a=t(67173),u=t(5527),c=t(32918),h=t(34251),i=t(8987),f=t(12932),l=t(49823),o=t(45359);class n{constructor(b,E){this.backendTimer=b,this.logger=E,null==E&&(this.logger=new r)}profileKernel(b,E,$){let W;const Z=()=>{W=$()};let X;const ut=l.now();if(this.backendTimer.timerAvailable())X=this.backendTimer.time(Z);else{Z();for(const Y of W)Y.dataSync();X=Promise.resolve({kernelMs:l.now()-ut})}if((0,u.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let Y=0;Y<W.length;Y++){const ht=W[Y];ht.data().then(Pt=>{s(Pt,ht.dtype,b)})}return{kernelName:b,outputs:W,inputs:E,timeMs:X.then(Y=>Y.kernelMs),extraInfo:X.then(Y=>null!=Y.getExtraProfileInfo?Y.getExtraProfileInfo():"")}}logKernelProfile(b){const{kernelName:E,outputs:$,timeMs:W,inputs:Z,extraInfo:X}=b;$.forEach(ut=>{Promise.all([ut.data(),W,X]).then(Dt=>{this.logger.logKernelProfile(E,ut,Dt[0],Dt[1],Z,Dt[2])})})}}function s(O,b,E){if("float32"!==b)return!1;for(let $=0;$<O.length;$++){const W=O[$];if(isNaN(W)||!isFinite(W))return console.warn(`Found ${W} in the result of '${E}'`),!0}return!1}class r{logKernelProfile(b,E,$,W,Z,X){const ut="number"==typeof W?o.oj(`${W}ms`,9):W.error,Dt=o.oj(b,25),Y=E.rank,ht=E.size,Pt=o.oj(E.shape.toString(),14);let pt="";for(const xt in Z){const Nt=Z[xt];if(null!=Nt){const Vt=Nt.shape||E.shape,Gt=Vt.length;pt+=`${xt}: ${Gt}D ${Gt>0?Vt:""} `}}console.log(`%c${Dt}\t%c${ut}\t%c${Y}D ${Pt}\t%c${ht}\t%c${pt}\t%c${X}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var g=t(4296),_=t(27664);function v(O){return null!=O.kernelName}class M{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(b=>b.name)))}}}dispose(){for(const b in this.registeredVariables)this.registeredVariables[b].dispose()}}let T=(()=>{class O{constructor(E){this.ENV=E,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new M}ready(){var E=this;return(0,e.Z)(function*(){if(null!=E.pendingBackendInit)return E.pendingBackendInit.then(()=>{});if(null!=E.backendInstance)return;const $=E.getSortedBackends();for(let W=0;W<$.length;W++){const Z=$[W];if(yield E.initializeBackend(Z).success)return void(yield E.setBackend(Z))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:E,asyncInit:$}=this.initializeBackendsAndReturnBest();if($)throw new Error(`The highest priority backend '${E}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(E)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(E){if(!(E in this.registry)){if(!(E in this.registryFactory))return null;{const{asyncInit:$}=this.initializeBackend(E);if($)return null}}return this.registry[E]}findBackendFactory(E){return E in this.registryFactory?this.registryFactory[E].factory:null}registerBackend(E,$,W=1){return E in this.registryFactory?(f.Z(`${E} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[E]={factory:$,priority:W},!0)}setBackend(E){var $=this;return(0,e.Z)(function*(){if(null==$.registryFactory[E])throw new Error(`Backend name '${E}' not found in registry`);if($.backendName=E,null==$.registry[E]){$.backendInstance=null;const{success:W,asyncInit:Z}=$.initializeBackend(E);if(!(Z?yield W:W))return!1}return $.backendInstance=$.registry[E],$.setupRegisteredKernels(),$.profiler=new n($.backendInstance),!0})()}setupRegisteredKernels(){(0,i.tr)(this.backendName).forEach($=>{null!=$.setupFunc&&$.setupFunc(this.backendInstance)})}disposeRegisteredKernels(E){(0,i.tr)(E).forEach(W=>{null!=W.disposeFunc&&W.disposeFunc(this.registry[E])})}initializeBackend(E){const $=this.registryFactory[E];if(null==$)throw new Error(`Cannot initialize backend ${E}, no registration found.`);try{const W=$.factory();if(!W||W instanceof a.Zu||"function"!=typeof W.then)return this.registry[E]=W,{success:!0,asyncInit:!1};{const Z=++this.pendingBackendInitId,X=W.then(ut=>!(Z<this.pendingBackendInitId||(this.registry[E]=ut,this.pendingBackendInit=null,0))).catch(ut=>(Z<this.pendingBackendInitId||(this.pendingBackendInit=null,f.Z(`Initialization of backend ${E} failed`),f.Z(ut.stack||ut.message)),!1));return this.pendingBackendInit=X,{success:X,asyncInit:!0}}}catch(W){return f.Z(`Initialization of backend ${E} failed`),f.Z(W.stack||W.message),{success:!1,asyncInit:!1}}}removeBackend(E){if(!(E in this.registryFactory))throw new Error(`${E} backend not found in registry`);this.backendName===E&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,E in this.registry&&(this.disposeRegisteredKernels(E),this.registry[E].dispose(),delete this.registry[E]),delete this.registryFactory[E],this.backendName===E&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((E,$)=>this.registryFactory[$].priority-this.registryFactory[E].priority)}initializeBackendsAndReturnBest(){const E=this.getSortedBackends();for(let $=0;$<E.length;$++){const W=E[$],{success:Z,asyncInit:X}=this.initializeBackend(W);if(X||Z)return{name:W,asyncInit:X}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(E,$){const W=this.state.tensorInfo.get($),Z=W.backend,X=this.readSync($),ut=Z.refCount($);Z.disposeData($,!0),W.backend=E,E.move($,X,W.shape,W.dtype,ut),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(E,$){let Z,W=null;if(null==$){if("function"!=typeof E)throw new Error("Please provide a function to tidy()");$=E}else{if("string"!=typeof E&&!(E instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof $)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");W=E}return this.scopedRun(()=>this.startScope(W),()=>this.endScope(Z),()=>(Z=$(),Z instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Z))}scopedRun(E,$,W){E();try{const Z=W();return $(),Z}catch(Z){throw $(),Z}}nextTensorId(){return O.nextTensorId++}nextVariableId(){return O.nextVariableId++}clone(E){const $=L.runKernel(h.iJz,{x:E});return this.addTapeNode(this.state.activeScope.name,{x:E},[$],ut=>({x:()=>L.runKernel(h.RFZ,{x:ut},{dtype:"float32"})}),[],{}),$}runKernel(E,$,W){if(null==(0,i.pI)(E,this.backendName))throw new Error(`Kernel '${E}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:E,inputs:$,attrs:W})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(E,$,W){const Z=this.backend.numDataIds();let X=0;W.forEach(Y=>{X+="complex64"===Y.dtype?3:1});const Dt=Z-$-X-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(Dt>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${Dt} data ids) after running '${E}'`)}runKernelFunc(E){let $,W=[];const Z=this.isTapeOn(),X=this.state.numBytes,ut=this.state.numTensors;let Dt,Y;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const ht=v(E)?E.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(v(E)){const{kernelName:Vt,inputs:Gt,attrs:oe}=E,Ee=(0,i.pI)(Vt,this.backendName);o.hu(null!=Ee,()=>`Cannot find registered kernel '${Vt}' for backend '${this.backendName}'`),Dt=()=>{const Ie=this.backend.numDataIds();Y=Ee.kernelFunc({inputs:Gt,attrs:oe,backend:this.backend});const ie=Array.isArray(Y)?Y:[Y];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(Vt,Ie,ie);const Zt=ie.map(ct=>null!=ct.rank?ct:this.makeTensorFromTensorInfo(ct));if(Z){const ct=this.getTensorsForGradient(Vt,Gt,Zt);W=this.saveTensorsForBackwardMode(ct)}return Zt}}else{const{forwardFunc:Vt}=E,Gt=oe=>{Z&&(W=oe.map(Ee=>this.keep(this.clone(Ee))))};Dt=()=>{const oe=this.backend.numDataIds();Y=this.tidy(()=>Vt(this.backend,Gt));const Ee=Array.isArray(Y)?Y:[Y];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(ht,oe,Ee),Ee}}const{inputs:Pt,attrs:pt}=E,xt=v(E)?null:E.backwardsFunc;let Nt;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(Nt=this.profiler.profileKernel(ht,Pt,()=>Dt()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(Nt),$=Nt.outputs):$=Dt()}),Z&&this.addTapeNode(ht,Pt,$,xt,W,pt),this.state.profiling&&this.state.activeProfile.kernels.push({name:ht,bytesAdded:this.state.numBytes-X,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-ut,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(Pt).map(Vt=>null!=Pt[Vt]?Pt[Vt].shape:null),outputShapes:$.map(Vt=>Vt.shape),kernelTimeMs:Nt.timeMs,extraInfo:Nt.extraInfo}),Array.isArray(Y)?$:$[0]}saveTensorsForBackwardMode(E){return E.map(W=>this.keep(this.clone(W)))}getTensorsForGradient(E,$,W){const Z=(0,i.uk)(E);if(null!=Z){const X=Z.inputsToSave||[],ut=Z.outputsToSave||[];let Dt;Z.saveAllInputs?(o.hu(Array.isArray($),()=>"saveAllInputs is true, expected inputs to be an array."),Dt=Object.keys($).map(ht=>$[ht])):Dt=X.map(ht=>$[ht]);const Y=W.filter((ht,Pt)=>ut[Pt]);return Dt.concat(Y)}return[]}makeTensor(E,$,W,Z){if(null==E)throw new Error("Values passed to engine.makeTensor() are null");Z=Z||this.backend;let X=E;"string"===(W=W||"float32")&&o.HD(E[0])&&(X=E.map(Y=>l.encodeString(Y)));const ut=Z.write(X,$,W),Dt=new g.es($,W,ut,this.nextTensorId());if(this.trackTensor(Dt,Z),"string"===W){const Y=this.state.tensorInfo.get(ut),ht=(0,o.Ub)(X);this.state.numBytes+=ht-Y.bytes,Y.bytes=ht}return Dt}makeTensorFromDataId(E,$,W,Z){return this.makeTensorFromTensorInfo({dataId:E,shape:$,dtype:W=W||"float32"},Z)}makeTensorFromTensorInfo(E,$){const{dataId:W,shape:Z,dtype:X}=E,ut=new g.es(Z,X,W,this.nextTensorId());return this.trackTensor(ut,$),ut}makeVariable(E,$=!0,W,Z){W=W||this.nextVariableId().toString(),null!=Z&&Z!==E.dtype&&(E=E.cast(Z));const X=new g._w(E,$,W,this.nextTensorId());if(null!=this.state.registeredVariables[X.name])throw new Error(`Variable with name ${X.name} was already registered`);return this.state.registeredVariables[X.name]=X,this.incRef(X,this.backend),X}trackTensor(E,$){this.state.numTensors++,"string"===E.dtype&&this.state.numStringTensors++;let W=0;"complex64"!==E.dtype&&"string"!==E.dtype&&(W=E.size*o.bT(E.dtype)),this.state.numBytes+=W,this.state.tensorInfo.has(E.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(E.dataId,{backend:$||this.backend,dtype:E.dtype,shape:E.shape,bytes:W})),E instanceof g._w||this.track(E)}incRef(E,$){this.trackTensor(E,$),this.backend.incRef(E.dataId)}removeDataId(E,$){this.state.tensorInfo.has(E)&&this.state.tensorInfo.get(E).backend===$&&(this.state.tensorInfo.delete(E),this.state.numDataBuffers--)}disposeTensor(E){if(!this.state.tensorInfo.has(E.dataId))return;const $=this.state.tensorInfo.get(E.dataId);if(this.state.numTensors--,"string"===E.dtype&&(this.state.numStringTensors--,this.state.numBytes-=$.bytes),"complex64"!==E.dtype&&"string"!==E.dtype){const W=E.size*o.bT(E.dtype);this.state.numBytes-=W}$.backend.disposeData(E.dataId)&&this.removeDataId(E.dataId,$.backend)}disposeVariables(){for(const E in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[E])}disposeVariable(E){this.disposeTensor(E),null!=this.state.registeredVariables[E.name]&&delete this.state.registeredVariables[E.name]}memory(){const E=this.backend.memory();return E.numTensors=this.state.numTensors,E.numDataBuffers=this.state.numDataBuffers,E.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(E.unreliable=!0,null==E.reasons&&(E.reasons=[]),E.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),E}profile(E){var $=this;return(0,e.Z)(function*(){$.state.profiling=!0;const W=$.state.numBytes,Z=$.state.numTensors;$.state.activeProfile.kernels=[],$.state.activeProfile.result=yield E(),$.state.profiling=!1,$.state.activeProfile.peakBytes=Math.max(...$.state.activeProfile.kernels.map(X=>X.totalBytesSnapshot)),$.state.activeProfile.newBytes=$.state.numBytes-W,$.state.activeProfile.newTensors=$.state.numTensors-Z;for(const X of $.state.activeProfile.kernels)X.kernelTimeMs=yield X.kernelTimeMs,X.extraInfo=yield X.extraInfo;return $.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(E,$,W,Z,X,ut){const Dt={id:this.state.nextTapeNodeId++,kernelName:E,inputs:$,outputs:W,saved:X},Y=(0,i.uk)(E);null!=Y&&(Z=Y.gradFunc),null!=Z&&(Dt.gradient=ht=>(ht=ht.map((Pt,pt)=>{if(null==Pt){const xt=W[pt],Nt=o.wT(xt.size,xt.dtype);return this.makeTensor(Nt,xt.shape,xt.dtype)}return Pt}),Z(ht.length>1?ht:ht[0],X,ut))),this.state.activeTape.push(Dt)}keep(E){return E.kept=!0,E}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(E){const $={track:[],name:"unnamed scope",id:this.state.nextScopeId++};E&&($.name=E),this.state.scopeStack.push($),this.state.activeScope=$}endScope(E){const $=(0,_.getTensorsInContainer)(E),W=new Set($.map(X=>X.id));for(let X=0;X<this.state.activeScope.track.length;X++){const ut=this.state.activeScope.track[X];!ut.kept&&!W.has(ut.id)&&ut.dispose()}const Z=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],$.forEach(X=>{!X.kept&&X.scopeId===Z.id&&this.track(X)})}gradients(E,$,W,Z=!1){if(o.hu($.length>0,()=>"gradients() received an empty list of xs."),null!=W&&"float32"!==W.dtype)throw new Error(`dy must have 'float32' dtype, but has '${W.dtype}'`);const X=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",E));o.hu(X instanceof g.es,()=>"The result y returned by f() must be a tensor.");const ut=function d(O,b,E){const $={},W={};for(let Dt=0;Dt<b.length;Dt++)$[b[Dt].id]=!0;for(let Dt=0;Dt<O.length;Dt++){const Y=O[Dt],ht=Y.inputs;for(const Pt in ht){const pt=ht[Pt];let xt=!1;for(let Nt=0;Nt<b.length;Nt++)if($[pt.id]){Y.outputs.forEach(Vt=>$[Vt.id]=!0),xt=!0,W[Y.id]=!0;break}if(xt)break}}const Z={};Z[E.id]=!0;const X={};for(let Dt=O.length-1;Dt>=0;Dt--){const Y=O[Dt],ht=Y.inputs;for(let Pt=0;Pt<Y.outputs.length;Pt++)if(Z[Y.outputs[Pt].id]){for(const pt in ht)Z[ht[pt].id]=!0,X[Y.id]=!0;break}}const ut=[];for(let Dt=0;Dt<O.length;Dt++){const Y=O[Dt];if(W[Y.id]&&X[Y.id]){const ht={};for(const pt in Y.inputs){const xt=Y.inputs[pt];$[xt.id]&&(ht[pt]=xt)}const Pt=Object.assign({},Y);Pt.inputs=ht,Pt.outputs=Y.outputs,ut.push(Pt)}}return ut}(this.state.activeTape,$,X);if(!Z&&0===ut.length&&$.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const Dt={};Dt[X.id]=W??function S(O){const b=(0,o.p8)((0,o.NA)(O),"float32");return L.makeTensor(b,O,"float32")}(X.shape),function p(O,b,E,$){for(let W=b.length-1;W>=0;W--){const Z=b[W],X=[];if(Z.outputs.forEach(Dt=>{const Y=O[Dt.id];X.push(null!=Y?Y:null)}),null==Z.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${Z.kernelName}.`);const ut=Z.gradient(X);for(const Dt in Z.inputs){if(!(Dt in ut))throw new Error(`Cannot backprop through input ${Dt}. Available gradients found: ${Object.keys(ut)}.`);const Y=E(()=>ut[Dt]());if("float32"!==Y.dtype)throw new Error(`Error in gradient for op ${Z.kernelName}. The gradient of input ${Dt} must have 'float32' dtype, but has '${Y.dtype}'`);const ht=Z.inputs[Dt];if(!o.cO(Y.shape,ht.shape))throw new Error(`Error in gradient for op ${Z.kernelName}. The gradient of input '${Dt}' has shape '${Y.shape}', which does not match the shape of the input '${ht.shape}'`);if(null==O[ht.id])O[ht.id]=Y;else{const Pt=O[ht.id];O[ht.id]=$(Pt,Y),Pt.dispose()}}}}(Dt,ut,ht=>this.tidy(ht),N);const Y=$.map(ht=>Dt[ht.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(ht=>{for(const Pt of ht.saved)Pt.dispose()}),this.state.activeTape=null),{value:X,grads:Y}})}customGrad(E){return o.hu(o.mf(E),()=>"The f passed in customGrad(f) must be a function."),(...$)=>{let W;o.hu($.every(Dt=>Dt instanceof g.es),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const Z={};return $.forEach((Dt,Y)=>{Z[Y]=Dt}),this.runKernelFunc({forwardFunc:(Dt,Y)=>(W=E(...$,Y),o.hu(W.value instanceof g.es,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),o.hu(o.mf(W.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),W.value),backwardsFunc:(Dt,Y)=>{const ht=W.gradFunc(Dt,Y),Pt=Array.isArray(ht)?ht:[ht];o.hu(Pt.length===$.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),o.hu(Pt.every(xt=>xt instanceof g.es),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const pt={};return Pt.forEach((xt,Nt)=>{pt[Nt]=()=>xt}),pt},inputs:Z})}}readSync(E){return this.state.tensorInfo.get(E).backend.readSync(E)}read(E){return this.state.tensorInfo.get(E).backend.read(E)}readToGPU(E,$){return this.state.tensorInfo.get(E).backend.readToGPU(E,$)}time(E){var $=this;return(0,e.Z)(function*(){const W=(0,l.now)(),Z=yield $.backend.time(E);return Z.wallMs=(0,l.now)()-W,Z})()}track(E){return null!=this.state.activeScope&&(E.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(E)),E}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new M;for(const E in this.registry)this.disposeRegisteredKernels(E),this.registry[E].dispose(),delete this.registry[E];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return O.nextTensorId=0,O.nextVariableId=0,O})();function P(){const O=(0,c.D)();if(null==O._tfengine){const b=new u.qA(O);O._tfengine=new T(b)}return(0,u.iG)(O._tfengine.ENV),(0,g.Vi)(()=>O._tfengine),O._tfengine}const L=P();function N(O,b){return L.runKernel(h.mm_,{a:O,b})}},881:(H,C,t)=>{"use strict";t(40687);var a=t(90322);const c=(0,t(5527).OB)();c.registerFlag("DEBUG",()=>!1,h=>{h&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),c.registerFlag("IS_BROWSER",()=>a.isBrowser()),c.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),c.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),c.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),c.registerFlag("PROD",()=>!1),c.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>c.getBool("DEBUG")),c.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),c.registerFlag("IS_TEST",()=>!1),c.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>c.getBool("DEBUG")),c.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),c.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),c.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1)},32918:(H,C,t)=>{"use strict";let e;function a(){if(null==e){let h;if(typeof window<"u")h=window;else if(typeof global<"u")h=global;else if(typeof process<"u")h=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");h=self}e=h}return e}function c(h,i){const f=function u(){const h=a();return null==h._tfGlobals&&(h._tfGlobals=new Map),h._tfGlobals}();if(f.has(h))return f.get(h);{const l=i();return f.set(h,l),f.get(h)}}t.d(C,{D:()=>a,R:()=>c})},63842:(H,C,t)=>{"use strict";t.d(C,{E:()=>c,O:()=>T});var e=t(37387);const u=t.n(e)()||e;function c(S){return u.fromString(S,!0,16)}const h=c("c3a5c85c97cb3127"),i=c("b492b66fbe98f273"),f=c("9ae16a3b2f90404f");function l(S){return S.xor(S.shru(47))}function o(S,P,L){const N=S.slice(P,P+L);return u.fromBytes(Array.from(N),!0,!0)}function n(S,P){return o(S,P,8)}function s(S,P){return o(S,P,4)}function r(S,P){return 0===P?S:S.shru(P).or(S.shl(64-P))}function d(S,P,L=c("9ddfea08eb382d69")){let N=S.xor(P).mul(L);N=N.xor(N.shru(47));let O=P.xor(N).mul(L);return O=O.xor(O.shru(47)),O=O.mul(L),O}function g(S,P,L,N){return function p(S,P,L,N,O,b){O=O.add(S),b=r(b.add(O).add(N),21);const E=O;return O=(O=O.add(P)).add(L),b=b.add(r(O,44)),[O.add(N),b.add(E)]}(n(S,P),n(S,P+8),n(S,P+16),n(S,P+24),L,N)}function T(S,P=S.length){const L=u.fromNumber(81,!0);if(P<=32)return P<=16?function _(S,P=S.length){if(P>=8){const L=f.add(2*P),N=n(S,0).add(f),O=n(S,P-8);return d(r(O,37).mul(L).add(N),r(N,25).add(O).mul(L),L)}if(P>=4){const L=f.add(2*P);return d(s(S,0).shl(3).add(P),s(S,P-4),L)}if(P>0){const E=P+(S[P-1]<<2);return l(f.mul(S[0]+(S[P>>1]<<8)).xor(h.mul(E))).mul(f)}return f}(S,P):function v(S,P=S.length){const L=f.add(2*P),N=n(S,0).mul(i),O=n(S,8),b=n(S,P-8).mul(L),E=n(S,P-16).mul(f);return d(r(N.add(O),43).add(r(b,30)).add(E),N.add(r(O.add(f),18)).add(b),L)}(S,P);if(P<=64)return function M(S,P=S.length){const L=f.add(2*P),N=n(S,0).mul(f),O=n(S,8),b=n(S,P-8).mul(L),E=n(S,P-16).mul(f),$=r(N.add(O),43).add(r(b,30)).add(E),W=d($,N.add(r(O.add(f),18)).add(b),L),Z=n(S,16).mul(L),X=n(S,24),ut=$.add(n(S,P-32)).mul(L),Dt=W.add(n(S,P-24)).mul(L);return d(r(Z.add(X),43).add(r(ut,30)).add(Dt),Z.add(r(X.add(N),18)).add(ut),L)}(S,P);let N=L,O=L.mul(i).add(113),b=l(O.mul(f).add(113)).mul(f),E=[u.UZERO,u.UZERO],$=[u.UZERO,u.UZERO];N=N.mul(f).add(n(S,0));let W=0;const Z=64*(P-1>>6),X=Z+(P-1&63)-63;do{N=r(N.add(O).add(E[0]).add(n(S,W+8)),37).mul(i),O=r(O.add(E[1]).add(n(S,W+48)),42).mul(i),N=N.xor($[1]),O=O.add(E[0]).add(n(S,W+40)),b=r(b.add($[0]),33).mul(i),E=g(S,W,E[1].mul(i),N.add($[0])),$=g(S,W+32,b.add($[1]),O.add(n(S,W+16))),[b,N]=[N,b],W+=64}while(W!==Z);const ut=i.add(b.and(255).shl(1));return W=X,$[0]=$[0].add(P-1&63),E[0]=E[0].add($[0]),$[0]=$[0].add(E[0]),N=r(N.add(O).add(E[0]).add(n(S,W+8)),37).mul(ut),O=r(O.add(E[1]).add(n(S,W+48)),42).mul(ut),N=N.xor($[1].mul(9)),O=O.add(E[0].mul(9).add(n(S,W+40))),b=r(b.add($[0]),33).mul(ut),E=g(S,W,E[1].mul(ut),N.add($[0])),$=g(S,W+32,b.add($[1]),O.add(n(S,W+16))),[b,N]=[N,b],d(d(E[0],$[0],ut).add(l(O).mul(h)).add(b),d(E[1],$[1],ut).add(N),ut)}},51462:(H,C,t)=>{"use strict";t.d(C,{ns:()=>g,y$:()=>T});var e=t(15861),u=(t(881),t(5527)),c=t(98339),h=t(50679),i=t(37864);const f="tensorflowjs",o="models_store",n="model_info_store";function d(){if(!(0,u.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const S=typeof window>"u"?self:window,P=S.indexedDB||S.mozIndexedDB||S.webkitIndexedDB||S.msIndexedDB||S.shimIndexedDB;if(null==P)throw new Error("The current browser does not appear to support IndexedDB.");return P}function p(S){const P=S.result;P.createObjectStore(o,{keyPath:"modelPath"}),P.createObjectStore(n,{keyPath:"modelPath"})}let g=(()=>{class S{constructor(L){if(this.indexedDB=d(),null==L||!L)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=L}save(L){var N=this;return(0,e.Z)(function*(){if(L.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return N.databaseAction(N.modelPath,L)})()}load(){var L=this;return(0,e.Z)(function*(){return L.databaseAction(L.modelPath)})()}databaseAction(L,N){return new Promise((O,b)=>{const E=this.indexedDB.open(f,1);E.onupgradeneeded=()=>p(E),E.onsuccess=()=>{const $=E.result;if(null==N){const W=$.transaction(o,"readonly"),X=W.objectStore(o).get(this.modelPath);X.onsuccess=()=>{if(null==X.result)return $.close(),b(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));O(X.result.modelArtifacts)},X.onerror=ut=>($.close(),b(X.error)),W.oncomplete=()=>$.close()}else{N.weightData=i.w.join(N.weightData);const W=(0,c.Q)(N),Z=$.transaction(n,"readwrite");let ut,Dt,X=Z.objectStore(n);try{ut=X.put({modelPath:this.modelPath,modelArtifactsInfo:W})}catch(Y){return b(Y)}ut.onsuccess=()=>{Dt=$.transaction(o,"readwrite");const Y=Dt.objectStore(o);let ht;try{ht=Y.put({modelPath:this.modelPath,modelArtifacts:N,modelArtifactsInfo:W})}catch(Pt){return b(Pt)}ht.onsuccess=()=>O({modelArtifactsInfo:W}),ht.onerror=Pt=>{X=Z.objectStore(n);const pt=X.delete(this.modelPath);pt.onsuccess=()=>($.close(),b(ht.error)),pt.onerror=xt=>($.close(),b(ht.error))}},ut.onerror=Y=>($.close(),b(ut.error)),Z.oncomplete=()=>{null==Dt?$.close():Dt.oncomplete=()=>$.close()}}},E.onerror=$=>b(E.error)})}}return S.URL_SCHEME="indexeddb://",S})();const _=S=>(0,u.OB)().getBool("IS_BROWSER")&&!Array.isArray(S)&&S.startsWith(g.URL_SCHEME)?function v(S){return new g(S)}(S.slice(g.URL_SCHEME.length)):null;h.U3.registerSaveRouter(_),h.U3.registerLoadRouter(_);class T{constructor(){this.indexedDB=d()}listModels(){var P=this;return(0,e.Z)(function*(){return new Promise((L,N)=>{const O=P.indexedDB.open(f,1);O.onupgradeneeded=()=>p(O),O.onsuccess=()=>{const b=O.result,E=b.transaction(n,"readonly"),W=E.objectStore(n).getAll();W.onsuccess=()=>{const Z={};for(const X of W.result)Z[X.modelPath]=X.modelArtifactsInfo;L(Z)},W.onerror=Z=>(b.close(),N(W.error)),E.oncomplete=()=>b.close()},O.onerror=b=>N(O.error)})})()}removeModel(P){var L=this;return(0,e.Z)(function*(){return P=function M(S){return S.startsWith(g.URL_SCHEME)?S.slice(g.URL_SCHEME.length):S}(P),new Promise((N,O)=>{const b=L.indexedDB.open(f,1);b.onupgradeneeded=()=>p(b),b.onsuccess=()=>{const E=b.result,$=E.transaction(n,"readwrite"),W=$.objectStore(n),Z=W.get(P);let X;Z.onsuccess=()=>{if(null==Z.result)return E.close(),O(new Error(`Cannot find model with path '${P}' in IndexedDB.`));{const ut=W.delete(P),Dt=()=>{X=E.transaction(o,"readwrite");const ht=X.objectStore(o).delete(P);ht.onsuccess=()=>N(Z.result.modelArtifactsInfo),ht.onerror=Pt=>O(Z.error)};ut.onsuccess=Dt,ut.onerror=Y=>(Dt(),E.close(),O(Z.error))}},Z.onerror=ut=>(E.close(),O(Z.error)),$.oncomplete=()=>{null==X?E.close():X.oncomplete=()=>E.close()}},b.onerror=E=>O(b.error)})})()}}},83187:(H,C,t)=>{"use strict";t.d(C,{Ew:()=>S,JL:()=>N});var e=t(15861),u=(t(881),t(5527)),c=t(45359),h=t(98339),i=t(37864),f=t(50679);const l="/",o="tensorflowjs_models",n="info",s="model_topology",r="weight_specs",d="weight_data",p="model_metadata";function _(O){return{info:[o,O,n].join(l),topology:[o,O,s].join(l),weightSpecs:[o,O,r].join(l),weightData:[o,O,d].join(l),modelMetadata:[o,O,p].join(l)}}function v(O){for(const b of Object.values(O))window.localStorage.removeItem(b)}function M(O){const b=O.split(l);if(b.length<3)throw new Error(`Invalid key format: ${O}`);return b.slice(1,b.length-1).join(l)}let S=(()=>{class O{constructor(E){if(!(0,u.OB)().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==E||!E)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=E,this.keys=_(this.modelPath)}save(E){var $=this;return(0,e.Z)(function*(){if(E.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const W=JSON.stringify(E.modelTopology),Z=JSON.stringify(E.weightSpecs),X=(0,h.Q)(E),ut=i.w.join(E.weightData);try{return $.LS.setItem($.keys.info,JSON.stringify(X)),$.LS.setItem($.keys.topology,W),$.LS.setItem($.keys.weightSpecs,Z),$.LS.setItem($.keys.weightData,(0,h._n)(ut)),$.LS.setItem($.keys.modelMetadata,JSON.stringify({format:E.format,generatedBy:E.generatedBy,convertedBy:E.convertedBy,signature:null!=E.signature?E.signature:void 0,userDefinedMetadata:null!=E.userDefinedMetadata?E.userDefinedMetadata:void 0,modelInitializer:null!=E.modelInitializer?E.modelInitializer:void 0,initializerSignature:null!=E.initializerSignature?E.initializerSignature:void 0,trainingConfig:null!=E.trainingConfig?E.trainingConfig:void 0})),{modelArtifactsInfo:X}}catch{throw v($.keys),new Error(`Failed to save model '${$.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${X.modelTopologyBytes}, weightSpecsBytes=${X.weightSpecsBytes}, weightDataBytes=${X.weightDataBytes}.`)}}})()}load(){var E=this;return(0,e.Z)(function*(){const $=JSON.parse(E.LS.getItem(E.keys.info));if(null==$)throw new Error(`In local storage, there is no model with name '${E.modelPath}'`);if("JSON"!==$.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const W={},Z=JSON.parse(E.LS.getItem(E.keys.topology));if(null==Z)throw new Error(`In local storage, the topology of model '${E.modelPath}' is missing.`);W.modelTopology=Z;const X=JSON.parse(E.LS.getItem(E.keys.weightSpecs));if(null==X)throw new Error(`In local storage, the weight specs of model '${E.modelPath}' are missing.`);W.weightSpecs=X;const ut=E.LS.getItem(E.keys.modelMetadata);if(null!=ut){const Y=JSON.parse(ut);W.format=Y.format,W.generatedBy=Y.generatedBy,W.convertedBy=Y.convertedBy,null!=Y.signature&&(W.signature=Y.signature),null!=Y.userDefinedMetadata&&(W.userDefinedMetadata=Y.userDefinedMetadata),null!=Y.modelInitializer&&(W.modelInitializer=Y.modelInitializer),null!=Y.initializerSignature&&(W.initializerSignature=Y.initializerSignature),null!=Y.trainingConfig&&(W.trainingConfig=Y.trainingConfig)}const Dt=E.LS.getItem(E.keys.weightData);if(null==Dt)throw new Error(`In local storage, the binary weight values of model '${E.modelPath}' are missing.`);return W.weightData=(0,h.n7)(Dt),W})()}}return O.URL_SCHEME="localstorage://",O})();const P=O=>(0,u.OB)().getBool("IS_BROWSER")&&!Array.isArray(O)&&O.startsWith(S.URL_SCHEME)?function L(O){return new S(O)}(O.slice(S.URL_SCHEME.length)):null;f.U3.registerSaveRouter(P),f.U3.registerLoadRouter(P);class N{constructor(){(0,c.hu)((0,u.OB)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,c.hu)(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var b=this;return(0,e.Z)(function*(){const E={},$=o+l,W=l+n;for(let Z=0;Z<b.LS.length;++Z){const X=b.LS.key(Z);X.startsWith($)&&X.endsWith(W)&&(E[M(X)]=JSON.parse(b.LS.getItem(X)))}return E})()}removeModel(b){var E=this;return(0,e.Z)(function*(){const $=_(b=function T(O){return O.startsWith(S.URL_SCHEME)?O.slice(S.URL_SCHEME.length):O}(b));if(null==E.LS.getItem($.info))throw new Error(`Cannot find model at path '${b}'`);const W=JSON.parse(E.LS.getItem($.info));return v($),W})()}}},46705:(H,C,t)=>{"use strict";t.d(C,{b:()=>a});var e=t(45359);function a(u,c,h,i){(function o(s){(0,e.hu)(null!=s&&Array.isArray(s)&&s.length>0,()=>"promises must be a none empty array")})(u),function n(s,r){(0,e.hu)(s>=0&&s<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${s}`),(0,e.hu)(r>=0&&r<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${r}`),(0,e.hu)(r>=s,()=>`startFraction must be no more than endFraction, but got startFraction ${s} and endFraction ${r}`)}(h=h??0,i=i??1);let f=0;return Promise.all(u.map(s=>(s.then(r=>{const d=h+ ++f/u.length*(i-h);return c(d),r}),s)))}},12932:(H,C,t)=>{"use strict";t.d(C,{Z:()=>a,c:()=>u});var e=t(5527);function a(...c){(0,e.OB)().getBool("IS_TEST")||(0,e.OB)().getBool("PROD")||console.warn(...c)}function u(...c){(0,e.OB)().getBool("IS_TEST")||(0,e.OB)().getBool("PROD")||console.log(...c)}},26989:(H,C,t)=>{"use strict";t.d(C,{W:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({abs_:function h(f){const l=(0,u._1)(f,"x","abs");return e.BV.runKernel("complex64"===l.dtype?a.yj2:a.SYM,{x:l})}})},91184:(H,C,t)=>{"use strict";t.d(C,{K:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({acos_:function h(f){const o={x:(0,u._1)(f,"x","acos")};return e.BV.runKernel(a.VGw,o)}})},15622:(H,C,t)=>{"use strict";t.d(C,{_:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({acosh_:function h(f){const o={x:(0,u._1)(f,"x","acosh")};return e.BV.runKernel(a.SpW,o)}})},87066:(H,C,t)=>{"use strict";t.d(C,{I:()=>f});var e=t(40687),a=t(34251),u=t(27664),c=t(1257);const f=(0,t(44195).op)({add_:function i(l,o){let n=(0,c._1)(l,"a","add"),s=(0,c._1)(o,"b","add");return[n,s]=(0,u.makeTypesMatch)(n,s),e.BV.runKernel(a.mm_,{a:n,b:s})}})},51862:(H,C,t)=>{"use strict";t.d(C,{$:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({all_:function h(f,l=null,o=!1){const s={x:(0,u._1)(f,"x","all","bool")};return e.BV.runKernel(a.oT6,s,{axis:l,keepDims:o})}})},40876:(H,C,t)=>{"use strict";t.d(C,{Y:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({any_:function h(f,l=null,o=!1){const s={x:(0,u._1)(f,"x","any","bool")};return e.BV.runKernel(a.IKK,s,{axis:l,keepDims:o})}})},45784:(H,C,t)=>{"use strict";t.d(C,{N:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({argMax_:function h(f,l=0){const n={x:(0,u._1)(f,"x","argMax")};return e.BV.runKernel(a.sJF,n,{axis:l})}})},78340:(H,C,t)=>{"use strict";t.d(C,{v:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({argMin_:function h(f,l=0){const n={x:(0,u._1)(f,"x","argMin")};return e.BV.runKernel(a.aJk,n,{axis:l})}})},80586:(H,C,t)=>{"use strict";t.d(C,{Z:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({asin_:function h(f){const o={x:(0,u._1)(f,"x","asin")};return e.BV.runKernel(a.M2y,o)}})},38355:(H,C,t)=>{"use strict";t.d(C,{V:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({asinh_:function h(f){const o={x:(0,u._1)(f,"x","asinh")};return e.BV.runKernel(a.qw7,o)}})},37881:(H,C,t)=>{"use strict";t.d(C,{z:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({atan_:function h(f){const o={x:(0,u._1)(f,"x","atan")};return e.BV.runKernel(a.jMg,o)}})},25825:(H,C,t)=>{"use strict";t.d(C,{f:()=>f});var e=t(40687),a=t(34251),u=t(27664),c=t(1257);const f=(0,t(44195).op)({atan2_:function i(l,o){let n=(0,c._1)(l,"a","atan2"),s=(0,c._1)(o,"b","atan2");return[n,s]=(0,u.makeTypesMatch)(n,s),e.BV.runKernel(a.QCc,{a:n,b:s})}})},17932:(H,C,t)=>{"use strict";t.d(C,{C:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({atanh_:function h(f){const o={x:(0,u._1)(f,"x","atanh")};return e.BV.runKernel(a.Oyi,o)}})},6903:(H,C,t)=>{"use strict";t.d(C,{w:()=>n});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(3062),i=t(5551),f=t(44195),l=t(25715);const n=(0,f.op)({avgPool_:function o(s,r,d,p,g){const _=(0,u._1)(s,"x","avgPool","float32");c.hu(i.jT(d,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${d} and dilations '1'`);let M=_,T=!1;3===_.rank&&(T=!0,M=(0,l.X)(_,[1,_.shape[0],_.shape[1],_.shape[2]])),c.hu(4===M.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${M.rank}.`),i.m("avgPool",p,g);let L=e.BV.runKernel(a.JhU,{x:M},{filterSize:r,strides:d,pad:p,dimRoundingMode:g});return L=(0,h.p)(L,_.dtype),T?(0,l.X)(L,[L.shape[1],L.shape[2],L.shape[3]]):L}})},3075:(H,C,t)=>{"use strict";t.d(C,{u:()=>n});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(3062),i=t(5551),f=t(44195),l=t(25715);const n=(0,f.op)({avgPool3d_:function o(s,r,d,p,g,_="NDHWC"){const v=(0,u._1)(s,"x","avgPool3d","float32");let M=v,T=!1;4===v.rank&&(T=!0,M=(0,l.X)(v,[1,v.shape[0],v.shape[1],v.shape[2],v.shape[3]])),c.hu(5===M.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${M.rank}.`),c.hu("NDHWC"===_,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${_}`),c.hu("number"==typeof d&&d>0||Array.isArray(d)&&d[0]>0&&d[1]>0&&d[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${d}'`),(0,i.m)("avgPool3d",p,g);let L=e.BV.runKernel(a._k9,{x:M},{filterSize:r,strides:d,pad:p,dimRoundingMode:g,dataFormat:_});return L=(0,h.p)(L,M.dtype),T?(0,l.X)(L,[L.shape[1],L.shape[2],L.shape[3],L.shape[4]]):L}})},30929:(H,C,t)=>{"use strict";t.d(C,{LJ:()=>l,Q3:()=>f,Vh:()=>u,YB:()=>a,kz:()=>c,lB:()=>i,rv:()=>h,sY:()=>o});var e=t(45359);function a(n,s){for(let r=0;r<n.length;++r)if(n[n.length-r-1]!==s-1-r)return!1;return!0}function u(n,s,r){const d=n.length+s.length,p=[];let g=0,_=0;for(let v=0;v<d;v++)-1===r.indexOf(v)?p.push(n[g++]):p.push(s[_++]);return p}function c(n,s){const r=[],d=n.length;for(let g=0;g<d;g++)-1===s.indexOf(g)&&r.push(n[g]);return[r,s.map(g=>n[g])]}function h(n,s){return u(n,s.map(d=>1),s)}function i(n,s,r){e.hu(a(s,r),()=>`${n} supports only inner-most axes for now. Got axes ${s} and rank-${r} input.`)}function f(n,s){if(a(n,s))return null;const r=[];for(let d=0;d<s;++d)-1===n.indexOf(d)&&r.push(d);return n.forEach(d=>r.push(d)),r}function l(n){return n.map((s,r)=>[r,s]).sort((s,r)=>s[1]-r[1]).map(s=>s[0])}function o(n,s){const r=[];for(let d=s-n;d<s;++d)r.push(d);return r}},92782:(H,C,t)=>{"use strict";t.d(C,{E:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({batchToSpaceND_:function i(l,o,n){const s=(0,u._1)(l,"x","batchToSpaceND"),r=o.reduce((g,_)=>g*_);return c.hu(s.rank>=1+o.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${o.length}`),c.hu(n.length===o.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${o.length}`),c.hu(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${o.join(" * ")} === ${r}`),e.BV.runKernel(a.zws,{x:s},{blockShape:o,crops:n})}})},35307:(H,C,t)=>{"use strict";t.d(C,{t:()=>o});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(25715);function i(n){let s;return s=0===n.rank||1===n.rank?(0,h.X)(n,[1,1,1,n.size]):2===n.rank?(0,h.X)(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?(0,h.X)(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,s}const o=(0,t(44195).op)({batchNorm_:function l(n,s,r,d,p,g){null==g&&(g=.001);const _=(0,u._1)(n,"x","batchNorm"),v=(0,u._1)(s,"mean","batchNorm"),M=(0,u._1)(r,"variance","batchNorm");let T,S;null!=p&&(T=(0,u._1)(p,"scale","batchNorm")),null!=d&&(S=(0,u._1)(d,"offset","batchNorm")),c.hu(v.rank===M.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),c.hu(null==S||v.rank===S.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),c.hu(null==T||v.rank===T.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const L={x:i(_),scale:T,offset:S,mean:v,variance:M},O=e.BV.runKernel(a.sHE,L,{varianceEpsilon:g});return(0,h.X)(O,_.shape)}})},43174:(H,C,t)=>{"use strict";t.d(C,{D:()=>i});var e=t(1257),a=t(45359),u=t(35307);const i=(0,t(44195).op)({batchNorm2d_:function h(f,l,o,n,s,r){const d=(0,e._1)(f,"x","batchNorm"),p=(0,e._1)(l,"mean","batchNorm"),g=(0,e._1)(o,"variance","batchNorm");let _,v;return null!=s&&(_=(0,e._1)(s,"scale","batchNorm")),null!=n&&(v=(0,e._1)(n,"offset","batchNorm")),a.hu(2===d.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${d.rank}.`),a.hu(2===p.rank||1===p.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${p.rank}.`),a.hu(2===g.rank||1===g.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${g.rank}.`),null!=_&&a.hu(2===_.rank||1===_.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${_.rank}.`),null!=v&&a.hu(2===v.rank||1===v.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${v.rank}.`),(0,u.t)(d,p,g,v,_,r)}})},24584:(H,C,t)=>{"use strict";t.d(C,{J:()=>i});var e=t(1257),a=t(45359),u=t(35307);const i=(0,t(44195).op)({batchNorm3d_:function h(f,l,o,n,s,r){const d=(0,e._1)(f,"x","batchNorm"),p=(0,e._1)(l,"mean","batchNorm"),g=(0,e._1)(o,"variance","batchNorm");let _,v;return null!=s&&(_=(0,e._1)(s,"scale","batchNorm")),null!=n&&(v=(0,e._1)(n,"offset","batchNorm")),a.hu(3===d.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${d.rank}.`),a.hu(3===p.rank||1===p.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${p.rank}.`),a.hu(3===g.rank||1===g.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${g.rank}.`),null!=_&&a.hu(3===_.rank||1===_.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${_.rank}.`),null!=v&&a.hu(3===v.rank||1===v.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${v.rank}.`),(0,u.t)(d,p,g,v,_,r)}})},35346:(H,C,t)=>{"use strict";t.d(C,{p:()=>i});var e=t(1257),a=t(45359),u=t(35307);const i=(0,t(44195).op)({batchNorm4d_:function h(f,l,o,n,s,r){const d=(0,e._1)(f,"x","batchNorm"),p=(0,e._1)(l,"mean","batchNorm"),g=(0,e._1)(o,"variance","batchNorm");let _,v;return null!=s&&(_=(0,e._1)(s,"scale","batchNorm")),null!=n&&(v=(0,e._1)(n,"offset","batchNorm")),a.hu(4===d.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${d.rank}.`),a.hu(4===p.rank||1===p.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${p.rank}.`),a.hu(4===g.rank||1===g.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${g.rank}.`),null!=_&&a.hu(4===_.rank||1===_.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${_.rank}.`),null!=v&&a.hu(4===v.rank||1===v.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${v.rank}.`),(0,u.t)(d,p,g,v,_,r)}})},27196:(H,C,t)=>{"use strict";t.d(C,{y:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({bincount_:function i(l,o,n){const s=(0,u._1)(l,"x","bincount"),r=(0,u._1)(o,"weights","bincount");return c.hu("int32"===s.dtype,()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),c.hu(n>=0,()=>`size must be non-negative, but got ${n}.`),c.hu(r.size===s.size||0===r.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`),e.BV.runKernel(a.zvY,{x:s,weights:r},{size:n})}})},90983:(H,C,t)=>{"use strict";t.d(C,{U:()=>o});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(87315),i=t(44195),f=t(25715);const o=(0,i.op)({broadcastTo_:function l(n,s){let r=(0,u._1)(n,"broadcastTo","x");const d=r.shape;if((0,c.Mu)(s),s.length<r.rank)throw new Error(`broadcastTo(): shape.length=${s.length} < input.rank=${r.rank}.`);if(s.length>r.rank){const T=r.shape.slice();for(;T.length<s.length;)T.unshift(1);r=(0,f.X)(r,T)}const p=r.shape,g=Array.from(s);for(let T=s.length-1;T>=0;T--)if(p[T]===s[T])g[T]=1;else if(1!==r.shape[T])throw new Error(`broadcastTo(): [${d}] cannot be broadcast to [${s}].`);return 0===g.map((T,S)=>T>1?S:-1).filter(T=>T>=0).length?(0,h.d)(r):e.BV.runKernel(a.n9L,{x:r},{reps:g})}})},93239:(H,C,t)=>{"use strict";function e(c,h){const i=c.length,f=[];for(let l=0;l<i;l++){const o=i-1-l;(h[h.length-1-l]||1)>1&&1===(c[o]||1)&&f.unshift(o)}return f}function a(c,h){const i=[];for(let f=0;f<h.length;f++){const l=c[c.length-f-1],o=h.length-f-1;(null==l||1===l&&h[o]>1)&&i.unshift(o)}return i}function u(c,h){const i=Math.max(c.length,h.length),f=new Array(i);for(let l=0;l<i;l++){let o=c[c.length-l-1];null==o&&(o=1);let n=h[h.length-l-1];if(null==n&&(n=1),1===o)f[i-l-1]=n;else if(1===n)f[i-l-1]=o;else{if(o!==n)throw Error(`Operands could not be broadcast together with shapes ${c} and ${h}.`);f[i-l-1]=o}}return f}t.r(C),t.d(C,{assertAndGetBroadcastShape:()=>u,getBroadcastDims:()=>e,getReductionAxes:()=>a})},80582:(H,C,t)=>{"use strict";t.d(C,{f:()=>u});var e=t(4296),a=t(45359);function u(c,h="float32",i){return h=h||"float32",a.Mu(c),new e.YD(c,h,i)}},3062:(H,C,t)=>{"use strict";t.d(C,{p:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({cast_:function i(l,o){const n=(0,u._1)(l,"x","cast");if(!c.LP(o))throw new Error(`Failed to cast to unknown dtype ${o}`);if("string"===o&&"string"!==n.dtype||"string"!==o&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return e.BV.runKernel(a.RFZ,{x:n},{dtype:o})}})},39723:(H,C,t)=>{"use strict";t.d(C,{m:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({ceil_:function h(f){const o={x:(0,u._1)(f,"x","ceil","float32")};return e.BV.runKernel(a.gJX,o)}})},46672:(H,C,t)=>{"use strict";t.d(C,{i:()=>l});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(62787);const l=(0,t(44195).op)({clipByValue_:function f(o,n,s){const r=(0,u._1)(o,"x","clipByValue");return c.hu(n<=s,()=>`Error in clip: min (${n}) must be less than or equal to max (${s}).`),n===s?(0,h.h)(r.shape,n,r.dtype):e.BV.runKernel(a.xnO,{x:r},{clipValueMin:n,clipValueMax:s})}})},87315:(H,C,t)=>{"use strict";t.d(C,{d:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({clone_:function h(f){const o={x:(0,u._1)(f,"x","clone","string_or_numeric")};return e.BV.runKernel(a.iJz,o)}})},93037:(H,C,t)=>{"use strict";t.d(C,{P:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({complex_:function i(l,o){const n=(0,u._1)(l,"real","complex"),s=(0,u._1)(o,"imag","complex");return c.k5(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`),e.BV.runKernel(a.Zz9,{real:n,imag:s})}})},64111:(H,C,t)=>{"use strict";t.d(C,{z:()=>l});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(87315);const l=(0,t(44195).op)({concat_:function f(o,n=0){(0,c.hu)(o.length>=1,()=>"Pass at least one tensor to concat");const s=(0,u.sI)(o,"tensors","concat","string_or_numeric");return"complex64"===s[0].dtype&&s.forEach(p=>{if("complex64"!==p.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${p.dtype}. `)}),1===s.length?(0,h.d)(s[0]):e.BV.runKernel(a.Eh3,s,{axis:n})}})},85702:(H,C,t)=>{"use strict";t.d(C,{g:()=>c});var e=t(64111);const c=(0,t(44195).op)({concat1d_:function u(h){return(0,e.z)(h,0)}})},83193:(H,C,t)=>{"use strict";t.d(C,{I:()=>c});var e=t(64111);const c=(0,t(44195).op)({concat2d_:function u(h,i){return(0,e.z)(h,i)}})},80763:(H,C,t)=>{"use strict";t.d(C,{M:()=>c});var e=t(64111);const c=(0,t(44195).op)({concat3d_:function u(h,i){return(0,e.z)(h,i)}})},44486:(H,C,t)=>{"use strict";t.d(C,{Z:()=>c});var e=t(64111);const c=(0,t(44195).op)({concat4d_:function u(h,i){return(0,e.z)(h,i)}})},28577:(H,C,t)=>{"use strict";t.d(C,{P:()=>l});var e=t(1257),a=t(45359),u=t(84451),c=t(5551),h=t(44195),i=t(25715);const l=(0,h.op)({conv1d_:function f(o,n,s,r,d="NWC",p=1,g){const _=(0,e._1)(o,"x","conv1d"),v=(0,e._1)(n,"filter","conv1d");let M=_,T=!1;2===_.rank&&(T=!0,M=(0,i.X)(_,[1,_.shape[0],_.shape[1]])),a.hu(3===M.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${M.rank}.`),a.hu(3===v.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${v.rank}.`),c.m("conv1d",r,g),a.hu(M.shape[2]===v.shape[1],()=>`Error in conv1d: depth of input (${M.shape[2]}) must match input depth for filter ${v.shape[1]}.`),a.hu(c.jT(s,p),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${s} and dilation '${p}'`),a.hu(c.U3(p),()=>"Error in conv1D: Dilated rates should be larger than 0."),a.hu(c.U3(s),()=>"Error in conv1D: Stride should be larger than 0."),a.hu("NWC"===d,()=>`Error in conv1d: got dataFormat of ${d} but only NWC is currently supported.`);const S=(0,i.X)(v,[1,v.shape[0],v.shape[1],v.shape[2]]),P=(0,i.X)(M,[M.shape[0],1,M.shape[1],M.shape[2]]),b=(0,u.T)(P,S,[1,s],r,"NHWC",[1,p],g);return(0,i.X)(b,T?[b.shape[2],b.shape[3]]:[b.shape[0],b.shape[2],b.shape[3]])}})},84451:(H,C,t)=>{"use strict";t.d(C,{T:()=>o});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(5551),i=t(44195),f=t(25715);const o=(0,i.op)({conv2d_:function l(n,s,r,d,p="NHWC",g=[1,1],_){const v=(0,u._1)(n,"x","conv2d","float32"),M=(0,u._1)(s,"filter","conv2d","float32");let T=v,S=!1;3===v.rank&&(S=!0,T=(0,f.X)(v,[1,v.shape[0],v.shape[1],v.shape[2]])),c.hu(4===T.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${T.rank}.`),c.hu(4===M.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${M.rank}.`),h.m("conv2d",d,_);const P="NHWC"===p?T.shape[3]:T.shape[1];c.hu(P===M.shape[2],()=>`Error in conv2d: depth of input (${P}) must match input depth for filter ${M.shape[2]}.`),c.hu(h.jT(r,g),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${g}'`),c.hu(h.U3(g),()=>"Error in conv2D: Dilated rates should be larger than 0."),c.hu(h.U3(r),()=>"Error in conv2D: Strides should be larger than 0.");const O=e.BV.runKernel(a.mhS,{x:T,filter:M},{strides:r,pad:d,dataFormat:p,dilations:g,dimRoundingMode:_});return S?(0,f.X)(O,[O.shape[1],O.shape[2],O.shape[3]]):O}})},10443:(H,C,t)=>{"use strict";t.d(C,{p:()=>l});var e=t(40687),a=t(34251),u=t(45359),c=t(5551),h=t(44195),i=t(25715);const l=(0,h.op)({conv2DBackpropFilter_:function f(o,n,s,r,d,p="NHWC",g){let _=o;3===o.rank&&(_=(0,i.X)(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let v=n;3===v.rank&&(v=(0,i.X)(n,[1,n.shape[0],n.shape[1],n.shape[2]])),u.hu(4===_.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${_.shape}.`),u.hu(4===v.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${v.shape}.`),u.hu(4===s.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${s}.`);const M="NHWC"===p?_.shape[3]:_.shape[1],T="NHWC"===p?v.shape[3]:v.shape[1];return u.hu(M===s[2],()=>`Error in conv2dDerFilter: depth of input ${M}) must match input depth in filter (${s[2]}.`),u.hu(T===s[3],()=>`Error in conv2dDerFilter: depth of dy (${T}) must match output depth for filter (${s[3]}).`),c.m("conv2dDerFilter",d,g),e.BV.runKernel(a.wUP,{x:_,dy:v},{strides:r,pad:d,dataFormat:p,dimRoundingMode:g,filterShape:s})}})},95743:(H,C,t)=>{"use strict";t.d(C,{_:()=>l});var e=t(40687),a=t(34251),u=t(45359),c=t(5551),h=t(44195),i=t(25715);const l=(0,h.op)({conv2DBackpropInput_:function f(o,n,s,r,d,p="NHWC",g){u.hu(o.length===n.rank,()=>`Length of inShape (${o.length}) and rank of dy (${n.rank}) must match`);let _=o,v=n,M=!1;3===n.rank&&(M=!0,v=(0,i.X)(n,[1,n.shape[0],n.shape[1],n.shape[2]]),_=[1,o[0],o[1],o[2]]),u.hu(4===_.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${_.length}.`),u.hu(4===v.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${v.rank}`),u.hu(4===s.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${s.rank}`);const T="NHWC"===p?_[3]:_[1],S="NHWC"===p?v.shape[3]:v.shape[1];u.hu(T===s.shape[2],()=>`Error in conv2dDerInput: depth of input (${T}) must match input depth for filter ${s.shape[2]}.`),u.hu(S===s.shape[3],()=>`Error in conv2dDerInput: depth of output (${S}) must match output depth for filter ${s.shape[3]}.`),c.m("conv2dDerInput",d,g);const N=e.BV.runKernel(a.wm,{dy:v,filter:s},{strides:r,pad:d,dataFormat:p,dimRoundingMode:g,inputShape:_});return M?(0,i.X)(N,[N.shape[1],N.shape[2],N.shape[3]]):N}})},98554:(H,C,t)=>{"use strict";t.d(C,{b:()=>h});var e=t(1257),a=t(95743);const h=(0,t(44195).op)({conv2dTranspose_:function c(i,f,l,o,n,s){const r=(0,e._1)(i,"x","conv2dTranspose"),d=(0,e._1)(f,"filter","conv2dTranspose");return(0,a._)(l,r,d,o,n,"NHWC",s)}})},15380:(H,C,t)=>{"use strict";t.d(C,{p:()=>o});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(5551),i=t(44195),f=t(25715);const o=(0,i.op)({conv3d_:function l(n,s,r,d,p="NDHWC",g=[1,1,1]){const _=(0,u._1)(n,"x","conv3d"),v=(0,u._1)(s,"filter","conv3d");let M=_,T=!1;4===_.rank&&(T=!0,M=(0,f.X)(_,[1,_.shape[0],_.shape[1],_.shape[2],_.shape[3]])),c.hu(5===M.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${M.rank}.`),c.hu(5===v.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${v.rank}.`),c.hu(M.shape[4]===v.shape[3],()=>`Error in conv3d: depth of input (${M.shape[4]}) must match input depth for filter ${v.shape[3]}.`),c.hu((0,h.jT)(r,g),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${r} and dilations '${g}'`),c.hu("NDHWC"===p,()=>`Error in conv3d: got dataFormat of ${p} but only NDHWC is currently supported.`),c.hu((0,h.U3)(g),()=>"Error in conv3D: Dilated rates should be larger than 0."),c.hu((0,h.U3)(r),()=>"Error in conv3D: Strides should be larger than 0.");const L=e.BV.runKernel(a.x12,{x:M,filter:v},{strides:r,pad:d,dataFormat:p,dilations:g});return T?(0,f.X)(L,[L.shape[1],L.shape[2],L.shape[3],L.shape[4]]):L}})},37022:(H,C,t)=>{"use strict";t.d(C,{_:()=>f});var e=t(40687),a=t(34251),u=t(45359),c=t(44195),h=t(25715);const f=(0,c.op)({conv3DBackpropInput_:function i(l,o,n,s,r){u.hu(l.length===o.rank,()=>`Length of inShape (${l.length}) and rank of dy (${o.rank}) must match`);let d=l,p=o,g=!1;4===o.rank&&(g=!0,p=(0,h.X)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=[1,l[0],l[1],l[2],l[3]]);const _=d[4],v=p.shape[4];u.hu(5===d.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${d.length}.`),u.hu(5===p.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${p.rank}`),u.hu(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),u.hu(_===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${_}) must match input depth for filter ${n.shape[3]}.`),u.hu(v===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${v}) must match output depth for filter ${n.shape[4]}.`);const S=e.BV.runKernel(a.ik2,{dy:p,filter:n},{pad:r,strides:s,inputShape:d});return g?(0,h.X)(S,[S.shape[1],S.shape[2],S.shape[3],S.shape[4]]):S}})},80325:(H,C,t)=>{"use strict";t.d(C,{$:()=>h});var e=t(1257),a=t(37022);const h=(0,t(44195).op)({conv3dTranspose_:function c(i,f,l,o,n){const s=(0,e._1)(i,"x","conv3dTranspose"),r=(0,e._1)(f,"filter","conv3dTranspose");return(0,a._)(l,s,r,o,n)}})},5551:(H,C,t)=>{"use strict";t.d(C,{I0:()=>_,Ix:()=>h,Rf:()=>a,U3:()=>M,Xw:()=>u,aO:()=>o,jT:()=>v,jw:()=>i,m:()=>S,pl:()=>c,sl:()=>T});var e=t(45359);function a(P,L,N,O,b="NHWC",E){return h(P,[...L,P[3]],N,E,O,null,null,T(b))}function u(P,L,N,O,b,E,$="channelsLast"){const[W,Z]=n(L);let X;if("channelsLast"===$)X=[W,Z,P[3],P[3]];else{if("channelsFirst"!==$)throw new Error(`Unknown dataFormat ${$}`);X=[W,Z,P[1],P[1]]}return h(P,X,N,O,b,E,!1,$)}function c(P,L,N,O,b,E,$="NDHWC"){const[W,Z,X]=s(L);let ut,Dt;if("NDHWC"===$)Dt="channelsLast",ut=[W,Z,X,P[4],P[4]];else{if("NCDHW"!==$)throw new Error(`Unknown dataFormat ${$}`);Dt="channelsFirst",ut=[W,Z,X,P[1],P[1]]}return i(P,ut,N,O,b,!1,Dt,E)}function h(P,L,N,O,b,E,$=!1,W="channelsLast"){let[Z,X,ut,Dt]=[-1,-1,-1,-1];if("channelsLast"===W)[Z,X,ut,Dt]=P;else{if("channelsFirst"!==W)throw new Error(`Unknown dataFormat ${W}`);[Z,Dt,X,ut]=P}const[Y,ht,,Pt]=L,[pt,xt]=n(N),[Nt,Vt]=n(O),Gt=r(Y,Nt),oe=r(ht,Vt),{padInfo:Ee,outHeight:Ie,outWidth:ie}=function d(P,L,N,O,b,E,$,W,Z){let X,ut,Dt;if("number"==typeof P){X={top:P,bottom:P,left:P,right:P,type:0===P?"VALID":"NUMBER"};const ht=function f(P,L,N,O,b){null==O&&(O=o(P,L,N));const $=P[1];return[g((P[0]-L+2*O)/N+1,b),g(($-L+2*O)/N+1,b)]}([L,N],E,O,P,W);ut=ht[0],Dt=ht[1]}else if("same"===P){ut=Math.ceil(L/O),Dt=Math.ceil(N/b);const Y=Math.max(0,(ut-1)*O+E-L),ht=Math.max(0,(Dt-1)*b+$-N),Pt=Math.floor(Y/2),pt=Y-Pt,xt=Math.floor(ht/2);X={top:Pt,bottom:pt,left:xt,right:ht-xt,type:"SAME"}}else if("valid"===P)X={top:0,bottom:0,left:0,right:0,type:"VALID"},ut=Math.ceil((L-E+1)/O),Dt=Math.ceil((N-$+1)/b);else{if("object"!=typeof P)throw Error(`Unknown padding parameter: ${P}`);{const Y="channelsLast"===Z?P[1][0]:P[2][0],ht="channelsLast"===Z?P[1][1]:P[2][1],Pt="channelsLast"===Z?P[2][0]:P[3][0],pt="channelsLast"===Z?P[2][1]:P[3][1];X={top:Y,bottom:ht,left:Pt,right:pt,type:0===Y&&0===ht&&0===Pt&&0===pt?"VALID":"EXPLICIT"},ut=g((L-E+Y+ht)/O+1,W),Dt=g((N-$+Pt+pt)/b+1,W)}}return{padInfo:X,outHeight:ut,outWidth:Dt}}(b,X,ut,pt,xt,Gt,oe,E,W),Zt=$?Pt*Dt:Pt;let ct;return"channelsFirst"===W?ct=[Z,Zt,Ie,ie]:"channelsLast"===W&&(ct=[Z,Ie,ie,Zt]),{batchSize:Z,dataFormat:W,inHeight:X,inWidth:ut,inChannels:Dt,outHeight:Ie,outWidth:ie,outChannels:Zt,padInfo:Ee,strideHeight:pt,strideWidth:xt,filterHeight:Y,filterWidth:ht,effectiveFilterHeight:Gt,effectiveFilterWidth:oe,dilationHeight:Nt,dilationWidth:Vt,inShape:P,outShape:ct,filterShape:L}}function i(P,L,N,O,b,E=!1,$="channelsLast",W){let[Z,X,ut,Dt,Y]=[-1,-1,-1,-1,-1];if("channelsLast"===$)[Z,X,ut,Dt,Y]=P;else{if("channelsFirst"!==$)throw new Error(`Unknown dataFormat ${$}`);[Z,Y,X,ut,Dt]=P}const[ht,Pt,pt,,xt]=L,[Nt,Vt,Gt]=s(N),[oe,Ee,Ie]=s(O),ie=r(ht,oe),Zt=r(Pt,Ee),ct=r(pt,Ie),{padInfo:It,outDepth:Ut,outHeight:q,outWidth:K}=function p(P,L,N,O,b,E,$,W,Z,X,ut){let Dt,Y,ht,Pt;if("valid"===P&&(P=0),"number"==typeof P){Dt={top:P,bottom:P,left:P,right:P,front:P,back:P,type:0===P?"VALID":"NUMBER"};const xt=function l(P,L,N,O,b,E){null==b&&(b=o(P,L[0],O[0]));const $=[0,0,0,N];for(let W=0;W<3;W++)P[W]+2*b>=L[W]&&($[W]=g((P[W]-L[W]+2*b)/O[W]+1,E));return $}([L,N,O,1],[W,Z,X],1,[b,E,$],P,ut);Y=xt[0],ht=xt[1],Pt=xt[2]}else{if("same"!==P)throw Error(`Unknown padding parameter: ${P}`);{Y=Math.ceil(L/b),ht=Math.ceil(N/E),Pt=Math.ceil(O/$);const pt=(Y-1)*b+W-L,xt=(ht-1)*E+Z-N,Nt=(Pt-1)*$+X-O,Vt=Math.floor(pt/2),Gt=pt-Vt,oe=Math.floor(xt/2),Ee=xt-oe,Ie=Math.floor(Nt/2);Dt={top:oe,bottom:Ee,left:Ie,right:Nt-Ie,front:Vt,back:Gt,type:"SAME"}}}return{padInfo:Dt,outDepth:Y,outHeight:ht,outWidth:Pt}}(b,X,ut,Dt,Nt,Vt,Gt,ie,Zt,ct,W),j=E?xt*Y:xt;let at;return"channelsFirst"===$?at=[Z,j,Ut,q,K]:"channelsLast"===$&&(at=[Z,Ut,q,K,j]),{batchSize:Z,dataFormat:$,inDepth:X,inHeight:ut,inWidth:Dt,inChannels:Y,outDepth:Ut,outHeight:q,outWidth:K,outChannels:j,padInfo:It,strideDepth:Nt,strideHeight:Vt,strideWidth:Gt,filterDepth:ht,filterHeight:Pt,filterWidth:pt,effectiveFilterDepth:ie,effectiveFilterHeight:Zt,effectiveFilterWidth:ct,dilationDepth:oe,dilationHeight:Ee,dilationWidth:Ie,inShape:P,outShape:at,filterShape:L}}function o(P,L,N,O=1){const b=r(L,O);return Math.floor((P[0]*(N-1)-N+b)/2)}function n(P){return"number"==typeof P?[P,P,P]:2===P.length?[P[0],P[1],1]:P}function s(P){return"number"==typeof P?[P,P,P]:P}function r(P,L){return L<=1?P:P+(P-1)*(L-1)}function g(P,L){if(!L)return Math.trunc(P);switch(L){case"round":return Math.round(P);case"ceil":return Math.ceil(P);case"floor":return Math.floor(P);default:throw new Error(`Unknown roundingMode ${L}`)}}function _(P){const[L,N,O]=n(P);return 1===L&&1===N&&1===O}function v(P,L){return _(P)||_(L)}function M(P){return n(P).every(L=>L>0)}function T(P){if("NHWC"===P)return"channelsLast";if("NCHW"===P)return"channelsFirst";throw new Error(`Unknown dataFormat ${P}`)}function S(P,L,N){if(null!=N){if("string"==typeof L)throw Error(`Error in ${P}: pad must be an integer when using dimRoundingMode ${N} but got pad ${L}.`);if("number"==typeof L)e.hu(e.GN(L),()=>`Error in ${P}: pad must be an integer when using dimRoundingMode ${N} but got pad ${L}.`);else{if("object"!=typeof L)throw Error(`Error in ${P}: Unknown padding parameter: ${L}`);L.forEach(O=>{O.forEach(b=>{e.hu(e.GN(b),()=>`Error in ${P}: pad must be an integer when using dimRoundingMode ${N} but got pad ${b}.`)})})}}}},19018:(H,C,t)=>{"use strict";t.d(C,{m:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({cos_:function h(f){const o={x:(0,u._1)(f,"x","cos","float32")};return e.BV.runKernel(a.mc4,o)}})},63237:(H,C,t)=>{"use strict";t.d(C,{f:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({cosh_:function h(f){const o={x:(0,u._1)(f,"x","cosh","float32")};return e.BV.runKernel(a.TR1,o)}})},69267:(H,C,t)=>{"use strict";t.d(C,{$:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({cumprod_:function h(f,l=0,o=!1,n=!1){const r={x:(0,u._1)(f,"x","cumprod")};return e.BV.runKernel(a.Byc,r,{axis:l,exclusive:o,reverse:n})}})},67157:(H,C,t)=>{"use strict";t.d(C,{z:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({cumsum_:function h(f,l=0,o=!1,n=!1){const r={x:(0,u._1)(f,"x","cumsum")};return e.BV.runKernel(a.iHb,r,{axis:l,exclusive:o,reverse:n})}})},62959:(H,C,t)=>{"use strict";t.d(C,{p:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({denseBincount_:function i(l,o,n,s=!1){const r=(0,u._1)(l,"x","denseBincount"),d=(0,u._1)(o,"weights","denseBincount");return c.hu("int32"===r.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),c.hu(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),c.hu(n>=0,()=>`size must be non-negative, but got ${n}.`),c.hu(d.size===r.size||0===d.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${d.shape}.`),e.BV.runKernel(a.QRR,{x:r,weights:d},{size:n,binaryOutput:s})}})},43961:(H,C,t)=>{"use strict";t.d(C,{n:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({depthToSpace_:function i(l,o,n="NHWC"){const s=(0,u._1)(l,"x","depthToSpace","float32"),r="NHWC"===n?s.shape[1]:s.shape[2],d="NHWC"===n?s.shape[2]:s.shape[3],p="NHWC"===n?s.shape[3]:s.shape[1];return c.hu(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`),c.hu(r*o>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${o}  for depthToSpace with input shape\n    ${s.shape}`),c.hu(d*o>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${d} and ${o} for depthToSpace with input shape\n        ${s.shape}`),c.hu(p%(o*o)==0,()=>`Dimension size must be evenly divisible by ${o*o} but is ${p} for depthToSpace with input shape ${s.shape}`),e.BV.runKernel(a.T0n,{x:s},{blockSize:o,dataFormat:n})}})},51172:(H,C,t)=>{"use strict";t.d(C,{B:()=>o});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(5551),i=t(44195),f=t(25715);const o=(0,i.op)({depthwiseConv2d_:function l(n,s,r,d,p="NHWC",g=[1,1],_){const v=(0,u._1)(n,"x","depthwiseConv2d","float32"),M=(0,u._1)(s,"filter","depthwiseConv2d","float32");let T=v,S=!1;3===v.rank&&(S=!0,T=(0,f.X)(v,[1,v.shape[0],v.shape[1],v.shape[2]])),c.hu(4===T.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${T.rank}.`),c.hu(4===M.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${M.rank}.`);const P="NHWC"===p?T.shape[3]:T.shape[1];c.hu(P===M.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${P}) must match the inChannels dimension in filter ${M.shape[2]}.`),h.m("depthwiseConv2d",d,_);const O=e.BV.runKernel(a.cie,{x:T,filter:M},{strides:r,pad:d,dataFormat:p,dilations:g,dimRoundingMode:_});return S?(0,f.X)(O,[O.shape[1],O.shape[2],O.shape[3]]):O}})},366:(H,C,t)=>{"use strict";t.d(C,{z:()=>i});var e=t(40687),a=t(34251),u=t(44195),c=t(25715);const i=(0,u.op)({depthwiseConv2dNativeBackpropFilter_:function h(f,l,o,n,s,r=[1,1],d){let p=f;3===f.rank&&(p=(0,c.X)(f,[1,f.shape[0],f.shape[1],f.shape[2]]));let g=l;return 3===g.rank&&(g=(0,c.X)(l,[1,l.shape[0],l.shape[1],l.shape[2]])),e.BV.runKernel(a.sL$,{x:p,dy:g},{strides:n,pad:s,dimRoundingMode:d,dilations:r,filterShape:o})}})},519:(H,C,t)=>{"use strict";t.d(C,{v:()=>i});var e=t(40687),a=t(34251),u=t(44195),c=t(25715);const i=(0,u.op)({depthwiseConv2dNativeBackpropInput_:function h(f,l,o,n,s,r=[1,1],d){let p=l,g=!1;3===l.rank&&(g=!0,p=(0,c.X)(l,[1,l.shape[0],l.shape[1],l.shape[2]]));const M=e.BV.runKernel(a.y7R,{dy:p,filter:o},{strides:n,pad:s,dimRoundingMode:d,dilations:r,inputShape:f});return g?(0,c.X)(M,[M.shape[1],M.shape[2],M.shape[3]]):M}})},22395:(H,C,t)=>{"use strict";t.d(C,{W:()=>l});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(44195),i=t(25715);const l=(0,h.op)({dilation2d_:function f(o,n,s,r,d=[1,1],p="NHWC"){const g=(0,u._1)(o,"x","dilation2d"),_=(0,u._1)(n,"filter","dilation2d");c.hu(3===g.rank||4===g.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${g.rank}.`),c.hu(3===_.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${_.rank}.`),c.hu("NHWC"===p,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${p}`);let v=g,M=!1;3===g.rank&&(v=(0,i.X)(g,[1,g.shape[0],g.shape[1],g.shape[2]]),M=!0),c.hu(v.shape[3]===_.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${v.shape[3]} vs ${_.shape[2]}`);const P=e.BV.runKernel(a.p4S,{x:v,filter:_},{strides:s,pad:r,dilations:d});return M?(0,i.X)(P,[P.shape[1],P.shape[2],P.shape[3]]):P}})},93530:(H,C,t)=>{"use strict";t.d(C,{h:()=>l});var e=t(40687),a=t(34251),u=t(27664),c=t(1257),h=t(31030);const l=(0,t(44195).op)({div_:function f(o,n){let s=(0,c._1)(o,"a","div"),r=(0,c._1)(n,"b","div");return[s,r]=(0,u.makeTypesMatch)(s,r),"int32"===s.dtype&&"int32"===r.dtype?(0,h.q)(s,r):e.BV.runKernel(a.oHH,{a:s,b:r},{})}})},94373:(H,C,t)=>{"use strict";t.d(C,{N:()=>o});var e=t(27664),a=t(1257),u=t(93530),c=t(34456),h=t(44195),i=t(12190),f=t(23143);const o=(0,h.op)({divNoNan_:function l(n,s){let r=(0,a._1)(n,"a","div"),d=(0,a._1)(s,"b","div");[r,d]=(0,e.makeTypesMatch)(r,d);const p=(0,u.h)(r,d),g=(0,f.P)(p),_=(0,c.D)(d,g);return(0,i.a)(_,g,p)}})},55106:(H,C,t)=>{"use strict";t.d(C,{A:()=>f});var e=t(1257),a=t(45359),u=t(15592),c=t(44195),h=t(25715);const f=(0,c.op)({dot_:function i(l,o){const n=(0,e._1)(l,"t1","dot"),s=(0,e._1)(o,"t2","dot");a.hu(!(1!==n.rank&&2!==n.rank||1!==s.rank&&2!==s.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=1===n.rank?n.size:n.shape[1],d=1===s.rank?s.size:s.shape[0];if(a.hu(r===d,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${d}.`),1===n.rank&&1===s.rank){const p=(0,h.X)(n,[1,-1]),g=(0,h.X)(s,[-1,1]),_=(0,u.O)(p,g);return(0,h.X)(_,[])}if(1===n.rank&&2===s.rank){const p=(0,h.X)(n,[1,-1]),g=(0,h.X)(s,[s.shape[0],s.shape[1]]),_=(0,u.O)(p,g);return(0,h.X)(_,[_.size])}if(2===n.rank&&1===s.rank){const p=(0,h.X)(s,[-1,1]),g=(0,u.O)(n,p);return(0,h.X)(g,[g.size])}{const p=(0,h.X)(s,[s.shape[0],s.shape[1]]);return(0,u.O)(n,p)}}})},4166:(H,C,t)=>{"use strict";t.d(C,{r:()=>r});var e=t(4296),a=t(1257),u=t(45359),c=t(87066),h=t(93530),f=t(8208),l=t(48737),o=t(44195),n=t(41442);const r=(0,o.op)({dropout_:function s(d,p,g,_){const v=(0,a._1)(d,"x","dropout");if(u.hu("float32"===v.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${v.dtype} tensor instead.`),u.hu(p>=0&&p<1,()=>`rate must be a float in the range [0, 1), but got ${p}.`),0===p)return d instanceof e.es?v.clone():v;const M=function i(d,p){if(null==p)return d.shape.slice();if(u.cO(d.shape,p))return p;if(d.shape.length===p.length){const g=[];for(let _=0;_<d.shape.length;_++)g.push(null==p[_]&&null!=d.shape[_]?d.shape[_]:p[_]);return g}return p}(v,g),T=1-p,S=(0,h.h)((0,f.G)((0,c.I)((0,n.L)(M,0,1,"float32",_),T)),T);return(0,l.d)(v,S)}})},55263:(H,C,t)=>{"use strict";t.d(C,{W:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({einsum_:function h(f,...l){const o=l.map((s,r)=>(0,u._1)(s,`tensors${r}`,"einsum"));return e.BV.runKernel(a.$g6,o,{equation:f})}})},89529:(H,C,t)=>{"use strict";t.d(C,{p:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({elu_:function h(f){const o={x:(0,u._1)(f,"x","elu","float32")};return e.BV.runKernel(a.SX0,o)}})},34456:(H,C,t)=>{"use strict";t.d(C,{D:()=>l});var e=t(40687),a=t(34251),u=t(27664),c=t(1257),h=t(93239);const l=(0,t(44195).op)({equal_:function f(o,n){let s=(0,c._1)(o,"a","equal","string_or_numeric"),r=(0,c._1)(n,"b","equal","string_or_numeric");return[s,r]=(0,u.makeTypesMatch)(s,r),(0,h.assertAndGetBroadcastShape)(s.shape,r.shape),e.BV.runKernel(a.hdR,{a:s,b:r})}})},14634:(H,C,t)=>{"use strict";t.d(C,{q:()=>l});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(3062);const l=(0,t(44195).op)({erf_:function f(o){let n=(0,u._1)(o,"x","erf");return c.hu("int32"===n.dtype||"float32"===n.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===n.dtype&&(n=(0,h.p)(n,"float32")),e.BV.runKernel(a.Omj,{x:n})}})},74279:(H,C,t)=>{"use strict";t.d(C,{d:()=>c});var e=t(93717);const c=(0,t(44195).op)({euclideanNorm_:function u(h,i=null,f=!1){return(0,e.K)(h,"euclidean",i,f)}})},5109:(H,C,t)=>{"use strict";t.d(C,{Q:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({exp_:function h(f){const o={x:(0,u._1)(f,"x","exp")};return e.BV.runKernel(a.NEP,o)}})},77228:(H,C,t)=>{"use strict";t.d(C,{d:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({expandDims_:function i(l,o=0){const n=(0,u._1)(l,"x","expandDims","string_or_numeric");return c.hu(o<=n.rank,()=>"Axis must be <= rank of the tensor"),e.BV.runKernel(a.YFo,{input:n},{dim:o})}})},85748:(H,C,t)=>{"use strict";t.d(C,{t:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({expm1_:function h(f){const o={x:(0,u._1)(f,"x","expm1")};return e.BV.runKernel(a.Y0y,o)}})},7999:(H,C,t)=>{"use strict";t.d(C,{i:()=>f});var e=t(80582),a=t(77228),u=t(44195),c=t(25715),h=t(42005);const f=(0,u.op)({eye_:function i(l,o,n,s="float32"){null==o&&(o=l);const r=(0,e.f)([l,o],s),d=l<=o?l:o;for(let g=0;g<d;++g)r.set(1,g,g);const p=(0,c.X)(r.toTensor(),[l,o]);if(null==n)return p;if(1===n.length)return(0,h.G)((0,a.d)(p,0),[n[0],1,1]);if(2===n.length)return(0,h.G)((0,a.d)((0,a.d)(p,0),0),[n[0],n[1],1,1]);if(3===n.length)return(0,h.G)((0,a.d)((0,a.d)((0,a.d)(p,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}})},62787:(H,C,t)=>{"use strict";t.d(C,{h:()=>c});var e=t(40687),a=t(34251),u=t(45359);function c(h,i,f){return(0,u.Mu)(h),f=f||(0,u.D2)(i),e.BV.runKernel(a.deh,{},{shape:h,value:i,dtype:f})}},8208:(H,C,t)=>{"use strict";t.d(C,{G:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({floor_:function h(f){const o={x:(0,u._1)(f,"x","floor","float32")};return e.BV.runKernel(a.OR,o)}})},31030:(H,C,t)=>{"use strict";t.d(C,{q:()=>f});var e=t(40687),a=t(34251),u=t(27664),c=t(1257);const f=(0,t(44195).op)({floorDiv_:function i(l,o){let n=(0,c._1)(l,"a","floorDiv"),s=(0,c._1)(o,"b","floorDiv");return[n,s]=(0,u.makeTypesMatch)(n,s),e.BV.runKernel(a.jeX,{a:n,b:s})}})},55877:(H,C,t)=>{"use strict";t.r(C),t.d(C,{conv2d:()=>v,depthwiseConv2d:()=>L,matMul:()=>b});var e=t(40687),a=t(63537),u=t(34251),c=t(27664),h=t(1257),i=t(45359),f=t(87066),l=t(93239),o=t(84451),n=t(10443),s=t(95743),r=t(5551),d=t(16254),p=t(44195),g=t(25715);const v=(0,p.op)({fusedConv2d_:function _({x:E,filter:$,strides:W,pad:Z,dataFormat:X="NHWC",dilations:ut=[1,1],dimRoundingMode:Dt,bias:Y,activation:ht="linear",preluActivationWeights:Pt,leakyreluAlpha:pt}){if(!1===(0,d.uy)(e.BV.state.gradientDepth,ht=ht||"linear")){i.hu("NHWC"===X,()=>`Error in fused conv2d: got dataFormat of ${X} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let Ut=(0,o.T)(E,$,W,Z,X,ut,Dt);return null!=Y&&(Ut=(0,f.I)(Ut,Y)),(0,d.QH)(Ut,ht,Pt,pt)}const xt=(0,h._1)(E,"x","conv2d","float32"),Nt=(0,h._1)($,"filter","conv2d","float32");let Vt=xt,Gt=!1;3===xt.rank&&(Gt=!0,Vt=(0,g.X)(xt,[1,xt.shape[0],xt.shape[1],xt.shape[2]])),i.hu(4===Vt.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${Vt.rank}.`),i.hu(4===Nt.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${Nt.rank}.`),r.m("fused conv2d",Z,Dt);const oe="NHWC"===X?Vt.shape[3]:Vt.shape[1];i.hu(Nt.shape[2]===oe,()=>`Error in conv2d: depth of input (${oe}) must match input depth for filter ${Nt.shape[2]}.`),i.hu(r.jT(W,ut),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${W} and dilations '${ut}'`);const Ee=r.Ix(Vt.shape,Nt.shape,W,ut,Z,Dt);let Ie,ie;if(null!=Y&&(Ie=(0,h._1)(Y,"bias","fused conv2d"),[Ie]=(0,c.makeTypesMatch)(Ie,xt),"NHWC"===X?l.assertAndGetBroadcastShape(Ee.outShape,Ie.shape):(i.hu(Ie.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${Ie.shape.length}.`),i.hu(0===Ie.shape.length||Ie.shape[0]===Ee.outChannels||1===Ie.shape[0],()=>`Error in fused conv2d: bias shape (${Ie.shape}) is not compatible with the number of output channels (${Ee.outChannels})`))),null!=Pt){const Ut=Pt.shape;if(i.hu(Ut.length<=1||3===Ut.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${Ut.length}.`),1===Ut.length)i.hu(1===Ut[0]||Ut[0]===Ee.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${Ut}) is not compatible with the number of output channels (${Ee.outChannels}).`);else if(3===Ut.length)try{l.assertAndGetBroadcastShape(Ut,Ee.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${Ut}) is not compatible with the output shape of the conv2d (${Ee.outShape}).`)}ie=(0,h._1)(Pt,"prelu weights","fused conv2d")}const Zt=(Ut,q)=>{i.hu("NHWC"===X,()=>`Error in gradient of fused conv2D: got dataFormat of ${X} but only NHWC is currently supported.`);const[K,j,at,dt]=q,kt=(0,d.Fr)(Ut,at,ht);i.hu(r.I0(ut),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${ut}'`);const ae=[(0,s._)(j.shape,kt,K,W,Z),(0,n.p)(j,kt,K.shape,W,Z)];if(null!=dt){const Re=(0,d.pf)(dt,kt);ae.push(Re)}return ae},ct={x:Vt,filter:Nt,bias:Ie,preluActivationWeights:ie},It={strides:W,pad:Z,dataFormat:X,dilations:ut,dimRoundingMode:Dt,activation:ht,leakyreluAlpha:pt};return null==Y?(0,a.cb)((q,K,j)=>{let at=e.BV.runKernel(u._V0,ct,It);return j([K,q,at]),Gt&&(at=(0,g.X)(at,[at.shape[1],at.shape[2],at.shape[3]])),{value:at,gradFunc:Zt}})(Vt,Nt):(0,a.cb)((q,K,j,at)=>{let dt=e.BV.runKernel(u._V0,ct,It);return at([K,q,dt,j]),Gt&&(dt=(0,g.X)(dt,[dt.shape[1],dt.shape[2],dt.shape[3]])),{value:dt,gradFunc:Zt}})(Vt,Nt,Ie)}});var M=t(51172),T=t(366),S=t(519);const L=(0,p.op)({fusedDepthwiseConv2d_:function P({x:E,filter:$,strides:W,pad:Z,dataFormat:X="NHWC",dilations:ut=[1,1],dimRoundingMode:Dt,bias:Y,activation:ht="linear",preluActivationWeights:Pt,leakyreluAlpha:pt}){if(!1===(0,d.uy)(e.BV.state.gradientDepth,ht)){let It=(0,M.B)(E,$,W,Z,X,ut,Dt);return null!=Y&&(It=(0,f.I)(It,Y)),(0,d.QH)(It,ht,Pt,pt)}const xt=(0,h._1)(E,"x","depthwiseConv2d","float32"),Nt=(0,h._1)($,"filter","depthwiseConv2d","float32");let Vt=xt,Gt=!1;3===xt.rank&&(Gt=!0,Vt=(0,g.X)(xt,[1,xt.shape[0],xt.shape[1],xt.shape[2]])),i.hu(4===Vt.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${Vt.rank}.`),i.hu(4===Nt.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${Nt.rank}.`),i.hu(Vt.shape[3]===Nt.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${Vt.shape[3]}) must match the inChannels dimension in filter ${Nt.shape[2]}.`),null==ut&&(ut=[1,1]),i.hu(r.jT(W,ut),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${W} and dilations '${ut}'`),r.m("fused depthwiseConv2d",Z,Dt);const oe=r.Ix(Vt.shape,Nt.shape,W,ut,Z,Dt,!0);let Ee,Ie;null!=Y&&(Ee=(0,h._1)(Y,"bias","fused conv2d"),[Ee]=(0,c.makeTypesMatch)(Ee,xt),l.assertAndGetBroadcastShape(oe.outShape,Ee.shape)),null!=Pt&&(Ie=(0,h._1)(Pt,"prelu weights","fused depthwiseConv2d"));const ie=(It,Ut)=>{i.hu(r.I0(ut),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${ut}'`);const[q,K,j,at]=Ut,dt=(0,d.Fr)(It,j,ht),kt=(0,S.v)(K.shape,dt,q,W,Z,ut,Dt),jt=(0,T.z)(K,dt,q.shape,W,Z,ut,Dt);return null!=at?[kt,jt,(0,d.pf)(Ee,dt)]:[kt,jt]},Zt={x:Vt,filter:Nt,bias:Ee,preluActivationWeights:Ie},ct={strides:W,pad:Z,dataFormat:X,dilations:ut,dimRoundingMode:Dt,activation:ht,leakyreluAlpha:pt};return null==Y?(0,a.cb)((Ut,q,K)=>{let j=e.BV.runKernel(u.luS,Zt,ct);return K([q,Ut,j]),Gt&&(j=(0,g.X)(j,[j.shape[1],j.shape[2],j.shape[3]])),{value:j,gradFunc:ie}})(Vt,Nt):(0,a.cb)((Ut,q,K,j)=>{let at=e.BV.runKernel(u.luS,Zt,ct);return j([q,Ut,at,K]),Gt&&(at=(0,g.X)(at,[at.shape[1],at.shape[2],at.shape[3]])),{value:at,gradFunc:ie}})(Vt,Nt,Ee)}});var N=t(15592);const b=(0,p.op)({fusedMatMul_:function O({a:E,b:$,transposeA:W=!1,transposeB:Z=!1,bias:X,activation:ut="linear",preluActivationWeights:Dt,leakyreluAlpha:Y=.2}){if(!1===(0,d.uy)(e.BV.state.gradientDepth,ut)){let dt=(0,N.O)(E,$,W,Z);return null!=X&&(dt=(0,f.I)(dt,X)),(0,d.QH)(dt,ut,Dt,Y)}let ht=(0,h._1)(E,"a","fused matMul"),Pt=(0,h._1)($,"b","fused matMul");[ht,Pt]=(0,c.makeTypesMatch)(ht,Pt);const pt=W?ht.shape[ht.rank-2]:ht.shape[ht.rank-1],xt=Z?Pt.shape[Pt.rank-1]:Pt.shape[Pt.rank-2],Nt=W?ht.shape[ht.rank-1]:ht.shape[ht.rank-2],Vt=Z?Pt.shape[Pt.rank-2]:Pt.shape[Pt.rank-1],Gt=ht.shape.slice(0,-2),oe=Pt.shape.slice(0,-2),Ee=i.NA(Gt),Ie=i.NA(oe);i.hu(pt===xt,()=>`Error in fused matMul: inner shapes (${pt}) and (${xt}) of Tensors with shapes ${ht.shape} and ${Pt.shape} and transposeA=${W} and transposeB=${Z} must match.`);const Zt=l.assertAndGetBroadcastShape(ht.shape.slice(0,-2),Pt.shape.slice(0,-2)).concat([Nt,Vt]),ct=(0,g.X)(ht,W?[Ee,pt,Nt]:[Ee,Nt,pt]),It=(0,g.X)(Pt,Z?[Ie,Vt,xt]:[Ie,xt,Vt]);let Ut,q;null!=X&&(Ut=(0,h._1)(X,"bias","fused matMul"),[Ut]=(0,c.makeTypesMatch)(Ut,ht),l.assertAndGetBroadcastShape(Zt,Ut.shape)),null!=Dt&&(q=(0,h._1)(Dt,"prelu weights","fused matMul"));const K=(dt,kt)=>{const[jt,Jt,ae,Re]=kt,Be=(0,d.Fr)((0,g.X)(dt,ae.shape),ae,ut);let Se,we;return W||Z?!W&&Z?(Se=(0,N.O)(Be,Jt,!1,!1),we=(0,N.O)(Be,jt,!0,!1)):W&&!Z?(Se=(0,N.O)(Jt,Be,!1,!0),we=(0,N.O)(jt,Be,!1,!1)):(Se=(0,N.O)(Jt,Be,!0,!0),we=(0,N.O)(Be,jt,!0,!0)):(Se=(0,N.O)(Be,Jt,!1,!0),we=(0,N.O)(jt,Be,!0,!1)),null!=X?[Se,we,(0,d.pf)(Re,Be)]:[Se,we]},j={a:ct,b:It,bias:Ut,preluActivationWeights:q},at={transposeA:W,transposeB:Z,activation:ut,leakyreluAlpha:Y};return null==X?(0,a.cb)((kt,jt,Jt)=>{const ae=e.BV.runKernel(u.usg,j,at);return Jt([kt,jt,ae]),{value:(0,g.X)(ae,Zt),gradFunc:K}})(ct,It):(0,a.cb)((kt,jt,Jt,ae)=>{const Re=e.BV.runKernel(u.usg,j,at);return ae([kt,jt,Re,Jt]),{value:(0,g.X)(Re,Zt),gradFunc:K}})(ct,It,Ut)}})},16254:(H,C,t)=>{"use strict";t.d(C,{Fr:()=>r,QH:()=>p,pf:()=>d,uy:()=>g});var e=t(93239),a=t(89529),u=t(59424),c=t(48737),h=t(71584),i=t(98586),f=t(64917),l=t(25715),o=t(86139),n=t(26034),s=t(69929);function r(_,v,M){if(null==M||"linear"===M)return _;if("relu"===M)return(0,c.d)(_,(0,n.N)(v));throw new Error(`Cannot compute gradient for fused activation ${M}.`)}function d(_,v){let M=v;const T=e.getReductionAxes(_.shape,v.shape);return T.length>0&&(M=(0,s.S)(M,T)),(0,l.X)(M,_.shape)}function p(_,v,M,T){if("linear"===v)return _;if("relu"===v)return(0,i.U)(_);if("elu"===v)return(0,a.p)(_);if("relu6"===v)return(0,f.b)(_);if("prelu"===v)return(0,h.A)(_,M);if("leakyrelu"===v)return(0,u.h)(_,T);if("sigmoid"===v)return(0,o.X)(_);throw new Error(`Unknown fused activation ${v}.`)}const g=(_,v)=>!(_>0)||"linear"===v},16117:(H,C,t)=>{"use strict";t.d(C,{I:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({gather_:function h(f,l,o=0,n=0){const s=(0,u._1)(f,"x","gather"),r=(0,u._1)(l,"indices","gather","int32");return e.BV.runKernel(a.qi_,{x:s,indices:r},{axis:o,batchDims:n})}})},54803:(H,C,t)=>{"use strict";t.d(C,{p:()=>l});var e=t(40687),a=t(34251),u=t(27664),c=t(1257),h=t(93239);const l=(0,t(44195).op)({greater_:function f(o,n){let s=(0,c._1)(o,"a","greater","string_or_numeric"),r=(0,c._1)(n,"b","greater","string_or_numeric");return[s,r]=(0,u.makeTypesMatch)(s,r),(0,h.assertAndGetBroadcastShape)(s.shape,r.shape),e.BV.runKernel(a.iZT,{a:s,b:r})}})},49886:(H,C,t)=>{"use strict";t.d(C,{b:()=>l});var e=t(40687),a=t(34251),u=t(27664),c=t(1257),h=t(93239);const l=(0,t(44195).op)({greaterEqual_:function f(o,n){let s=(0,c._1)(o,"a","greaterEqual","string_or_numeric"),r=(0,c._1)(n,"b","greaterEqual","string_or_numeric");return[s,r]=(0,u.makeTypesMatch)(s,r),(0,h.assertAndGetBroadcastShape)(s.shape,r.shape),e.BV.runKernel(a.Acj,{a:s,b:r})}})},51844:(H,C,t)=>{"use strict";t.d(C,{a:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({imag_:function h(f){const o={input:(0,u._1)(f,"input","imag")};return e.BV.runKernel(a.J_u,o)}})},46346:(H,C,t)=>{"use strict";t.d(C,{B:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({cropAndResize_:function i(l,o,n,s,r="bilinear",d=0){const p=(0,u._1)(l,"image","cropAndResize"),g=(0,u._1)(o,"boxes","cropAndResize","float32"),_=(0,u._1)(n,"boxInd","cropAndResize","int32"),v=g.shape[0];return c.hu(4===p.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${p.rank}.`),c.hu(2===g.rank&&4===g.shape[1],()=>`Error in cropAndResize: boxes must be have size [${v},4] but had shape ${g.shape}.`),c.hu(1===_.rank&&_.shape[0]===v,()=>`Error in cropAndResize: boxInd must be have size [${v}] but had shape ${g.shape}.`),c.hu(2===s.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),c.hu(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),c.hu("bilinear"===r||"nearest"===r,()=>`method must be bilinear or nearest, but was ${r}`),e.BV.runKernel(a.VcC,{image:p,boxes:g,boxInd:_},{method:r,extrapolationValue:d,cropSize:s})}})},58941:(H,C,t)=>{"use strict";t.d(C,{V:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({flipLeftRight_:function i(l){const o=(0,u._1)(l,"image","flipLeftRight","float32");return c.hu(4===o.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${o.rank}.`),e.BV.runKernel(a.Uyb,{image:o},{})}})},29475:(H,C,t)=>{"use strict";t.d(C,{F:()=>i});var e=t(1257),a=t(45359),u=t(44195),c=t(42005);const i=(0,u.op)({grayscaleToRGB_:function h(f){const l=(0,e._1)(f,"image","grayscaleToRGB"),o=l.rank-1,n=l.shape[o];a.hu(l.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${l.rank}.`),a.hu(1===n,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);const s=new Array(l.rank);return s.fill(1,0,o),s[o]=3,(0,c.G)(l,s)}})},67600:(H,C,t)=>{"use strict";t.d(C,{o:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(2647);const f=(0,t(44195).op)({nonMaxSuppression_:function i(l,o,n,s=.5,r=Number.NEGATIVE_INFINITY){const d=(0,u._1)(l,"boxes","nonMaxSuppression","float32"),p=(0,u._1)(o,"scores","nonMaxSuppression","float32"),g=(0,c.e)(d,p,n,s,r);return e.BV.runKernel(a.uv1,{boxes:d,scores:p},{maxOutputSize:n=g.maxOutputSize,iouThreshold:s=g.iouThreshold,scoreThreshold:r=g.scoreThreshold})}})},72717:(H,C,t)=>{"use strict";t.d(C,{V:()=>l});var e=t(15861),a=t(97228),u=t(1257),c=t(2647),h=t(28472);function f(){return(f=(0,e.Z)(function*(o,n,s,r=.5,d=Number.NEGATIVE_INFINITY){const p=(0,u._1)(o,"boxes","nonMaxSuppressionAsync"),g=(0,u._1)(n,"scores","nonMaxSuppressionAsync"),_=(0,c.e)(p,g,s,r,d);s=_.maxOutputSize,r=_.iouThreshold,d=_.scoreThreshold;const v=yield Promise.all([p.data(),g.data()]),M=v[0],T=v[1],{selectedIndices:S}=(0,a.GP)(M,T,s,r,d);return p!==o&&p.dispose(),g!==n&&g.dispose(),(0,h.R)(S,"int32")})).apply(this,arguments)}const l=function i(o,n,s){return f.apply(this,arguments)}},89358:(H,C,t)=>{"use strict";t.d(C,{q:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(2647);const f=(0,t(44195).op)({nonMaxSuppressionPadded_:function i(l,o,n,s=.5,r=Number.NEGATIVE_INFINITY,d=!1){const p=(0,u._1)(l,"boxes","nonMaxSuppression"),g=(0,u._1)(o,"scores","nonMaxSuppression"),_=(0,c.e)(p,g,n,s,r,null),L=e.BV.runKernel(a.cye,{boxes:p,scores:g},{maxOutputSize:_.maxOutputSize,iouThreshold:_.iouThreshold,scoreThreshold:_.scoreThreshold,padToMaxOutputSize:d});return{selectedIndices:L[0],validOutputs:L[1]}}})},11233:(H,C,t)=>{"use strict";t.d(C,{N:()=>o});var e=t(15861),a=t(97228),u=t(1257),c=t(2647),h=t(48661),i=t(28472);function l(){return(l=(0,e.Z)(function*(n,s,r,d=.5,p=Number.NEGATIVE_INFINITY,g=!1){const _=(0,u._1)(n,"boxes","nonMaxSuppressionAsync"),v=(0,u._1)(s,"scores","nonMaxSuppressionAsync"),M=(0,c.e)(_,v,r,d,p,null),T=M.maxOutputSize,S=M.iouThreshold,P=M.scoreThreshold,[L,N]=yield Promise.all([_.data(),v.data()]),{selectedIndices:O,validOutputs:b}=(0,a.qP)(L,N,T,S,P,g);return _!==n&&_.dispose(),v!==s&&v.dispose(),{selectedIndices:(0,i.R)(O,"int32"),validOutputs:(0,h.i)(b,"int32")}})).apply(this,arguments)}const o=function f(n,s,r){return l.apply(this,arguments)}},20591:(H,C,t)=>{"use strict";t.d(C,{t:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(2647);const f=(0,t(44195).op)({nonMaxSuppressionWithScore_:function i(l,o,n,s=.5,r=Number.NEGATIVE_INFINITY,d=0){const p=(0,u._1)(l,"boxes","nonMaxSuppression"),g=(0,u._1)(o,"scores","nonMaxSuppression"),_=(0,c.e)(p,g,n,s,r,d),T=e.BV.runKernel(a.W0H,{boxes:p,scores:g},{maxOutputSize:n=_.maxOutputSize,iouThreshold:s=_.iouThreshold,scoreThreshold:r=_.scoreThreshold,softNmsSigma:d=_.softNmsSigma});return{selectedIndices:T[0],selectedScores:T[1]}}})},6106:(H,C,t)=>{"use strict";t.d(C,{B:()=>l});var e=t(15861),a=t(97228),u=t(1257),c=t(2647),h=t(28472);function f(){return(f=(0,e.Z)(function*(o,n,s,r=.5,d=Number.NEGATIVE_INFINITY,p=0){const g=(0,u._1)(o,"boxes","nonMaxSuppressionAsync"),_=(0,u._1)(n,"scores","nonMaxSuppressionAsync"),v=(0,c.e)(g,_,s,r,d,p);s=v.maxOutputSize,r=v.iouThreshold,d=v.scoreThreshold,p=v.softNmsSigma;const M=yield Promise.all([g.data(),_.data()]),T=M[0],S=M[1],{selectedIndices:P,selectedScores:L}=(0,a.pA)(T,S,s,r,d,p);return g!==o&&g.dispose(),_!==n&&_.dispose(),{selectedIndices:(0,h.R)(P,"int32"),selectedScores:(0,h.R)(L)}})).apply(this,arguments)}const l=function i(o,n,s){return f.apply(this,arguments)}},51353:(H,C,t)=>{"use strict";t.d(C,{I:()=>l});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(44195),i=t(25715);const l=(0,h.op)({resizeBilinear_:function f(o,n,s=!1,r=!1){const d=(0,u._1)(o,"images","resizeBilinear");c.hu(3===d.rank||4===d.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${d.rank}.`),c.hu(2===n.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${n}.`),c.hu(!1===r||!1===s,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let p=d,g=!1;3===d.rank&&(g=!0,p=(0,i.X)(d,[1,d.shape[0],d.shape[1],d.shape[2]]));const[]=n,M=e.BV.runKernel(a._Yw,{images:p},{alignCorners:s,halfPixelCenters:r,size:n});return g?(0,i.X)(M,[M.shape[1],M.shape[2],M.shape[3]]):M}})},87373:(H,C,t)=>{"use strict";t.d(C,{j:()=>l});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(44195),i=t(25715);const l=(0,h.op)({resizeNearestNeighbor_:function f(o,n,s=!1,r=!1){const d=(0,u._1)(o,"images","resizeNearestNeighbor");c.hu(3===d.rank||4===d.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${d.rank}.`),c.hu(2===n.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${n}.`),c.hu("float32"===d.dtype||"int32"===d.dtype,()=>"`images` must have `int32` or `float32` as dtype"),c.hu(!1===r||!1===s,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let p=d,g=!1;3===d.rank&&(g=!0,p=(0,i.X)(d,[1,d.shape[0],d.shape[1],d.shape[2]]));const[]=n,M=e.BV.runKernel(a.dpD,{images:p},{alignCorners:s,halfPixelCenters:r,size:n});return g?(0,i.X)(M,[M.shape[1],M.shape[2],M.shape[3]]):M}})},56407:(H,C,t)=>{"use strict";t.d(C,{A:()=>o});var e=t(1257),a=t(45359),u=t(3062),c=t(55263),h=t(77228),i=t(44195),f=t(28472);const o=(0,i.op)({rgbToGrayscale_:function l(n){const s=(0,e._1)(n,"image","RGBToGrayscale"),d=s.shape[s.rank-1];a.hu(s.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${s.rank}.`),a.hu(3===d,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${d}.`);const p=s.dtype,g=(0,u.p)(s,"float32"),_=(0,f.R)([.2989,.587,.114]);let v;switch(s.rank){case 2:v=(0,c.W)("ij,j->i",g,_);break;case 3:v=(0,c.W)("ijk,k->ij",g,_);break;case 4:v=(0,c.W)("ijkl,l->ijk",g,_);break;case 5:v=(0,c.W)("ijklm,m->ijkl",g,_);break;case 6:v=(0,c.W)("ijklmn,n->ijklm",g,_);break;default:throw new Error("Not a valid tensor rank.")}return v=(0,h.d)(v,-1),(0,u.p)(v,p)}})},65043:(H,C,t)=>{"use strict";t.d(C,{f:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({rotateWithOffset_:function i(l,o,n=0,s=.5){const r=(0,u._1)(l,"image","rotateWithOffset","float32");return c.hu(4===r.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`),e.BV.runKernel(a.b9H,{image:r},{radians:o,fillValue:n,center:s})}})},62201:(H,C,t)=>{"use strict";t.d(C,{L:()=>N});var e=t(28472),a=t(44195),u=t(3062),c=t(8874),h=t(27196),i=t(22223),f=t(54803),l=t(69929),o=t(87066),n=t(48737),s=t(93530),r=t(61191),d=t(21974),p=t(12190),g=t(62787),_=t(58317),v=t(56944),M=t(23905),T=t(45359),S=t(1257);const N=(0,a.op)({threshold_:function P(O,b="binary",E=!1,$=.5){const W=(0,S._1)(O,"image","threshold"),Dt=W.shape[0]*W.shape[1];let ht,Pt,pt,xt,Y=(0,n.d)((0,e.R)([$]),255);if(T.hu(3===W.rank,()=>`Error in threshold: image must be rank 3,but got rank ${W.rank}.`),T.hu(3===W.shape[2]||1===W.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${W.shape[2]}.`),T.hu("int32"===W.dtype||"float32"===W.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${W.dtype}.`),T.hu("otsu"===b||"binary"===b,()=>`Method must be binary or otsu, but was ${b}`),3===W.shape[2]){[ht,Pt,pt]=(0,c.V)(W,[1,1,1],-1);const Gt=(0,n.d)(ht,.2989),oe=(0,n.d)(Pt,.587),Ee=(0,n.d)(pt,.114);xt=(0,o.I)((0,o.I)(Gt,oe),Ee)}else xt=O;"otsu"===b&&(Y=function L(O,b){let Z,X,ut,Dt,Y,ht,E=(0,e.R)([-1]),$=(0,e.R)([0]),W=(0,e.R)([0]);for(let Pt=0;Pt<O.size-1;Pt++){Z=(0,_.t)(O,0,Pt+1),X=(0,_.t)(O,Pt+1),Y=(0,s.h)((0,l.S)(Z),b),ht=(0,s.h)((0,l.S)(X),b);const pt=(0,l.S)((0,n.d)(Z,(0,v.w)(0,Z.size)));ut=(0,s.h)(pt,(0,l.S)(Z));const xt=(0,g.h)(X.shape,Z.size),Nt=(0,o.I)((0,v.w)(0,X.size),xt),Vt=(0,n.d)(X,Nt);Dt=(0,s.h)((0,l.S)(Vt),(0,l.S)(X));const Gt=(0,r.l)(ut,Dt),oe=(0,r.l)(ut,Dt),Ee=(0,n.d)(Y,ht);W=(0,n.d)((0,n.d)(Ee,Gt),oe);const Ie=(0,f.p)(W,$);$=(0,p.a)(Ie,W,$),E=(0,p.a)(Ie,(0,e.R)([Pt]),E)}return E}((0,h.y)((0,u.p)((0,d.N)(xt),"int32"),(0,M.X)([]),256),Dt));const Nt=E?(0,i.z)(xt,Y):(0,f.p)(xt,Y);return(0,u.p)((0,n.d)(Nt,255),"int32")}})},33316:(H,C,t)=>{"use strict";t.d(C,{v:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({transform_:function i(l,o,n="nearest",s="constant",r=0,d){const p=(0,u._1)(l,"image","transform","float32"),g=(0,u._1)(o,"transforms","transform","float32");return c.hu(4===p.rank,()=>`Error in transform: image must be rank 4,but got rank ${p.rank}.`),c.hu(2===g.rank&&(g.shape[0]===p.shape[0]||1===g.shape[0])&&8===g.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),c.hu(null==d||2===d.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${d}.`),e.BV.runKernel(a.wx7,{image:p,transforms:g},{interpolation:n,fillMode:s,fillValue:r,outputShape:d})}})},75622:(H,C,t)=>{"use strict";t.d(C,{x:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({isFinite_:function h(f){const o={x:(0,u._1)(f,"x","isFinite")};return e.BV.runKernel(a.avt,o)}})},48381:(H,C,t)=>{"use strict";t.d(C,{U:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({isInf_:function h(f){const o={x:(0,u._1)(f,"x","isInf")};return e.BV.runKernel(a.iWB,o)}})},6483:(H,C,t)=>{"use strict";t.d(C,{i:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({isNaN_:function h(f){const o={x:(0,u._1)(f,"x","isNaN")};return e.BV.runKernel(a.r7n,o)}})},59424:(H,C,t)=>{"use strict";t.d(C,{h:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({leakyRelu_:function h(f,l=.2){const n={x:(0,u._1)(f,"x","leakyRelu")};return e.BV.runKernel(a.J$2,n,{alpha:l})}})},82761:(H,C,t)=>{"use strict";t.d(C,{d:()=>l});var e=t(40687),a=t(34251),u=t(27664),c=t(1257),h=t(93239);const l=(0,t(44195).op)({less_:function f(o,n){let s=(0,c._1)(o,"a","less","string_or_numeric"),r=(0,c._1)(n,"b","less","string_or_numeric");return[s,r]=(0,u.makeTypesMatch)(s,r),(0,h.assertAndGetBroadcastShape)(s.shape,r.shape),e.BV.runKernel(a.vtC,{a:s,b:r})}})},22223:(H,C,t)=>{"use strict";t.d(C,{z:()=>l});var e=t(40687),a=t(34251),u=t(27664),c=t(1257),h=t(93239);const l=(0,t(44195).op)({lessEqual_:function f(o,n){let s=(0,c._1)(o,"a","lessEqual","string_or_numeric"),r=(0,c._1)(n,"b","lessEqual","string_or_numeric");return[s,r]=(0,u.makeTypesMatch)(s,r),(0,h.assertAndGetBroadcastShape)(s.shape,r.shape),e.BV.runKernel(a.CAk,{a:s,b:r})}})},24491:(H,C,t)=>{"use strict";t.d(C,{P:()=>M});var e=t(1257),a=t(45359),u=t(49886),c=t(82761),h=t(22223),i=t(93080),f=t(72684),l=t(15048),o=t(44195),n=t(56944),s=t(25715),r=t(57958),d=t(61191),p=t(92219),g=t(12190),_=t(36467);const M=(0,o.op)({bandPart_:function v(T,S,P){const L=(0,e._1)(T,"a","bandPart");(0,a.hu)(L.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${L.rank}.`);const N=L.shape,[O,b]=L.shape.slice(-2);let E,$;"number"==typeof S?((0,a.hu)(S%1==0,()=>`bandPart(): numLower must be an integer, got ${S}.`),(0,a.hu)(S<=O,()=>`bandPart(): numLower (${S}) must not be greater than the number of rows (${O}).`),E=(0,e._1)(S<0?O:S,"numLower","bandPart")):((0,a.hu)("int32"===S.dtype,()=>"bandPart(): numLower's dtype must be an int32."),E=(0,g.a)((0,c.d)(S,0),O,(0,f.L)(S,O))),"number"==typeof P?((0,a.hu)(P%1==0,()=>`bandPart(): numUpper must be an integer, got ${P}.`),(0,a.hu)(P<=b,()=>`bandPart(): numUpper (${P}) must not be greater than the number of columns (${b}).`),$=(0,e._1)(P<0?b:P,"numUpper","bandPart")):((0,a.hu)("int32"===P.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),$=(0,g.a)((0,c.d)(P,0),b,(0,f.L)(P,b)));const W=(0,s.X)((0,n.w)(0,O,1,"int32"),[-1,1]),Z=(0,n.w)(0,b,1,"int32"),X=(0,d.l)(W,Z),ut=(0,i.H)((0,h.z)(X,E),(0,u.b)(X,(0,l.W)($))),Dt=(0,_.l)([O,b],L.dtype);return(0,s.X)((0,r.k)((0,p.H)((0,s.X)(L,[-1,O,b])).map(Y=>(0,g.a)(ut,Y,Dt))),N)}})},47388:(H,C,t)=>{"use strict";t.d(C,{G:()=>d});var e=t(40687),a=t(45359),u=t(93530),c=t(48737),h=t(93717),i=t(44195),f=t(8874),l=t(2494),o=t(57958),n=t(61191),s=t(69929);const d=(0,i.op)({gramSchmidt_:function r(p){let g;if(Array.isArray(p)){g=!1,(0,a.hu)(null!=p&&p.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const M=p[0].shape[0];for(let T=1;T<p.length;++T)(0,a.hu)(p[T].shape[0]===M,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${p[T].shape[0]} vs. ${M})`)}else g=!0,p=(0,f.V)(p,p.shape[0],0).map(M=>(0,l.L)(M,[0]));(0,a.hu)(p.length<=p[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${p.length}) exceeds number of dimensions (${p[0].shape[0]}).`);const _=[],v=p;for(let M=0;M<p.length;++M)_.push(e.BV.tidy(()=>{let T=v[M];if(M>0)for(let S=0;S<M;++S){const P=(0,c.d)((0,s.S)((0,c.d)(_[S],T)),_[S]);T=(0,n.l)(T,P)}return(0,u.h)(T,(0,h.K)(T,"euclidean"))}));return g?(0,o.k)(_,0):_}})},51695:(H,C,t)=>{"use strict";t.d(C,{qr:()=>O});var e=t(40687),a=t(12773),u=t(45359),c=t(87315),h=t(64111),i=t(93530),f=t(7999),l=t(54803),o=t(15592),n=t(48737),s=t(15048),r=t(93717),d=t(44195),p=t(25715),g=t(58317),_=t(57958),v=t(61191),M=t(54174),T=t(19194),S=t(92219),P=t(12190);function N(b,E=!1){return e.BV.tidy(()=>{(0,u.hu)(2===b.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${b.shape.length}D Tensor.`);const $=b.shape[0],W=b.shape[1];let Z=(0,f.i)($),X=(0,c.d)(b);const ut=(0,M.o)([[1]],[1,1]);let Dt=(0,c.d)(ut);const Y=$>=W?W:$;for(let ht=0;ht<Y;++ht){const Pt=X,pt=Dt,xt=Z;[Dt,X,Z]=e.BV.tidy(()=>{const Nt=(0,g.t)(X,[ht,ht],[$-ht,1]),Vt=(0,r.K)(Nt),Gt=(0,g.t)(X,[ht,ht],[1,1]),oe=(0,P.a)((0,l.p)(Gt,0),(0,M.o)([[-1]]),(0,M.o)([[1]])),Ee=(0,v.l)(Gt,(0,n.d)(oe,Vt)),Ie=(0,i.h)(Nt,Ee);Dt=1===Ie.shape[0]?(0,c.d)(ut):(0,h.z)([ut,(0,g.t)(Ie,[1,0],[Ie.shape[0]-1,Ie.shape[1]])],0);const ie=(0,s.W)((0,i.h)((0,o.O)(oe,Ee),Vt)),Zt=(0,g.t)(X,[ht,0],[$-ht,W]),ct=(0,n.d)(ie,Dt),It=(0,T.p)(Dt);if(0===ht)X=(0,v.l)(Zt,(0,o.O)(ct,(0,o.O)(It,Zt)));else{const K=(0,v.l)(Zt,(0,o.O)(ct,(0,o.O)(It,Zt)));X=(0,h.z)([(0,g.t)(X,[0,0],[ht,W]),K],0)}const Ut=(0,T.p)(ct),q=(0,g.t)(Z,[0,ht],[$,Z.shape[1]-ht]);if(0===ht)Z=(0,v.l)(q,(0,o.O)((0,o.O)(q,Dt),Ut));else{const K=(0,v.l)(q,(0,o.O)((0,o.O)(q,Dt),Ut));Z=(0,h.z)([(0,g.t)(Z,[0,0],[$,ht]),K],1)}return[Dt,X,Z]}),(0,a.B9)([Pt,pt,xt])}return!E&&$>W&&(Z=(0,g.t)(Z,[0,0],[$,W]),X=(0,g.t)(X,[0,0],[W,W])),[Z,X]})}const O=(0,d.op)({qr_:function L(b,E=!1){if((0,u.hu)(b.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${b.rank}`),2===b.rank)return N(b,E);{const $=b.shape.slice(0,b.shape.length-2).reduce((Y,ht)=>Y*ht),W=(0,S.H)((0,p.X)(b,[$,b.shape[b.shape.length-2],b.shape[b.shape.length-1]]),0),Z=[],X=[];return W.forEach(Y=>{const[ht,Pt]=N(Y,E);Z.push(ht),X.push(Pt)}),[(0,p.X)((0,_.k)(Z,0),b.shape),(0,p.X)((0,_.k)(X,0),b.shape)]}}})},1523:(H,C,t)=>{"use strict";t.d(C,{G:()=>l});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(44195),i=t(25715);const l=(0,h.op)({localResponseNormalization_:function f(o,n=5,s=1,r=1,d=.5){const p=(0,u._1)(o,"x","localResponseNormalization");c.hu(4===p.rank||3===p.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${p.rank}.`),c.hu(c.GN(n),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${n}.`);let g=p,_=!1;3===p.rank&&(_=!0,g=(0,i.X)(p,[1,p.shape[0],p.shape[1],p.shape[2]]));const T=e.BV.runKernel(a.eZ0,{x:g},{depthRadius:n,bias:s,alpha:r,beta:d});return _?(0,i.X)(T,[T.shape[1],T.shape[2],T.shape[3]]):T}})},5919:(H,C,t)=>{"use strict";t.d(C,{c:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({log_:function h(f){const o={x:(0,u._1)(f,"x","log","float32")};return e.BV.runKernel(a.ZbH,o)}})},44088:(H,C,t)=>{"use strict";t.d(C,{K:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({log1p_:function h(f){const o={x:(0,u._1)(f,"x","log1p")};return e.BV.runKernel(a.kU,o)}})},14034:(H,C,t)=>{"use strict";t.d(C,{e:()=>o});var e=t(63537),a=t(1257),u=t(48737),c=t(15048),h=t(44195),i=t(86139),f=t(94487);const o=(0,h.op)({logSigmoid_:function l(n){const s=(0,a._1)(n,"x","logSigmoid");return(0,e.cb)(d=>({value:(0,c.W)((0,f.W)((0,c.W)(d))),gradFunc:_=>(0,u.d)(_,(0,i.X)((0,c.W)(d)))}))(s)}})},56455:(H,C,t)=>{"use strict";t.d(C,{C:()=>r});var e=t(63537),a=t(1257),u=t(3062),c=t(5109),h=t(5919),i=t(33043),f=t(48737),l=t(44195),o=t(61191),n=t(69929);const r=(0,l.op)({logSoftmax_:function s(d,p=-1){const g=(0,a._1)(d,"logits","logSoftmax");if(-1===p&&(p=g.rank-1),p!==g.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${g.rank} and axis was ${p}`);return(0,e.cb)((v,M)=>{const S=(0,i.F)(v,p,!0),P=(0,o.l)(v,S),L=(0,o.l)((0,u.p)(P,"float32"),(0,h.c)((0,n.S)((0,c.Q)(P),p,!0)));return M([L]),{value:L,gradFunc:(O,b)=>{const[E]=b,W=(0,c.Q)(E);return(0,o.l)(O,(0,f.d)((0,n.S)(O,p,!0),W))}}})(g)}})},56735:(H,C,t)=>{"use strict";t.d(C,{l:()=>d});var e=t(1257),a=t(45359),u=t(87066),c=t(30929),h=t(5109),i=t(5919),f=t(33043),l=t(44195),o=t(25715),n=t(61191),s=t(69929);const d=(0,l.op)({logSumExp_:function r(p,g=null,_=!1){const v=(0,e._1)(p,"x","logSumExp"),M=(0,a.EC)(g,v.shape),T=(0,f.F)(v,M,!0),S=(0,n.l)(v,T),P=(0,h.Q)(S),L=(0,s.S)(P,M),N=(0,i.c)(L),O=(0,u.I)((0,o.X)(T,N.shape),N);if(_){const b=(0,c.rv)(O.shape,M);return(0,o.X)(O,b)}return O}})},93080:(H,C,t)=>{"use strict";t.d(C,{H:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(93239);const f=(0,t(44195).op)({logicalAnd_:function i(l,o){const n=(0,u._1)(l,"a","logicalAnd","bool"),s=(0,u._1)(o,"b","logicalAnd","bool");return(0,c.assertAndGetBroadcastShape)(n.shape,s.shape),e.BV.runKernel(a.PYm,{a:n,b:s})}})},36399:(H,C,t)=>{"use strict";t.d(C,{h:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({logicalNot_:function h(f){const o={x:(0,u._1)(f,"x","logicalNot","bool")};return e.BV.runKernel(a.VfG,o)}})},72693:(H,C,t)=>{"use strict";t.d(C,{K:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(93239);const f=(0,t(44195).op)({logicalOr_:function i(l,o){const n=(0,u._1)(l,"a","logicalOr","bool"),s=(0,u._1)(o,"b","logicalOr","bool");return(0,c.assertAndGetBroadcastShape)(n.shape,s.shape),e.BV.runKernel(a.MZg,{a:n,b:s})}})},44574:(H,C,t)=>{"use strict";t.d(C,{e:()=>l});var e=t(1257),a=t(93239),u=t(93080),c=t(36399),h=t(72693);const l=(0,t(44195).op)({logicalXor_:function f(o,n){const s=(0,e._1)(o,"a","logicalXor","bool"),r=(0,e._1)(n,"b","logicalXor","bool");return(0,a.assertAndGetBroadcastShape)(s.shape,r.shape),(0,u.H)((0,h.K)(o,n),(0,c.h)((0,u.H)(o,n)))}})},54839:(H,C,t)=>{"use strict";t.d(C,{I:()=>e});var e=function(a){return a[a.NONE=0]="NONE",a[a.MEAN=1]="MEAN",a[a.SUM=2]="SUM",a[a.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",a}(e||{})},31663:(H,C,t)=>{"use strict";t.d(C,{O:()=>o});var e=t(1257),a=t(45359),u=t(26989),c=t(54839),h=t(44195),i=t(61191),f=t(51433);const o=(0,h.op)({absoluteDifference_:function l(n,s,r,d=c.I.SUM_BY_NONZERO_WEIGHTS){const p=(0,e._1)(n,"labels","absoluteDifference"),g=(0,e._1)(s,"predictions","absoluteDifference");let _=null;null!=r&&(_=(0,e._1)(r,"weights","absoluteDifference")),(0,a.k5)(p.shape,g.shape,"Error in absoluteDifference: ");const v=(0,u.W)((0,i.l)(p,g));return(0,f.m)(v,_,d)}})},51433:(H,C,t)=>{"use strict";t.d(C,{m:()=>d});var e=t(1257),a=t(3062),u=t(93530),c=t(54839),h=t(69357),i=t(48737),f=t(23062),l=t(84968),o=t(44195),n=t(48661),s=t(69929);const d=(0,o.op)({computeWeightedLoss_:function r(p,g,_=c.I.SUM_BY_NONZERO_WEIGHTS){const v=(0,e._1)(p,"losses","computeWeightedLoss");let M=null;null!=g&&(M=(0,e._1)(g,"weights","computeWeightedLoss"));const T=null==M?v:(0,i.d)(v,M);if(_===c.I.NONE)return T;if(_===c.I.SUM)return(0,s.S)(T);if(_===c.I.MEAN){if(null==M)return(0,h.J)(T);{const S=v.size/M.size,P=(0,u.h)((0,s.S)(T),(0,s.S)(M));return S>1?(0,u.h)(P,(0,n.i)(S)):P}}if(_===c.I.SUM_BY_NONZERO_WEIGHTS){if(null==M)return(0,u.h)((0,s.S)(T),(0,n.i)(v.size));{const S=(0,i.d)(M,(0,l.i)(v.shape)),P=(0,a.p)((0,s.S)((0,f.Q)(S,(0,n.i)(0))),"float32");return(0,u.h)((0,s.S)(T),P)}}throw Error(`Unknown reduction: ${_}`)}})},55006:(H,C,t)=>{"use strict";t.d(C,{Z:()=>s});var e=t(1257),a=t(45359),u=t(54839),c=t(48737),h=t(44195),i=t(48661),f=t(61191),l=t(69929),o=t(51433);const s=(0,h.op)({cosineDistance_:function n(r,d,p,g,_=u.I.SUM_BY_NONZERO_WEIGHTS){const v=(0,e._1)(r,"labels","cosineDistance"),M=(0,e._1)(d,"predictions","cosineDistance");let T=null;null!=g&&(T=(0,e._1)(g,"weights","cosineDistance")),(0,a.k5)(v.shape,M.shape,"Error in cosineDistance: ");const S=(0,i.i)(1),P=(0,f.l)(S,(0,l.S)((0,c.d)(v,M),p,!0));return(0,o.m)(P,T,_)}})},55158:(H,C,t)=>{"use strict";t.d(C,{O:()=>s});var e=t(1257),a=t(45359),u=t(54839),c=t(48737),h=t(44195),i=t(98586),f=t(48661),l=t(61191),o=t(51433);const s=(0,h.op)({hingeLoss_:function n(r,d,p,g=u.I.SUM_BY_NONZERO_WEIGHTS){let _=(0,e._1)(r,"labels","hingeLoss");const v=(0,e._1)(d,"predictions","hingeLoss");let M=null;null!=p&&(M=(0,e._1)(p,"weights","hingeLoss")),(0,a.k5)(_.shape,v.shape,"Error in hingeLoss: ");const T=(0,f.i)(1);_=(0,l.l)((0,c.d)((0,f.i)(2),_),T);const S=(0,i.U)((0,l.l)(T,(0,c.d)(_,v)));return(0,o.m)(S,M,g)}})},63566:(H,C,t)=>{"use strict";t.d(C,{H:()=>p});var e=t(1257),a=t(45359),u=t(26989),c=t(87066),h=t(54839),i=t(72684),f=t(48737),l=t(44195),o=t(48661),n=t(7527),s=t(61191),r=t(51433);const p=(0,l.op)({huberLoss_:function d(g,_,v,M=1,T=h.I.SUM_BY_NONZERO_WEIGHTS){const S=(0,e._1)(g,"labels","huberLoss"),P=(0,e._1)(_,"predictions","huberLoss");let L=null;null!=v&&(L=(0,e._1)(v,"weights","huberLoss")),(0,a.k5)(S.shape,P.shape,"Error in huberLoss: ");const N=(0,o.i)(M),O=(0,u.W)((0,s.l)(P,S)),b=(0,i.L)(O,N),E=(0,s.l)(O,b),$=(0,c.I)((0,f.d)((0,o.i)(.5),(0,n.h)(b)),(0,f.d)(N,E));return(0,r.m)($,L,T)}})},21745:(H,C,t)=>{"use strict";t.d(C,{g:()=>d});var e=t(1257),a=t(45359),u=t(87066),c=t(5919),h=t(54839),i=t(48737),f=t(15048),l=t(44195),o=t(48661),n=t(61191),s=t(51433);const d=(0,l.op)({logLoss_:function r(p,g,_,v=1e-7,M=h.I.SUM_BY_NONZERO_WEIGHTS){const T=(0,e._1)(p,"labels","logLoss"),S=(0,e._1)(g,"predictions","logLoss");let P=null;null!=_&&(P=(0,e._1)(_,"weights","logLoss")),(0,a.k5)(T.shape,S.shape,"Error in logLoss: ");const L=(0,o.i)(1),N=(0,o.i)(v),O=(0,f.W)((0,i.d)(T,(0,c.c)((0,u.I)(S,N)))),b=(0,i.d)((0,n.l)(L,T),(0,c.c)((0,u.I)((0,n.l)(L,S),N))),E=(0,n.l)(O,b);return(0,s.m)(E,P,M)}})},63609:(H,C,t)=>{"use strict";t.d(C,{F:()=>l});var e=t(1257),a=t(45359),u=t(54839),c=t(44195),h=t(99539),i=t(51433);const l=(0,c.op)({meanSquaredError_:function f(o,n,s,r=u.I.SUM_BY_NONZERO_WEIGHTS){const d=(0,e._1)(o,"labels","meanSquaredError"),p=(0,e._1)(n,"predictions","meanSquaredError");let g=null;null!=s&&(g=(0,e._1)(s,"weights","meanSquaredError")),(0,a.k5)(d.shape,p.shape,"Error in meanSquaredError: ");const _=(0,h.$)(d,p);return(0,i.m)(_,g,r)}})},98181:(H,C,t)=>{"use strict";t.d(C,{f:()=>v});var e=t(1257),a=t(45359),u=t(26989),c=t(87066),h=t(5109),i=t(44088),f=t(54839),l=t(48737),o=t(15048),n=t(44195),s=t(98586),r=t(48661),d=t(61191),p=t(51433);const v=(0,n.op)({sigmoidCrossEntropy_:function _(M,T,S,P=0,L=f.I.SUM_BY_NONZERO_WEIGHTS){let N=(0,e._1)(M,"multiClassLabels","sigmoidCrossEntropy");const O=(0,e._1)(T,"logits","sigmoidCrossEntropy");let b=null;if(null!=S&&(b=(0,e._1)(S,"weights","sigmoidCrossEntropy")),(0,a.k5)(N.shape,O.shape,"Error in sigmoidCrossEntropy: "),P>0){const $=(0,r.i)(P),W=(0,r.i)(1),Z=(0,r.i)(.5);N=(0,c.I)((0,l.d)(N,(0,d.l)(W,$)),(0,l.d)(Z,$))}const E=function g(M,T){const S=(0,e._1)(M,"labels","sigmoidCrossEntropyWithLogits"),P=(0,e._1)(T,"logits","sigmoidCrossEntropyWithLogits");(0,a.k5)(S.shape,P.shape,"Error in sigmoidCrossEntropyWithLogits: ");const L=(0,s.U)(P),N=(0,l.d)(P,S),O=(0,i.K)((0,h.Q)((0,o.W)((0,u.W)(P))));return(0,c.I)((0,d.l)(L,N),O)}(N,O);return(0,p.m)(E,b,L)}})},59780:(H,C,t)=>{"use strict";t.d(C,{E:()=>P});var e=t(63537),a=t(1257),u=t(45359),c=t(87066),h=t(30929),i=t(3062),f=t(93530),l=t(5109),o=t(56735),n=t(54839),s=t(48737),r=t(15048),d=t(44195),p=t(25715),g=t(48661),_=t(61191),v=t(69929),M=t(51433);const P=(0,d.op)({softmaxCrossEntropy_:function S(L,N,O,b=0,E=n.I.SUM_BY_NONZERO_WEIGHTS){let $=(0,a._1)(L,"onehotLabels","softmaxCrossEntropy");const W=(0,a._1)(N,"logits","softmaxCrossEntropy");let Z=null;if(null!=O&&(Z=(0,a._1)(O,"weights","softmaxCrossEntropy")),(0,u.k5)($.shape,W.shape,"Error in softmaxCrossEntropy: "),b>0){const ut=(0,g.i)(b),Dt=(0,g.i)(1),Y=(0,g.i)($.shape[1]);$=(0,c.I)((0,s.d)($,(0,_.l)(Dt,ut)),(0,f.h)(ut,Y))}const X=function T(L,N,O=-1){if(-1===O&&(O=N.rank-1),O!==N.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${N.rank} and dim was ${O}`);return(0,e.cb)((E,$,W)=>{const X=(0,o.l)($,[O],!0),ut=(0,_.l)((0,i.p)($,"float32"),X);W([E,ut]);const Dt=(0,r.W)((0,s.d)(ut,E));return{value:(0,v.S)(Dt,[O]),gradFunc:(Pt,pt)=>{const[xt,Nt]=pt,Vt=(0,h.rv)(Pt.shape,[O]);return[(0,s.d)((0,p.X)(Pt,Vt),(0,_.l)((0,i.p)(xt,"float32"),(0,l.Q)(Nt))),(0,s.d)((0,p.X)(Pt,Vt),(0,_.l)((0,l.Q)(Nt),(0,i.p)(xt,"float32")))]}}})(L,N)}($,W);return(0,M.m)(X,Z,E)}})},15592:(H,C,t)=>{"use strict";t.d(C,{O:()=>f});var e=t(40687),a=t(34251),u=t(27664),c=t(1257);const f=(0,t(44195).op)({matMul_:function i(l,o,n=!1,s=!1){let r=(0,c._1)(l,"a","matMul"),d=(0,c._1)(o,"b","matMul");return[r,d]=(0,u.makeTypesMatch)(r,d),e.BV.runKernel(a.XLW,{a:r,b:d},{transposeA:n,transposeB:s})}})},33043:(H,C,t)=>{"use strict";t.d(C,{F:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({max_:function h(f,l=null,o=!1){const s={x:(0,u._1)(f,"x","max")};return e.BV.runKernel(a.YoZ,s,{reductionIndices:l,keepDims:o})}})},12444:(H,C,t)=>{"use strict";t.d(C,{_:()=>o});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(5551),i=t(44195),f=t(25715);const o=(0,i.op)({maxPool_:function l(n,s,r,d,p){const g=(0,u._1)(n,"x","maxPool");let v=g,M=!1;3===g.rank&&(M=!0,v=(0,f.X)(g,[1,g.shape[0],g.shape[1],g.shape[2]])),c.hu(4===v.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${v.rank}.`),c.hu(h.jT(r,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '1'`),h.m("maxPool",d,p);const P=e.BV.runKernel(a.mTV,{x:v},{filterSize:s,strides:r,pad:d,dimRoundingMode:p});return M?(0,f.X)(P,[P.shape[1],P.shape[2],P.shape[3]]):P}})},30481:(H,C,t)=>{"use strict";t.d(C,{Y:()=>o});var e=t(40687),a=t(34251),u=t(1257),c=t(45359),h=t(5551),i=t(44195),f=t(25715);const o=(0,i.op)({maxPool3d_:function l(n,s=[1,1,1],r,d,p,g="NDHWC"){const _=(0,u._1)(n,"x","maxPool3d");let v=_,M=!1;4===_.rank&&(M=!0,v=(0,f.X)(_,[1,_.shape[0],_.shape[1],_.shape[2],_.shape[3]])),c.hu(5===v.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${v.rank}.`),c.hu("NDHWC"===g,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${g}`),(0,h.m)("maxPool3d",d,p);const P=e.BV.runKernel(a.OAf,{x:v},{filterSize:s,strides:r,pad:d,dimRoundingMode:p,dataFormat:g});return M?(0,f.X)(P,[P.shape[1],P.shape[2],P.shape[3],P.shape[4]]):P}})},60765:(H,C,t)=>{"use strict";t.d(C,{g:()=>o});var e=t(40687),a=t(34251),u=t(27664),c=t(1257),h=t(93239),i=t(3062);const o=(0,t(44195).op)({maximum_:function l(n,s){let r=(0,c._1)(n,"a","maximum"),d=(0,c._1)(s,"b","maximum");return[r,d]=(0,u.makeTypesMatch)(r,d),"bool"===r.dtype&&(r=(0,i.p)(r,"int32"),d=(0,i.p)(d,"int32")),(0,h.assertAndGetBroadcastShape)(r.shape,d.shape),e.BV.runKernel(a.BMI,{a:r,b:d})}})},69357:(H,C,t)=>{"use strict";t.d(C,{J:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({mean_:function h(f,l=null,o=!1){const s={x:(0,u._1)(f,"x","mean")};return e.BV.runKernel(a.q2K,s,{axis:l,keepDims:o})}})},69602:(H,C,t)=>{"use strict";t.d(C,{V:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({min_:function h(f,l=null,o=!1){const s={x:(0,u._1)(f,"x","min")};return e.BV.runKernel(a.c17,s,{axis:l,keepDims:o})}})},72684:(H,C,t)=>{"use strict";t.d(C,{L:()=>o});var e=t(40687),a=t(34251),u=t(27664),c=t(1257),h=t(93239),i=t(3062);const o=(0,t(44195).op)({minimum_:function l(n,s){let r=(0,c._1)(n,"a","minimum"),d=(0,c._1)(s,"b","minimum");return[r,d]=(0,u.makeTypesMatch)(r,d),"bool"===r.dtype&&(r=(0,i.p)(r,"int32"),d=(0,i.p)(d,"int32")),(0,h.assertAndGetBroadcastShape)(r.shape,d.shape),e.BV.runKernel(a.q8u,{a:r,b:d})}})},84639:(H,C,t)=>{"use strict";t.d(C,{V:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({mirrorPad_:function i(l,o,n){c.hu("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=(0,u._1)(l,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");c.hu(o.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${o.length}.`);const r="reflect"===n?1:0;for(let g=0;g<s.rank;g++)c.hu(2===o[g].length,()=>"Invalid number of paddings. Must be length of 2 each."),c.hu(o[g][0]>=0&&o[g][0]<=s.shape[g]-r&&o[g][1]>=0&&o[g][1]<=s.shape[g]-r,()=>`Padding in dimension ${g} cannot be greater than or equal to ${s.shape[g]-r} or less than 0 for input of shape ${s.shape}`);return e.BV.runKernel(a.jQs,{x:s},{paddings:o,mode:n})}})},71612:(H,C,t)=>{"use strict";t.d(C,{w:()=>f});var e=t(40687),a=t(34251),u=t(27664),c=t(1257);const f=(0,t(44195).op)({mod_:function i(l,o){let n=(0,c._1)(l,"a","mod"),s=(0,c._1)(o,"b","mod");return[n,s]=(0,u.makeTypesMatch)(n,s),e.BV.runKernel(a.Vbg,{a:n,b:s})}})},11821:(H,C,t)=>{"use strict";t.d(C,{G:()=>s});var e=t(1257),a=t(45359),u=t(30929),c=t(3062),h=t(69357),i=t(44195),f=t(25715),l=t(7527),o=t(61191);const s=(0,i.op)({moments_:function n(r,d=null,p=!1){r=(0,e._1)(r,"x","moments");const g=(0,a.EC)(d,r.shape),_=(0,h.J)(r,g,p);let v=_.shape;p||(v=(0,u.rv)(_.shape,g));const M=(0,l.h)((0,o.l)((0,c.p)(r,"float32"),(0,f.X)(_,v)));return{mean:_,variance:(0,h.J)(M,g,p)}}})},48737:(H,C,t)=>{"use strict";t.d(C,{d:()=>f});var e=t(40687),a=t(34251),u=t(27664),c=t(1257);const f=(0,t(44195).op)({mul_:function i(l,o){let n=(0,c._1)(l,"a","mul"),s=(0,c._1)(o,"b","mul");return[n,s]=(0,u.makeTypesMatch)(n,s),e.BV.runKernel(a.wYn,{a:n,b:s})}})},15048:(H,C,t)=>{"use strict";t.d(C,{W:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({neg_:function h(f){const o={x:(0,u._1)(f,"x","neg")};return e.BV.runKernel(a.kuV,o)}})},2647:(H,C,t)=>{"use strict";t.d(C,{e:()=>a});var e=t(45359);function a(u,c,h,i,f,l){null==i&&(i=.5),null==f&&(f=Number.NEGATIVE_INFINITY),null==l&&(l=0);const o=u.shape[0];return h=Math.min(h,o),e.hu(0<=i&&i<=1,()=>`iouThreshold must be in [0, 1], but was '${i}'`),e.hu(2===u.rank,()=>`boxes must be a 2D tensor, but was of rank '${u.rank}'`),e.hu(4===u.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${u.shape[1]}`),e.hu(1===c.rank,()=>"scores must be a 1D tensor"),e.hu(c.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${c.shape[0]}`),e.hu(0<=l&&l<=1,()=>`softNmsSigma must be in [0, 1], but was '${l}'`),{maxOutputSize:h,iouThreshold:i,scoreThreshold:f,softNmsSigma:l}}},93717:(H,C,t)=>{"use strict";t.d(C,{K:()=>_});var e=t(1257),a=t(45359),u=t(26989),c=t(30929),h=t(33043),i=t(69602),f=t(44195),l=t(82962),o=t(25715),n=t(48661),s=t(70930),r=t(7527),d=t(69929);function g(v,M,T=null){if(0===v.rank)return(0,u.W)(v);if(1!==v.rank&&null===T)return g((0,o.X)(v,[-1]),M,T);if(1===v.rank||"number"==typeof T||Array.isArray(T)&&1===T.length){if(1===M)return(0,d.S)((0,u.W)(v),T);if(M===1/0)return(0,h.F)((0,u.W)(v),T);if(M===-1/0)return(0,i.V)((0,u.W)(v),T);if("euclidean"===M||2===M)return(0,s._)((0,d.S)((0,l.s)((0,u.W)(v),(0,n.i)(2,"int32")),T));throw new Error(`Error in norm: invalid ord value: ${M}`)}if(Array.isArray(T)&&2===T.length){if(1===M)return(0,h.F)((0,d.S)((0,u.W)(v),T[0]),T[1]-1);if(M===1/0)return(0,h.F)((0,d.S)((0,u.W)(v),T[1]),T[0]);if(M===-1/0)return(0,i.V)((0,d.S)((0,u.W)(v),T[1]),T[0]);if("fro"===M||"euclidean"===M)return(0,s._)((0,d.S)((0,r.h)(v),T));throw new Error(`Error in norm: invalid ord value: ${M}`)}throw new Error(`Error in norm: invalid axis: ${T}`)}const _=(0,f.op)({norm_:function p(v,M="euclidean",T=null,S=!1){const P=g(v=(0,e._1)(v,"x","norm"),M,T);let L=P.shape;if(S){const N=(0,a.EC)(T,v.shape);L=c.rv(P.shape,N)}return(0,o.X)(P,L)}})},23062:(H,C,t)=>{"use strict";t.d(C,{Q:()=>l});var e=t(40687),a=t(34251),u=t(27664),c=t(1257),h=t(93239);const l=(0,t(44195).op)({notEqual_:function f(o,n){let s=(0,c._1)(o,"a","notEqual","string_or_numeric"),r=(0,c._1)(n,"b","notEqual","string_or_numeric");return[s,r]=(0,u.makeTypesMatch)(s,r),(0,h.assertAndGetBroadcastShape)(s.shape,r.shape),e.BV.runKernel(a.yQU,{a:s,b:r})}})},5618:(H,C,t)=>{"use strict";t.d(C,{l:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({oneHot_:function h(f,l,o=1,n=0,s="int32"){if(l<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${l}`);const d={indices:(0,u._1)(f,"indices","oneHot","int32")};return e.BV.runKernel(a.we_,d,{dtype:s,depth:l,onValue:o,offValue:n})}})},84968:(H,C,t)=>{"use strict";t.d(C,{i:()=>h});var e=t(40687),a=t(45359),u=t(93037),c=t(36467);function h(i,f="float32"){if((0,a.Mu)(i),"complex64"===f){const o=h(i,"float32"),n=(0,c.l)(i,"float32");return(0,u.P)(o,n)}const l=(0,a.p8)((0,a.NA)(i),f);return e.BV.makeTensor(l,i,f)}},75034:(H,C,t)=>{"use strict";t.d(C,{J:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({onesLike_:function h(f){const o={x:(0,u._1)(f,"x","onesLike")};return e.BV.runKernel(a.qWM,o)}})},20404:(H,C,t)=>{"use strict";t.d(C,{v:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({pad_:function h(f,l,o=0){const n=(0,u._1)(f,"x","pad");if(0===n.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return e.BV.runKernel(a.lyA,{x:n},{paddings:l,constantValue:o})}})},91640:(H,C,t)=>{"use strict";t.d(C,{d:()=>d});var e=t(1257),a=t(45359),u=t(6903),c=t(92782),h=t(5551),i=t(12444),f=t(44195),l=t(25715),o=t(89619);const d=(0,f.op)({pool_:function n(p,g,_,v,M,T,S){null==M&&(M=[1,1]),null==T&&(T=1),0===v&&(v="valid");const P=(0,e._1)(p,"x","maxPool");let L=P,N=!1;3===P.rank&&(N=!0,L=(0,l.X)(P,[1,P.shape[0],P.shape[1],P.shape[2]])),a.hu(h.jT(T,M),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${T} and dilations '${M}'`);const O=h.Xw(L.shape,g,T,M,v),b=[O.dilationHeight,O.dilationWidth];let E;E="same"===v?function r(p,g){const v=p.map((S,P)=>S+(S-1)*(g[P]-1)).map(S=>S-1),M=v.map(S=>Math.floor(S/2)),T=v.map((S,P)=>S-M[P]);return v.map((S,P)=>[M[P],T[P]])}([O.filterHeight,O.filterWidth],b):[[0,0],[0,0]];const $=1===b[0]&&1===b[1],[W,Z]=function s(p,g,_){const v=_.map(O=>O[0]),M=_.map(O=>O[1]),T=p.concat(v,M),S=g.map((O,b)=>(O-T[b]%O)%O),P=M.map((O,b)=>O+S[b]),L=g.map((O,b)=>[v[b],P[b]]),N=g.map((O,b)=>[0,S[b]]);return[L,N]}([O.inHeight,O.inWidth],b,E),X=$?v:"valid",ut=$?L:(0,o.f)(L,b,W),Y=("avg"===_?()=>(0,u.w)(ut,g,T,X,S):()=>(0,i._)(ut,g,T,X,S))(),ht=$?Y:(0,c.E)(Y,b,Z);return N?(0,l.X)(ht,[ht.shape[1],ht.shape[2],ht.shape[3]]):ht}})},82962:(H,C,t)=>{"use strict";t.d(C,{s:()=>f});var e=t(40687),a=t(34251),u=t(27664),c=t(1257);const f=(0,t(44195).op)({pow_:function i(l,o){let n=(0,c._1)(l,"base","pow"),s=(0,c._1)(o,"exp","pow");return[n,s]=(0,u.makeTypesMatch)(n,s),e.BV.runKernel(a.pe_,{a:n,b:s})}})},71584:(H,C,t)=>{"use strict";t.d(C,{A:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({prelu_:function h(f,l){const o=(0,u._1)(f,"x","prelu"),n=(0,u._1)(l,"alpha","prelu");return e.BV.runKernel(a.o0g,{x:o,alpha:n})}})},43006:(H,C,t)=>{"use strict";function e(a,u=!1){console.log(a.toString(u))}t.d(C,{S:()=>e})},90794:(H,C,t)=>{"use strict";t.d(C,{W:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(3062);const f=(0,t(44195).op)({prod_:function i(l,o=null,n=!1){let s=(0,u._1)(l,"x","prod");return"bool"===s.dtype&&(s=(0,c.p)(s,"int32")),e.BV.runKernel(a.DlI,{x:s},{axis:o,keepDims:n})}})},21246:(H,C,t)=>{"use strict";t.d(C,{n:()=>i});var e=t(45359),a=t(80582),u=t(44195),c=t(42474);const i=(0,u.op)({randomNormal_:function h(f,l=0,o=1,n,s){if((0,e.Mu)(f),null!=n&&"bool"===n)throw new Error(`Unsupported data type ${n}`);const r=new c.Yi(l,o,n,!1,s),d=(0,a.f)(f,n);for(let p=0;p<d.values.length;p++)d.values[p]=r.nextValue();return d.toTensor()}})},41442:(H,C,t)=>{"use strict";t.d(C,{L:()=>i});var e=t(45359),a=t(80582),u=t(44195),c=t(42474);const i=(0,u.op)({randomUniform_:function h(f,l=0,o=1,n="float32",s){(0,e.Mu)(f);const r=(0,a.f)(f,n),d=new c.wv(l,o,null,s);for(let p=0;p<r.values.length;p++)r.values[p]=d.nextValue();return r.toTensor()}})},56944:(H,C,t)=>{"use strict";t.d(C,{w:()=>u});var e=t(40687),a=t(34251);function u(c,h,i=1,f="float32"){if(0===i)throw new Error("Cannot have a step of zero");return e.BV.runKernel(a.e6w,{},{start:c,stop:h,step:i,dtype:f})}},66027:(H,C,t)=>{"use strict";t.d(C,{k:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({real_:function h(f){const o={input:(0,u._1)(f,"input","real")};return e.BV.runKernel(a.xJR,o)}})},34831:(H,C,t)=>{"use strict";t.d(C,{M:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({reciprocal_:function h(f){const o={x:(0,u._1)(f,"x","reciprocal")};return e.BV.runKernel(a.$HU,o)}})},98586:(H,C,t)=>{"use strict";t.d(C,{U:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({relu_:function h(f){const o={x:(0,u._1)(f,"x","relu")};return e.BV.runKernel(a.qkr,o)}})},64917:(H,C,t)=>{"use strict";t.d(C,{b:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({relu6_:function h(f){const o={x:(0,u._1)(f,"x","relu6")};return e.BV.runKernel(a.SbG,o)}})},25715:(H,C,t)=>{"use strict";t.d(C,{X:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({reshape_:function h(f,l){const n={x:(0,u._1)(f,"x","reshape","string_or_numeric")};return e.BV.runKernel(a.HZH,n,{shape:l})}})},66825:(H,C,t)=>{"use strict";t.d(C,{G:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({reverse_:function h(f,l){const n={x:(0,u._1)(f,"x","reverse")};return e.BV.runKernel(a.mKl,n,{dims:l})}})},21974:(H,C,t)=>{"use strict";t.d(C,{N:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({round_:function h(f){const o={x:(0,u._1)(f,"x","round")};return e.BV.runKernel(a.e07,o)}})},68893:(H,C,t)=>{"use strict";t.d(C,{b:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({rsqrt_:function h(f){const o={x:(0,u._1)(f,"x","rsqrt","float32")};return e.BV.runKernel(a.bV0,o)}})},48661:(H,C,t)=>{"use strict";t.d(C,{i:()=>u});var e=t(49823),a=t(87431);function u(c,h){if(((0,e.isTypedArray)(c)&&"string"!==h||Array.isArray(c))&&"complex64"!==h)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===h&&(0,e.isTypedArray)(c)&&!(c instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,a.H)(c,[],[],h)}},29614:(H,C,t)=>{"use strict";t.d(C,{U:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({selu_:function h(f){const o={x:(0,u._1)(f,"x","selu")};return e.BV.runKernel(a.oFR,o)}})},42152:(H,C,t)=>{"use strict";t.d(C,{$:()=>a,y:()=>e});const e=1.7580993408473768,a=1.0507009873554805},36762:(H,C,t)=>{"use strict";t.d(C,{U:()=>l});var e=t(1257),a=t(45359),u=t(84451),c=t(51172),h=t(44195),i=t(25715);const l=(0,h.op)({separableConv2d_:function f(o,n,s,r,d,p=[1,1],g="NHWC"){const _=(0,e._1)(o,"x","separableConv2d"),v=(0,e._1)(n,"depthwiseFilter","separableConv2d"),M=(0,e._1)(s,"pointwiseFilter","separableConv2d");let T=_,S=!1;if(3===_.rank&&(S=!0,T=(0,i.X)(_,[1,_.shape[0],_.shape[1],_.shape[2]])),"NCHW"===g)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");a.hu(4===T.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${T.rank}.`),a.hu(4===v.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${v.rank}.`),a.hu(4===M.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${v.rank}.`),a.hu(1===M.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${M.shape[0]}.`),a.hu(1===M.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${M.shape[1]}.`);const P=v.shape[2],L=v.shape[3];a.hu(M.shape[2]===P*L,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${P*L}, but got ${M.shape[2]}.`);const N=(0,c.B)(T,v,r,d,g,p),b=(0,u.T)(N,M,1,"valid",g);return S?(0,i.X)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}})},86139:(H,C,t)=>{"use strict";t.d(C,{X:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({sigmoid_:function h(f){const o={x:(0,u._1)(f,"x","sigmoid","float32")};return e.BV.runKernel(a.a5O,o)}})},94058:(H,C,t)=>{"use strict";t.d(C,{X:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({sign_:function h(f){const o={x:(0,u._1)(f,"x","sign")};return e.BV.runKernel(a.i5y,o)}})},70068:(H,C,t)=>{"use strict";t.d(C,{W:()=>l});var e=t(64111),a=t(62787),u=t(44195),c=t(25715),h=t(58317),i=t(54174);const l=(0,u.op)({frame_:function f(o,n,s,r=!1,d=0){let p=0;const g=[];for(;p+n<=o.size;)g.push((0,h.t)(o,p,n)),p+=s;if(r)for(;p<o.size;){const _=p+n-o.size,v=(0,e.z)([(0,h.t)(o,p,n-_),(0,a.h)([_],d)]);g.push(v),p+=s}return 0===g.length?(0,i.o)([],[0,n]):(0,c.X)((0,e.z)(g),[g.length,n])}})},66461:(H,C,t)=>{"use strict";t.d(C,{f:()=>c});var e=t(44195),a=t(71150);const c=(0,e.op)({hammingWindow_:function u(h){return(0,a.m)(h,.54,.46)}})},39171:(H,C,t)=>{"use strict";t.d(C,{l:()=>c});var e=t(44195),a=t(71150);const c=(0,e.op)({hannWindow_:function u(h){return(0,a.m)(h,.5,.5)}})},69595:(H,C,t)=>{"use strict";t.d(C,{Z:()=>l});var e=t(48737),a=t(44195),u=t(71150),c=t(1638),h=t(70068),i=t(39171);const l=(0,a.op)({stft_:function f(o,n,s,r,d=i.l){null==r&&(r=(0,u.G)(n));const p=(0,h.W)(o,n,s),g=(0,e.d)(p,d(n));return(0,c.Q)(g,r)}})},71150:(H,C,t)=>{"use strict";t.d(C,{G:()=>a,m:()=>u});var e=t(28472);function a(c){return Math.floor(Math.pow(2,Math.ceil(Math.log(c)/Math.log(2))))}function u(c,h,i){const f=1-c%2,l=new Float32Array(c);for(let o=0;o<c;++o){const n=2*Math.PI*o/(c+f-1);l[o]=h-i*Math.cos(n)}return(0,e.R)(l,"float32")}},52438:(H,C,t)=>{"use strict";t.d(C,{O:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({sin_:function h(f){const o={x:(0,u._1)(f,"x","sin","float32")};return e.BV.runKernel(a.RQH,o)}})},319:(H,C,t)=>{"use strict";t.d(C,{R:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({sinh_:function h(f){const o={x:(0,u._1)(f,"x","sinh")};return e.BV.runKernel(a.wYB,o)}})},58317:(H,C,t)=>{"use strict";t.d(C,{t:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({slice_:function h(f,l,o){const n=(0,u._1)(f,"x","slice","string_or_numeric");if(0===n.rank)throw new Error("Slicing scalar is not possible");return e.BV.runKernel(a.p2w,{x:n},{begin:l,size:o})}})},96606:(H,C,t)=>{"use strict";t.d(C,{j:()=>i});var e=t(1257),a=t(45359),u=t(44195),c=t(58317);const i=(0,u.op)({slice1d_:function h(f,l,o){const n=(0,e._1)(f,"x","slice1d");return a.hu(1===n.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),(0,c.t)(n,[l],[o])}})},89131:(H,C,t)=>{"use strict";t.d(C,{S:()=>i});var e=t(1257),a=t(45359),u=t(44195),c=t(58317);const i=(0,u.op)({slice2d_:function h(f,l,o){const n=(0,e._1)(f,"x","slice2d");return a.hu(2===n.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),(0,c.t)(n,l,o)}})},26525:(H,C,t)=>{"use strict";t.d(C,{C:()=>i});var e=t(1257),a=t(45359),u=t(44195),c=t(58317);const i=(0,u.op)({slice3d_:function h(f,l,o){const n=(0,e._1)(f,"x","slice3d");return a.hu(3===n.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),(0,c.t)(n,l,o)}})},15332:(H,C,t)=>{"use strict";t.d(C,{p:()=>i});var e=t(1257),a=t(45359),u=t(44195),c=t(58317);const i=(0,u.op)({slice4d_:function h(f,l,o){const n=(0,e._1)(f,"x","slice4d");return a.hu(4===n.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),(0,c.t)(n,l,o)}})},22320:(H,C,t)=>{"use strict";t.r(C),t.d(C,{assertParamsValid:()=>c,computeFlatOffset:()=>v,computeOutShape:()=>i,getNormalizedAxes:()=>n,isSliceContinous:()=>_,maskToAxes:()=>h,parseSliceParams:()=>M,sliceInfo:()=>T,startForAxis:()=>p,startIndicesWithElidedDims:()=>s,stopForAxis:()=>g,stopIndicesWithElidedDims:()=>r,stridesForAxis:()=>d,stridesWithElidedDims:()=>f});var e=t(45359);const a=-2,u=-1;function c(L,N,O){const b=L.shape.length;e.hu(b===N.length,()=>`Error in slice${b}D: Length of begin ${N} must match the rank of the array (${b}).`),e.hu(b===O.length,()=>`Error in slice${b}D: Length of size ${O} must match the rank of the array (${b}).`);for(let E=0;E<b;++E)e.hu(N[E]+O[E]<=L.shape[E],()=>`Error in slice${b}D: begin[${E}] + size[${E}] (${N[E]+O[E]}) would overflow input.shape[${E}] (${L.shape[E]})`)}function h(L){const N=[];let O=0;for(;L>0;)1&L&&N.push(O),L/=2,O++;return N}function i(L,N,O){const b=[];for(let E=0;E<L.length;E++)b[E]=Math.ceil((N[E]-L[E])/O[E]);return b}function f(L,N,O,b){const E=[...L];for(let $=E.length;$<b.length;$++)E.push(1);for(let $=0;$<O;$++)0===$?E[N]=1:(E.splice(N,0,1),E.pop());return E}function l(L,N,O){return O<=L?O:O-(N-1)}function o(L,N){const O=[];for(let b=0;b<L;b++)O.push(N+b);return O}function n(L,N,O,b,E,$,W,Z,X){const ut=L.length;let Dt=new Array(ut),Y=new Array(ut),ht=new Array(ut);if(N.length&&O>0){const Pt=N[0],pt=O+1;Dt=s(W,Pt,pt,b,L),Y=r(Z,Pt,pt,E,L),ht=f($,Pt,pt,L)}else for(let Pt=0;Pt<ut;Pt++)Dt[Pt]=p(W,b,$,L,Pt,X),Y[Pt]=g(Z,E,$,L,Pt,X),ht[Pt]=d($,Pt,X);return{begin:Dt,end:Y,strides:ht}}function s(L,N,O,b,E){const $=[...E],W=o(O,N);for(let Z=0;Z<$.length;Z++)if(W.indexOf(Z)>-1)$[Z]=0;else{const X=l(N,O,Z);let ut=b[X];L&1<<X&&(ut=0),$[Z]=ut}return $}function r(L,N,O,b,E){const $=[...E],W=o(O,N);for(let Z=0;Z<$.length;Z++)if(W.indexOf(Z)>-1)$[Z]=Number.MAX_SAFE_INTEGER;else{const X=l(N,O,Z);let ut=b[X];L&1<<X&&(ut=Number.MAX_SAFE_INTEGER),$[Z]=ut}for(let Z=0;Z<$.length;Z++)$[Z]<0&&($[Z]+=E[Z]),$[Z]=e.uZ(0,$[Z],E[Z]);return $}function d(L,N,O){let b=L[N];return(O&1<<N||null==b)&&(b=1),b}function p(L,N,O,b,E,$){let W=N[E];(L&1<<E||$&1<<E||null==W)&&(W=(O[E]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const X=b[E];return W<0&&(W+=X),W=e.uZ(0,W,X-1),W}function g(L,N,O,b,E,$){let W=N[E];const Z=O[E]||1;(L&1<<E||$&1<<E||null==W)&&(W=Z>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const X=b[E];return W<0&&(W+=X),W=Z>0?e.uZ(0,W,X):e.uZ(-1,W,X-1),W}function _(L,N,O){let b=O.length;for(let E=0;E<O.length;E++)if(O[E]>1){b=E;break}for(let E=b+1;E<O.length;E++)if(N[E]>0||O[E]!==L[E])return!1;return!0}function v(L,N){let O=L.length>0?L[L.length-1]:1;for(let b=0;b<L.length-1;b++)O+=L[b]*N[b];return O}function M(L,N,O){let b;const E=L.shape.length;let $;return b="number"==typeof N?[N,...new Array(E-1).fill(0)]:N.length<E?N.concat(new Array(E-N.length).fill(0)):N.slice(),b.forEach(W=>{e.hu(-1!==W,()=>"slice() does not support negative begin indexing.")}),$=null==O?new Array(E).fill(-1):"number"==typeof O?[O,...new Array(E-1).fill(-1)]:O.length<E?O.concat(new Array(E-O.length).fill(-1)):O,$=$.map((W,Z)=>W>=0?W:(e.hu(-1===W,()=>`Negative size values should be exactly -1 but got ${W} for the slice() size at index ${Z}.`),L.shape[Z]-b[Z])),[b,$]}function T(L,N,O,b,E,$,W,Z,X){let ut;if(null==b?(ut=new Array(N.length),ut.fill(1)):ut=b,null!=W&&W&W-1)throw new Error("Multiple ellipses in slice is not allowed.");let Dt=!1;const Y={dims:ut.length,numAddAxisAfterEllipsis:0,begin:N.slice(),end:O.slice(),strides:ut.slice(),beginMask:E,endMask:$,ellipsisMask:W,newAxisMask:Z,shrinkAxisMask:X};for(let oe=0;oe<Y.dims;oe++)Dt&&!!(1<<oe&Z)&&Y.numAddAxisAfterEllipsis++,1<<oe&W&&(Dt=!0);Dt||(Y.ellipsisMask|=1<<Y.dims,Y.dims++);const ht={dims:L.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function S(L,N){N.beginMask=0,N.endMask=0,N.shrinkAxisMask=0;let O=0;N.beginValid=null!=L.begin,N.endValid=null!=L.end,N.begin=new Array(N.dims),N.end=new Array(N.dims),N.strides=new Array(N.dims),N.finalShapeGatherIndices=[],N.finalShapeGatherIndicesSparse=[],N.inputShapeGatherIndicesSparse=new Array(N.dims);for(let b=0;b<L.dims;b++)if(1<<b&L.ellipsisMask){const E=Math.min(N.dims-(L.dims-b)+1+L.numAddAxisAfterEllipsis,N.dims);for(;O<E;O++)N.begin[O]=0,N.end[O]=0,N.strides[O]=1,N.beginMask|=1<<O,N.endMask|=1<<O,N.finalShapeGatherIndices.push(O),N.finalShapeGatherIndicesSparse.push(-1),N.inputShapeGatherIndicesSparse[O]=b}else if(1<<b&L.newAxisMask)N.finalShapeGatherIndices.push(a),N.finalShapeGatherIndicesSparse.push(-1);else{if(O===N.begin.length)throw Error(`Index out of range using input dim ${O}; input has only ${N.dims} dims, ${N.begin.length}.`);null!=L.begin&&(N.begin[O]=L.begin[b]),null!=L.end&&(N.end[O]=L.end[b]),N.strides[O]=L.strides[b],L.beginMask&1<<b&&(N.beginMask|=1<<O),L.endMask&1<<b&&(N.endMask|=1<<O),L.shrinkAxisMask&1<<b?(N.finalShapeGatherIndices.push(u),N.finalShapeGatherIndicesSparse.push(-1),N.shrinkAxisMask|=1<<O):(N.finalShapeGatherIndices.push(O),N.finalShapeGatherIndicesSparse.push(b)),N.inputShapeGatherIndicesSparse[O]=b,O++}}(Y,ht);let Pt=!0,pt=!0,xt=!0;const Nt=[],Vt=[];for(let oe=0;oe<L.length;++oe){if(0===ht.strides[oe])throw Error(`strides[${oe}] must be non-zero`);const Ee=!!(ht.shrinkAxisMask&1<<oe),Ie=L[oe];if(-1===Ie){Nt.push(Ee?1:-1);continue}const ie=[ht.beginMask&1<<oe,ht.endMask&1<<oe],Zt=[ht.strides[oe]>0?0:-1,ht.strides[oe]>0?Ie:Ie-1];if(Ee&&ht.strides[oe]<=0)throw Error("only stride 1 allowed on non-range indexing.");xt=xt&&1===ht.strides[oe];const ct=!!(ht.beginMask&1<<oe&&ht.endMask&1<<oe);if(ht.beginValid&&ht.endValid){if(Ee){const K=ht.begin[oe]<0?Ie+ht.begin[oe]:ht.begin[oe];if(ht.begin[oe]=K,ht.end[oe]=ht.begin[oe]+1,K<0||K>=Ie)throw Error(`slice index ${ht.begin[oe]} of dimension ${oe} out of bounds.`)}else ht.begin[oe]=P(ht.begin[oe],0,ht.strides[oe],Ie,ie,Zt),ht.end[oe]=P(ht.end[oe],1,ht.strides[oe],Ie,ie,Zt);const q=1===ht.strides[oe]&&0===ht.begin[oe]&&ht.end[oe]===Ie;Pt=Pt&&q,pt=pt&&(0===oe&&1===ht.strides[oe]||q)}else Pt=Pt&&1===ht.strides[oe]&&ct,pt=pt&&(0===oe&&1===ht.strides[oe]||ct);let It,Ut=!1;if(ht.beginValid&&ht.endValid?(It=ht.end[oe]-ht.begin[oe],Ut=!0):Ee?(It=1,Ut=!0):ct&&Ie>=0&&(It=ht.strides[oe]<0?-Ie:Ie,Ut=!0),Ut){let q;q=0===It||It<0!=ht.strides[oe]<0?0:Math.trunc(It/ht.strides[oe])+(It%ht.strides[oe]!=0?1:0),Nt.push(q)}else Nt.push(-1)}for(let oe=0;oe<ht.finalShapeGatherIndices.length;++oe){const Ee=ht.finalShapeGatherIndices[oe];Ee>=0?Vt.push(Nt[Ee]):Ee===a&&Vt.push(1)}return{finalShapeSparse:Vt.filter((oe,Ee)=>ht.finalShapeGatherIndices[Ee]!==a),finalShape:Vt,isIdentity:Pt,sliceDim0:pt,isSimpleSlice:xt,begin:ht.begin,end:ht.end,strides:ht.strides}}function P(L,N,O,b,E,$){if(E[N])return O>0?$[N]:$[N+1&1];{const W=L<0?b+L:L;return W<$[0]?$[0]:W>$[1]?$[1]:W}}},38683:(H,C,t)=>{"use strict";t.d(C,{X:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({softmax_:function h(f,l=-1){const o=(0,u._1)(f,"logits","softmax","float32");if(-1===l&&(l=o.rank-1),l!==o.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o.rank} and dim was ${l}`);return e.BV.runKernel(a.Gcp,{logits:o},{dim:l})}})},94487:(H,C,t)=>{"use strict";t.d(C,{W:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({softplus_:function h(f){const o={x:(0,u._1)(f,"x","softplus")};return e.BV.runKernel(a.MRv,o)}})},89619:(H,C,t)=>{"use strict";t.d(C,{f:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({spaceToBatchND_:function i(l,o,n){const s=(0,u._1)(l,"x","spaceToBatchND");return c.hu(s.rank>=1+o.length,()=>`input rank ${s.rank} should be > than [blockShape] ${o.length}`),c.hu(n.length===o.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${o.length}`),c.hu(s.shape.reduce((p,g,_)=>_>0&&_<=o.length?p&&(g+n[_-1][0]+n[_-1][1])%o[_-1]==0:p,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${o.toString()}`),e.BV.runKernel(a.TQc,{x:s},{blockShape:o,paddings:n})}})},13373:(H,C,t)=>{"use strict";t.d(C,{M:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({sparseFillEmptyRows_:function h(f,l,o,n){const s=(0,u._1)(f,"indices","sparseFillEmptyRows","int32"),r=(0,u._1)(l,"values","sparseFillEmptyRows"),d=(0,u._1)(o,"denseShape","sparseFillEmptyRows","int32"),p=(0,u._1)(n,"defaultValue","sparseFillEmptyRows",r.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==r.rank)throw new Error(`Values should be Tensor1D but received shape ${r.shape}`);if(1!==d.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${d.shape}`);if(0!==p.rank)throw new Error(`Default value should be a scalar but received shape ${p.shape}`);const _=e.BV.runKernel(a.O3z,{indices:s,values:r,denseShape:d,defaultValue:p});return{outputIndices:_[0],outputValues:_[1],emptyRowIndicator:_[2],reverseIndexMap:_[3]}}})},8733:(H,C,t)=>{"use strict";t.d(C,{x:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({sparseReshape_:function h(f,l,o){const n=(0,u._1)(f,"inputIndices","sparseReshape","int32"),s=(0,u._1)(l,"inputShape","sparseReshape","int32"),r=(0,u._1)(o,"newShape","sparseReshape","int32");if(2!==n.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${n.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==r.rank)throw new Error(`New shape should be Tensor1D but received shape ${r.shape}`);const p=e.BV.runKernel(a.nhH,{inputIndices:n,inputShape:s,newShape:r});return{outputIndices:p[0],outputShape:p[1]}}})},15274:(H,C,t)=>{"use strict";t.d(C,{S:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({sparseSegmentMean_:function h(f,l,o){const n=(0,u._1)(f,"data","sparseSegmentMean"),s=(0,u._1)(l,"indices","sparseSegmentMean","int32"),r=(0,u._1)(o,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==r.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${r.shape}`);return e.BV.runKernel(a.w3H,{data:n,indices:s,segmentIds:r})}})},17450:(H,C,t)=>{"use strict";t.d(C,{l:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({sparseSegmentSum_:function h(f,l,o){const n=(0,u._1)(f,"data","sparseSegmentSum"),s=(0,u._1)(l,"indices","sparseSegmentSum","int32"),r=(0,u._1)(o,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==r.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${r.shape}`);return e.BV.runKernel(a.ZjV,{data:n,indices:s,segmentIds:r})}})},79738:(H,C,t)=>{"use strict";t.d(C,{k:()=>i});var e=t(40687),a=t(34251),u=t(45359);const i=(0,t(44195).op)({fft_:function h(f){return(0,u.hu)("complex64"===f.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${f.dtype}.`),e.BV.runKernel(a.vwp,{input:f})}})},40527:(H,C,t)=>{"use strict";t.d(C,{S:()=>i});var e=t(40687),a=t(34251),u=t(45359);const i=(0,t(44195).op)({ifft_:function h(f){return(0,u.hu)("complex64"===f.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${f.dtype}.`),e.BV.runKernel(a.Qg5,{input:f})}})},76065:(H,C,t)=>{"use strict";t.d(C,{w:()=>d});var e=t(93037),a=t(64111),u=t(51844),c=t(48737),h=t(44195),i=t(66027),f=t(25715),l=t(66825),o=t(48661),n=t(58317),s=t(40527);const d=(0,h.op)({irfft_:function r(p){const g=p.shape[p.shape.length-1],_=p.size/g;let v;if(g<=2){const M=(0,f.X)(p,[_,g]);v=(0,s.S)(M)}else{const M=[_,2*(g-1)],T=(0,f.X)((0,i.k)(p),[_,g]),S=(0,f.X)((0,u.a)(p),[_,g]),P=(0,l.G)((0,n.t)(T,[0,1],[_,g-2]),1),L=(0,c.d)((0,l.G)((0,n.t)(S,[0,1],[_,g-2]),1),(0,o.i)(-1)),N=(0,a.z)([T,P],1),O=(0,a.z)([S,L],1),b=(0,f.X)((0,e.P)(N,O),[M[0],M[1]]);v=(0,s.S)(b)}if(v=(0,i.k)(v),3===p.rank&&0!==p.shape[0]){const M=v,T=p.shape[0];v=(0,f.X)(v,[T,v.shape[0]/T,v.shape[1]]),M.dispose()}return v}})},1638:(H,C,t)=>{"use strict";t.d(C,{Q:()=>p});var e=t(45359),a=t(93037),u=t(64111),c=t(51844),h=t(44195),i=t(66027),f=t(25715),l=t(58317),o=t(8874),n=t(36467),s=t(23143),r=t(79738);const p=(0,h.op)({rfft_:function d(g,_){(0,e.hu)("float32"===g.dtype,()=>`The dtype for rfft() must be real value but got ${g.dtype}`);let v=g.shape[g.shape.length-1];const M=g.size/v;let T;if(null!=_&&_<v){const Z=g.shape.map(ut=>0),X=g.shape.map(ut=>ut);X[g.shape.length-1]=_,T=(0,l.t)(g,Z,X),v=_}else if(null!=_&&_>v){const Z=g.shape.map(X=>X);Z[g.shape.length-1]=_-v,T=(0,u.z)([g,(0,n.l)(Z)],g.shape.length-1),v=_}else T=g;const S=(0,s.P)(T),P=(0,f.X)((0,a.P)(T,S),[M,v]),L=(0,r.k)(P),N=Math.floor(v/2)+1,O=(0,i.k)(L),b=(0,c.a)(L),E=(0,o.V)(O,[N,v-N],O.shape.length-1),$=(0,o.V)(b,[N,v-N],b.shape.length-1),W=T.shape.slice();return W[T.shape.length-1]=N,(0,f.X)((0,a.P)(E[0],$[0]),W)}})},8874:(H,C,t)=>{"use strict";t.d(C,{V:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({split_:function h(f,l,o=0){const s={x:(0,u._1)(f,"x","split")};return e.BV.runKernel(a.L8s,s,{numOrSizeSplits:l,axis:o})}})},70930:(H,C,t)=>{"use strict";t.d(C,{_:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({sqrt_:function h(f){const o={x:(0,u._1)(f,"x","sqrt","float32")};return e.BV.runKernel(a.FKq,o)}})},7527:(H,C,t)=>{"use strict";t.d(C,{h:()=>h});var e=t(40687),a=t(1257);const h=(0,t(44195).op)({square_:function c(i){const f=(0,a._1)(i,"x","square");return e.BV.runKernel("Square",{x:f},{})}})},99539:(H,C,t)=>{"use strict";t.d(C,{$:()=>l});var e=t(40687),a=t(34251),u=t(27664),c=t(1257),h=t(93239);const l=(0,t(44195).op)({squaredDifference_:function f(o,n){let s=(0,c._1)(o,"a","squaredDifference"),r=(0,c._1)(n,"b","squaredDifference");return[s,r]=(0,u.makeTypesMatch)(s,r),(0,h.assertAndGetBroadcastShape)(s.shape,r.shape),e.BV.runKernel(a._tC,{a:s,b:r},{})}})},2494:(H,C,t)=>{"use strict";t.d(C,{L:()=>i});var e=t(1257),a=t(45359),u=t(44195),c=t(25715);const i=(0,u.op)({squeeze_:function h(f,l){const o=(0,e._1)(f,"x","squeeze","string_or_numeric");return(0,c.X)(o,(0,a.bp)(o.shape,l).newShape)}})},57958:(H,C,t)=>{"use strict";t.d(C,{k:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({stack_:function i(l,o=0){const n=(0,u.sI)(l,"tensors","stack","string_or_numeric");return c.hu(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&c.hu(o<=n[0].rank,()=>"Axis must be <= rank of the tensor"),e.BV.runKernel(a.QiL,n,{axis:o})}})},26034:(H,C,t)=>{"use strict";t.d(C,{N:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({step_:function h(f,l=0){const n={x:(0,u._1)(f,"x","step")};return e.BV.runKernel(a.h8e,n,{alpha:l})}})},5367:(H,C,t)=>{"use strict";t.d(C,{N:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({stridedSlice_:function h(f,l,o,n,s=0,r=0,d=0,p=0,g=0){const v={x:(0,u._1)(f,"x","stridedSlice","string_or_numeric")};return e.BV.runKernel(a.jQk,v,{begin:l,end:o,strides:n,beginMask:s,endMask:r,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:g})}})},95149:(H,C,t)=>{"use strict";t.d(C,{i:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({staticRegexReplace_:function h(f,l,o,n=!0){const s=(0,u._1)(f,"input","staticRegexReplace","string");return e.BV.runKernel(a.e0R,{x:s},{pattern:l,rewrite:o,replaceGlobal:n})}})},12310:(H,C,t)=>{"use strict";t.d(C,{l:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({stringNGrams_:function h(f,l,o,n,s,r,d,p){const g=(0,u._1)(f,"data","stringNGrams","string");if("string"!==g.dtype)throw new Error("Data must be of datatype string");if(1!==g.shape.length)throw new Error(`Data must be a vector, saw: ${g.shape}`);const _=(0,u._1)(l,"dataSplits","stringNGrams");if("int32"!==_.dtype)throw new Error("Data splits must be of datatype int32");const T=e.BV.runKernel(a._JP,{data:g,dataSplits:_},{separator:o,nGramWidths:n,leftPad:s,rightPad:r,padWidth:d,preserveShortSequences:p});return{nGrams:T[0],nGramsSplits:T[1]}}})},29703:(H,C,t)=>{"use strict";t.d(C,{S:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({stringSplit_:function h(f,l,o=!0){const n=(0,u._1)(f,"input","stringSplit","string"),s=(0,u._1)(l,"delimiter","stringSplit","string");if(1!==n.rank)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const p=e.BV.runKernel(a.s1s,{input:n,delimiter:s},{skipEmpty:o});return{indices:p[0],values:p[1],shape:p[2]}}})},89399:(H,C,t)=>{"use strict";t.d(C,{I:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({stringToHashBucketFast_:function h(f,l){const o=(0,u._1)(f,"input","stringToHashBucketFast","string"),n={numBuckets:l};if(l<=0)throw new Error("Number of buckets must be at least 1");return e.BV.runKernel(a.XkS,{input:o},n)}})},61191:(H,C,t)=>{"use strict";t.d(C,{l:()=>f});var e=t(40687),a=t(34251),u=t(27664),c=t(1257);const f=(0,t(44195).op)({sub_:function i(l,o){let n=(0,c._1)(l,"a","sub"),s=(0,c._1)(o,"b","sub");return[n,s]=(0,u.makeTypesMatch)(n,s),e.BV.runKernel(a.Tr8,{a:n,b:s})}})},69929:(H,C,t)=>{"use strict";t.d(C,{S:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(3062);const f=(0,t(44195).op)({sum_:function i(l,o=null,n=!1){let s=(0,u._1)(l,"x","sum");return"bool"===s.dtype&&(s=(0,c.p)(s,"int32")),e.BV.runKernel(a.GBy,{x:s},{axis:o,keepDims:n})}})},82500:(H,C,t)=>{"use strict";t.d(C,{O:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({tan_:function h(f){const o={x:(0,u._1)(f,"x","tan","float32")};return e.BV.runKernel(a.sEM,o)}})},25987:(H,C,t)=>{"use strict";t.d(C,{A:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({tanh_:function h(f){const o={x:(0,u._1)(f,"x","tanh","float32")};return e.BV.runKernel(a.MIZ,o)}})},23905:(H,C,t)=>{"use strict";t.d(C,{X:()=>u});var e=t(1257),a=t(87431);function u(c,h,i){const f=(0,e.C)(c,i);return(0,a.H)(c,h,f,i)}},28472:(H,C,t)=>{"use strict";t.d(C,{R:()=>c});var e=t(1257),a=t(45359),u=t(87431);function c(h,i){(0,a.Cq)(h);const f=(0,e.C)(h,i);if(1!==f.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,u.H)(h,null,f,i)}},54174:(H,C,t)=>{"use strict";t.d(C,{o:()=>c});var e=t(1257),a=t(45359),u=t(87431);function c(h,i,f){if((0,a.Cq)(h),null!=i&&2!==i.length)throw new Error("tensor2d() requires shape to have two numbers");const l=(0,e.C)(h,f);if(2!==l.length&&1!==l.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===l.length&&null==i)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,u.H)(h,i,l,f)}},87431:(H,C,t)=>{"use strict";t.d(C,{H:()=>h});var e=t(40687),a=t(1216),u=t(45359),c=t(49823);function h(i,f,l,o){if(null==o)o=(0,u.D2)(i);else if("complex64"===o)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if((0,a.$F)(i)||(0,a.Oq)(i)){if("float32"!==o&&"int32"!==o)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${o}.`);return e.BV.backend.createTensorFromGPUData(i,f||l,o)}if(!(0,c.isTypedArray)(i)&&!Array.isArray(i)&&"number"!=typeof i&&"boolean"!=typeof i&&"string"!=typeof i)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=f){(0,u.Mu)(f);const n=(0,u.NA)(f),s=(0,u.NA)(l);(0,u.hu)(n===s,()=>`Based on the provided shape, [${f}], the tensor should have ${n} values but has ${s}`);for(let r=0;r<l.length;++r){const p=r!==l.length-1||l[r]!==(0,u.NA)(f.slice(r));(0,u.hu)(l[r]===f[r]||!p,()=>`Error creating a new Tensor. Inferred shape (${l}) does not match the provided shape (${f}). `)}}return!(0,c.isTypedArray)(i)&&!Array.isArray(i)&&(i=[i]),f=f||l,i="string"!==o?(0,c.toTypedArray)(i,o):(0,c.flatten)(i,[],!0),e.BV.makeTensor(i,f,o)}},42005:(H,C,t)=>{"use strict";t.d(C,{G:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({tile_:function i(l,o){const n=(0,u._1)(l,"x","tile","string_or_numeric");return c.hu(n.rank===o.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${o}.`),e.BV.runKernel(a.n9L,{x:n},{reps:o})}})},54927:(H,C,t)=>{"use strict";t.d(C,{h:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({topk_:function h(f,l=1,o=!0){const n=(0,u._1)(f,"x","topk");if(0===n.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=n.shape[n.shape.length-1];if(l<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${l}`);if(l>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${l}`);const r={x:n},d={k:l,sorted:o},[p,g]=e.BV.runKernel(a.cWu,r,d);return{values:p,indices:g}}})},19194:(H,C,t)=>{"use strict";t.d(C,{p:()=>r});var e=t(40687),a=t(12773),u=t(34251),c=t(1257),h=t(45359),i=t(93037),f=t(51844),l=t(15048),o=t(44195),n=t(66027);const r=(0,o.op)({transpose_:function s(d,p,g){const _=(0,c._1)(d,"x","transpose");if(null==p&&(p=_.shape.map((T,S)=>S).reverse()),h.hu(_.rank===p.length,()=>`Error in transpose: rank of input ${_.rank} must match length of perm ${p}.`),p.forEach(T=>{h.hu(T>=0&&T<_.rank,()=>`All entries in 'perm' must be between 0 and ${_.rank-1} but got ${p}`)}),_.rank<=1)return _.clone();const v={x:_},M={perm:p};return"complex64"===_.dtype?(0,a.lu)(()=>{let T=(0,n.k)(_),S=(0,f.a)(_);return T=e.BV.runKernel(u.G3Y,{x:T},M),S=e.BV.runKernel(u.G3Y,{x:S},M),g&&(S=(0,l.W)(S)),(0,i.P)(T,S)}):e.BV.runKernel(u.G3Y,v,M)}})},87206:(H,C,t)=>{"use strict";t.d(C,{X:()=>i});var e=t(45359),a=t(80582),u=t(44195),c=t(42474);const i=(0,u.op)({truncatedNormal_:function h(f,l=0,o=1,n,s){if((0,e.Mu)(f),null!=n&&"bool"===n)throw new Error("Unsupported data type $ { dtype }");const r=new c.Yi(l,o,n,!0,s),d=(0,a.f)(f,n);for(let p=0;p<d.values.length;p++)d.values[p]=r.nextValue();return d.toTensor()}})},18130:(H,C,t)=>{"use strict";t.d(C,{T:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({unique_:function i(l,o=0){const n=(0,u._1)(l,"x","unique","string_or_numeric");(0,c.hu)(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:o},[d,p]=e.BV.runKernel(a.kpP,s,r);return{values:d,indices:p}}})},47715:(H,C,t)=>{"use strict";t.d(C,{p:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({unsortedSegmentSum_:function i(l,o,n){const s=(0,u._1)(l,"x","unsortedSegmentSum"),r=(0,u._1)(o,"segmentIds","unsortedSegmentSum","int32");return(0,c.hu)((0,c.GN)(n),()=>"numSegments must be of dtype int"),e.BV.runKernel(a.Qvg,{x:s,segmentIds:r},{numSegments:n})}})},92219:(H,C,t)=>{"use strict";t.d(C,{H:()=>f});var e=t(40687),a=t(34251),u=t(1257),c=t(45359);const f=(0,t(44195).op)({unstack_:function i(l,o=0){const n=(0,u._1)(l,"x","unstack","string_or_numeric");return c.hu(o>=-n.shape.length&&o<n.shape.length,()=>`Axis = ${o} is not in [-${n.shape.length}, ${n.shape.length})`),e.BV.runKernel(a.ToN,{value:n},{axis:o})}})},15178:(H,C,t)=>{"use strict";t.d(C,{V:()=>a});var e=t(40687);function a(u,c=!0,h,i){return e.BV.makeVariable(u,c,h,i)}},12190:(H,C,t)=>{"use strict";t.d(C,{a:()=>l});var e=t(40687),a=t(34251),u=t(1257),c=t(90983),h=t(93239);const l=(0,t(44195).op)({where_:function f(o,n,s){const r=(0,u._1)(n,"a","where"),d=(0,u._1)(s,"b","where"),p=(0,u._1)(o,"condition","where","bool"),g=(0,h.assertAndGetBroadcastShape)((0,h.assertAndGetBroadcastShape)(p.shape,r.shape),d.shape),_=(0,c.U)(p,g),v=(0,c.U)(r,g),M=(0,c.U)(d,g);return e.BV.runKernel(a.PhF,{condition:_,t:v,e:M})}})},36467:(H,C,t)=>{"use strict";t.d(C,{l:()=>c});var e=t(40687),a=t(45359),u=t(93037);function c(h,i="float32"){if((0,a.Mu)(h),"complex64"===i){const l=c(h,"float32"),o=c(h,"float32");return(0,u.P)(l,o)}const f=(0,a.wT)((0,a.NA)(h),i);return e.BV.makeTensor(f,h,i)}},23143:(H,C,t)=>{"use strict";t.d(C,{P:()=>i});var e=t(40687),a=t(34251),u=t(1257);const i=(0,t(44195).op)({zerosLike_:function h(f){const o={x:(0,u._1)(f,"x","zerosLike")};return e.BV.runKernel(a.RuY,o)}})},71960:(H,C,t)=>{"use strict";t.d(C,{z:()=>s});var e=t(15861),a=t(40687),u=t(12773),c=t(87066),h=t(93530),i=t(48737),f=t(70930),l=t(7527),o=t(23143),n=t(57075);class s extends n.g{static get className(){return"Adadelta"}constructor(d,p,g=null){super(),this.learningRate=d,this.rho=p,this.epsilon=g,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==g&&(this.epsilon=a.BV.backend.epsilon())}applyGradients(d){(Array.isArray(d)?d.map(g=>g.name):Object.keys(d)).forEach((g,_)=>{const v=a.BV.registeredVariables[g],M=!1;null==this.accumulatedGrads[_]&&(this.accumulatedGrads[_]={originalName:`${g}/accum_grad`,variable:(0,u.lu)(()=>(0,o.P)(v).variable(M))}),null==this.accumulatedUpdates[_]&&(this.accumulatedUpdates[_]={originalName:`${g}/accum_var`,variable:(0,u.lu)(()=>(0,o.P)(v).variable(M))});const T=Array.isArray(d)?d[_].tensor:d[g];if(null==T)return;const S=this.accumulatedGrads[_].variable,P=this.accumulatedUpdates[_].variable;(0,u.lu)(()=>{const L=(0,c.I)((0,i.d)(S,this.rho),(0,i.d)((0,l.h)(T),1-this.rho)),N=(0,i.d)((0,h.h)((0,f._)((0,c.I)(P,this.epsilon)),(0,f._)((0,c.I)(S,this.epsilon))),T),O=(0,c.I)((0,i.d)(P,this.rho),(0,i.d)((0,l.h)(N),1-this.rho));S.assign(L),P.assign(O);const b=(0,c.I)((0,i.d)(N,-this.learningRate),v);v.assign(b)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,u.B9)(this.accumulatedGrads.map(d=>d.variable)),(0,u.B9)(this.accumulatedUpdates.map(d=>d.variable)))}getWeights(){var d=this;return(0,e.Z)(function*(){const p=[...d.accumulatedGrads,...d.accumulatedUpdates];return[yield d.saveIterations()].concat(p.map(g=>({name:g.originalName,tensor:g.variable})))})()}setWeights(d){var p=this;return(0,e.Z)(function*(){const g=(d=yield p.extractIterations(d)).length/2,_=!1;p.accumulatedGrads=d.slice(0,g).map(v=>({originalName:v.name,variable:v.tensor.variable(_)})),p.accumulatedUpdates=d.slice(g,2*g).map(v=>({originalName:v.name,variable:v.tensor.variable(_)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(d,p){return new d(p.learningRate,p.rho,p.epsilon)}}},55328:(H,C,t)=>{"use strict";t.d(C,{H:()=>s});var e=t(15861),a=t(40687),u=t(12773),c=t(87066),h=t(93530),i=t(62787),f=t(48737),l=t(70930),o=t(7527),n=t(57075);class s extends n.g{static get className(){return"Adagrad"}constructor(d,p=.1){super(),this.learningRate=d,this.initialAccumulatorValue=p,this.accumulatedGrads=[]}applyGradients(d){(Array.isArray(d)?d.map(g=>g.name):Object.keys(d)).forEach((g,_)=>{const v=a.BV.registeredVariables[g];null==this.accumulatedGrads[_]&&(this.accumulatedGrads[_]={originalName:`${g}/accumulator`,variable:(0,u.lu)(()=>(0,i.h)(v.shape,this.initialAccumulatorValue).variable(!1))});const M=Array.isArray(d)?d[_].tensor:d[g];if(null==M)return;const T=this.accumulatedGrads[_].variable;(0,u.lu)(()=>{const S=(0,c.I)(T,(0,o.h)(M));T.assign(S);const P=(0,c.I)((0,f.d)((0,h.h)(M,(0,l._)((0,c.I)(S,a.BV.backend.epsilon()))),-this.learningRate),v);v.assign(P)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,u.B9)(this.accumulatedGrads.map(d=>d.variable))}getWeights(){var d=this;return(0,e.Z)(function*(){return[yield d.saveIterations()].concat(d.accumulatedGrads.map(p=>({name:p.originalName,tensor:p.variable})))})()}setWeights(d){var p=this;return(0,e.Z)(function*(){d=yield p.extractIterations(d),p.accumulatedGrads=d.map(_=>({originalName:_.name,variable:_.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(d,p){return new d(p.learningRate,p.initialAccumulatorValue)}}},46330:(H,C,t)=>{"use strict";t.d(C,{a:()=>p});var e=t(15861),a=t(40687),u=t(12773),c=t(87066),h=t(93530),i=t(48737),f=t(82962),l=t(48661),o=t(70930),n=t(7527),s=t(61191),r=t(23143),d=t(57075);class p extends d.g{static get className(){return"Adam"}constructor(_,v,M,T=null){super(),this.learningRate=_,this.beta1=v,this.beta2=M,this.epsilon=T,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,u.lu)(()=>{this.accBeta1=(0,l.i)(v).variable(),this.accBeta2=(0,l.i)(M).variable()}),null==T&&(this.epsilon=a.BV.backend.epsilon())}applyGradients(_){const v=Array.isArray(_)?_.map(M=>M.name):Object.keys(_);(0,u.lu)(()=>{const M=(0,s.l)(1,this.accBeta1),T=(0,s.l)(1,this.accBeta2);v.forEach((S,P)=>{const L=a.BV.registeredVariables[S],N=!1;null==this.accumulatedFirstMoment[P]&&(this.accumulatedFirstMoment[P]={originalName:`${S}/m`,variable:(0,u.lu)(()=>(0,r.P)(L).variable(N))}),null==this.accumulatedSecondMoment[P]&&(this.accumulatedSecondMoment[P]={originalName:`${S}/v`,variable:(0,u.lu)(()=>(0,r.P)(L).variable(N))});const O=Array.isArray(_)?_[P].tensor:_[S];if(null==O)return;const b=this.accumulatedFirstMoment[P].variable,E=this.accumulatedSecondMoment[P].variable,$=(0,c.I)((0,i.d)(b,this.beta1),(0,i.d)(O,1-this.beta1)),W=(0,c.I)((0,i.d)(E,this.beta2),(0,i.d)((0,n.h)(O),1-this.beta2)),Z=(0,h.h)($,M),X=(0,h.h)(W,T);b.assign($),E.assign(W);const ut=(0,c.I)((0,i.d)((0,h.h)(Z,(0,c.I)((0,o._)(X),this.epsilon)),-this.learningRate),L);L.assign(ut)}),this.accBeta1.assign((0,i.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,i.d)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,u.B9)(this.accumulatedFirstMoment.map(_=>_.variable)),null!=this.accumulatedSecondMoment&&(0,u.B9)(this.accumulatedSecondMoment.map(_=>_.variable))}getWeights(){var _=this;return(0,e.Z)(function*(){const v=[..._.accumulatedFirstMoment,..._.accumulatedSecondMoment];return[yield _.saveIterations()].concat(v.map(M=>({name:M.originalName,tensor:M.variable})))})()}setWeights(_){var v=this;return(0,e.Z)(function*(){_=yield v.extractIterations(_),(0,u.lu)(()=>{v.accBeta1.assign((0,f.s)(v.beta1,v.iterations_+1)),v.accBeta2.assign((0,f.s)(v.beta2,v.iterations_+1))});const M=_.length/2,T=!1;v.accumulatedFirstMoment=_.slice(0,M).map(S=>({originalName:S.name,variable:S.tensor.variable(T)})),v.accumulatedSecondMoment=_.slice(M,2*M).map(S=>({originalName:S.name,variable:S.tensor.variable(T)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(_,v){return new _(v.learningRate,v.beta1,v.beta2,v.epsilon)}}},23771:(H,C,t)=>{"use strict";t.d(C,{D:()=>d});var e=t(15861),a=t(40687),u=t(12773),c=t(26989),h=t(87066),i=t(93530),f=t(60765),l=t(48737),o=t(48661),n=t(61191),s=t(23143),r=t(57075);class d extends r.g{static get className(){return"Adamax"}constructor(g,_,v,M=null,T=0){super(),this.learningRate=g,this.beta1=_,this.beta2=v,this.epsilon=M,this.decay=T,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,u.lu)(()=>{this.iteration=(0,o.i)(0).variable(),this.accBeta1=(0,o.i)(_).variable()}),null==M&&(this.epsilon=a.BV.backend.epsilon())}applyGradients(g){const _=Array.isArray(g)?g.map(v=>v.name):Object.keys(g);(0,u.lu)(()=>{const v=(0,n.l)(1,this.accBeta1),M=(0,i.h)(-this.learningRate,(0,h.I)((0,l.d)(this.iteration,this.decay),1));_.forEach((T,S)=>{const P=a.BV.registeredVariables[T],L=!1;null==this.accumulatedFirstMoment[S]&&(this.accumulatedFirstMoment[S]={originalName:`${T}/m`,variable:(0,s.P)(P).variable(L)}),null==this.accumulatedWeightedInfNorm[S]&&(this.accumulatedWeightedInfNorm[S]={originalName:`${T}/v`,variable:(0,s.P)(P).variable(L)});const N=Array.isArray(g)?g[S].tensor:g[T];if(null==N)return;const O=this.accumulatedFirstMoment[S].variable,b=this.accumulatedWeightedInfNorm[S].variable,E=(0,h.I)((0,l.d)(O,this.beta1),(0,l.d)(N,1-this.beta1)),$=(0,l.d)(b,this.beta2),W=(0,c.W)(N),Z=(0,f.g)($,W);O.assign(E),b.assign(Z);const X=(0,h.I)((0,l.d)((0,i.h)(M,v),(0,i.h)(E,(0,h.I)(Z,this.epsilon))),P);P.assign(X)}),this.iteration.assign((0,h.I)(this.iteration,1)),this.accBeta1.assign((0,l.d)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,u.B9)(this.accumulatedFirstMoment.map(g=>g.variable)),null!=this.accumulatedWeightedInfNorm&&(0,u.B9)(this.accumulatedWeightedInfNorm.map(g=>g.variable))}getWeights(){return(0,e.Z)(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(g){return(0,e.Z)(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(g,_){return new g(_.learningRate,_.beta1,_.beta2,_.epsilon,_.decay)}}},76680:(H,C,t)=>{"use strict";t.d(C,{r:()=>o});var e=t(15861),a=t(40687),u=t(12773),c=t(87066),h=t(48737),i=t(48661),f=t(23143),l=t(29115);class o extends l.D{static get className(){return"Momentum"}constructor(s,r,d=!1){super(s),this.learningRate=s,this.momentum=r,this.useNesterov=d,this.accumulations=[],this.m=(0,i.i)(this.momentum)}applyGradients(s){(Array.isArray(s)?s.map(d=>d.name):Object.keys(s)).forEach((d,p)=>{const g=a.BV.registeredVariables[d];null==this.accumulations[p]&&(this.accumulations[p]={originalName:`${d}/momentum`,variable:(0,u.lu)(()=>(0,f.P)(g).variable(!1))});const _=this.accumulations[p].variable,v=Array.isArray(s)?s[p].tensor:s[d];null!=v&&(0,u.lu)(()=>{let M;const T=(0,c.I)((0,h.d)(this.m,_),v);M=(0,c.I)((0,h.d)(this.c,this.useNesterov?(0,c.I)(v,(0,h.d)(T,this.m)):T),g),_.assign(T),g.assign(M)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,u.B9)(this.accumulations.map(s=>s.variable))}setMomentum(s){this.momentum=s}getWeights(){var s=this;return(0,e.Z)(function*(){return[yield s.saveIterations()].concat(s.accumulations.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(s){var r=this;return(0,e.Z)(function*(){s=yield r.extractIterations(s),r.accumulations=s.map(p=>({originalName:p.name,variable:p.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(s,r){return new s(r.learningRate,r.momentum,r.useNesterov)}}},57075:(H,C,t)=>{"use strict";t.d(C,{g:()=>i});var e=t(15861),a=t(12773),u=t(63537),c=t(48661),h=t(44807);class i extends h.Serializable{minimize(l,o=!1,n){const{value:s,grads:r}=this.computeGradients(l,n);if(null!=n){const d=n.map(p=>({name:p.name,tensor:r[p.name]}));this.applyGradients(d)}else this.applyGradients(r);return(0,a.B9)(r),o?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(l,o){return(0,u.pn)(l,o)}dispose(){null!=this.iterations_&&(0,a.B9)(this.iterations_)}saveIterations(){var l=this;return(0,e.Z)(function*(){return null==l.iterations_&&(l.iterations_=0),{name:"iter",tensor:(0,c.i)(l.iterations_,"int32")}})()}getWeights(){return(0,e.Z)(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(l){var o=this;return(0,e.Z)(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${o.getClassName()}`)})()}extractIterations(l){var o=this;return(0,e.Z)(function*(){return o.iterations_=(yield l[0].tensor.data())[0],l.slice(1)})()}}Object.defineProperty(i,Symbol.hasInstance,{value:f=>null!=f.minimize&&null!=f.computeGradients&&null!=f.applyGradients})},93529:(H,C,t)=>{"use strict";t.d(C,{e:()=>l});var e=t(71960),a=t(55328),u=t(46330),c=t(23771),h=t(76680),i=t(1051),f=t(29115);class l{static sgd(n){return new f.D(n)}static momentum(n,s,r=!1){return new h.r(n,s,r)}static rmsprop(n,s=.9,r=0,d=null,p=!1){return new i.g(n,s,r,d,p)}static adam(n=.001,s=.9,r=.999,d=null){return new u.a(n,s,r,d)}static adadelta(n=.001,s=.95,r=null){return new e.z(n,s,r)}static adamax(n=.002,s=.9,r=.999,d=null,p=0){return new c.D(n,s,r,d,p)}static adagrad(n,s=.1){return new a.H(n,s)}}},98754:(H,C,t)=>{"use strict";t.d(C,{V:()=>n});var e=t(71960),a=t(55328),u=t(46330),c=t(23771),h=t(76680),i=t(1051),f=t(29115),l=t(44807);const o=[e.z,a.H,u.a,c.D,h.r,i.g,f.D];function n(){for(const s of o)(0,l.registerClass)(s)}},1051:(H,C,t)=>{"use strict";t.d(C,{g:()=>r});var e=t(15861),a=t(40687),u=t(12773),c=t(87066),h=t(93530),i=t(48737),f=t(70930),l=t(7527),o=t(61191),n=t(23143),s=t(57075);class r extends s.g{static get className(){return"RMSProp"}constructor(p,g=.9,_=0,v=null,M=!1){if(super(),this.learningRate=p,this.decay=g,this.momentum=_,this.epsilon=v,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=M,null==v&&(this.epsilon=a.BV.backend.epsilon()),null==p)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(p){(Array.isArray(p)?p.map(_=>_.name):Object.keys(p)).forEach((_,v)=>{const M=a.BV.registeredVariables[_],T=!1;null==this.accumulatedMeanSquares[v]&&(this.accumulatedMeanSquares[v]={originalName:`${_}/rms`,variable:(0,u.lu)(()=>(0,n.P)(M).variable(T))}),null==this.accumulatedMoments[v]&&(this.accumulatedMoments[v]={originalName:`${_}/momentum`,variable:(0,u.lu)(()=>(0,n.P)(M).variable(T))}),null==this.accumulatedMeanGrads[v]&&this.centered&&(this.accumulatedMeanGrads[v]={originalName:`${_}/mg`,variable:(0,u.lu)(()=>(0,n.P)(M).variable(T))});const S=Array.isArray(p)?p[v].tensor:p[_];if(null==S)return;const P=this.accumulatedMeanSquares[v].variable,L=this.accumulatedMoments[v].variable;(0,u.lu)(()=>{const N=(0,c.I)((0,i.d)(P,this.decay),(0,i.d)((0,l.h)(S),1-this.decay));if(this.centered){const O=this.accumulatedMeanGrads[v].variable,b=(0,c.I)((0,i.d)(O,this.decay),(0,i.d)(S,1-this.decay)),E=(0,h.h)((0,i.d)(S,this.learningRate),(0,f._)((0,o.l)(N,(0,c.I)((0,l.h)(b),this.epsilon)))),$=(0,c.I)((0,i.d)(L,this.momentum),E);P.assign(N),O.assign(b),L.assign($);const W=(0,o.l)(M,$);M.assign(W)}else{const O=(0,c.I)((0,i.d)(P,this.decay),(0,i.d)((0,l.h)(S),1-this.decay)),b=(0,c.I)((0,i.d)(L,this.momentum),(0,h.h)((0,i.d)(S,this.learningRate),(0,f._)((0,c.I)(O,this.epsilon))));P.assign(O),L.assign(b);const E=(0,o.l)(M,b);M.assign(E)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,u.B9)(this.accumulatedMeanSquares.map(p=>p.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,u.B9)(this.accumulatedMeanGrads.map(p=>p.variable)),null!=this.accumulatedMoments&&(0,u.B9)(this.accumulatedMoments.map(p=>p.variable))}getWeights(){var p=this;return(0,e.Z)(function*(){const g=[...p.accumulatedMeanSquares,...p.accumulatedMoments];return p.centered&&g.push(...p.accumulatedMeanGrads),[yield p.saveIterations()].concat(g.map(_=>({name:_.originalName,tensor:_.variable})))})()}setWeights(p){var g=this;return(0,e.Z)(function*(){p=yield g.extractIterations(p);const _=g.centered?p.length/3:p.length/2,v=!1;g.accumulatedMeanSquares=p.slice(0,_).map(M=>({originalName:M.name,variable:M.tensor.variable(v)})),g.accumulatedMoments=p.slice(_,2*_).map(M=>({originalName:M.name,variable:M.tensor.variable(v)})),g.centered&&(g.accumulatedMeanGrads=p.slice(2*_,3*_).map(M=>({originalName:M.name,variable:M.tensor.variable(v)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(p,g){return new p(g.learningRate,g.decay,g.momentum,g.epsilon,g.centered)}}},29115:(H,C,t)=>{"use strict";t.d(C,{D:()=>l});var e=t(15861),a=t(40687),u=t(12773),c=t(87066),h=t(48737),i=t(48661),f=t(57075);class l extends f.g{static get className(){return"SGD"}constructor(n){super(),this.learningRate=n,this.setLearningRate(n)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,d)=>{const p=Array.isArray(n)?n[d].tensor:n[r];if(null==p)return;const g=a.BV.registeredVariables[r];(0,u.lu)(()=>{const _=(0,c.I)((0,h.d)(this.c,p),g);g.assign(_)})}),this.incrementIterations()}setLearningRate(n){this.learningRate=n,null!=this.c&&this.c.dispose(),this.c=(0,u.Cn)((0,i.i)(-n))}dispose(){this.c.dispose()}getWeights(){var n=this;return(0,e.Z)(function*(){return[yield n.saveIterations()]})()}setWeights(n){var s=this;return(0,e.Z)(function*(){if(0!==(n=yield s.extractIterations(n)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(n,s){return new n(s.learningRate)}}},94705:(H,C,t)=>{"use strict";function e(a){return a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array||a instanceof Uint8ClampedArray}t.d(C,{j:()=>e})},15545:(H,C,t)=>{"use strict";var e=t(26989),a=t(4296);(0,a.t3)().prototype.abs=function(){return this.throwIfDisposed(),(0,e.W)(this)};var u=t(91184);(0,a.t3)().prototype.acos=function(){return this.throwIfDisposed(),(0,u.K)(this)};var c=t(15622);(0,a.t3)().prototype.acosh=function(){return this.throwIfDisposed(),(0,c._)(this)};var h=t(87066);(0,a.t3)().prototype.add=function(wt){return this.throwIfDisposed(),(0,h.I)(this,wt)};var i=t(51862);(0,a.t3)().prototype.all=function(wt,xe){return this.throwIfDisposed(),(0,i.$)(this,wt,xe)};var f=t(40876);(0,a.t3)().prototype.any=function(wt,xe){return this.throwIfDisposed(),(0,f.Y)(this,wt,xe)};var l=t(45784);(0,a.t3)().prototype.argMax=function(wt){return this.throwIfDisposed(),(0,l.N)(this,wt)};var o=t(78340);(0,a.t3)().prototype.argMin=function(wt){return this.throwIfDisposed(),(0,o.v)(this,wt)};var n=t(25715),s=t(45359);(0,a.t3)().prototype.asScalar=function(){return this.throwIfDisposed(),(0,s.hu)(1===this.size,()=>"The array must have only 1 element."),(0,n.X)(this,[])};var r=t(3062);(0,a.t3)().prototype.asType=function(wt){return this.throwIfDisposed(),(0,r.p)(this,wt)},(0,a.t3)().prototype.as1D=function(){return this.throwIfDisposed(),(0,n.X)(this,[this.size])},(0,a.t3)().prototype.as2D=function(wt,xe){return this.throwIfDisposed(),(0,n.X)(this,[wt,xe])},(0,a.t3)().prototype.as3D=function(wt,xe,Ge){return this.throwIfDisposed(),(0,n.X)(this,[wt,xe,Ge])},(0,a.t3)().prototype.as4D=function(wt,xe,Ge,nn){return this.throwIfDisposed(),(0,n.X)(this,[wt,xe,Ge,nn])},(0,a.t3)().prototype.as5D=function(wt,xe,Ge,nn,En){return this.throwIfDisposed(),(0,n.X)(this,[wt,xe,Ge,nn,En])};var d=t(80586);(0,a.t3)().prototype.asin=function(){return this.throwIfDisposed(),(0,d.Z)(this)};var p=t(38355);(0,a.t3)().prototype.asinh=function(){return this.throwIfDisposed(),(0,p.V)(this)};var g=t(37881);(0,a.t3)().prototype.atan=function(){return this.throwIfDisposed(),(0,g.z)(this)};var _=t(25825);(0,a.t3)().prototype.atan2=function(wt){return this.throwIfDisposed(),(0,_.f)(this,wt)};var v=t(17932);(0,a.t3)().prototype.atanh=function(){return this.throwIfDisposed(),(0,v.C)(this)};var M=t(6903);(0,a.t3)().prototype.avgPool=function(wt,xe,Ge,nn){return this.throwIfDisposed(),(0,M.w)(this,wt,xe,Ge,nn)};var T=t(92782);(0,a.t3)().prototype.batchToSpaceND=function(wt,xe){return this.throwIfDisposed(),(0,T.E)(this,wt,xe)};var S=t(35307);(0,a.t3)().prototype.batchNorm=function(wt,xe,Ge,nn,En){return this.throwIfDisposed(),(0,S.t)(this,wt,xe,Ge,nn,En)};var P=t(90983);(0,a.t3)().prototype.broadcastTo=function(wt){return this.throwIfDisposed(),(0,P.U)(this,wt)},(0,a.t3)().prototype.cast=function(wt){return this.throwIfDisposed(),(0,r.p)(this,wt)};var L=t(39723);(0,a.t3)().prototype.ceil=function(){return this.throwIfDisposed(),(0,L.m)(this)};var N=t(46672);(0,a.t3)().prototype.clipByValue=function(wt,xe){return this.throwIfDisposed(),(0,N.i)(this,wt,xe)};var O=t(64111);(0,a.t3)().prototype.concat=function(wt,xe){return this.throwIfDisposed(),wt instanceof a.es&&(wt=[wt]),(0,O.z)([this,...wt],xe)};var b=t(28577);(0,a.t3)().prototype.conv1d=function(wt,xe,Ge,nn,En,Rn){return this.throwIfDisposed(),(0,b.P)(this,wt,xe,Ge,nn,En,Rn)};var E=t(98554);(0,a.t3)().prototype.conv2dTranspose=function(wt,xe,Ge,nn,En){return this.throwIfDisposed(),(0,E.b)(this,wt,xe,Ge,nn,En)};var $=t(84451);(0,a.t3)().prototype.conv2d=function(wt,xe,Ge,nn,En,Rn){return this.throwIfDisposed(),(0,$.T)(this,wt,xe,Ge,nn,En,Rn)};var W=t(19018);(0,a.t3)().prototype.cos=function(){return this.throwIfDisposed(),(0,W.m)(this)};var Z=t(63237);(0,a.t3)().prototype.cosh=function(){return this.throwIfDisposed(),(0,Z.f)(this)};var X=t(69267);(0,a.t3)().prototype.cumprod=function(wt,xe,Ge){return this.throwIfDisposed(),(0,X.$)(this,wt,xe,Ge)};var ut=t(67157);(0,a.t3)().prototype.cumsum=function(wt,xe,Ge){return this.throwIfDisposed(),(0,ut.z)(this,wt,xe,Ge)};var Dt=t(43961);(0,a.t3)().prototype.depthToSpace=function(wt,xe){return this.throwIfDisposed(),(0,Dt.n)(this,wt,xe)};var Y=t(51172);(0,a.t3)().prototype.depthwiseConv2d=function(wt,xe,Ge,nn,En,Rn){return this.throwIfDisposed(),(0,Y.B)(this,wt,xe,Ge,nn,En,Rn)};var ht=t(22395);(0,a.t3)().prototype.dilation2d=function(wt,xe,Ge,nn,En){return this.throwIfDisposed(),(0,ht.W)(this,wt,xe,Ge,nn,En)};var Pt=t(94373);(0,a.t3)().prototype.divNoNan=function(wt){return this.throwIfDisposed(),(0,Pt.N)(this,wt)};var pt=t(93530);(0,a.t3)().prototype.div=function(wt){return this.throwIfDisposed(),(0,pt.h)(this,wt)};var xt=t(55106);(0,a.t3)().prototype.dot=function(wt){return this.throwIfDisposed(),(0,xt.A)(this,wt)};var Nt=t(89529);(0,a.t3)().prototype.elu=function(){return this.throwIfDisposed(),(0,Nt.p)(this)};var Vt=t(34456);(0,a.t3)().prototype.equal=function(wt){return this.throwIfDisposed(),(0,Vt.D)(this,wt)};var Gt=t(14634);(0,a.t3)().prototype.erf=function(){return this.throwIfDisposed(),(0,Gt.q)(this)};var oe=t(74279);(0,a.t3)().prototype.euclideanNorm=function(wt,xe){return this.throwIfDisposed(),(0,oe.d)(this,wt,xe)};var Ee=t(5109);(0,a.t3)().prototype.exp=function(){return this.throwIfDisposed(),(0,Ee.Q)(this)};var Ie=t(77228);(0,a.t3)().prototype.expandDims=function(wt){return this.throwIfDisposed(),(0,Ie.d)(this,wt)};var ie=t(85748);(0,a.t3)().prototype.expm1=function(){return this.throwIfDisposed(),(0,ie.t)(this)};var Zt=t(79738);(0,a.t3)().prototype.fft=function(){return this.throwIfDisposed(),(0,Zt.k)(this)},(0,a.t3)().prototype.flatten=function(){return this.throwIfDisposed(),(0,n.X)(this,[this.size])};var ct=t(8208);(0,a.t3)().prototype.floor=function(){return this.throwIfDisposed(),(0,ct.G)(this)};var It=t(31030);(0,a.t3)().prototype.floorDiv=function(wt){return this.throwIfDisposed(),(0,It.q)(this,wt)};var Ut=t(16117);(0,a.t3)().prototype.gather=function(wt,xe,Ge){return this.throwIfDisposed(),(0,Ut.I)(this,wt,xe,Ge)};var q=t(49886);(0,a.t3)().prototype.greaterEqual=function(wt){return this.throwIfDisposed(),(0,q.b)(this,wt)};var K=t(54803);(0,a.t3)().prototype.greater=function(wt){return this.throwIfDisposed(),(0,K.p)(this,wt)};var j=t(40527);(0,a.t3)().prototype.ifft=function(){return this.throwIfDisposed(),(0,j.S)(this)};var at=t(76065);(0,a.t3)().prototype.irfft=function(){return this.throwIfDisposed(),(0,at.w)(this)};var dt=t(75622);(0,a.t3)().prototype.isFinite=function(){return this.throwIfDisposed(),(0,dt.x)(this)};var kt=t(48381);(0,a.t3)().prototype.isInf=function(){return this.throwIfDisposed(),(0,kt.U)(this)};var jt=t(6483);(0,a.t3)().prototype.isNaN=function(){return this.throwIfDisposed(),(0,jt.i)(this)};var Jt=t(59424);(0,a.t3)().prototype.leakyRelu=function(wt){return this.throwIfDisposed(),(0,Jt.h)(this,wt)};var ae=t(22223);(0,a.t3)().prototype.lessEqual=function(wt){return this.throwIfDisposed(),(0,ae.z)(this,wt)};var Re=t(82761);(0,a.t3)().prototype.less=function(wt){return this.throwIfDisposed(),(0,Re.d)(this,wt)};var Be=t(1523);(0,a.t3)().prototype.localResponseNormalization=function(wt,xe,Ge,nn){return this.throwIfDisposed(),(0,Be.G)(this,wt,xe,Ge,nn)};var Se=t(14034);(0,a.t3)().prototype.logSigmoid=function(){return this.throwIfDisposed(),(0,Se.e)(this)};var we=t(56455);(0,a.t3)().prototype.logSoftmax=function(wt){return this.throwIfDisposed(),(0,we.C)(this,wt)};var Ae=t(56735);(0,a.t3)().prototype.logSumExp=function(wt,xe){return this.throwIfDisposed(),(0,Ae.l)(this,wt,xe)};var Te=t(5919);(0,a.t3)().prototype.log=function(){return this.throwIfDisposed(),(0,Te.c)(this)};var Je=t(44088);(0,a.t3)().prototype.log1p=function(){return this.throwIfDisposed(),(0,Je.K)(this)};var tn=t(93080);(0,a.t3)().prototype.logicalAnd=function(wt){return this.throwIfDisposed(),(0,tn.H)(this,wt)};var On=t(36399);(0,a.t3)().prototype.logicalNot=function(){return this.throwIfDisposed(),(0,On.h)(this)};var mn=t(72693);(0,a.t3)().prototype.logicalOr=function(wt){return this.throwIfDisposed(),(0,mn.K)(this,wt)};var hn=t(44574);(0,a.t3)().prototype.logicalXor=function(wt){return this.throwIfDisposed(),(0,hn.e)(this,wt)};var Pn=t(15592);(0,a.t3)().prototype.matMul=function(wt,xe,Ge){return this.throwIfDisposed(),(0,Pn.O)(this,wt,xe,Ge)};var ns=t(12444);(0,a.t3)().prototype.maxPool=function(wt,xe,Ge,nn){return this.throwIfDisposed(),(0,ns._)(this,wt,xe,Ge,nn)};var Lt=t(33043);(0,a.t3)().prototype.max=function(wt,xe){return this.throwIfDisposed(),(0,Lt.F)(this,wt,xe)};var ee=t(60765);(0,a.t3)().prototype.maximum=function(wt){return this.throwIfDisposed(),(0,ee.g)(this,wt)};var re=t(69357);(0,a.t3)().prototype.mean=function(wt,xe){return this.throwIfDisposed(),(0,re.J)(this,wt,xe)};var Qt=t(69602);(0,a.t3)().prototype.min=function(wt,xe){return this.throwIfDisposed(),(0,Qt.V)(this,wt,xe)};var se=t(72684);(0,a.t3)().prototype.minimum=function(wt){return this.throwIfDisposed(),(0,se.L)(this,wt)};var Ue=t(84639);(0,a.t3)().prototype.mirrorPad=function(wt,xe){return this.throwIfDisposed(),(0,Ue.V)(this,wt,xe)};var We=t(71612);(0,a.t3)().prototype.mod=function(wt){return this.throwIfDisposed(),(0,We.w)(this,wt)};var rn=t(48737);(0,a.t3)().prototype.mul=function(wt){return this.throwIfDisposed(),(0,rn.d)(this,wt)};var yn=t(15048);(0,a.t3)().prototype.neg=function(){return this.throwIfDisposed(),(0,yn.W)(this)};var An=t(93717);(0,a.t3)().prototype.norm=function(wt,xe,Ge){return this.throwIfDisposed(),(0,An.K)(this,wt,xe,Ge)};var vn=t(23062);(0,a.t3)().prototype.notEqual=function(wt){return this.throwIfDisposed(),(0,vn.Q)(this,wt)};var en=t(5618);(0,a.t3)().prototype.oneHot=function(wt,xe=1,Ge=0){return this.throwIfDisposed(),(0,en.l)(this,wt,xe,Ge)};var dn=t(75034);(0,a.t3)().prototype.onesLike=function(){return this.throwIfDisposed(),(0,dn.J)(this)};var Mn=t(20404);(0,a.t3)().prototype.pad=function(wt,xe){return this.throwIfDisposed(),(0,Mn.v)(this,wt,xe)};var Ln=t(91640);(0,a.t3)().prototype.pool=function(wt,xe,Ge,nn,En,Rn){return this.throwIfDisposed(),(0,Ln.d)(this,wt,xe,Ge,nn,En,Rn)};var cs=t(82962);(0,a.t3)().prototype.pow=function(wt){return this.throwIfDisposed(),(0,cs.s)(this,wt)};var kn=t(71584);(0,a.t3)().prototype.prelu=function(wt){return this.throwIfDisposed(),(0,kn.A)(this,wt)};var wn=t(90794);(0,a.t3)().prototype.prod=function(wt,xe){return this.throwIfDisposed(),(0,wn.W)(this,wt,xe)};var ds=t(34831);(0,a.t3)().prototype.reciprocal=function(){return this.throwIfDisposed(),(0,ds.M)(this)};var ss=t(98586);(0,a.t3)().prototype.relu=function(){return this.throwIfDisposed(),(0,ss.U)(this)};var Os=t(64917);(0,a.t3)().prototype.relu6=function(){return this.throwIfDisposed(),(0,Os.b)(this)},(0,a.t3)().prototype.reshapeAs=function(wt){return this.throwIfDisposed(),(0,n.X)(this,wt.shape)},(0,a.t3)().prototype.reshape=function(wt){return this.throwIfDisposed(),(0,n.X)(this,wt)};var Ps=t(51353);(0,a.t3)().prototype.resizeBilinear=function(wt,xe,Ge){return this.throwIfDisposed(),(0,Ps.I)(this,wt,xe,Ge)};var Ms=t(87373);(0,a.t3)().prototype.resizeNearestNeighbor=function(wt,xe,Ge){return this.throwIfDisposed(),(0,Ms.j)(this,wt,xe,Ge)};var Ts=t(66825);(0,a.t3)().prototype.reverse=function(wt){return this.throwIfDisposed(),(0,Ts.G)(this,wt)};var ys=t(1638);(0,a.t3)().prototype.rfft=function(){return this.throwIfDisposed(),(0,ys.Q)(this)};var Gn=t(21974);(0,a.t3)().prototype.round=function(){return this.throwIfDisposed(),(0,Gn.N)(this)};var Rs=t(68893);(0,a.t3)().prototype.rsqrt=function(){return this.throwIfDisposed(),(0,Rs.b)(this)};var As=t(29614);(0,a.t3)().prototype.selu=function(){return this.throwIfDisposed(),(0,As.U)(this)};var Ss=t(36762);(0,a.t3)().prototype.separableConv2d=function(wt,xe,Ge,nn,En,Rn){return this.throwIfDisposed(),(0,Ss.U)(this,wt,xe,Ge,nn,En,Rn)};var bs=t(86139);(0,a.t3)().prototype.sigmoid=function(){return this.throwIfDisposed(),(0,bs.X)(this)};var $s=t(94058);(0,a.t3)().prototype.sign=function(){return this.throwIfDisposed(),(0,$s.X)(this)};var Bs=t(52438);(0,a.t3)().prototype.sin=function(){return this.throwIfDisposed(),(0,Bs.O)(this)};var Ls=t(319);(0,a.t3)().prototype.sinh=function(){return this.throwIfDisposed(),(0,Ls.R)(this)};var Hn=t(58317);(0,a.t3)().prototype.slice=function(wt,xe){return this.throwIfDisposed(),(0,Hn.t)(this,wt,xe)};var Yn=t(38683);(0,a.t3)().prototype.softmax=function(wt){return this.throwIfDisposed(),(0,Yn.X)(this,wt)};var hs=t(94487);(0,a.t3)().prototype.softplus=function(){return this.throwIfDisposed(),(0,hs.W)(this)};var Ns=t(89619);(0,a.t3)().prototype.spaceToBatchND=function(wt,xe){return this.throwIfDisposed(),(0,Ns.f)(this,wt,xe)};var Us=t(8874);(0,a.t3)().prototype.split=function(wt,xe){return this.throwIfDisposed(),(0,Us.V)(this,wt,xe)};var Ws=t(70930);(0,a.t3)().prototype.sqrt=function(){return this.throwIfDisposed(),(0,Ws._)(this)};var ks=t(7527);(0,a.t3)().prototype.square=function(){return this.throwIfDisposed(),(0,ks.h)(this)};var ws=t(99539);(0,a.t3)().prototype.squaredDifference=function(wt){return this.throwIfDisposed(),(0,ws.$)(this,wt)};var Fs=t(2494);(0,a.t3)().prototype.squeeze=function(wt){return this.throwIfDisposed(),(0,Fs.L)(this,wt)};var Ks=t(57958);(0,a.t3)().prototype.stack=function(wt,xe){this.throwIfDisposed();const Ge=wt instanceof a.es?[this,wt]:[this,...wt];return(0,Ks.k)(Ge,xe)};var Vs=t(26034);(0,a.t3)().prototype.step=function(wt){return this.throwIfDisposed(),(0,Vs.N)(this,wt)};var os=t(5367);(0,a.t3)().prototype.stridedSlice=function(wt,xe,Ge,nn,En,Rn,Js,fs){return this.throwIfDisposed(),(0,os.N)(this,wt,xe,Ge,nn,En,Rn,Js,fs)};var ps=t(61191);(0,a.t3)().prototype.sub=function(wt){return this.throwIfDisposed(),(0,ps.l)(this,wt)};var zs=t(69929);(0,a.t3)().prototype.sum=function(wt,xe){return this.throwIfDisposed(),(0,zs.S)(this,wt,xe)};var Gs=t(82500);(0,a.t3)().prototype.tan=function(){return this.throwIfDisposed(),(0,Gs.O)(this)};var Fn=t(25987);(0,a.t3)().prototype.tanh=function(){return this.throwIfDisposed(),(0,Fn.A)(this)};var Hs=t(42005);(0,a.t3)().prototype.tile=function(wt){return this.throwIfDisposed(),(0,Hs.G)(this,wt)},(0,a.t3)().prototype.toBool=function(){return this.throwIfDisposed(),(0,r.p)(this,"bool")},(0,a.t3)().prototype.toFloat=function(){return this.throwIfDisposed(),(0,r.p)(this,"float32")},(0,a.t3)().prototype.toInt=function(){return this.throwIfDisposed(),(0,r.p)(this,"int32")};var js=t(54927);(0,a.t3)().prototype.topk=function(wt,xe){return this.throwIfDisposed(),(0,js.h)(this,wt,xe)};var Xs=t(19194);(0,a.t3)().prototype.transpose=function(wt){return this.throwIfDisposed(),(0,Xs.p)(this,wt)};var rs=t(18130);(0,a.t3)().prototype.unique=function(wt){return this.throwIfDisposed(),(0,rs.T)(this,wt)};var Ys=t(47715);(0,a.t3)().prototype.unsortedSegmentSum=function(wt,xe){return this.throwIfDisposed(),(0,Ys.p)(this,wt,xe)};var Zs=t(92219);(0,a.t3)().prototype.unstack=function(wt){return this.throwIfDisposed(),(0,Zs.H)(this,wt)};var Qs=t(12190);(0,a.t3)().prototype.where=function(wt,xe){return this.throwIfDisposed(),(0,Qs.a)(wt,this,xe)};var Kn=t(23143);(0,a.t3)().prototype.zerosLike=function(){return this.throwIfDisposed(),(0,Kn.P)(this)}},15564:(H,C,t)=>{"use strict";var e=t(34251),a=t(3062),u=t(48737),c=t(26034);const h={kernelName:e.SYM,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,u.d)(gt,(0,c.N)((0,a.p)(vt,"float32"),-1))}}};var i=t(93530),f=t(15048),l=t(48661),o=t(70930),n=t(7527),s=t(61191);const r={kernelName:e.VGw,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>{const yt=(0,n.h)((0,a.p)(vt,"float32")),Kt=(0,o._)((0,s.l)((0,l.i)(1),yt));return(0,f.W)((0,i.h)(gt,Kt))}}}},d={kernelName:e.SpW,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>{const yt=(0,o._)((0,s.l)((0,n.h)((0,a.p)(vt,"float32")),1));return(0,i.h)(gt,yt)}}}};var p=t(93239),g=t(25715),_=t(69929);const v={kernelName:e.mm_,inputsToSave:["a","b"],gradFunc:(gt,St)=>{const[vt,yt]=St,Kt=p.assertAndGetBroadcastShape(vt.shape,yt.shape);return{a:()=>{let Ht=gt;const qt=p.getReductionAxes(vt.shape,Kt);return qt.length>0&&(Ht=(0,_.S)(Ht,qt)),(0,g.X)(Ht,vt.shape)},b:()=>{let Ht=gt;const qt=p.getReductionAxes(yt.shape,Kt);return qt.length>0&&(Ht=(0,_.S)(Ht,qt)),(0,g.X)(Ht,yt.shape)}}}},M={kernelName:e.Xze,saveAllInputs:!0,gradFunc:(gt,St)=>{const vt={};return St.forEach((yt,Kt)=>{vt[Kt]=()=>gt.clone()}),vt}};var T=t(23143);const S={kernelName:e.sJF,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,T.P)(vt)}}},P={kernelName:e.aJk,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,T.P)(vt)}}},L={kernelName:e.M2y,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,i.h)(gt,(0,o._)((0,s.l)((0,l.i)(1),(0,n.h)((0,a.p)(vt,"float32")))))}}};var N=t(87066);const O={kernelName:e.qw7,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>{const yt=(0,o._)((0,N.I)((0,l.i)(1),(0,n.h)((0,a.p)(vt,"float32"))));return(0,i.h)(gt,yt)}}}},b={kernelName:e.QCc,inputsToSave:["a","b"],gradFunc:(gt,St)=>{const[vt,yt]=St,Kt=(0,p.assertAndGetBroadcastShape)(vt.shape,yt.shape);return{a:()=>{const Ht=(0,N.I)((0,n.h)(vt),(0,n.h)(yt));let qt=(0,u.d)(gt,(0,i.h)(yt,Ht));const Ke=(0,p.getReductionAxes)(vt.shape,Kt);return Ke.length>0&&(qt=(0,_.S)(qt,Ke)),(0,g.X)(qt,vt.shape)},b:()=>{const Ht=(0,N.I)((0,n.h)(vt),(0,n.h)(yt));let qt=(0,f.W)((0,u.d)(gt,(0,i.h)(vt,Ht)));const Ke=(0,p.getReductionAxes)(yt.shape,Kt);return Ke.length>0&&(qt=(0,_.S)(qt,Ke)),(0,g.X)(qt,yt.shape)}}}},E={kernelName:e.jMg,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,i.h)(gt,(0,N.I)((0,n.h)((0,a.p)(vt,"float32")),1))}}},$={kernelName:e.Oyi,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,i.h)(gt,(0,s.l)((0,l.i)(1),(0,n.h)((0,a.p)(vt,"float32"))))}}};var W=t(40687),Z=t(1257),X=t(45359),ut=t(5551),Dt=t(44195);const ht=(0,Dt.op)({avgPool3dGrad_:function Y(gt,St,vt,yt,Kt,Xt){const ne=(0,Z._1)(gt,"dy","avgPool3dGrad"),Ht=(0,Z._1)(St,"input","avgPool3dGrad");let qt=ne,Ke=Ht,Xe=!1;4===Ht.rank&&(Xe=!0,qt=(0,g.X)(ne,[1,ne.shape[0],ne.shape[1],ne.shape[2],ne.shape[3]]),Ke=(0,g.X)(Ht,[1,Ht.shape[0],Ht.shape[1],Ht.shape[2],Ht.shape[3]])),X.hu(5===qt.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${qt.rank}.`),X.hu(5===Ke.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${Ke.rank}.`),(0,ut.m)("avgPool3dGrad",Kt,Xt);const ln=W.BV.runKernel(e.IMb,{dy:qt,input:Ke},{filterSize:vt,strides:yt,pad:Kt,dimRoundingMode:Xt});return Xe?(0,g.X)(ln,[ln.shape[1],ln.shape[2],ln.shape[3],ln.shape[4]]):ln}}),Pt={kernelName:e._k9,inputsToSave:["x"],gradFunc:(gt,St,vt)=>{const[yt]=St,{filterSize:Kt,strides:Xt,pad:ne,dimRoundingMode:Ht}=vt;return{x:()=>ht(gt,yt,Kt,Xt,ne,Ht)}}},xt=(0,Dt.op)({avgPoolGrad_:function pt(gt,St,vt,yt,Kt){const Xt=(0,Z._1)(gt,"dy","avgPoolGrad"),ne=(0,Z._1)(St,"input","avgPoolGrad");X.hu(ne.rank===Xt.rank,()=>`Rank of input (${ne.rank}) does not match rank of dy (${Xt.rank})`);let Ht=ne,qt=Xt,Ke=!1;3===ne.rank&&(Ke=!0,Ht=(0,g.X)(ne,[1,ne.shape[0],ne.shape[1],ne.shape[2]]),qt=(0,g.X)(Xt,[1,Xt.shape[0],Xt.shape[1],Xt.shape[2]])),X.hu(4===qt.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${qt.rank}.`),X.hu(4===Ht.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${Ht.rank}.`);const on=W.BV.runKernel(e.ROF,{dy:qt,input:Ht},{filterSize:vt,strides:yt,pad:Kt});return Ke?(0,g.X)(on,[on.shape[1],on.shape[2],on.shape[3]]):on}}),Nt={kernelName:e.JhU,inputsToSave:["x"],gradFunc:(gt,St,vt)=>{const[yt]=St,{filterSize:Kt,strides:Xt,pad:ne}=vt;return{x:()=>xt(gt,yt,Kt,Xt,ne)}}};var Vt=t(15592);const Gt={kernelName:e.XLW,inputsToSave:["a","b"],gradFunc:(gt,St,vt)=>{const[yt,Kt]=St,{transposeA:Xt,transposeB:ne}=vt;return Xt||ne?!Xt&&ne?{a:()=>(0,Vt.O)(gt,Kt,!1,!1),b:()=>(0,Vt.O)(gt,yt,!0,!1)}:Xt&&!ne?{a:()=>(0,Vt.O)(Kt,gt,!1,!0),b:()=>(0,Vt.O)(yt,gt,!1,!1)}:{a:()=>(0,Vt.O)(Kt,gt,!0,!0),b:()=>(0,Vt.O)(gt,yt,!0,!0)}:{a:()=>(0,Vt.O)(gt,Kt,!1,!0),b:()=>(0,Vt.O)(yt,gt,!0,!1)}}};var oe=t(89619);const Ee={kernelName:e.zws,gradFunc:(gt,St,vt)=>{const{blockShape:yt,crops:Kt}=vt;return{x:()=>(0,oe.f)(gt,yt,Kt)}}},Ie={kernelName:e.Ly9,gradFunc:(gt,St,vt)=>{const Kt=vt.inputShape,Xt=vt.shape,ne=Array.from(Xt);for(let qt=Kt.length-1;qt>=0;qt--)if(Kt[qt]===Xt[qt])ne[qt]=1;else if(1!==Kt[qt])throw new Error(`broadcastTo(): [${Kt}] cannot be broadcast to [${Xt}].`);const Ht=[];for(let qt=0;qt<ne.length;qt++)ne[qt]>1&&Ht.push(qt);return{x:()=>(0,_.S)(gt,Ht,!0)}}},ie={kernelName:e.RFZ,gradFunc:gt=>({x:()=>gt.clone()})},Zt={kernelName:e.gJX,gradFunc:gt=>({x:()=>(0,T.P)(gt)})};var ct=t(49886),It=t(22223),Ut=t(93080),q=t(12190);const K={kernelName:e.xnO,inputsToSave:["x"],gradFunc:(gt,St,vt)=>{const[yt]=St,{clipValueMin:Kt,clipValueMax:Xt}=vt;return{x:()=>(0,q.a)((0,Ut.H)((0,ct.b)(yt,Kt),(0,It.z)(yt,Xt)),gt,(0,T.P)(gt))}}},j={kernelName:e.yj2,inputsToSave:["x"],gradFunc:h.gradFunc};var at=t(8874);const dt={kernelName:e.Eh3,saveAllInputs:!0,gradFunc:(gt,St,vt)=>{const yt=St.map(qt=>qt.shape),{axis:Kt}=vt,Xt=(0,X.EC)(Kt,St[0].shape)[0],ne=yt.map(qt=>qt[Xt]);return(0,at.V)(gt,ne,Xt).map(qt=>()=>qt)}};var kt=t(10443),jt=t(95743);const Jt={kernelName:e.mhS,inputsToSave:["x","filter"],gradFunc:(gt,St,vt)=>{const[yt,Kt]=St,{dilations:Xt,strides:ne,pad:Ht,dataFormat:qt}=vt;return X.hu(ut.I0(Xt),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${Xt}'`),{x:()=>(0,jt._)(yt.shape,gt,Kt,ne,Ht,qt),filter:()=>(0,kt.p)(yt,gt,Kt.shape,ne,Ht,qt)}}};var ae=t(84451);const Re={kernelName:e.wm,inputsToSave:["dy","filter"],gradFunc:(gt,St,vt)=>{const[yt,Kt]=St,{strides:Xt,pad:ne,dataFormat:Ht,dimRoundingMode:qt}=vt;return{dy:()=>(0,ae.T)(gt,Kt,Xt,ne,Ht,1,qt),filter:()=>(0,kt.p)(gt,yt,Kt.shape,Xt,ne,Ht,qt)}}},Se=(0,Dt.op)({conv3DBackpropFilter_:function Be(gt,St,vt,yt,Kt){let Xt=gt;4===gt.rank&&(Xt=(0,g.X)(gt,[1,gt.shape[0],gt.shape[1],gt.shape[2],gt.shape[3]]));let ne=St;return 4===ne.rank&&(ne=(0,g.X)(St,[1,St.shape[0],St.shape[1],St.shape[2],St.shape[3]])),X.hu(5===Xt.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${Xt.shape}.`),X.hu(5===ne.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${ne.shape}.`),X.hu(5===vt.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${vt}.`),X.hu(Xt.shape[4]===vt[3],()=>`Error in conv3dDerFilter: depth of input ${Xt.shape[4]}) must match input depth in filter (${vt[3]}.`),X.hu(ne.shape[4]===vt[4],()=>`Error in conv3dDerFilter: depth of dy (${ne.shape[4]}) must match output depth for filter (${vt[4]}).`),W.BV.runKernel(e.o2y,{x:Xt,dy:ne},{strides:yt,pad:Kt,filterShape:vt})}});var we=t(37022);const Ae={kernelName:e.x12,inputsToSave:["x","filter"],gradFunc:(gt,St,vt)=>{const{dilations:yt,strides:Kt,pad:Xt}=vt;X.hu((0,ut.I0)(yt),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${yt}'`);const[ne,Ht]=St;return{x:()=>(0,we._)(ne.shape,gt,Ht,Kt,Xt),filter:()=>Se(ne,gt,Ht.shape,Kt,Xt)}}};var Te=t(52438);const Je={kernelName:e.mc4,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,u.d)((0,f.W)((0,Te.O)((0,a.p)(vt,"float32"))),gt)}}};var tn=t(319);const On={kernelName:e.TR1,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,u.d)((0,tn.R)((0,a.p)(vt,"float32")),gt)}}};var mn=t(30929),hn=t(67157),Pn=t(19194);const ns={kernelName:e.iHb,inputsToSave:["x"],gradFunc:(gt,St,vt)=>{const[yt]=St,{axis:Kt,exclusive:Xt,reverse:ne}=vt;return{x:()=>{const Ht=(0,mn.Q3)([Kt],yt.rank);let qt=(0,hn.z)(gt,Kt,Xt,!ne);return null!=Ht&&(qt=(0,Pn.p)(qt,Ht)),qt}}}};var Lt=t(366),ee=t(519);const re={kernelName:e.cie,inputsToSave:["x","filter"],gradFunc:(gt,St,vt)=>{const{dilations:yt,strides:Kt,pad:Xt,dimRoundingMode:ne}=vt,Ht=yt??[1,1];X.hu(ut.I0(Ht),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${Ht}'`);const[qt,Ke]=St;return X.hu(4===qt.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${qt.rank}.`),X.hu(4===Ke.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${Ke.rank}.`),X.hu(qt.shape[3]===Ke.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${qt.shape[3]}) must match the inChannels dimension in filter ${Ke.shape[2]}.`),X.hu(ut.jT(Kt,Ht),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${Kt} and dilations '${Ht}'.`),ut.m("depthwiseConv2d",Xt,ne),{x:()=>(0,ee.v)(qt.shape,gt,Ke,Kt,Xt,Ht,ne),filter:()=>(0,Lt.z)(qt,gt,Ke.shape,Kt,Xt,Ht,ne)}}},Qt={kernelName:e.p4S,inputsToSave:["x","filter"],gradFunc:(gt,St,vt)=>{const[yt,Kt]=St,Xt={x:yt,filter:Kt,dy:gt},ne={x:yt,filter:Kt,dy:gt};return{x:()=>W.BV.runKernel(e.ekb,Xt,vt),filter:()=>W.BV.runKernel(e.Vn9,ne,vt)}}},se={kernelName:e.SX0,outputsToSave:[!0],gradFunc:(gt,St)=>{const[vt]=St,yt={dy:gt,y:vt};return{x:()=>W.BV.runKernel(e.HEU,yt)}}};var Ue=t(5109);const We={kernelName:e.Omj,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St,yt=(0,u.d)((0,Ue.Q)((0,f.W)((0,n.h)(vt))),2/Math.sqrt(Math.PI));return{x:()=>(0,u.d)(gt,yt)}}},rn={kernelName:e.NEP,outputsToSave:[!0],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,u.d)(gt,vt)}}},yn={kernelName:e.YFo,inputsToSave:["input"],gradFunc:(gt,St)=>{const[vt]=St;return{input:()=>(0,g.X)(gt,vt.shape)}}},An={kernelName:e.Y0y,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,u.d)(gt,(0,Ue.Q)(vt))}}},vn={kernelName:e.OR,gradFunc:gt=>({x:()=>(0,T.P)(gt)})},en={kernelName:e.jeX,inputsToSave:["a","b"],gradFunc:(gt,St)=>{const[vt,yt]=St,Kt=(0,p.assertAndGetBroadcastShape)(vt.shape,yt.shape);return{a:()=>{const Ht=(0,i.h)(gt,(0,a.p)(yt,"float32")),qt=(0,p.getReductionAxes)(vt.shape,Kt);return qt.length>0?(0,g.X)((0,_.S)(Ht,qt),vt.shape):Ht},b:()=>{let Ht=(0,u.d)(gt,(0,a.p)(vt,"float32"));const qt=(0,p.getReductionAxes)(yt.shape,Kt);qt.length>0&&(Ht=(0,g.X)((0,_.S)(Ht,qt),yt.shape));const Ke=(0,n.h)(yt);return(0,f.W)((0,i.h)(Ht,(0,a.p)(Ke,"float32")))}}}};var dn=t(68893),Mn=t(42005);const Ln={kernelName:e.sHE,inputsToSave:["x","mean","variance","scale"],gradFunc:(gt,St,vt)=>{const{varianceEpsilon:yt}=vt,[Kt,Xt,ne,Ht]=St,qt=Ht??(0,l.i)(1),Ke=(0,p.getReductionAxes)(Xt.shape,Kt.shape),Xe=[];if(1===Xt.rank){for(let Dn=0;Dn<Kt.shape.length-1;++Dn)Xe.push(Kt.shape[Dn]);Xe.push(1)}const an=(0,s.l)(Kt,Xt),on=(0,u.d)(gt,qt),ln=(0,dn.b)((0,N.I)(ne,(0,l.i)(yt))),Sn=(0,u.d)((0,u.d)((0,u.d)(ln,ln),ln),(0,l.i)(-.5));return{x:()=>(0,g.X)((0,u.d)((0,u.d)(gt,1===Xt.rank?(0,Mn.G)((0,g.X)(ln,[1,1,1,Xt.shape[0]]),Xe):ln),qt),Kt.shape),mean:()=>{let Dn=(0,u.d)((0,u.d)(ln,(0,l.i)(-1)),on);return 1===Xt.rank&&(Dn=(0,_.S)(Dn,Ke)),(0,g.X)(Dn,Xt.shape)},variance:()=>{let Dn=(0,u.d)((0,u.d)(Sn,an),on);return 1===Xt.rank&&(Dn=(0,_.S)(Dn,Ke)),(0,g.X)(Dn,Xt.shape)},scale:()=>{const Dn=(0,u.d)(an,ln);let ls=(0,u.d)(gt,Dn);return 1===Xt.rank&&(ls=(0,_.S)(ls,Ke)),(0,g.X)(ls,Xt.shape)},offset:()=>{let Dn=gt;return 1===Xt.rank&&(Dn=(0,_.S)(Dn,Ke)),(0,g.X)(Dn,Xt.shape)}}}};var cs=t(57958),kn=t(47715);const wn={kernelName:e.qi_,inputsToSave:["x","indices"],gradFunc:(gt,St,vt)=>{const[yt,Kt]=St,{axis:Xt,batchDims:ne}=vt,Ht=(0,X.EC)(Xt,yt.shape)[0],qt=(Ke,Xe,an)=>()=>{const on=Ke.shape,ln=Xe.size,Sn=on.slice(0,Ht),Vn=Sn.length,$n=on.slice(Xt,on.length).slice(1),oo=$n.length,ro=ds(0,Vn),Io=ds(Vn+1,Vn+1+oo),Dn=ss([Sn,[ln],$n]),ls=(0,g.X)(an,Dn),or=(0,g.X)(Xe,[ln]),Oo=ss([[Vn],ro,Io]),rr=(0,Pn.p)(ls,Oo);let ao=(0,kn.p)(rr,or,Ke.shape[Ht]);const ar=(0,mn.LJ)(Oo);return ao=(0,Pn.p)(ao,ar),ao};if(1===ne){const Xe=yt.split(yt.shape[0],0);return{x:()=>(0,cs.k)(Xe.map((ln,Sn)=>qt(ln,Kt.slice(Sn,1),gt.slice(Sn,1))())).reshape(yt.shape),indices:()=>Kt}}return{x:qt(yt,Kt,gt),indices:()=>Kt}}};function ds(gt,St){const vt=[];for(let yt=gt;yt<St;++yt)vt.push(yt);return vt}function ss(gt){const St=[];for(let vt=0;vt<gt.length;++vt)for(let yt=0;yt<gt[vt].length;++yt)St.push(gt[vt][yt]);return St}const Os={kernelName:e.Acj,inputsToSave:["a","b"],gradFunc:(gt,St)=>{const[vt,yt]=St;return{a:()=>(0,T.P)(vt),b:()=>(0,T.P)(yt)}}},Ps={kernelName:e.iJz,gradFunc:gt=>({x:()=>(0,a.p)(gt,"float32")})},Ms={kernelName:e.avt,gradFunc:gt=>({x:()=>(0,T.P)(gt)})},Ts={kernelName:e.iWB,gradFunc:gt=>({x:()=>(0,T.P)(gt)})},ys={kernelName:e.r7n,gradFunc:gt=>({x:()=>(0,T.P)(gt)})};var Gn=t(54803);const Rs={kernelName:e.J$2,inputsToSave:["x"],gradFunc:(gt,St,vt)=>{const[yt]=St,{alpha:Kt}=vt,Xt=(0,Gn.p)(yt,0);return{x:()=>(0,q.a)(Xt,gt,(0,u.d)(gt,Kt))}}},As={kernelName:e.kU,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,i.h)(gt,(0,N.I)(vt,1))}}},Ss={kernelName:e.ZbH,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,i.h)(gt,(0,a.p)(vt,"float32"))}}},bs={kernelName:e.qCd,inputsToSave:[],outputsToSave:[!0],gradFunc:(gt,St,vt)=>{const[yt]=St,{axis:Kt}=vt;return{logits:()=>{const ne=(0,Ue.Q)(yt);return(0,s.l)(gt,(0,u.d)((0,_.S)(gt,Kt,!0),ne))}}}},Bs=(0,Dt.op)({localResponseNormalizationBackprop_:function $s(gt,St,vt,yt=5,Kt=1,Xt=1,ne=.5){return W.BV.runKernel(e.Hhh,{x:gt,y:St,dy:vt},{depthRadius:yt,bias:Kt,alpha:Xt,beta:ne})}}),Ls={kernelName:e.eZ0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(gt,St,vt)=>{const[yt,Kt]=St,{depthRadius:Xt,bias:ne,alpha:Ht,beta:qt}=vt;return{x:()=>Bs(yt,Kt,gt,Xt,ne,Ht,qt)}}};var Hn=t(34456);function Yn(gt,St,vt,yt){return St.rank<vt.rank&&(St=(0,g.X)(St,mn.rv(St.shape,yt))),gt.rank<vt.rank&&(gt=(0,g.X)(gt,mn.rv(gt.shape,yt))),{x:()=>(0,u.d)(gt,(0,a.p)((0,Hn.D)(vt,St),gt.dtype))}}const hs={kernelName:e.YoZ,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(gt,St,vt)=>{const yt=vt,{reductionIndices:Kt}=yt,Xt=St[0],qt=Yn(gt,St[1],Xt,X.EC(Kt,Xt.shape));return{x:()=>qt.x()}}};var Ns=t(82761);const Us={kernelName:e.BMI,inputsToSave:["a","b"],gradFunc:(gt,St)=>{const[vt,yt]=St;return{a:()=>(0,u.d)(gt,(0,a.p)((0,ct.b)(vt,yt),"float32")),b:()=>(0,u.d)(gt,(0,a.p)((0,Ns.d)(vt,yt),"float32"))}}},ks=(0,Dt.op)({maxPool3dGrad_:function Ws(gt,St,vt,yt,Kt,Xt,ne){const Ht=(0,Z._1)(gt,"dy","maxPool3dGrad"),qt=(0,Z._1)(St,"input","maxPool3dGrad"),Ke=(0,Z._1)(vt,"output","maxPool3dGrad");let Xe=Ht,an=qt,on=Ke,ln=!1;4===qt.rank&&(ln=!0,Xe=(0,g.X)(Ht,[1,Ht.shape[0],Ht.shape[1],Ht.shape[2],Ht.shape[3]]),an=(0,g.X)(qt,[1,qt.shape[0],qt.shape[1],qt.shape[2],qt.shape[3]]),on=(0,g.X)(Ke,[1,Ke.shape[0],Ke.shape[1],Ke.shape[2],Ke.shape[3]])),X.hu(5===Xe.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${Xe.rank}.`),X.hu(5===an.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${an.rank}.`),X.hu(5===on.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${on.rank}.`),(0,ut.m)("maxPool3dGrad",Xt,ne);const $n=W.BV.runKernel(e.OU7,{dy:Xe,input:an,output:on},{filterSize:yt,strides:Kt,pad:Xt,dimRoundingMode:ne});return ln?(0,g.X)($n,[$n.shape[1],$n.shape[2],$n.shape[3],$n.shape[4]]):$n}}),ws={kernelName:e.OAf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(gt,St,vt)=>{const[yt,Kt]=St,{filterSize:Xt,strides:ne,pad:Ht,dimRoundingMode:qt}=vt;return{x:()=>ks(gt,yt,Kt,Xt,ne,Ht,qt)}}},Ks=(0,Dt.op)({maxPoolGrad_:function Fs(gt,St,vt,yt,Kt,Xt,ne){const Ht=(0,Z._1)(gt,"dy","maxPoolGrad"),qt=(0,Z._1)(St,"input","maxPoolGrad"),Ke=(0,Z._1)(vt,"output","maxPoolGrad");return X.hu(qt.rank===Ht.rank,()=>`Rank of input (${qt.rank}) does not match rank of dy (${Ht.rank})`),X.hu(4===Ht.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${Ht.rank}.`),X.hu(4===qt.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${qt.rank}.`),ut.m("maxPoolGrad",Xt,ne),W.BV.runKernel(e.OV7,{dy:Ht,input:qt,output:Ke},{filterSize:yt,strides:Kt,pad:Xt,dimRoundingMode:ne})}}),Vs={kernelName:e.mTV,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(gt,St,vt)=>{const[yt,Kt]=St,{filterSize:Xt,strides:ne,pad:Ht}=vt;return{x:()=>Ks(gt,yt,Kt,Xt,ne,Ht)}}};var os=t(84968);const ps={kernelName:e.q2K,inputsToSave:["x"],gradFunc:(gt,St,vt)=>{const[yt]=St,{axis:Kt}=vt,Xt=X.EC(Kt,yt.shape),Ht=(0,mn.kz)(yt.shape,Xt)[1],qt=X.NA(Ht);return{x:()=>{const Xe=yt.shape.slice();Xt.forEach(ln=>{Xe[ln]=1});const an=(0,g.X)(gt,Xe);return(0,i.h)((0,u.d)(an,(0,os.i)(yt.shape,"float32")),qt)}}}},zs={kernelName:e.c17,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(gt,St,vt)=>{const yt=vt,{axis:Kt}=yt,[Xt,ne]=St,qt=Yn(gt,ne,Xt,X.EC(Kt,Xt.shape));return{x:()=>qt.x()}}},Gs={kernelName:e.q8u,inputsToSave:["a","b"],gradFunc:(gt,St)=>{const[vt,yt]=St;return{a:()=>(0,u.d)(gt,(0,a.p)((0,It.z)(vt,yt),"float32")),b:()=>(0,u.d)(gt,(0,a.p)((0,Gn.p)(vt,yt),"float32"))}}};var Fn=t(58317);const Hs={kernelName:e.jQs,inputsToSave:["x"],gradFunc:(gt,St,vt)=>{const yt=St[0],{paddings:Kt}=vt,Xt=Kt.map(ne=>ne[0]);return{x:()=>(0,Fn.t)(gt,Xt,yt.shape)}}};var js=t(8208);const Xs={kernelName:e.Vbg,inputsToSave:["a","b"],gradFunc:(gt,St)=>{const[vt,yt]=St,Kt=(0,p.assertAndGetBroadcastShape)(vt.shape,yt.shape);return{a:()=>{const Ht=(0,p.getReductionAxes)(vt.shape,Kt);return Ht.length>0?(0,g.X)((0,_.S)(gt,Ht),vt.shape):gt},b:()=>{const Ht=(0,u.d)(gt,(0,f.W)((0,js.G)((0,i.h)(vt,yt)))),qt=(0,p.getReductionAxes)(yt.shape,Kt);return qt.length>0?(0,g.X)((0,_.S)(Ht,qt),yt.shape):Ht}}}},rs={kernelName:e.wYn,inputsToSave:["a","b"],gradFunc:(gt,St)=>{const[vt,yt]=St,Kt=(0,p.assertAndGetBroadcastShape)(vt.shape,yt.shape);return{a:()=>{const Ht=(0,u.d)(gt,(0,a.p)(yt,"float32")),qt=(0,p.getReductionAxes)(vt.shape,Kt);return qt.length>0?(0,g.X)((0,_.S)(Ht,qt),vt.shape):Ht},b:()=>{const Ht=(0,u.d)(gt,(0,a.p)(vt,"float32")),qt=(0,p.getReductionAxes)(yt.shape,Kt);return qt.length>0?(0,g.X)((0,_.S)(Ht,qt),yt.shape):Ht}}}},Ys={kernelName:e.kuV,gradFunc:gt=>({x:()=>(0,f.W)(gt)})};var Zs=t(36467);const Qs={kernelName:e.we_,inputsToSave:["indices"],gradFunc:(gt,St)=>{const vt=St[0];return{indices:()=>(0,Zs.l)(vt.shape,"float32")}}},Kn={kernelName:e.qWM,gradFunc:gt=>({x:()=>(0,T.P)(gt)})};var wt=t(92219);const xe={kernelName:e.QiL,saveAllInputs:!0,gradFunc:(gt,St,vt)=>{const{axis:yt}=vt;return(0,wt.H)(gt,yt).map(Xt=>()=>Xt)}},Ge={kernelName:e.lyA,inputsToSave:["x"],gradFunc:(gt,St,vt)=>{const yt=St[0],{paddings:Kt}=vt,Xt=Kt.map(ne=>ne[0]);return{x:()=>(0,Fn.t)(gt,Xt,yt.shape)}}};var nn=t(5919),En=t(82962);const Rn={kernelName:e.pe_,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(gt,St)=>{const[vt,yt,Kt]=St,Xt=vt,ne=yt,Ht=p.assertAndGetBroadcastShape(Xt.shape,ne.shape);return{a:()=>{const Xe=(0,a.p)(ne,"float32");let an=(0,u.d)(gt,(0,u.d)(Xe,(0,En.s)(Xt,(0,s.l)(Xe,(0,l.i)(1)))));const on=p.getReductionAxes(Xt.shape,Ht);return on.length>0&&(an=(0,_.S)(an,on)),(0,g.X)(an,Xt.shape)},b:()=>{const Xe=(0,Gn.p)(Xt,0),an=(0,q.a)(Xe,(0,nn.c)(Xt),(0,T.P)(Xt));let on=(0,u.d)(gt,(0,u.d)(Kt,an));const ln=p.getReductionAxes(ne.shape,Ht);return ln.length>0&&(on=(0,_.S)(on,ln)),(0,g.X)(on,ne.shape)}}}},Js={kernelName:e.o0g,inputsToSave:["x","alpha"],gradFunc:(gt,St)=>{const[vt,yt]=St,Kt=(0,Gn.p)(vt,0);return{x:()=>(0,q.a)(Kt,gt,(0,u.d)(gt,yt)),alpha:()=>{let Xt=(0,q.a)(Kt,(0,T.P)(gt),(0,u.d)(gt,vt));const ne=(0,p.getReductionAxes)(yt.shape,gt.shape);return ne.length>0&&(Xt=(0,_.S)(Xt,ne)),(0,g.X)(Xt,yt.shape)}}}};var fs=t(69267);const So={kernelName:e.DlI,inputsToSave:["x"],gradFunc:(gt,St,vt)=>{const[yt]=St,{axis:Kt}=vt;let Xt=[];return Xt=null==Kt?yt.shape.map((ne,Ht)=>Ht):"number"==typeof Kt?[Kt]:Kt,{x:()=>function ho(gt,St,vt){const yt=gt.shape.length,Kt=yt-vt.length,Xt=mn.Q3(vt,yt);let ne=gt;null!=Xt&&(ne=(0,Pn.p)(gt,Xt));const Ht=ne.shape.slice(),Ke=Ht.splice(yt-vt.length,vt.length).reduce((on,ln)=>on*ln,1);Ht.push(Ke);let an=function Ao(gt,St,vt){const yt=gt.shape.slice();yt[vt]=1;const Kt=(0,g.X)(St,yt),Xt=(0,fs.$)(gt,vt,!0,!1),ne=(0,fs.$)(gt,vt,!0,!0),Ht=(0,u.d)(Xt,ne);return(0,u.d)(Kt,Ht)}(ne.reshape(Ht),St,Kt);if(an=an.reshape(ne.shape),null!=Xt){const on=mn.LJ(Xt);an=(0,Pn.p)(an,on)}return an}(yt,gt,Xt)}}},dr={kernelName:e.oHH,inputsToSave:["a","b"],gradFunc:(gt,St)=>{const[vt,yt]=St,Kt=p.assertAndGetBroadcastShape(vt.shape,yt.shape);return{a:()=>{const Ht=(0,i.h)(gt,(0,a.p)(yt,"float32")),qt=p.getReductionAxes(vt.shape,Kt);return qt.length>0?(0,g.X)((0,_.S)(Ht,qt),vt.shape):Ht},b:()=>{let Ht=(0,u.d)(gt,(0,a.p)(vt,"float32"));const qt=p.getReductionAxes(yt.shape,Kt);qt.length>0&&(Ht=(0,g.X)((0,_.S)(Ht,qt),yt.shape));const Ke=(0,n.h)(yt);return(0,f.W)((0,i.h)(Ht,(0,a.p)(Ke,"float32")))}}}},po={kernelName:e.$HU,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,i.h)(gt,(0,f.W)((0,n.h)(vt)))}}},bo={kernelName:e.SbG,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St,yt=(0,u.d)((0,It.z)(vt,6),(0,c.N)(vt));return{x:()=>(0,u.d)(gt,(0,a.p)(yt,"float32"))}}},as={kernelName:e.qkr,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,u.d)(gt,(0,a.p)((0,c.N)(vt),"float32"))}}},$o={kernelName:e.HZH,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,g.X)(gt,vt.shape)}}},Bo={kernelName:e._Yw,inputsToSave:["images"],gradFunc:(gt,St,vt)=>{const[yt]=St,Kt={dy:gt,images:yt};return{images:()=>W.BV.runKernel(e.zbQ,Kt,vt)}}},Lo={kernelName:e.dpD,inputsToSave:["images"],gradFunc:(gt,St,vt)=>{const[yt]=St,Kt={dy:gt,images:yt};return{images:()=>W.BV.runKernel(e.Hmb,Kt,vt)}}};var ms=t(66825);const gs={kernelName:e.mKl,gradFunc:(gt,St,vt)=>{const{dims:yt}=vt,Kt=(0,X.EC)(yt,gt.shape);return{x:()=>(0,ms.G)(gt,Kt)}}},fo={kernelName:e.e07,gradFunc:gt=>({x:()=>(0,T.P)(gt)})},No={kernelName:e.bV0,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,f.W)((0,i.h)(gt,(0,u.d)((0,En.s)(vt,1.5),2)))}}};var Uo=t(36399);const qs={kernelName:e.PhF,inputsToSave:["condition"],gradFunc:(gt,St)=>{const[vt]=St;return{condition:()=>(0,a.p)((0,T.P)(vt),"float32"),t:()=>(0,u.d)(gt,(0,a.p)(vt,gt.dtype)),e:()=>(0,u.d)(gt,(0,a.p)((0,Uo.h)(vt),gt.dtype))}}};var _s=t(42152);const to={kernelName:e.oFR,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>{const yt=(0,Gn.p)(vt,(0,l.i)(0)),Kt=(0,l.i)(_s.y),Xt=(0,l.i)(_s.$),ne=(0,u.d)(gt,Xt),Ht=(0,u.d)((0,u.d)(gt,Kt),(0,Ue.Q)((0,a.p)(vt,"float32")));return(0,q.a)(yt,ne,Ht)}}}},mo={kernelName:e.a5O,outputsToSave:[!0],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,u.d)(gt,(0,u.d)(vt,(0,s.l)((0,l.i)(1),vt)))}}},Wo={kernelName:e.i5y,gradFunc:gt=>({x:()=>(0,T.P)(gt)})};var eo=t(19018);const no={kernelName:e.RQH,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,u.d)((0,eo.m)((0,a.p)(vt,"float32")),gt)}}};var ko=t(63237);const wo={kernelName:e.wYB,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,u.d)((0,ko.f)((0,a.p)(vt,"float32")),gt)}}};var Fo=t(20404),Zn=t(22320);const Es={kernelName:e.p2w,inputsToSave:["x"],gradFunc:(gt,St,vt)=>{const[yt]=St,{begin:Kt,size:Xt}=vt,ne=yt.shape,[Ht,qt]=(0,Zn.parseSliceParams)(yt,Kt,Xt),Ke=[];for(let Xe=0;Xe<gt.rank;Xe++)Ke.push([Ht[Xe],ne[Xe]-Ht[Xe]-qt[Xe]]);return{x:()=>(0,Fo.v)(gt,Ke)}}},Ko={kernelName:e.Gcp,outputsToSave:[!0],gradFunc:(gt,St,vt)=>{const[yt]=St,{dim:Kt}=vt,ne=(0,u.d)(gt,yt);return{logits:()=>(0,s.l)(ne,(0,u.d)((0,_.S)(ne,[Kt],!0),yt))}}};var is=t(86139);const Vo={kernelName:e.MRv,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,u.d)(gt,(0,is.X)(vt))}}};var go=t(92782);const _o={kernelName:e.TQc,gradFunc:(gt,St,vt)=>{const{blockShape:yt,paddings:Kt}=vt;return{x:()=>(0,go.E)(gt,yt,Kt)}}};var Eo=t(64111);const xo={kernelName:e.L8s,gradFunc:(gt,St,vt)=>{const{axis:yt}=vt;return{x:()=>(0,Eo.z)(gt,yt)}}},Do={kernelName:e.FKq,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,i.h)(gt,(0,u.d)((0,o._)((0,a.p)(vt,"float32")),2))}}},so={kernelName:e.bK0,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,u.d)(gt,(0,u.d)((0,a.p)(vt,"float32"),2))}}},zo={kernelName:e._tC,inputsToSave:["a","b"],gradFunc:(gt,St)=>{const[vt,yt]=St,Kt=(0,l.i)(2);return{a:()=>(0,u.d)(gt,(0,u.d)(Kt,(0,s.l)(vt,yt))),b:()=>(0,u.d)(gt,(0,u.d)(Kt,(0,s.l)(yt,vt)))}}},xs={kernelName:e.h8e,gradFunc:gt=>({x:()=>(0,T.P)(gt)})},vo={kernelName:e.Tr8,inputsToSave:["a","b"],gradFunc:(gt,St)=>{const[vt,yt]=St,Kt=p.assertAndGetBroadcastShape(vt.shape,yt.shape);return{a:()=>{let Ht=gt;const qt=p.getReductionAxes(vt.shape,Kt);return qt.length>0&&(Ht=(0,_.S)(Ht,qt)),(0,g.X)(Ht,vt.shape)},b:()=>{let Ht=gt;const qt=p.getReductionAxes(yt.shape,Kt);return qt.length>0&&(Ht=(0,_.S)(Ht,qt)),(0,g.X)((0,f.W)(Ht),yt.shape)}}}},Co={kernelName:e.GBy,inputsToSave:["x"],gradFunc:(gt,St,vt)=>{const[yt]=St,Kt=yt.shape.slice(),{axis:Xt}=vt;(0,X.EC)(Xt,yt.shape).forEach(Ke=>{Kt[Ke]=1});const Ht=(0,g.X)(gt,Kt),qt=(0,u.d)(Ht,(0,os.i)(yt.shape,"float32"));return{x:()=>qt}}},Go={kernelName:e.sEM,inputsToSave:["x"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,i.h)(gt,(0,n.h)((0,eo.m)(vt)))}}},Ho={kernelName:e.MIZ,outputsToSave:[!0],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>(0,u.d)((0,s.l)((0,l.i)(1),(0,n.h)(vt)),gt)}}},jo={kernelName:e.n9L,inputsToSave:["x"],gradFunc:(gt,St,vt)=>{const[yt]=St,{reps:Kt}=vt;return{x:()=>{let ne=(0,T.P)(yt);if(1===yt.rank)for(let Ht=0;Ht<Kt[0];++Ht)ne=(0,N.I)(ne,(0,Fn.t)(gt,[Ht*yt.shape[0]],[yt.shape[0]]));else if(2===yt.rank)for(let Ht=0;Ht<Kt[0];++Ht)for(let qt=0;qt<Kt[1];++qt)ne=(0,N.I)(ne,(0,Fn.t)(gt,[Ht*yt.shape[0],qt*yt.shape[1]],[yt.shape[0],yt.shape[1]]));else if(3===yt.rank)for(let Ht=0;Ht<Kt[0];++Ht)for(let qt=0;qt<Kt[1];++qt)for(let Ke=0;Ke<Kt[2];++Ke)ne=(0,N.I)(ne,(0,Fn.t)(gt,[Ht*yt.shape[0],qt*yt.shape[1],Ke*yt.shape[2]],[yt.shape[0],yt.shape[1],yt.shape[2]]));else{if(4!==yt.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${yt.rank} tensors yet.`);for(let Ht=0;Ht<Kt[0];++Ht)for(let qt=0;qt<Kt[1];++qt)for(let Ke=0;Ke<Kt[2];++Ke)for(let Xe=0;Xe<Kt[3];++Xe)ne=(0,N.I)(ne,(0,Fn.t)(gt,[Ht*yt.shape[0],qt*yt.shape[1],Ke*yt.shape[2],Xe*yt.shape[3]],[yt.shape[0],yt.shape[1],yt.shape[2],yt.shape[3]]))}return ne}}}},Xo={kernelName:e.G3Y,gradFunc:(gt,St,vt)=>{const yt=vt,{perm:Kt}=yt,Xt=mn.LJ(Kt);return{x:()=>(0,Pn.p)(gt,Xt)}}},Yo={kernelName:e.ToN,gradFunc:(gt,St,vt)=>{const yt=vt,{axis:Kt}=yt;return{value:()=>(0,cs.k)(gt,Kt)}}};var Zo=t(77228),Qo=t(16117),Jo=t(60765);const qo={kernelName:e.Qvg,inputsToSave:["segmentIds"],gradFunc:(gt,St)=>{const[vt]=St;return{x:()=>function tr(gt,St){const vt=(0,Jo.g)(St,(0,T.P)(St)),yt=(0,Qo.I)(gt,vt);let Kt=(0,ct.b)(St,(0,l.i)(0,"int32"));const Xt=yt.rank-Kt.rank;for(let Ht=0;Ht<Xt;++Ht)Kt=(0,Zo.d)(Kt,Ht+1);Kt=(0,Ut.H)(Kt,(0,os.i)(yt.shape,"bool"));const ne=(0,T.P)(yt);return(0,q.a)(Kt,yt,ne)}(gt,vt)}}},er={kernelName:e.RuY,gradFunc:gt=>({x:()=>(0,T.P)(gt)})};var nr=t(8987);const sr=[h,r,d,v,M,S,P,L,O,b,E,$,Pt,Nt,Gt,Ee,Ie,ie,Zt,K,j,dt,Re,Jt,Ae,Je,On,ns,re,Qt,dr,se,We,rn,yn,An,en,vn,Ln,wn,Os,Ps,Ms,Ts,ys,Rs,As,Ss,bs,Ls,hs,hs,Us,ws,Vs,ps,zs,Gs,Hs,Xs,rs,Ys,Qs,Kn,xe,Ge,Ge,Rn,Js,So,po,bo,as,$o,Bo,Lo,gs,fo,No,qs,to,mo,Wo,no,wo,Es,Ko,Vo,_o,_o,xo,xo,Do,zo,so,xs,vo,Co,Go,Ho,jo,Xo,Yo,qo,er];for(const gt of sr)(0,nr.Li)(gt)},44807:(H,C,t)=>{"use strict";t.r(C),t.d(C,{Serializable:()=>c,SerializationMap:()=>h,getRegisteredName:()=>f,registerClass:()=>i});var e=t(45359);const a=new Map,u=new Map;class c{getClassName(){return this.constructor.className}static fromConfig(o,n){return new o(n)}}class h{constructor(){this.classNameMap={}}static getMap(){return null==h.instance&&(h.instance=new h),h.instance}static register(o){h.getMap().classNameMap[o.className]=[o,o.fromConfig]}}function i(l,o,n){(0,e.hu)(null!=l.className,()=>"Class being registered does not have the static className property defined."),(0,e.hu)("string"==typeof l.className,()=>"className is required to be a string, but got type "+typeof l.className),(0,e.hu)(l.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof o>"u"&&(o="Custom"),typeof n>"u"&&(n=l.className);const r=o+">"+n;return h.register(l),a.set(r,l),u.set(l,r),l}function f(l){return u.has(l)?u.get(l):l.className}},58047:(H,C,t)=>{"use strict";t.d(C,{H:()=>h});var e=t(45359);const a=20,u=3,c=7;function h(s,r,d,p){const g=(0,e.e3)(r),_=function i(s,r,d,p){const g=(0,e.NA)(r),_=p[p.length-1],v=new Array(_).fill(0),M=r.length,T="complex64"===d?n(s):s;if(M>1)for(let S=0;S<g/_;S++){const P=S*_;for(let L=0;L<_;L++)v[L]=Math.max(v[L],f(T[P+L],0,d).length)}return v}(s,r,d,g),v=r.length,M=o(s,r,d,g,_),T=["Tensor"];return p&&(T.push(`  dtype: ${d}`),T.push(`  rank: ${v}`),T.push(`  shape: [${r}]`),T.push("  values:")),T.push(M.map(S=>"    "+S).join("\n")),T.join("\n")}function f(s,r,d){let p;return p=Array.isArray(s)?`${parseFloat(s[0].toFixed(c))} + ${parseFloat(s[1].toFixed(c))}j`:(0,e.HD)(s)?`'${s}'`:"bool"===d?l(s):parseFloat(s.toFixed(c)).toString(),(0,e.oj)(p,r)}function l(s){return 0===s?"false":"true"}function o(s,r,d,p,g,_=!0){const v="complex64"===d?2:1,M=r[0],T=r.length;if(0===T)return"complex64"===d?[f(n(s)[0],0,d)]:"bool"===d?[l(s[0])]:[s[0].toString()];if(1===T){if(M>a){let W=Array.from(s.slice(0,u*v)),Z=Array.from(s.slice((M-u)*v,M*v));return"complex64"===d&&(W=n(W),Z=n(Z)),["["+W.map((X,ut)=>f(X,g[ut],d)).join(", ")+", ..., "+Z.map((X,ut)=>f(X,g[M-u+ut],d)).join(", ")+"]"]}return["["+("complex64"===d?n(s):Array.from(s)).map(($,W)=>f($,g[W],d)).join(", ")+"]"]}const S=r.slice(1),P=p.slice(1),L=p[0]*v,N=[];if(M>a){for(let E=0;E<u;E++){const $=E*L;N.push(...o(s.slice($,$+L),S,d,P,g,!1))}N.push("...");for(let E=M-u;E<M;E++){const $=E*L;N.push(...o(s.slice($,$+L),S,d,P,g,E===M-1))}}else for(let E=0;E<M;E++){const $=E*L;N.push(...o(s.slice($,$+L),S,d,P,g,E===M-1))}const O=2===T?",":"";N[0]="["+(M>0?N[0]+O:"");for(let E=1;E<N.length-1;E++)N[E]=" "+N[E]+O;let b=",\n";for(let E=2;E<T;E++)b+="\n";return N[N.length-1]=" "+N[N.length-1]+"]"+(_?"":b),N}function n(s){const r=[];for(let d=0;d<s.length;d+=2)r.push([s[d],s[d+1]]);return r}},1257:(H,C,t)=>{"use strict";t.d(C,{C:()=>f,_1:()=>n,sI:()=>s});var e=t(40687),a=t(5527),u=t(4296),c=t(1216),h=t(49823),i=t(45359);function f(r,d){let p=r;if((0,h.isTypedArray)(r))return"string"===d?[]:[r.length];if((0,c.Oq)(r))return[r.height,r.width*(r.channels||"RGBA").length];if((0,c.$F)(r))return[r.buffer.size/(null==d?4:(0,i.bT)(d))];if(!Array.isArray(r))return[];const g=[];for(;Array.isArray(p)||(0,h.isTypedArray)(p)&&"string"!==d;)g.push(p.length),p=p[0];return Array.isArray(r)&&(0,a.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&l(r,g,[]),g}function l(r,d,p){if(p=p||[],!Array.isArray(r)&&!(0,h.isTypedArray)(r))return void(0,i.hu)(0===d.length,()=>`Element arr[${p.join("][")}] is a primitive, but should be an array/TypedArray of ${d[0]} elements`);(0,i.hu)(d.length>0,()=>`Element arr[${p.join("][")}] should be a primitive, but is an array of ${r.length} elements`),(0,i.hu)(r.length===d[0],()=>`Element arr[${p.join("][")}] should have ${d[0]} elements, but has ${r.length} elements`);const g=d.slice(1);for(let _=0;_<r.length;++_)l(r[_],g,p.concat(_))}function o(r,d,p,g){if("string_or_numeric"!==r){if(null==r)throw new Error("Expected dtype cannot be null.");if("numeric"!==r&&r!==d||"numeric"===r&&"string"===d)throw new Error(`Argument '${p}' passed to '${g}' must be ${r} tensor, but got ${d} tensor`)}}function n(r,d,p,g="numeric"){if(r instanceof(0,u.t3)())return o(g,r.dtype,d,p),r;let _=(0,i.D2)(r);if("string"!==_&&["bool","int32","float32"].indexOf(g)>=0&&(_=g),o(g,_,d,p),null==r||!(0,h.isTypedArray)(r)&&!Array.isArray(r)&&"number"!=typeof r&&"boolean"!=typeof r&&"string"!=typeof r)throw new Error(`Argument '${d}' passed to '${p}' must be a Tensor or TensorLike, but got '${null==r?"null":r.constructor.name}'`);const v=f(r,_);!(0,h.isTypedArray)(r)&&!Array.isArray(r)&&(r=[r]);const T="string"!==_?(0,h.toTypedArray)(r,_):(0,h.flatten)(r,[],!0);return e.BV.makeTensor(T,v,_)}function s(r,d,p,g="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${d} passed to ${p} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((v,M)=>n(v,`${d}[${M}]`,p,g))}},57304:(H,C,t)=>{"use strict";t.d(C,{p:()=>a});const a=t(93529).e},45359:(H,C,t)=>{"use strict";function e(q){let K=q.length,j=0;for(;K>0;)j=Math.random()*K|0,K--,h(q,K,j)}function a(q,K){if(q.length!==K.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${q.length}Second array length was ${K.length}`);let j=q.length,at=0;for(;j>0;)at=Math.random()*j|0,j--,h(q,j,at),h(K,j,at)}function u(q,K,j){return Math.max(q,Math.min(K,j))}function c(q){return q%2==0?q:q+1}function h(q,K,j){const at=q[K];q[K]=q[j],q[j]=at}function i(q){let K=0;for(let j=0;j<q.length;j++)K+=q[j];return K}function f(q,K){const j=Math.random();return K*j+(1-j)*q}function l(q,K){let j=0;for(let at=0;at<q.length;at++){const dt=Number(q[at])-Number(K[at]);j+=dt*dt}return j}function o(q,K){if(!q)throw new Error("string"==typeof K?K:K())}function n(q,K,j=""){o(g(q,K),()=>j+` Shapes ${q} and ${K} must match`)}function s(q){o(null!=q,()=>"The input to the tensor constructor must be a non-null value.")}function r(q){if(0===q.length)return 1;let K=q[0];for(let j=1;j<q.length;j++)K*=q[j];return K}function d(q){return 0===q.length}function p(q,K){if(q===K)return!0;if(null==q||null==K||q.length!==K.length)return!1;for(let j=0;j<q.length;j++)if(null!==q[j]&&null!==K[j]&&q[j]!==K[j])return!1;return!0}function g(q,K){if(q===K)return!0;if(null==q||null==K||q.length!==K.length)return!1;for(let j=0;j<q.length;j++)if(q[j]!==K[j])return!1;return!0}function _(q){return q%1==0}function v(q){if(null!=Math.tanh)return Math.tanh(q);if(q===1/0)return 1;if(q===-1/0)return-1;{const K=Math.exp(2*q);return(K-1)/(K+1)}}function M(q){const K=Math.ceil(Math.sqrt(q));return[K,Math.ceil(q/K)]}function T(q){const K=new Uint32Array(q);for(let j=0;j<q;++j)K[j]=j;return e(K),K}function S(q,K){return K<=q.length?q:q+" ".repeat(K-q.length)}function P(q,K=dt=>0,j,at){return new Promise((dt,kt)=>{let jt=0;const Jt=()=>{if(q())return void dt();jt++;const ae=K(jt);null!=j&&jt>=j?kt():null!=at?at(Jt,ae):setTimeout(Jt,ae)};Jt()})}function L(q,K){let j=1,at=-1;for(let kt=0;kt<q.length;++kt)if(q[kt]>=0)j*=q[kt];else if(-1===q[kt]){if(-1!==at)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${at} and dim ${kt}`);at=kt}else if(q[kt]<0)throw Error(`Shapes can not be < 0. Found ${q[kt]} at dim ${kt}`);if(-1===at){if(K>0&&K!==j)throw Error(`Size(${K}) must match the product of shape ${q}`);return q}if(0===j)throw Error(`Cannot infer the missing size in [${q}] when there are 0 elements`);if(K%j!=0)throw Error(`The implicit shape can't be a fractional number. Got ${K} / ${j}`);const dt=q.slice();return dt[at]=K/j,dt}function N(q,K){const j=K.length;return o((q=null==q?K.map((at,dt)=>dt):[].concat(q)).every(at=>at>=-j&&at<j),()=>`All values in axis param must be in range [-${j}, ${j}) but got axis ${q}`),o(q.every(at=>_(at)),()=>`All values in axis param must be integers but got axis ${q}`),q.map(at=>at<0?j+at:at)}function O(q,K){const j=[],at=[],dt=null!=K&&Array.isArray(K)&&0===K.length,kt=null==K||dt?null:N(K,q).sort();let jt=0;for(let Jt=0;Jt<q.length;++Jt){if(null!=kt){if(kt[jt]===Jt&&1!==q[Jt])throw new Error(`Can't squeeze axis ${Jt} since its dim '${q[Jt]}' is not 1`);(null==kt[jt]||kt[jt]>Jt)&&1===q[Jt]&&(j.push(q[Jt]),at.push(Jt)),kt[jt]<=Jt&&jt++}1!==q[Jt]&&(j.push(q[Jt]),at.push(Jt))}return{newShape:j,keptDims:at}}function b(q,K){return E(q,K)}function E(q,K){let j=null;if(null==q||"float32"===q)j=new Float32Array(K);else if("int32"===q)j=new Int32Array(K);else if("bool"===q)j=new Uint8Array(K);else{if("string"!==q)throw new Error(`Unknown data type ${q}`);j=new Array(K)}return j}function $(q,K){for(let j=0;j<q.length;j++){const at=q[j];if(isNaN(at)||!isFinite(at))throw Error(`A tensor of type ${K} being uploaded contains ${at}.`)}}function W(q){return"bool"===q||"complex64"===q||"float32"===q||"int32"===q||"string"===q}function Z(q,K){return!("complex64"===K||"float32"===K&&"complex64"!==q||"int32"===K&&"float32"!==q&&"complex64"!==q||"bool"===K&&"bool"===q)}function X(q){if("float32"===q||"int32"===q)return 4;if("complex64"===q)return 8;if("bool"===q)return 1;throw new Error(`Unknown dtype ${q}`)}function ut(q){if(null==q)return 0;let K=0;return q.forEach(j=>K+=j.length),K}function Dt(q){return"string"==typeof q||q instanceof String}function Y(q){return"boolean"==typeof q}function ht(q){return"number"==typeof q}function Pt(q){return Array.isArray(q)?Pt(q[0]):q instanceof Float32Array?"float32":q instanceof Int32Array||q instanceof Uint8Array||q instanceof Uint8ClampedArray?"int32":ht(q)?"float32":Dt(q)?"string":Y(q)?"bool":"float32"}function pt(q){return!!(q&&q.constructor&&q.call&&q.apply)}function xt(q,K){for(let j=K;j<q;++j)if(q%j==0)return j;return q}function Nt(q){const K=q.length;if(K<2)return[];const j=new Array(K-1);j[K-2]=q[K-1];for(let at=K-3;at>=0;--at)j[at]=j[at+1]*q[at+1];return j}function Vt(q,K,j,at=!1){const dt=new Array;if(1===K.length){const kt=K[0]*(at?2:1);for(let jt=0;jt<kt;jt++)dt[jt]=j[q+jt]}else{const kt=K[0],jt=K.slice(1),Jt=jt.reduce((ae,Re)=>ae*Re)*(at?2:1);for(let ae=0;ae<kt;ae++)dt[ae]=Vt(q+ae*Jt,jt,j,at)}return dt}function Gt(q,K,j=!1){if(0===q.length)return K[0];const at=q.reduce((dt,kt)=>dt*kt)*(j?2:1);if(0===at)return[];if(at!==K.length)throw new Error(`[${q}] does not match the input size ${K.length}${j?" for a complex tensor":""}.`);return Vt(0,q,K,j)}function oe(q,K){if(Array.isArray(q))return q;if("float32"===K)return q instanceof Float32Array?q:new Float32Array(q);if("int32"===K)return q instanceof Int32Array?q:new Int32Array(q);if("bool"===K||"string"===K)return Uint8Array.from(new Int32Array(q));throw new Error(`Unknown dtype ${K}`)}function Ee(q,K){const j=Ie(q,K);for(let at=0;at<j.length;at++)j[at]=1;return j}function Ie(q,K){if(null==K||"float32"===K||"complex64"===K)return new Float32Array(q);if("int32"===K)return new Int32Array(q);if("bool"===K)return new Uint8Array(q);throw new Error(`Unknown data type ${K}`)}function ie(q,K){const j=q.reduce((at,dt)=>at*dt,1);if(null==K||"float32"===K)return Gt(q,new Float32Array(j));if("int32"===K)return Gt(q,new Int32Array(j));if("bool"===K)return Gt(q,new Uint8Array(j));throw new Error(`Unknown data type ${K}`)}function Zt(q){q.forEach(K=>{o(Number.isInteger(K)&&K>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${q}].`)})}function ct(q,K,j){if(0===K)return 0;if(1===K)return q[0];let at=q[q.length-1];for(let dt=0;dt<q.length-1;++dt)at+=j[dt]*q[dt];return at}function It(q,K,j){if(0===K)return[];if(1===K)return[q];const at=new Array(K);for(let dt=0;dt<at.length-1;++dt)at[dt]=Math.floor(q/j[dt]),q-=at[dt]*j[dt];return at[at.length-1]=q,at}function Ut(q){return q&&q.then&&"function"==typeof q.then}t.d(C,{AE:()=>v,Cq:()=>s,D2:()=>Pt,D5:()=>$,DK:()=>p,E7:()=>l,EC:()=>N,GN:()=>_,GX:()=>Gt,HD:()=>Dt,JZ:()=>L,KS:()=>oe,LF:()=>h,LP:()=>W,Mu:()=>Zt,NA:()=>r,NE:()=>It,QB:()=>Z,Sm:()=>i,TV:()=>e,U$:()=>T,Ub:()=>ut,WD:()=>P,WP:()=>b,YP:()=>M,bT:()=>X,bj:()=>f,bp:()=>O,cO:()=>g,d7:()=>a,e3:()=>Nt,hj:()=>ht,hu:()=>o,jP:()=>xt,jn:()=>Y,k5:()=>n,l6:()=>ie,mf:()=>pt,nY:()=>c,oj:()=>S,p8:()=>Ee,qy:()=>ct,rQ:()=>E,tI:()=>Ut,uZ:()=>u,wT:()=>Ie,xH:()=>d})},62180:(H,C,t)=>{"use strict";t.d(C,{i:()=>e});const e="4.22.0"},37387:H=>{H.exports=t;var C=null;try{C=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(b,E,$){this.low=0|b,this.high=0|E,this.unsigned=!!$}function e(b){return!0===(b&&b.__isLong__)}Object.defineProperty(t.prototype,"__isLong__",{value:!0}),t.isLong=e;var a={},u={};function c(b,E){var $,W,Z;return E?(Z=0<=(b>>>=0)&&b<256)&&(W=u[b])?W:($=i(b,(0|b)<0?-1:0,!0),Z&&(u[b]=$),$):(Z=-128<=(b|=0)&&b<128)&&(W=a[b])?W:($=i(b,b<0?-1:0,!1),Z&&(a[b]=$),$)}function h(b,E){if(isNaN(b))return E?v:_;if(E){if(b<0)return v;if(b>=d)return L}else{if(b<=-p)return N;if(b+1>=p)return P}return b<0?h(-b,E).neg():i(b%r|0,b/r|0,E)}function i(b,E,$){return new t(b,E,$)}t.fromInt=c,t.fromNumber=h,t.fromBits=i;var f=Math.pow;function l(b,E,$){if(0===b.length)throw Error("empty string");if("NaN"===b||"Infinity"===b||"+Infinity"===b||"-Infinity"===b)return _;if("number"==typeof E?($=E,E=!1):E=!!E,($=$||10)<2||36<$)throw RangeError("radix");var W;if((W=b.indexOf("-"))>0)throw Error("interior hyphen");if(0===W)return l(b.substring(1),E,$).neg();for(var Z=h(f($,8)),X=_,ut=0;ut<b.length;ut+=8){var Dt=Math.min(8,b.length-ut),Y=parseInt(b.substring(ut,ut+Dt),$);if(Dt<8){var ht=h(f($,Dt));X=X.mul(ht).add(h(Y))}else X=(X=X.mul(Z)).add(h(Y))}return X.unsigned=E,X}function o(b,E){return"number"==typeof b?h(b,E):"string"==typeof b?l(b,E):i(b.low,b.high,"boolean"==typeof E?E:b.unsigned)}t.fromString=l,t.fromValue=o;var r=4294967296,d=r*r,p=d/2,g=c(1<<24),_=c(0);t.ZERO=_;var v=c(0,!0);t.UZERO=v;var M=c(1);t.ONE=M;var T=c(1,!0);t.UONE=T;var S=c(-1);t.NEG_ONE=S;var P=i(-1,2147483647,!1);t.MAX_VALUE=P;var L=i(-1,-1,!0);t.MAX_UNSIGNED_VALUE=L;var N=i(0,-2147483648,!1);t.MIN_VALUE=N;var O=t.prototype;O.toInt=function(){return this.unsigned?this.low>>>0:this.low},O.toNumber=function(){return this.unsigned?(this.high>>>0)*r+(this.low>>>0):this.high*r+(this.low>>>0)},O.toString=function(E){if((E=E||10)<2||36<E)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(N)){var $=h(E),W=this.div($),Z=W.mul($).sub(this);return W.toString(E)+Z.toInt().toString(E)}return"-"+this.neg().toString(E)}for(var X=h(f(E,6),this.unsigned),ut=this,Dt="";;){var Y=ut.div(X),Pt=(ut.sub(Y.mul(X)).toInt()>>>0).toString(E);if((ut=Y).isZero())return Pt+Dt;for(;Pt.length<6;)Pt="0"+Pt;Dt=""+Pt+Dt}},O.getHighBits=function(){return this.high},O.getHighBitsUnsigned=function(){return this.high>>>0},O.getLowBits=function(){return this.low},O.getLowBitsUnsigned=function(){return this.low>>>0},O.getNumBitsAbs=function(){if(this.isNegative())return this.eq(N)?64:this.neg().getNumBitsAbs();for(var E=0!=this.high?this.high:this.low,$=31;$>0&&!(E&1<<$);$--);return 0!=this.high?$+33:$+1},O.isZero=function(){return 0===this.high&&0===this.low},O.eqz=O.isZero,O.isNegative=function(){return!this.unsigned&&this.high<0},O.isPositive=function(){return this.unsigned||this.high>=0},O.isOdd=function(){return!(1&~this.low)},O.isEven=function(){return!(1&this.low)},O.equals=function(E){return e(E)||(E=o(E)),(this.unsigned===E.unsigned||this.high>>>31!=1||E.high>>>31!=1)&&this.high===E.high&&this.low===E.low},O.eq=O.equals,O.notEquals=function(E){return!this.eq(E)},O.neq=O.notEquals,O.ne=O.notEquals,O.lessThan=function(E){return this.comp(E)<0},O.lt=O.lessThan,O.lessThanOrEqual=function(E){return this.comp(E)<=0},O.lte=O.lessThanOrEqual,O.le=O.lessThanOrEqual,O.greaterThan=function(E){return this.comp(E)>0},O.gt=O.greaterThan,O.greaterThanOrEqual=function(E){return this.comp(E)>=0},O.gte=O.greaterThanOrEqual,O.ge=O.greaterThanOrEqual,O.compare=function(E){if(e(E)||(E=o(E)),this.eq(E))return 0;var $=this.isNegative(),W=E.isNegative();return $&&!W?-1:!$&&W?1:this.unsigned?E.high>>>0>this.high>>>0||E.high===this.high&&E.low>>>0>this.low>>>0?-1:1:this.sub(E).isNegative()?-1:1},O.comp=O.compare,O.negate=function(){return!this.unsigned&&this.eq(N)?N:this.not().add(M)},O.neg=O.negate,O.add=function(E){e(E)||(E=o(E));var Pt=0,pt=0,xt=0,Nt=0;return xt+=(Nt+=(65535&this.low)+(65535&E.low))>>>16,pt+=(xt+=(this.low>>>16)+(E.low>>>16))>>>16,Pt+=(pt+=(65535&this.high)+(65535&E.high))>>>16,Pt+=(this.high>>>16)+(E.high>>>16),i((xt&=65535)<<16|(Nt&=65535),(Pt&=65535)<<16|(pt&=65535),this.unsigned)},O.subtract=function(E){return e(E)||(E=o(E)),this.add(E.neg())},O.sub=O.subtract,O.multiply=function(E){if(this.isZero())return _;if(e(E)||(E=o(E)),C)return i(C.mul(this.low,this.high,E.low,E.high),C.get_high(),this.unsigned);if(E.isZero())return _;if(this.eq(N))return E.isOdd()?N:_;if(E.eq(N))return this.isOdd()?N:_;if(this.isNegative())return E.isNegative()?this.neg().mul(E.neg()):this.neg().mul(E).neg();if(E.isNegative())return this.mul(E.neg()).neg();if(this.lt(g)&&E.lt(g))return h(this.toNumber()*E.toNumber(),this.unsigned);var Z=65535&this.high,X=this.low>>>16,ut=65535&this.low,Y=65535&E.high,ht=E.low>>>16,Pt=65535&E.low,pt=0,xt=0,Nt=0,Vt=0;return Nt+=(Vt+=ut*Pt)>>>16,xt+=(Nt+=X*Pt)>>>16,Nt&=65535,xt+=(Nt+=ut*ht)>>>16,pt+=(xt+=Z*Pt)>>>16,xt&=65535,pt+=(xt+=X*ht)>>>16,xt&=65535,pt+=(xt+=ut*Y)>>>16,pt+=(this.high>>>16)*Pt+Z*ht+X*Y+ut*(E.high>>>16),i((Nt&=65535)<<16|(Vt&=65535),(pt&=65535)<<16|(xt&=65535),this.unsigned)},O.mul=O.multiply,O.divide=function(E){if(e(E)||(E=o(E)),E.isZero())throw Error("division by zero");var W,Z,X;if(C)return this.unsigned||-2147483648!==this.high||-1!==E.low||-1!==E.high?i((this.unsigned?C.div_u:C.div_s)(this.low,this.high,E.low,E.high),C.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?v:_;if(this.unsigned){if(E.unsigned||(E=E.toUnsigned()),E.gt(this))return v;if(E.gt(this.shru(1)))return T;X=v}else{if(this.eq(N))return E.eq(M)||E.eq(S)?N:E.eq(N)?M:(W=this.shr(1).div(E).shl(1)).eq(_)?E.isNegative()?M:S:(Z=this.sub(E.mul(W)),X=W.add(Z.div(E)));if(E.eq(N))return this.unsigned?v:_;if(this.isNegative())return E.isNegative()?this.neg().div(E.neg()):this.neg().div(E).neg();if(E.isNegative())return this.div(E.neg()).neg();X=_}for(Z=this;Z.gte(E);){W=Math.max(1,Math.floor(Z.toNumber()/E.toNumber()));for(var Dt=Math.ceil(Math.log(W)/Math.LN2),Y=Dt<=48?1:f(2,Dt-48),ht=h(W),Pt=ht.mul(E);Pt.isNegative()||Pt.gt(Z);)Pt=(ht=h(W-=Y,this.unsigned)).mul(E);ht.isZero()&&(ht=M),X=X.add(ht),Z=Z.sub(Pt)}return X},O.div=O.divide,O.modulo=function(E){return e(E)||(E=o(E)),C?i((this.unsigned?C.rem_u:C.rem_s)(this.low,this.high,E.low,E.high),C.get_high(),this.unsigned):this.sub(this.div(E).mul(E))},O.mod=O.modulo,O.rem=O.modulo,O.not=function(){return i(~this.low,~this.high,this.unsigned)},O.and=function(E){return e(E)||(E=o(E)),i(this.low&E.low,this.high&E.high,this.unsigned)},O.or=function(E){return e(E)||(E=o(E)),i(this.low|E.low,this.high|E.high,this.unsigned)},O.xor=function(E){return e(E)||(E=o(E)),i(this.low^E.low,this.high^E.high,this.unsigned)},O.shiftLeft=function(E){return e(E)&&(E=E.toInt()),0==(E&=63)?this:E<32?i(this.low<<E,this.high<<E|this.low>>>32-E,this.unsigned):i(0,this.low<<E-32,this.unsigned)},O.shl=O.shiftLeft,O.shiftRight=function(E){return e(E)&&(E=E.toInt()),0==(E&=63)?this:E<32?i(this.low>>>E|this.high<<32-E,this.high>>E,this.unsigned):i(this.high>>E-32,this.high>=0?0:-1,this.unsigned)},O.shr=O.shiftRight,O.shiftRightUnsigned=function(E){if(e(E)&&(E=E.toInt()),0==(E&=63))return this;var $=this.high;return E<32?i(this.low>>>E|$<<32-E,$>>>E,this.unsigned):i(32===E?$:$>>>E-32,0,this.unsigned)},O.shru=O.shiftRightUnsigned,O.shr_u=O.shiftRightUnsigned,O.toSigned=function(){return this.unsigned?i(this.low,this.high,!1):this},O.toUnsigned=function(){return this.unsigned?this:i(this.low,this.high,!0)},O.toBytes=function(E){return E?this.toBytesLE():this.toBytesBE()},O.toBytesLE=function(){var E=this.high,$=this.low;return[255&$,$>>>8&255,$>>>16&255,$>>>24,255&E,E>>>8&255,E>>>16&255,E>>>24]},O.toBytesBE=function(){var E=this.high,$=this.low;return[E>>>24,E>>>16&255,E>>>8&255,255&E,$>>>24,$>>>16&255,$>>>8&255,255&$]},t.fromBytes=function(E,$,W){return W?t.fromBytesLE(E,$):t.fromBytesBE(E,$)},t.fromBytesLE=function(E,$){return new t(E[0]|E[1]<<8|E[2]<<16|E[3]<<24,E[4]|E[5]<<8|E[6]<<16|E[7]<<24,$)},t.fromBytesBE=function(E,$){return new t(E[4]<<24|E[5]<<16|E[6]<<8|E[7],E[0]<<24|E[1]<<16|E[2]<<8|E[3],$)}},46580:(H,C,t)=>{"use strict";t.d(C,{i:()=>e});const e="4.22.0"},6356:(H,C,t)=>{"use strict";t.d(C,{GD:()=>P,Gc:()=>g,aI:()=>N});var e=t(30003),a=t(12992),u=t(42688);class c extends e.m7h.Serializable{getConfig(){return{}}}e.m7h.registerClass((()=>{class O extends c{apply(E,$=1){return a.py(E,$)}}return O.className="elu",O})());let i=(()=>{class O extends c{apply(E){return e.U8D(E)}}return O.className="selu",O})();e.m7h.registerClass(i);let f=(()=>{class O extends c{apply(E){return e.UYe(E)}}return O.className="relu",O})();e.m7h.registerClass(f);let l=(()=>{class O extends c{apply(E){return(0,e.lub)(()=>e.LTh(6,e.UYe(E)))}}return O.className="relu6",O})();e.m7h.registerClass(l),e.m7h.registerClass((()=>{class O extends c{apply(E){return E}}return O.className="linear",O})());let n=(()=>{class O extends c{apply(E){return e.XD2(E)}}return O.className="sigmoid",O})();e.m7h.registerClass(n),e.m7h.registerClass((()=>{class O extends c{apply(E){return a.HX(E)}}return O.className="hardSigmoid",O})());let r=(()=>{class O extends c{apply(E){return e.Wvh(E)}}return O.className="softplus",O})();e.m7h.registerClass(r),e.m7h.registerClass((()=>{class O extends c{apply(E){return a.O(E)}}return O.className="softsign",O})());let p=(()=>{class O extends c{apply(E){return e.AEp(E)}}return O.className="tanh",O})();e.m7h.registerClass(p);let g=(()=>{class O extends c{apply(E,$=-1){return e.XAC(E,$)}}return O.className="softmax",O})();e.m7h.registerClass(g);let _=(()=>{class O extends c{apply(E,$=-1){return e.CmS(E,$)}}return O.className="logSoftmax",O})();e.m7h.registerClass(_);let v=(()=>{class O extends c{apply(E){return(0,e.lub)(()=>e.lub(()=>{const $=Math.sqrt(2),W=e.dC7(.5,e.IHx(1,e.qNN(e.hiC(E,$))));return e.dC7(E,W)}))}}return O.className="gelu",O})();e.m7h.registerClass(v);let M=(()=>{class O extends c{apply(E){return(0,e.lub)(()=>e.dC7(.5,e.dC7(E,e.IHx(1,e.AEp(e.dC7(e._b3(e.hiC(2,Math.PI)),e.IHx(E,e.dC7(.044715,e.sQ3(E,3)))))))))}}return O.className="gelu_new",O})();e.m7h.registerClass(M);let T=(()=>{class O extends c{apply(E){return(0,e.lub)(()=>e.dC7(E,e.AEp(e.Wvh(E))))}}return O.className="mish",O})();e.m7h.registerClass(T);let S=(()=>{class O extends c{apply(E,$=1){return(0,e.lub)(()=>e.dC7(e.XD2(e.dC7(E,$)),E))}}return O.className="swish",O})();function P(O){return O.getClassName()}function L(O,b={}){return(0,u.tU)(O,e.m7h.SerializationMap.getMap().classNameMap,b,"activation")}function N(O){if(null==O){return L({className:"linear",config:{}})}if("string"==typeof O){const b={};return b.className=O,b.config={},L(b)}return O instanceof c?O:L(O)}e.m7h.registerClass(S)},73915:(H,C,t)=>{"use strict";t.d(C,{Ho:()=>u,rf:()=>h});var e=t(30003);let a;function u(){return null==a&&(a=(0,e.y3$)().epsilon()),a}function h(){return"channelsLast"}},32547:(H,C,t)=>{"use strict";t.d(C,{L:()=>a,s:()=>c});let e=0;function a(){return e++}const u={};function c(h=""){return h in u||(u[h]=0),u[h]+=1,h+u[h].toString()}},12992:(H,C,t)=>{"use strict";t.d(C,{AK:()=>N,GZ:()=>S,Gg:()=>P,HX:()=>ht,Iq:()=>E,KC:()=>Pt,O:()=>Dt,Uz:()=>g,a2:()=>X,c9:()=>_,dt:()=>r,h6:()=>$,mV:()=>T,nG:()=>L,pj:()=>s,py:()=>ut,rv:()=>Y,rx:()=>d,uI:()=>M,xH:()=>p});var e=t(30003),a=t(65999),u=t(18357),c=t(57774),h=t(73915);function s(pt,xt){return e.pju(pt,xt)}function r(pt,xt=-1){const Nt=pt.shape.slice();return xt<0&&(xt=Nt.length+xt+1),Nt.splice(xt,0,1),e.XLQ(pt,Nt)}function d(pt,xt){return(0,e.lub)(()=>{if(2!==pt.shape.length)throw new u.nu(`repeat() expects a rank-2 tensor, but received a rank-${pt.shape.length} tensor.`);return P(r(pt,1),[1,xt,1])})}function p(pt){const xt=[c.NS(pt.shape)];return e.XLQ(pt,xt)}function g(pt){if(pt.rank<=1)throw new u.nu(`batchFlatten requires a minimum rank of 2. Got rank: ${pt.rank}.`);const xt=[pt.shape[0],c.NS(pt.shape,1)];return e.XLQ(pt,xt)}function _(pt,xt,Nt){return(0,e.lub)(()=>{switch(pt.rank){case 1:return e.jZU(pt,xt,Nt);case 2:return e.SmN(pt,[xt,0],[Nt,pt.shape[1]]);case 3:return e.CnO(pt,[xt,0,0],[Nt,pt.shape[1],pt.shape[2]]);case 4:return e.p0P(pt,[xt,0,0,0],[Nt,pt.shape[1],pt.shape[2],pt.shape[3]]);case 5:return e.tPi(pt,[xt,0,0,0,0],[Nt,pt.shape[1],pt.shape[2],pt.shape[3],pt.shape[4]]);case 6:return e.tPi(pt,[xt,0,0,0,0,0],[Nt,pt.shape[1],pt.shape[2],pt.shape[3],pt.shape[4],pt.shape[5]]);default:throw new u.nu(`sliceAlongFirstAxis() received an unsupported tensor rank: ${pt.rank}`)}})}function v(pt,xt,Nt){return(0,e.lub)(()=>{switch(pt.rank){case 1:return e.jZU(pt,xt,Nt);case 2:return e.SmN(pt,[0,xt],[pt.shape[0],Nt]);case 3:return e.CnO(pt,[0,0,xt],[pt.shape[0],pt.shape[1],Nt]);case 4:return e.p0P(pt,[0,0,0,xt],[pt.shape[0],pt.shape[1],pt.shape[2],Nt]);default:throw new u.nu(`sliceAlongLastAxis() received an unsupported tensor rank: ${pt.rank}`)}})}function M(pt,xt,Nt,Vt){return(0,e.lub)(()=>{switch(pt.rank){case 1:return e.jZU(pt,xt,Nt);case 2:switch(Vt){case 1:return _(pt,xt,Nt);case 2:return v(pt,xt,Nt);default:throw new u.nu(`The axis is not within the rank of the tensor ${Vt}`)}case 3:switch(Vt){case 1:return _(pt,xt,Nt);case 2:return e.CnO(pt,[0,xt,0],[pt.shape[0],Nt,pt.shape[2]]);case 3:return v(pt,xt,Nt);default:throw new u.nu(`The axis is not within the rank of the tensor ${Vt}`)}case 4:switch(Vt){case 1:return _(pt,xt,Nt);case 2:return e.p0P(pt,[0,xt,0,0],[pt.shape[0],Nt,pt.shape[2],pt.shape[3]]);case 3:return e.p0P(pt,[0,0,xt,0],[pt.shape[0],pt.shape[1],Nt,pt.shape[3]]);case 4:return v(pt,xt,Nt);default:throw new u.nu(`The axis is not within the rank of the tensor ${Vt}`)}default:throw new u.nu(`sliceAlongLastAxis() received an unsupported tensor rank: ${pt.rank}`)}})}function T(pt,xt=-1){let Nt;return xt<0&&(Nt=pt[0].rank,xt=0!==Nt?Nt:0),xt===pt[0].rank&&(xt=-1),e.zoF(pt,xt)}function S(pt,xt){switch(pt.rank){case 1:return e.gME([pt,xt]);case 2:return e.Izb([pt,xt],0);case 3:return e.MNy([pt,xt],0);case 4:return e.ZaL([pt,xt],0);default:throw new u.nu(`concatAlongFirstAxis() received an unsupported tensor rank: ${pt.rank}`)}}function P(pt,xt){if(Array.isArray(xt)||(xt=[xt]),pt.rank!==xt.length)throw new u.nu(`The length of input n (${xt.length}) does not match the number of dimensions in input x (${pt.rank})`);return e.Gg6(pt,xt)}function L(pt,xt=0,Nt=1,Vt,Gt){return e.nGf(pt,xt,Nt,Vt,Gt)}function N(pt,xt,Nt,Vt){if(pt.rank<2||xt.rank<2)throw new u.nj(`dot requires both inputs to be rank >= 2 but got x shape = ${pt.shape} and y shape = ${xt.shape}`);if(xt.rank>=3&&pt.shape.slice(-1)[0]!==xt.shape.slice(-2)[0])throw new u.nj(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${pt.shape} and  y shape = ${xt.shape}`);if(2===pt.rank&&2===xt.rank)return e.imm.matMul({a:pt,b:xt,transposeA:!1,transposeB:!1,bias:Vt?Z(pt.rank,Vt,(0,h.rf)()):null,activation:Nt});{const Gt=pt.shape.slice(),oe=Gt.pop();pt=e.XLQ(pt,[-1,oe]);const Ee=xt.shape.slice(),Ie=Ee.pop(),ie=Ee.pop(),Zt=[...Ee,Ie],ct=Array.from({length:xt.rank},(K,j)=>0===j?xt.rank-2:j<=xt.rank-2?j-1:j);xt=e.XLQ(e.p4s(xt,ct),[ie,-1]);const It=[...Gt,...Zt];return e.XLQ(e.imm.matMul({a:pt,b:xt,transposeA:!1,transposeB:!1,bias:Vt?Z(pt.rank,Vt,(0,h.rf)()):null,activation:Nt}),It)}}function E(pt,xt,Nt){return(0,e.lub)(()=>(xt=Array.isArray(xt)?(0,e.RRF)(xt,"int32"):e.pju(xt,"int32"),e.Iqj(pt,xt,Nt)))}function $(pt){return e.dC7(pt,pt)}function Z(pt,xt,Nt){const Vt=xt.shape;if(1!==xt.rank&&xt.rank!==pt)throw new u.nu(`Unexpected bias dimensions: ${xt.rank}; expected it to be 1 or ${pt}`);if(5===pt){if("channelsFirst"===Nt)return e.XLQ(xt,1===Vt.length?[1,Vt[0],1,1,1]:[1,Vt[3],Vt[0],Vt[1],Vt[2]]);if("channelsLast"===Nt)return e.XLQ(xt,1===Vt.length?[1,1,1,1,Vt[0]]:[1].concat(Vt))}else if(4===pt){if("channelsFirst"===Nt)return e.XLQ(xt,1===Vt.length?[1,Vt[0],1,1]:[1,Vt[2],Vt[0],Vt[1]]);if("channelsLast"===Nt)return e.XLQ(xt,1===Vt.length?[1,1,1,Vt[0]]:[1].concat(Vt))}else if(3===pt){if("channelsFirst"===Nt)return e.XLQ(xt,1===Vt.length?[1,Vt[0],1]:[1,Vt[1],Vt[0]]);if("channelsLast"===Nt)return e.XLQ(xt,1===Vt.length?[1,1,Vt[0]]:[1].concat(Vt))}else if(pt<3)return xt;throw new u.nu(`Unsupported input rank by biasAdd: ${xt.rank}`)}function X(pt,xt,Nt){return(0,e.lub)(()=>(null==Nt&&(Nt=(0,h.rf)()),(0,a.cj)(Nt),e.IHx(pt,Z(pt.rank,xt,Nt))))}function ut(pt,xt=1){if(1!==xt)throw new u.nj(`Support for alpha values other than 1 (${xt}) is not implemented yet.`);return e.pyx(pt)}function Dt(pt){return(0,e.lub)(()=>e.hiC(pt,e.IHx(e.WnP(pt),1)))}function Y(pt,xt,Nt,Vt){return(0,e.lub)(()=>e.rvX(pt,xt,Nt,Vt))}function ht(pt){return(0,e.lub)(()=>{const xt=e.IHx(.5,e.dC7(.2,pt));return e.iUl(xt,0,1)})}function Pt(pt,xt,Nt=!1){return Nt?pt():xt()}},65999:(H,C,t)=>{"use strict";t.d(C,{Lp:()=>f,MU:()=>r,cj:()=>c,f4:()=>n,w8:()=>d,wU:()=>h,zb:()=>i});var e=t(4555),a=t(42688);const u=new Map;function c(_){(0,a.xn)(e.PS,"DataFormat",_)}function h(_){(0,a.xn)(e.Mz,"InterpolationFormat",_)}function i(_){(0,a.xn)(e.zx,"PaddingMode",_)}function f(_){(0,a.xn)(e.MK,"PoolMode",_)}const l=[],o="/";function n(_,v){l.push(_);try{const M=v();return l.pop(),M}catch(M){throw l.pop(),M}}function r(_){if(!g(_))throw new Error("Not a valid tensor name: '"+_+"'");return function s(){return 0===l.length?"":l.join(o)+o}()+_}function d(_){if(!g(_))throw new Error("Not a valid tensor name: '"+_+"'");u.has(_)||u.set(_,0);const v=u.get(_);if(u.set(_,u.get(_)+1),v>0){const M=`${_}_${v}`;return u.set(M,1),M}return _}const p=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function g(_){return!!_.match(p)}},70530:(H,C,t)=>{"use strict";t.d(C,{W:()=>u});var e=t(92641);let a=(()=>{class c{constructor(i){this.seed=i}next(){if(void 0!==this.seed)return this.seed++}}return c.className="RandomSeed",c})(),u=(()=>{class c extends e.mh{constructor(i){super(i),this.randomGenerator=new a(i.seed)}getConfig(){const i={seed:this.randomGenerator.seed},f=super.getConfig();return Object.assign(i,f),i}}return c.className="BaseRandomLayer",c})()},12618:(H,C,t)=>{"use strict";t.d(C,{W:()=>p});var e=t(30003),a=t(32547),u=t(18357),c=t(28467),h=t(42688),i=t(41609),f=t(8022),l=t(3097),o=t(18032),n=t(7405),s=t(51090),r=t(92641);class p extends r.mh{constructor(_){if(super({}),this.containerNodes=new Set,this.name=_.name,null==this.name){const Y=this.getClassName().toLowerCase();this.name=(0,a.s)(Y)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(_.inputs)?_.inputs.slice():[_.inputs],this.outputs=Array.isArray(_.outputs)?_.outputs.slice():[_.outputs],h.Tw(this.inputs).length!==this.inputs.length)throw new u.nu(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(Y=>Y.name)}`);h.Tw(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(Y=>Y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const Y of this.outputs){const Pt=Y.nodeIndex,pt=Y.tensorIndex;this.outputLayers.push(Y.sourceLayer),this.outputLayersNodeIndices.push(Pt),this.outputLayersTensorIndices.push(pt)}for(const Y of this.inputs){const ht=Y.sourceLayer,Pt=Y.nodeIndex,pt=Y.tensorIndex;h.hu(0===Pt,"input layer has >1 nodes"),h.hu(0===pt,"input layer has >1 tensors"),this.inputLayers.push(ht),this.inputLayersNodeIndices.push(Pt),this.inputLayersTensorIndices.push(pt)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let Y=0;Y<this.inputLayers.length;Y++){const ht=this.inputLayers[Y];if(!(ht instanceof s.l))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${_.inputs}. Input ${Y} (0-based) originates from layer type ${ht.getClassName()}.`);this.inputNames.push(ht.name),this.feedInputShapes.push(ht.batchInputShape),this.feedInputNames.push(ht.name)}for(const Y of this.outputLayers)this.outputNames.push(Y.name);this.internalInputShapes=this.inputs.map(Y=>Y.shape),this.internalOutputShapes=this.outputs.map(Y=>Y.shape);const v={},M={},T={},S={},P={},L=[],N=(Y,ht,Pt,pt,xt,Nt)=>{(null==pt||null==xt||null==Nt)&&(pt=Y.sourceLayer,xt=Y.nodeIndex,Nt=Y.tensorIndex);const Vt=pt.inboundNodes[xt];if(-1!==Pt.indexOf(Vt))throw new u.LH(`The tensor ${Y.name} at layer "${pt.name}" is part of a cycle.`);if(-1!==ht.indexOf(Vt))return;this.containerNodes.add(p.nodeKey(pt,xt)),pt.id in P||(P[pt.id]=Object.keys(P).length),-1===Pt.indexOf(Vt)&&Pt.push(Vt);const Gt=Vt.inboundLayers.length;for(let oe=0;oe<Gt;oe++)N(Vt.inputTensors[oe],ht,Pt,Vt.inboundLayers[oe],Vt.nodeIndices[oe],Vt.tensorIndices[oe]);for(ht.push(Vt);Pt.indexOf(Vt)>=0;)Pt.splice(Pt.indexOf(Vt),1);L.push(Vt)},O=[],b=[];for(const Y of this.outputs)N(Y,O,b);const E=L.slice().reverse();for(const Y of E){M[Y.id]=Y,Y.id in v||(v[Y.id]=0);let ht=v[Y.id];ht=Math.max(ht,null==T[Y.outboundLayer.id]?0:T[Y.outboundLayer.id]),T[Y.outboundLayer.id]=ht,S[Y.outboundLayer.id]=Y.outboundLayer,v[Y.id]=ht;for(let pt=0;pt<Y.inboundLayers.length;pt++){const Vt=Y.inboundLayers[pt].inboundNodes[Y.nodeIndices[pt]];v[Vt.id]=Math.max(ht+1,null==v[Vt.id]?0:v[Vt.id]),M[Vt.id]=Vt}}const $={};for(const Y in v){const ht=v[Y];ht in $||($[ht]=[]),$[ht].push(M[Y])}const W={};for(const Y in T){const ht=T[Y];ht in W||(W[ht]=[]),W[ht].push(S[Y])}let Z=Object.keys(W).map(Y=>parseInt(Y,10)).sort(h.L7);this.layers=[];for(const Y of Z){const ht=W[Y];ht.sort((Pt,pt)=>{const xt=P[Pt.id],Nt=P[pt.id];return xt<Nt?-1:xt>Nt?1:0});for(const Pt of ht)Pt instanceof p&&this.internalContainerRefs.push(Pt),this.layers.push(Pt)}this.layersByDepth=W,Z=Object.keys($).map(Y=>parseInt(Y,10)).sort(h.L7);const X=this.inputs.slice(),ut=[];for(const Y of Z)for(const ht of $[Y]){const Pt=ht.outboundLayer;if(null!=Pt){for(const pt of ht.inputTensors)if(-1===X.indexOf(pt))throw new u.LH(`Graph disconnected: cannot obtain value for tensor ${pt} at layer "${Pt.name}". The following previous layers were accessed without issue: ${ut}`);for(const pt of ht.outputTensors)X.push(pt);ut.push(Pt.name)}}this.nodesByDepth=$;const Dt=this.layers.map(Y=>Y.name);for(const Y of Dt){const ht=Dt.filter(Pt=>Pt===Y).length;if(1!==ht)throw new u.LH(`The name "${Y}" is used ${ht} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(Dt))}this.outboundNodes=[],this.inboundNodes=[],new r.NB({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(Y=>null),outputMasks:this.outputs.map(Y=>null),inputShapes:this.inputs.map(Y=>Y.shape),outputShapes:this.outputs.map(Y=>Y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const _={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const v of this.layers)_.numDisposedVariables+=v.dispose().numDisposedVariables;for(const v of this.internalContainerRefs)_.numDisposedVariables+=v.dispose().numDisposedVariables}return _.refCountAfterDispose=this._refCount,_}get trainable(){return this.trainable_}set trainable(_){this.layers.forEach(v=>{v._trainableWeights.forEach(M=>M.trainable=_)}),this.trainable_=_}get trainableWeights(){if(this._trainableWeights.length>0)throw new u.nu("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let _=[];for(const v of this.layers)_=_.concat(v.trainableWeights);return _}get nonTrainableWeights(){const _=[];for(const v of this.layers)_.push(...v.nonTrainableWeights);if(!this.trainable){const v=[];for(const M of this.layers)v.push(...M.trainableWeights);return v.concat(_)}return _}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(_,v=!0){const M={};let T=0;const S=(g=>{const _=Object.keys(g);if(0===_.length)return!1;const v=_[0].split("/");return!isNaN(parseInt(v[v.length-1],10))})(_);S&&this.parseWeights(_);for(const L of this.layers)for(const[N,O]of L.weights.entries()){const b=S?`${O.name.split("/").slice(0,-1).join("/")+"/"}${N}`:O.originalName;if(null!=M[b])throw new u.nu(`Duplicate weight name: ${b}`);M[b]=O,T++}const P=[];for(const L in _){let N=L;if(null==M[L]){const O=L.split("/");N=O.slice(0,-2).concat([O[O.length-1]]).join("/")}if(null!=M[N])P.push([M[N],_[L]]);else if(v)throw new u.nu(`Provided weight data has no target variable: ${L}`);delete M[N]}if(v){const L=[];for(const N in M)L.push(N);if(L.length>0)throw new u.nu(`${L.length} of ${T} weights are not set: ${L}`)}(0,l.zb)(P)}parseWeights(_){for(const v in Object.keys(_)){const M=v.split("/"),T=["vars","layer_checkpoint_dependencies"],S=M.map(P=>P.startsWith("_")?P.slice(1):P).filter(P=>!T.includes(P)).join("/");S!==v&&(_[S]=_[v],delete _[v])}}updatedConfig(){const _=this.getConfig(),v={};return v.className=this.getClassName(),v.config=_,v.kerasVersion=`tfjs-layers ${o.i}`,v.backend="TensorFlow.js",v}toJSON(_,v=!0){const M=(0,i.q)(this.updatedConfig());return v?JSON.stringify(M):M}call(_,v){return(0,e.lub)(()=>{_=h.zZ(_);const M=new n.l2;for(let T=0;T<this.inputs.length;++T)M.add(this.inputs[T],_[T]);return(0,n.ht)(this.outputs,M,v)})}computeMask(_,v){return(0,e.lub)(()=>{let M;return _=h.zZ(_),M=null==v?h.JE(null,_.length):h.zZ(v),this.runInternalGraph(_,M)[1]})}computeOutputShape(_){const v=f.x6(_);if(v.length!==this.inputLayers.length)throw new u.nu(`Invalid inputShape argument ${_}: model has ${this.inputLayers.length} tensor inputs.`);const M={};for(let L=0;L<v.length;L++)M[this.inputLayers[L].name+"_0_0"]=v[L];const T=Object.keys(this.nodesByDepth).map(L=>parseInt(L,10)).sort(h.L7);if(T.length>1)for(const L of T){const N=this.nodesByDepth[L];for(const O of N){const b=O.outboundLayer;if(-1!==this.inputLayers.map(X=>X.id).indexOf(b.id))continue;const E=[];for(let X=0;X<O.inboundLayers.length;X++)E.push(M[`${O.inboundLayers[X].name}_${O.nodeIndices[X]}_${O.tensorIndices[X]}`]);const $=b.computeOutputShape(h.Bq(E)),W=f.x6($),Z=b.inboundNodes.indexOf(O);for(let X=0;X<W.length;X++)M[`${b.name}_${Z}_${X}`]=W[X]}}const S=[],P=[];for(let L=0;L<this.outputLayers.length;L++)P.push(`${this.outputLayers[L].name}_${this.outputLayersNodeIndices[L]}_${this.outputLayersTensorIndices[L]}`);for(let L=0;L<P.length;L++){const N=P[L];h.hu(N in M),S.push(M[N])}return h.Bq(S)}runInternalGraph(_,v){null==v&&(v=h.JE(null,_.length));const M={};for(let N=0;N<this.inputs.length;++N)M[this.inputs[N].id]=[_[N],v[N]];const T=Object.keys(this.nodesByDepth).map(N=>parseInt(N,10)).sort(h.L7);for(const N of T){const O=this.nodesByDepth[N];for(const b of O){const E=b.outboundLayer,$=b.inputTensors,W=b.outputTensors,Z=new Array;for(const X of $)X.id in M&&Z.push(M[X.id]);if(Z.length===$.length){let ut,Dt,Y,ht,X={};if(null!=b.callArgs&&(X=b.callArgs),1===Z.length){const[Pt,pt]=Z[0];null==X.mask&&(X.mask=pt),Y=h.zZ(E.call(Pt,X)),ht=h.zZ(E.computeMask(Pt,pt)),ut=[Pt],Dt=[pt]}else ut=Z.map(Pt=>Pt[0]),Dt=Z.map(Pt=>Pt[1]),null==X.mask&&(X.mask=Dt),Y=h.zZ(E.call(ut,X)),ht=h.zZ(E.computeMask(ut,Dt));if(E.activityRegularizer)throw new u.nj("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let Pt=0;Pt<W.length;++Pt)M[W[Pt].id]=[Y[Pt],ht[Pt]]}}}const S=[],P=[],L=[];for(const N of this.outputs){h.hu(N.id in M,`Could not compute output ${N.name} : ${N.id}`);const[O,b]=M[N.id];L.push(O.shape),S.push(O),P.push(b)}return[S,P,L]}buildNodeConversionMap(_){const v={};let M;for(const T of this.layers){M=T instanceof p?1:0;for(let S=0;S<T.inboundNodes.length;S++){const P=p.nodeKey(T,S);this.containerNodes.has(P)&&(v[P]=M,M+=1)}}return v}getLayer(_,v){if(null!=v)return this.findLayer(v);if(null==_)throw new u.nu("Provide either a layer name or layer index");if("number"==typeof _)return this.findLayer(_);for(const M of this.layers)if(M.name===_)return M;throw new u.nu(`No such layer: ${_}`)}findLayer(_){if(this.layers.length<=_)throw new u.nu(`Was asked to retrieve layer at index ${_}, but model only has ${this.layers.length} layer(s).`);return this.layers[_]}calculateLosses(){return(0,e.lub)(()=>{const _=[];for(const v of this.layers)for(let M=0;M<v.inboundNodes.length;++M){const T=p.nodeKey(v,M);this.containerNodes.has(T)&&_.push(...v.calculateLosses())}return _})}getConfig(){const _={name:this.name},v=this.buildNodeConversionMap(this.layers),M=[];for(const P of this.layers){const L=P.getClassName(),N=P.getConfig(),O=[];for(let E=0;E<P.inboundNodes.length;E++){const $=P.inboundNodes[E],W=p.nodeKey(P,E);let Z={};if(this.containerNodes.has(W)){if($.callArgs)try{JSON.stringify($.callArgs),Z=$.callArgs}catch{console.warn(`Layer ${P.name} was passed non-serializable keyword arguments: ${$.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),Z={}}if($.inboundLayers.length>0){const X=[];for(let ut=0;ut<$.inboundLayers.length;ut++){const Dt=$.inboundLayers[ut],ht=$.tensorIndices[ut];let pt=v[p.nodeKey(Dt,$.nodeIndices[ut])];null==pt&&(pt=0),X.push([Dt.name,pt,ht,Z])}O.push(X)}}}const b={};b.name=P.name,b.className=L,b.config=N,b.inboundNodes=O,M.push(b)}_.layers=M;const T=[];for(let P=0;P<this.inputLayers.length;P++){const L=this.inputLayers[P],O=p.nodeKey(L,this.inputLayersNodeIndices[P]);if(!this.containerNodes.has(O))continue;let b=v[O];null==b&&(b=0),T.push([L.name,b,this.inputLayersTensorIndices[P]])}_.inputLayers=T;const S=[];for(let P=0;P<this.outputLayers.length;P++){const L=this.outputLayers[P],O=p.nodeKey(L,this.outputLayersNodeIndices[P]);if(!this.containerNodes.has(O))continue;let b=v[O];null==b&&(b=0),S.push([L.name,b,this.outputLayersTensorIndices[P]])}return _.outputLayers=S,_}static fromConfig(_,v,M={},T=!1){const S={},P={};function L(ut,Dt){ut.name in P?P[ut.name].push(Dt):P[ut.name]=[Dt]}function N(ut,Dt){const Y=[];let ht;for(const Pt of Dt){const pt=Pt[0],xt=Pt[1],Nt=Pt[2];if(ht=null==Pt[3]?{}:Pt[3],!(pt in S))return void L(ut,Dt);const Vt=S[pt];if(Vt.inboundNodes.length<=xt)return void L(ut,Dt);Y.push(Vt.inboundNodes[xt].outputTensors[Nt])}Y.length>0&&ut.apply(h.Bq(Y),ht)}function O(ut){const Dt=ut.name,Y=(0,c.v)(ut,null!=v.customObjects?v.customObjects:{});Y.setFastWeightInitDuringBuild(T),S[Dt]=Y,ut.inboundNodes.forEach(Pt=>{if(!(Pt instanceof Array))throw new u.nu(`Corrupted configuration, expected array for nodeData: ${Pt}`);L(Y,Pt)})}const b=v.name,E=v.layers;for(const ut of E)O(ut);for(;!h.nK(P);)for(const ut of E){const Dt=S[ut.name];if(Dt.name in P){const Y=P[Dt.name];delete P[Dt.name];for(const ht of Y)N(Dt,ht)}}const $=[],W=[],Z=v.inputLayers;for(const ut of Z){const Dt=ut[0],Y=ut[1],ht=ut[2];h.hu(Dt in S),$.push(S[Dt].inboundNodes[Y].outputTensors[ht])}const X=v.outputLayers;for(const ut of X){const Dt=ut[0],Y=ut[1],ht=ut[2];h.hu(Dt in S),W.push(S[Dt].inboundNodes[Y].outputTensors[ht])}return new _({inputs:$,outputs:W,name:b})}get stateful(){if(this._stateful)throw new u.nu("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const _ of this.layers)if(_.stateful)return!0;return!1}resetStates(){(0,e.lub)(()=>{this.layers.forEach(_=>{_.stateful&&_.resetStates()})})}}},7405:(H,C,t)=>{"use strict";t.d(C,{l2:()=>l,ht:()=>r,kS:()=>s});var e=t(30003),a=t(18357);class u{constructor(M){this.maxEntries=M||100,this.cache=new Map}get(M){let T;return this.cache.has(M)&&(T=this.cache.get(M),this.cache.delete(M),this.cache.set(M,T)),T}put(M,T){if(this.cache.has(M))this.cache.delete(M);else if(this.cache.size>=this.maxEntries){const S=this.cache.keys().next().value;this.cache.delete(S)}this.cache.set(M,T)}getMaxEntries(){return this.maxEntries}setMaxEntries(M){if(M<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${M}.`);if(this.maxEntries>M)for(let T=0;T<this.maxEntries-M;T++){const S=this.cache.keys().next().value;this.cache.delete(S)}this.maxEntries=M}}var c=t(42688),h=t(51090),i=t(92641);class l{constructor(M){if(this.id2Value={},this.id2Mask={},this.name2Id={},M instanceof l)for(const T in M.id2Value)this.id2Value[T]=M.id2Value[T],T in M.id2Mask&&(this.id2Mask[T]=M.id2Mask[T]);else{if(null==M)return;for(const T of M)this.add(T.key,T.value)}}add(M,T,S){if(null!=this.id2Value[M.id])throw new a.nu(`Duplicate key: name=${M.name}, id=${M.id}`);return this.id2Value[M.id]=function f(v,M){if(null==v.dtype||v.dtype===M.dtype)return M;try{return(0,e.pju)(M,v.dtype)}catch{throw new a.nu(`The dtype of the feed (${M.dtype}) can not be cast to the dtype of the key '${v.name}' (${v.dtype}).`)}}(M,T),this.name2Id[M.name]=M.id,null!=S&&(this.id2Mask[M.id]=S),this}addFeed(M){this.add(M.key,M.value)}hasKey(M){return null!=this.id2Value[M.id]}names(){return Object.keys(this.name2Id)}getValue(M){if(M instanceof i.Iy){if(null==this.id2Value[M.id])throw new a.nu(`Nonexistent key: ${M.name}`);return this.id2Value[M.id]}{const T=this.name2Id[M];if(null==T)throw new a.nu(`Feed dict has no SymbolicTensor name: ${M}`);return this.id2Value[T]}}getMask(M){if(M instanceof i.Iy){if(null==this.id2Value[M.id])throw new a.nu(`Nonexistent key: ${M.name}`);return this.id2Mask[M.id]}{const T=this.name2Id[M];if(null==T)throw new a.nu(`Feed dict has no SymbolicTensor name: ${M}`);return this.id2Mask[T]}}disposeMasks(){null!=this.id2Mask&&(0,e.B90)(this.id2Mask)}}const o=new u,n=new u;function s(v){o?.setMaxEntries(v),n?.setMaxEntries(v)}function r(v,M,T,S){const P=null!=T&&T.training,L=Array.isArray(v),N=L?v:[v],O=N.map(ut=>ut.name),b=[],E=M.names();for(const ut of O)-1!==E.indexOf(ut)?b.push(M.getValue(ut)):b.push(null);null!=S&&(S.maxNumTensors=-1/0,S.minNumTensors=1/0);const $=O.join(",")+"|"+M.names().sort().join(",");let Z,W=o.get($);if(null==W){const ut=function d(v,M){e.D5U.assert(null!=v&&v.length>0,()=>"Expected at least one fetch, got none");let T=[],S={};if(1===v.length){const P=g(v[0],M);T=P.sorted,S=P.recipientMap}else{const P=new Set;for(const L of v){const{sorted:N,recipientMap:O}=g(L,M);for(const b of N)P.has(b.name)||(T.push(b),P.add(b.name));for(const b in O)null==S[b]&&(S[b]=new Set),O[b].forEach(E=>S[b].add(E))}}return{sorted:T,recipientCounts:p(S)}}(N,M);W=ut.sorted,Z=ut.recipientCounts,o.put($,W),n.put($,Z)}Z={},P||Object.assign(Z,n.get($));const X=new l(M);for(let ut=0;ut<W.length;++ut){if(null!=S){const Ee=(0,e.sq6)().numTensors;Ee>S.maxNumTensors&&(S.maxNumTensors=Ee),Ee<S.minNumTensors&&(S.minNumTensors=Ee)}const Dt=W[ut],Y=Dt.sourceLayer;if(Y instanceof h.l)continue;const ht=[],Pt=[],pt=[];let xt=!1;for(const Ee of Dt.inputs){const Ie=X.getValue(Ee),ie=X.getMask(Ee);ht.push(Ie),Pt.push(ie),null!=ie&&(xt=!0),P||(Z[Ee.name]--,0===Z[Ee.name]&&!M.hasKey(Ee)&&-1===O.indexOf(Ee.name)&&!Ie.isDisposed&&!0!==Ee.sourceLayer.stateful&&pt.push(Ie))}xt&&((T=T||{}).mask=Pt[0]);const Nt=(0,c.zZ)(Y.apply(ht,T));let Vt=null;Y.supportsMasking&&(Vt=Y.computeMask(ht,Pt));const Gt=_(Dt),oe=Array.isArray(Gt)?Gt:[Gt];for(let Ee=0;Ee<oe.length;++Ee){X.hasKey(oe[Ee])||X.add(oe[Ee],Nt[Ee],Array.isArray(Vt)?Vt[0]:Vt);const Ie=O.indexOf(oe[Ee].name);-1!==Ie&&(b[Ie]=Nt[Ee])}P||(0,e.B90)(pt)}return X.disposeMasks(),L?b:b[0]}function p(v){const M={};for(const T in v)M[T]=v[T].size;return M}function g(v,M){const T=new Set,S=[],P={};for(const O of M.names())T.add(O);const L=[],N=[];for(L.push(v);L.length>0;){const O=L[L.length-1];if(T.has(O.name)){L.pop();continue}const b=N[N.length-1]===L.length-1;if(0===O.inputs.length||b)L.pop(),S.push(O),T.add(O.name),b&&N.pop();else{N.push(L.length-1);for(const E of O.inputs)null==P[E.name]&&(P[E.name]=new Set),P[E.name].add(O.name),!T.has(E.name)&&L.push(E)}}return{sorted:S,recipientMap:P}}function _(v){let M;if(1===v.sourceLayer.inboundNodes.length)M=v.sourceLayer.output;else{let T=null;for(let S=0;S<v.sourceLayer.inboundNodes.length;++S)for(const P of v.sourceLayer.inboundNodes[S].outputTensors)if(P.id===v.id){T=S;break}M=v.sourceLayer.getOutputAt(T)}return M}},72488:(H,C,t)=>{"use strict";t.d(C,{D:()=>v,y:()=>r});var e=t(15861),a=t(30003),u=t(86025),c=t(18357),h=t(8518),i=t(42688),f=t(69001);function o(T,S){let P,L;P=S.xs,L=S.ys,a.D5U.assert(null!=P&&null!=L,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${S}`);const O=n("input",T.inputNames,P),b=n("output",T.outputNames,L),E=O[0].shape[0];a.D5U.assert(O.length===T.inputs.length,()=>`LayersModel has ${T.inputs.length} inputs, but the dataset provides ${O.length} inputs.  (Expected input keys: ${JSON.stringify(T.inputNames)})`),a.D5U.assert(b.length===T.outputs.length,()=>`LayersModel has ${T.outputs.length} outputs, but the dataset provides ${b.length} outputs.  (Expected output keys: ${JSON.stringify(T.outputNames)})`);for(let $=0;$<O.length;$++)a.D5U.assert(O[$].shape[0]===E,()=>`Batch size mismatch: input ${T.inputNames[$]} has ${O[$].shape[0]}; expected  ${E} based on input ${T.inputNames[0]}.`);for(let $=0;$<b.length;$++)a.D5U.assert(b[$].shape[0]===E,()=>`Batch size mismatch: output ${T.outputNames[$]} has ${b[$].shape[0]}; expected  ${E} based on input ${T.inputNames[0]}.`);return{xs:O,ys:b}}function n(T,S,P){if(P instanceof a.esB)return[P];if(Array.isArray(P))return a.D5U.assert(P.length===S.length,()=>`Received an array of ${P.length} Tensors, but expected ${S.length} to match the ${T} keys ${S}.`),P;{const L=[];for(const N of S){if(null==P[N])throw new c.nu(`The feature data generated by the dataset lacks the required ${T} key '${N}'.`);L.push(P[N])}return L}}function r(T,S,P){return d.apply(this,arguments)}function d(){return(d=(0,e.Z)(function*(T,S,P){const L=null!=P.batchesPerEpoch;if(a.D5U.assert(null!=T.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),a.D5U.assert(null!=P,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),a.D5U.assert(null!=P.epochs&&P.epochs>0&&Number.isInteger(P.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${P.epochs}`),a.D5U.assert(!L||P.batchesPerEpoch>0&&Number.isInteger(P.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${P.batchesPerEpoch}`),a.D5U.assert(null==P.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),T.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");T.isTraining=!0;try{const N=null!=P.validationData;let O,b;if(N)if(g(P.validationData))a.D5U.assert(null==P.validationBatches||P.validationBatches>0&&Number.isInteger(P.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${P.validationBatches}`);else{const Pt=function s(T){if(3===T.length)throw new c.nj("Validation with sample weights is not implemented yet.");return{xs:T[0],ys:T[1]}}(P.validationData);O=Pt.xs,b=Pt.ys}const E=T.makeTrainFunction(),$=T.getDedupedMetricsNames();let W;W=N?$.slice().concat($.map(Pt=>"val_"+Pt)):$.slice();const Z=(0,u.CZ)(P.callbacks,P.yieldEvery),X=null==P.verbose?1:P.verbose,{callbackList:ut,history:Dt}=(0,u.m$)(Z,X,P.epochs,null,null,function p(T,S){let P=null;return null!=S.batchesPerEpoch?P=S.batchesPerEpoch:Number.isFinite(T.size)&&(P=T.size),P}(S,P),null,N,W);ut.setModel(T),T.history=Dt,yield ut.onTrainBegin(),T.stopTraining_=!1;let Y=null==P.initialEpoch?0:P.initialEpoch,ht=yield S.iterator();for(;Y<P.epochs;){const Pt={};yield ut.onEpochBegin(Y);let pt=0,xt=0;for(L||(ht=yield S.iterator());!L||pt<P.batchesPerEpoch;){const Nt=yield ht.next();if(L&&Nt.done){console.warn(`You provided \`batchesPerEpoch\` as ${P.batchesPerEpoch}, but your dataset iterator ran out of data after ${pt} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${P.batchesPerEpoch*P.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=Nt.value){const{xs:Vt,ys:Gt}=o(T,Nt.value),oe={};oe.batch=xt,oe.size=Vt[0].shape[0],yield ut.onBatchBegin(xt,oe);const Ee=[];if(null!=P.classWeight){const Zt=(0,f.Vf)(P.classWeight,T.outputNames);for(let ct=0;ct<Zt.length;++ct)Ee.push(yield(0,f.tl)(Gt[ct],null,Zt[ct]))}const Ie=Vt.concat(Gt).concat(Ee),ie=E(Ie);a.B90(Ie);for(let Zt=0;Zt<$.length;++Zt){const It=ie[Zt];oe[$[Zt]]=It,a.CnY(It)}yield ut.onBatchEnd(xt,oe),(0,h.i)(oe),xt++,pt++}if(L?pt>=P.batchesPerEpoch:Nt.done){if(N){let Vt;Vt=g(P.validationData)?(0,i.zZ)(yield T.evaluateDataset(P.validationData,{batches:P.validationBatches})):(0,i.zZ)(T.evaluate(O,b,{batchSize:null==P.validationBatchSize?32:P.validationBatchSize,verbose:0}));for(let Gt=0;Gt<T.metricsNames.length;++Gt)Pt[`val_${T.metricsNames[Gt]}`]=Vt[Gt]}break}if(T.stopTraining_)break}if(yield ut.onEpochEnd(Y,Pt),Y++,T.stopTraining_)break}return yield ut.onTrainEnd(),yield T.history.syncData(),T.history}finally{T.isTraining=!1}})).apply(this,arguments)}function g(T){return"function"==typeof T.iterator}function v(T,S,P){return M.apply(this,arguments)}function M(){return(M=(0,e.Z)(function*(T,S,P){const L=null!=(P=P||{}).batches,N=T.testFunction;let O=[];if(P.verbose>0)throw new c.nj("Verbose mode is not implemented yet.");a.D5U.assert(!L||P.batches>0&&Number.isInteger(P.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(P.batches)}`);const b=function _(T){return"function"==typeof T.next}(S)?S:yield S.iterator();let E=0,$=0;for(;!L||$<P.batches;){const W=yield b.next();if(O=a.lub(()=>{if(W.value){const{xs:Z,ys:X}=o(T,W.value),ut=Z.concat(X),Dt=a.lub(()=>N(ut));if(a.B90(ut),0===$)for(let ht=0;ht<Dt.length;++ht)O.push((0,a.iD$)(0));const Y=ut[0].shape[0];for(let ht=0;ht<Dt.length;++ht){const Pt=Dt[ht],pt=O[ht];O[ht]=a.lub(()=>a.IHx(O[ht],a.dC7(Y,Pt))),$>0&&a.B90(pt)}a.B90(Dt),E+=Y,++$}return O}),W.done){L&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${P.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let W=0;W<O.length;++W){const Z=O[W];O[W]=a.hiC(O[W],E),a.B90(Z)}return(0,i.Bq)(O)})).apply(this,arguments)}},86765:(H,C,t)=>{"use strict";t.d(C,{R_:()=>i,YV:()=>f,YX:()=>h,fQ:()=>u,kS:()=>l,sf:()=>c});var e=t(30003),a=t(12992);function u(o){e.D5U.assert(o>0&&Number.isInteger(o),()=>`batchSize is required to be a positive integer, but got ${o}`)}function c(o,n,s){return null==o?[null]:Array.isArray(o)?o.map(r=>(0,a.c9)(r,n,s-n)):(0,a.c9)(o,n,s-n)}function h(o,n){return e.lub(()=>null==o?null:Array.isArray(o)?o.map(s=>h(s,n)):(0,a.Iq)(o,"int32"===n.dtype?n:e.pju(n,"int32")))}function i(o,n){const s=[];let r=0,d=null;for(;r<o;)d=r+n,d>=o&&(d=o),s.push([r,d]),r=d;return s}function f(o){const n=[];o instanceof e.esB&&(o=[o]);for(let s=0;s<o.length;++s){const r=o[s];if(1===r.rank)n.push((0,a.dt)(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(r)}}return n}function l(o,n){if(null==o)return;const s=[];if(n instanceof e.esB)s.push(n.id);else if(Array.isArray(n))n.forEach(d=>s.push(d.id));else if(null!=n)for(const d in n)s.push(n[d].id);const r=[];if(o instanceof e.esB)-1===s.indexOf(o.id)&&r.push(o);else if(Array.isArray(o))o.forEach(d=>{-1===s.indexOf(d.id)&&r.push(d)});else if(null!=o)for(const d in o){const p=o[d];-1===s.indexOf(p.id)&&r.push(p)}r.forEach(d=>{d.isDisposed||d.dispose()})}},69001:(H,C,t)=>{"use strict";t.d(C,{Vf:()=>c,mo:()=>l,tl:()=>i});var e=t(15861),a=t(30003);function c(o,n){return function u(o,n,s){const r=n.length;if(null==o||Array.isArray(o)&&0===o.length)return n.map(d=>null);if(1===r)return Array.isArray(o)&&1===o.length?o:"object"==typeof o&&n[0]in o?[o[n[0]]]:[o];if(Array.isArray(o)){if(o.length!==r)throw new Error(`Provided ${s} is an array of ${o.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return o}if("object"==typeof o&&Object.keys(o).length>0&&"object"==typeof o[Object.keys(o)[0]]){const d=[];return n.forEach(p=>{d.push(p in o?o[p]:null)}),d}throw new Error(`The model has multiple (${r}) outputs, so ${s} must be either an array with ${r} elements or an object with ${n} keys. Provided ${s} not understood: ${JSON.stringify(o)}`)}(o,n,"classWeight")}function i(o,n,s,r){return f.apply(this,arguments)}function f(){return(f=(0,e.Z)(function*(o,n,s,r){if(null!=n||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=s){const d=(0,a.lub)(()=>{if(1===o.shape.length)return(0,a.d9v)(o);if(2===o.shape.length){if(o.shape[1]>1)return(0,a.NqF)(o,1);if(1===o.shape[1])return(0,a.XLQ)(o,[o.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${o.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${o.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),p=Array.from(yield d.data());(0,a.B90)(d);const g=[];return p.forEach(_=>{if(null==s[_])throw new Error(`classWeight must contain all classes in the training data. The class ${_} exists in the data but not in classWeight`);g.push(s[_])}),(0,a.RRF)(g,"float32")}return null})).apply(this,arguments)}function l(o,n){return(0,a.dC7)(o,n)}},18357:(H,C,t)=>{"use strict";t.d(C,{LH:()=>a,j1:()=>e,nj:()=>c,nu:()=>u,ps:()=>h});class e extends Error{constructor(l){super(l),Object.setPrototypeOf(this,e.prototype)}}class a extends Error{constructor(l){super(l),Object.setPrototypeOf(this,a.prototype)}}class u extends Error{constructor(l){super(l),Object.setPrototypeOf(this,u.prototype)}}class c extends Error{constructor(l){super(l),Object.setPrototypeOf(this,c.prototype)}}class h extends Error{constructor(l){super(l),Object.setPrototypeOf(this,h.prototype)}}},99246:(H,C,t)=>{"use strict";var e=t(30003),a=t(7405);(0,e.OBj)().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,a.kS)},4555:(H,C,t)=>{"use strict";t.d(C,{MK:()=>c,Mz:()=>a,PS:()=>e,eY:()=>h,zx:()=>u});const e=["channelsFirst","channelsLast"],a=["nearest","bilinear"],u=["valid","same","causal"],c=["max","avg"],h=["sum","mul","concat","ave"]},1065:(H,C,t)=>{"use strict";t.d(C,{J7:()=>a,RR:()=>e});const e=["fanIn","fanOut","fanAvg"],a=["normal","uniform","truncatedNormal"]},13680:(H,C,t)=>{"use strict";t.d(C,{n:()=>h});var e=t(30003),a=t(8022),u=t(18357),c=t(12992);function h(i,f,l,o){let n=(0,a.nQ)(i);if("int32"!==n.dtype&&(n=c.pj(n,"int32")),"int"===f)return n;const s=n.shape;if(0===n.rank&&(n=(0,e.dt4)(n,-1)),"oneHot"===f&&1!==n.shape[n.shape.length-1]&&(n=(0,e.dt4)(n,-1)),n.rank>2)throw new u.nu(`When outputMode is not int, maximum output rank is 2 Received outputMode ${f} and input shape ${s} which would result in output rank ${n.rank}.`);const r=["multiHot","oneHot"].includes(f);let p;if(p=(0,e.ppE)(n,typeof o<"u"&&"count"===f?o:[],l,r),"tfIdf"!==f)return p;if(o)return(0,e.dC7)(p,o);throw new u.nu("When outputMode is 'tfIdf', weights must be provided.")}},28467:(H,C,t)=>{"use strict";t.d(C,{v:()=>u});var e=t(30003),a=t(42688);function u(c,h={},i=!1){return(0,a.tU)(c,e.m7h.SerializationMap.getMap().classNameMap,h,"layer",i)}},23313:(H,C,t)=>{"use strict";t.d(C,{j:()=>c});var e=t(30003),a=t(73915),u=t(18357);function c(h){const i={Adagrad:()=>e.p_j.adagrad(.01),Adadelta:()=>e.p_j.adadelta(1,.95,(0,a.Ho)()),Adam:()=>e.p_j.adam(.001,.9,.999,(0,a.Ho)()),Adamax:()=>e.p_j.adamax(.002,.9,.999,(0,a.Ho)(),0),RMSProp:()=>e.p_j.rmsprop(.001,.9,0,(0,a.Ho)()),SGD:()=>e.p_j.sgd(.01)};if(i.adagrad=i.Adagrad,i.adadelta=i.Adadelta,i.adam=i.Adam,i.adamax=i.Adamax,i.rmsprop=i.RMSProp,i.sgd=i.SGD,h in i)return i[h]();throw new u.nu(`Unknown Optimizer ${h}`)}},26887:(H,C,t)=>{"use strict";t.d(C,{WE:()=>a});const e=1048576;function a(c,h,i=!1){if(null==c||"object"!=typeof c||Object.getPrototypeOf(c)!==Object.prototype||!u(c))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(i){const f=JSON.stringify(c);f.length>e&&console.warn(`User-defined metadata of model "${h}" is too large in size (length=${f.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${e}.`)}}function u(c){if(null===c)return!0;if("object"==typeof c){if(Object.getPrototypeOf(c)===Object.prototype){const h=Object.keys(c);for(const i of h)if("string"!=typeof i||!u(c[i]))return!1;return!0}if(Array.isArray(c)){for(const h of c)if(!u(h))return!1;return!0}return!1}{const h=typeof c;return"string"===h||"number"===h||"boolean"===h}}},20154:(H,C,t)=>{"use strict";t.d(C,{$U:()=>i,AF:()=>c,kt:()=>h});var e=t(18357),a=t(42688),u=t(57774);function c(f,l,o){if("number"==typeof f)return(0,a.JE)(f,l);if(f.length!==l)throw new e.nu(`The ${o} argument must be an integer or tuple of ${l} integers. Received: ${f.length} elements.`);for(let n=0;n<l;++n){const s=f[n];if(!(0,u.U)(s))throw new e.nu(`The ${o} argument must be an integer or tuple of ${l} integers. Received: ${JSON.stringify(f)} including a non-integer number ${s}`)}return f}function h(f,l,o,n,s=1){if(null==f)return f;let d;return d="same"===o?f:f-(l+(l-1)*(s-1))+1,Math.floor((d+n-1)/n)}function i(f,l,o,n){if(null==f)return null;if("valid"===n)f=f*l+(0,u.Fp)([o-l,0]);else{if("same"!==n)throw new e.nu(`Unsupport padding mode: ${n}.`);f*=l}return f}},86493:(H,C,t)=>{"use strict";t.d(C,{I:()=>a});var e=t(37055);function a(l,o,n,s=console.log){const r=function c(l){let o=!0;const n=[],s=[];for(const r in l.nodesByDepth)n.push(l.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){o=!1;break}s.push(...r)}if(o)for(const r of l.layers){let d=!1;for(const p of r.inboundNodes)if(-1!==s.indexOf(p)){if(d){o=!1;break}d=!0}if(!o)break}return o}(l),d=["Layer (type)","Input Shape","Output shape","Param #"];let p;if(r?(o=o||90,n=n||[.32,.61,.89,1]):(o=o||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(M=>Math.floor(o*M))),!r){d.push("Receives inputs"),p=[];for(const M in l.nodesByDepth)p.push(...l.nodesByDepth[M])}s("_".repeat(o)),h(d,n,s),s("=".repeat(o));const g=l.layers;for(let M=0;M<g.length;++M)r?i(g[M],n,s):f(g[M],n,p,s),s((M===g.length-1?"=":"_").repeat(o));l.checkTrainableWeightsConsistency();const _=function u(l){let o;return o=(0,e.t)(null!=l.collectedTrainableWeights?l.collectedTrainableWeights:l.trainableWeights),o}(l),v=(0,e.t)(l.nonTrainableWeights);s(`Total params: ${_+v}`),s(`Trainable params: ${_}`),s(`Non-trainable params: ${v}`),s("_".repeat(o))}function h(l,o,n=console.log){let s="";for(let r=0;r<l.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=l[r],s=s.slice(0,o[r]),s+=" ".repeat(o[r]-s.length);n(s)}function i(l,o,n){let s,r;try{r=l.inboundNodes.map(_=>JSON.stringify(_.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(l.outputShape)}catch{s="multiple"}h([`${l.name} (${l.getClassName()})`,r,s,l.countParams().toString()],o,n)}function f(l,o,n,s){let r,d;try{d=l.inboundNodes.map(T=>JSON.stringify(T.inputShapes)).join(",")}catch{d="multiple"}try{r=JSON.stringify(l.outputShape)}catch{r="multiple"}const p=[];for(const T of l.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(T)))for(let S=0;S<T.inboundLayers.length;++S)p.push(`${T.inboundLayers[S].name}[${T.nodeIndices[S]}][${T.tensorIndices[S]}]`);const g=l.name,_=l.getClassName(),v=0===p.length?"":p[0];h([`${g} (${_})`,d,r,l.countParams().toString(),v],o,s);for(let T=1;T<p.length;++T)h(["","","","",p[T]],o,s)}},57774:(H,C,t)=>{"use strict";t.d(C,{Fp:()=>h,NS:()=>u,U:()=>a,VV:()=>c,w6:()=>n});var e=t(18357);function a(s){return s===parseInt(s.toString(),10)}function u(s,r,d){null==r&&(r=0),null==d&&(d=s.length);let p=1;for(let g=r;g<d;++g)p*=s[g];return p}function c(s){if(0===s.length)return Number.NaN;let r=Number.POSITIVE_INFINITY;for(let d=0;d<s.length;d++){const p=s[d];p<r&&(r=p)}return r}function h(s){if(0===s.length)return Number.NaN;let r=Number.NEGATIVE_INFINITY;for(let d=0;d<s.length;d++){const p=s[d];p>r&&(r=p)}return r}function n(s,r){if(r<s)throw new e.nu(`end (${r}) < begin (${s}) is forbidden.`);const d=[];for(let p=s;p<r;++p)d.push(p);return d}},8022:(H,C,t)=>{"use strict";t.d(C,{Wf:()=>h,XO:()=>a,nQ:()=>c,x6:()=>u});var e=t(18357);function a(i){return Array.isArray(i)&&Array.isArray(i[0])}function u(i){return 0===i.length?[]:Array.isArray(i[0])?i:[i]}function c(i){let f;if(Array.isArray(i)){if(1!==i.length)throw new e.nu(`Expected Tensor length to be 1; got ${i.length}`);f=i[0]}else f=i;return f}function h(i){if(Array.isArray(i)&&Array.isArray(i[0])){if(1===i.length)return i[0];throw new e.nu(`Expected exactly 1 Shape; got ${i.length}`)}return i}},37055:(H,C,t)=>{"use strict";function e(a){let u=0;for(const c of a)u+=0===c.shape.length?1:c.shape.reduce((h,i)=>h*i);return u}t.d(C,{t:()=>e})},18032:(H,C,t)=>{"use strict";t.d(C,{i:()=>e});const e="4.22.0"},42006:(H,C,t)=>{"use strict";t.d(C,{i:()=>e});const e="4.22.0"},78645:(H,C,t)=>{"use strict";t.d(C,{x:()=>f});var e=t(65592),a=t(55113);const c=(0,t(82306).d)(o=>function(){o(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});var h=t(49039),i=t(81441);let f=(()=>{class o extends e.y{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(s){const r=new l(this,this);return r.operator=s,r}_throwIfClosed(){if(this.closed)throw new c}next(s){(0,i.x)(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(s)}})}error(s){(0,i.x)(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=s;const{observers:r}=this;for(;r.length;)r.shift().error(s)}})}complete(){(0,i.x)(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:s}=this;for(;s.length;)s.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var s;return(null===(s=this.observers)||void 0===s?void 0:s.length)>0}_trySubscribe(s){return this._throwIfClosed(),super._trySubscribe(s)}_subscribe(s){return this._throwIfClosed(),this._checkFinalizedStatuses(s),this._innerSubscribe(s)}_innerSubscribe(s){const{hasError:r,isStopped:d,observers:p}=this;return r||d?a.Lc:(this.currentObservers=null,p.push(s),new a.w0(()=>{this.currentObservers=null,(0,h.P)(p,s)}))}_checkFinalizedStatuses(s){const{hasError:r,thrownError:d,isStopped:p}=this;r?s.error(d):p&&s.complete()}asObservable(){const s=new e.y;return s.source=this,s}}return o.create=(n,s)=>new l(n,s),o})();class l extends f{constructor(n,s){super(),this.destination=n,this.source=s}next(n){var s,r;null===(r=null===(s=this.destination)||void 0===s?void 0:s.next)||void 0===r||r.call(s,n)}error(n){var s,r;null===(r=null===(s=this.destination)||void 0===s?void 0:s.error)||void 0===r||r.call(s,n)}complete(){var n,s;null===(s=null===(n=this.destination)||void 0===n?void 0:n.complete)||void 0===s||s.call(n)}_subscribe(n){var s,r;return null!==(r=null===(s=this.source)||void 0===s?void 0:s.subscribe(n))&&void 0!==r?r:a.Lc}}},55113:(H,C,t)=>{"use strict";t.d(C,{Lc:()=>h,Nn:()=>i,w0:()=>c});var e=t(84674),a=t(59732),u=t(49039);class c{constructor(o){this.initialTeardown=o,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let o;if(!this.closed){this.closed=!0;const{_parentage:n}=this;if(n)if(this._parentage=null,Array.isArray(n))for(const d of n)d.remove(this);else n.remove(this);const{initialTeardown:s}=this;if((0,e.m)(s))try{s()}catch(d){o=d instanceof a.B?d.errors:[d]}const{_finalizers:r}=this;if(r){this._finalizers=null;for(const d of r)try{f(d)}catch(p){o=o??[],p instanceof a.B?o=[...o,...p.errors]:o.push(p)}}if(o)throw new a.B(o)}}add(o){var n;if(o&&o!==this)if(this.closed)f(o);else{if(o instanceof c){if(o.closed||o._hasParent(this))return;o._addParent(this)}(this._finalizers=null!==(n=this._finalizers)&&void 0!==n?n:[]).push(o)}}_hasParent(o){const{_parentage:n}=this;return n===o||Array.isArray(n)&&n.includes(o)}_addParent(o){const{_parentage:n}=this;this._parentage=Array.isArray(n)?(n.push(o),n):n?[n,o]:o}_removeParent(o){const{_parentage:n}=this;n===o?this._parentage=null:Array.isArray(n)&&(0,u.P)(n,o)}remove(o){const{_finalizers:n}=this;n&&(0,u.P)(n,o),o instanceof c&&o._removeParent(this)}}c.EMPTY=(()=>{const l=new c;return l.closed=!0,l})();const h=c.EMPTY;function i(l){return l instanceof c||l&&"closed"in l&&(0,e.m)(l.remove)&&(0,e.m)(l.add)&&(0,e.m)(l.unsubscribe)}function f(l){(0,e.m)(l)?l():l.unsubscribe()}},24036:(H,C,t)=>{"use strict";t.d(C,{z:()=>u});var e=t(46973),a=t(80305);function u(c,h){const i="object"==typeof h;return new Promise((f,l)=>{const o=new a.Hp({next:n=>{f(n),o.unsubscribe()},error:l,complete:()=>{i?f(h.defaultValue):l(new e.K)}});c.subscribe(o)})}},46973:(H,C,t)=>{"use strict";t.d(C,{K:()=>a});const a=(0,t(82306).d)(u=>function(){u(this),this.name="EmptyError",this.message="no elements in sequence"})},69864:function(H,C,t){var e;!function(a,u){function h(o){var n=this,s=function l(){var o=4022871197;return function(s){s=String(s);for(var r=0;r<s.length;r++){var d=.02519603282416938*(o+=s.charCodeAt(r));d-=o=d>>>0,o=(d*=o)>>>0,o+=4294967296*(d-=o)}return 2.3283064365386963e-10*(o>>>0)}}();n.next=function(){var r=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=r-(n.c=0|r)},n.c=1,n.s0=s(" "),n.s1=s(" "),n.s2=s(" "),n.s0-=s(o),n.s0<0&&(n.s0+=1),n.s1-=s(o),n.s1<0&&(n.s1+=1),n.s2-=s(o),n.s2<0&&(n.s2+=1),s=null}function i(o,n){return n.c=o.c,n.s0=o.s0,n.s1=o.s1,n.s2=o.s2,n}function f(o,n){var s=new h(o),r=n&&n.state,d=s.next;return d.int32=function(){return 4294967296*s.next()|0},d.double=function(){return d()+11102230246251565e-32*(2097152*d()|0)},d.quick=d,r&&("object"==typeof r&&i(r,s),d.state=function(){return i(s,{})}),d}u&&u.exports?u.exports=f:t.amdD&&t.amdO?void 0!==(e=function(){return f}.call(C,t,C,u))&&(u.exports=e):this.alea=f}(0,H=t.nmd(H))},53789:function(H,C,t){var e;!function(a,u){function h(l){var o=this,n="";o.next=function(){var r=o.b,d=o.c,p=o.d,g=o.a;return r=r<<25^r>>>7^d,d=d-p|0,p=p<<24^p>>>8^g,g=g-r|0,o.b=r=r<<20^r>>>12^d,o.c=d=d-p|0,o.d=p<<16^d>>>16^g,o.a=g-r|0},o.a=0,o.b=0,o.c=-1640531527,o.d=1367130551,l===Math.floor(l)?(o.a=l/4294967296|0,o.b=0|l):n+=l;for(var s=0;s<n.length+20;s++)o.b^=0|n.charCodeAt(s),o.next()}function i(l,o){return o.a=l.a,o.b=l.b,o.c=l.c,o.d=l.d,o}function f(l,o){var n=new h(l),s=o&&o.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var g=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===g);return g},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&i(s,n),r.state=function(){return i(n,{})}),r}u&&u.exports?u.exports=f:t.amdD&&t.amdO?void 0!==(e=function(){return f}.call(C,t,C,u))&&(u.exports=e):this.tychei=f}(0,H=t.nmd(H))},93919:function(H,C,t){var e;!function(a,u){function h(l){var o=this,n="";o.x=0,o.y=0,o.z=0,o.w=0,o.next=function(){var r=o.x^o.x<<11;return o.x=o.y,o.y=o.z,o.z=o.w,o.w^=o.w>>>19^r^r>>>8},l===(0|l)?o.x=l:n+=l;for(var s=0;s<n.length+64;s++)o.x^=0|n.charCodeAt(s),o.next()}function i(l,o){return o.x=l.x,o.y=l.y,o.z=l.z,o.w=l.w,o}function f(l,o){var n=new h(l),s=o&&o.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var g=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===g);return g},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&i(s,n),r.state=function(){return i(n,{})}),r}u&&u.exports?u.exports=f:t.amdD&&t.amdO?void 0!==(e=function(){return f}.call(C,t,C,u))&&(u.exports=e):this.xor128=f}(0,H=t.nmd(H))},23358:function(H,C,t){var e;!function(a,u){function h(l){var o=this;o.next=function(){var p,g,s=o.w,r=o.X,d=o.i;return o.w=s=s+1640531527|0,g=r[d+34&127],p=r[d=d+1&127],g^=g<<13,p^=p<<17,g=r[d]=(g^=g>>>15)^(p^=p>>>12),o.i=d,g+(s^s>>>16)|0},function n(s,r){var d,p,g,_,v,M=[],T=128;for(r===(0|r)?(p=r,r=null):(r+="\0",p=0,T=Math.max(T,r.length)),g=0,_=-32;_<T;++_)r&&(p^=r.charCodeAt((_+32)%r.length)),0===_&&(v=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,_>=0&&(g=0==(d=M[127&_]^=p+(v=v+1640531527|0))?g+1:0);for(g>=128&&(M[127&(r&&r.length||0)]=-1),g=127,_=512;_>0;--_)p=M[g+34&127],d=M[g=g+1&127],p^=p<<13,d^=d<<17,M[g]=(p^=p>>>15)^(d^=d>>>12);s.w=v,s.X=M,s.i=g}(o,l)}function i(l,o){return o.i=l.i,o.w=l.w,o.X=l.X.slice(),o}function f(l,o){null==l&&(l=+new Date);var n=new h(l),s=o&&o.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var g=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===g);return g},r.int32=n.next,r.quick=r,s&&(s.X&&i(s,n),r.state=function(){return i(n,{})}),r}u&&u.exports?u.exports=f:t.amdD&&t.amdO?void 0!==(e=function(){return f}.call(C,t,C,u))&&(u.exports=e):this.xor4096=f}(0,H=t.nmd(H))},95353:function(H,C,t){var e;!function(a,u){function h(l){var o=this;o.next=function(){var d,p,s=o.x,r=o.i;return d=s[r],p=(d^=d>>>7)^d<<24,p^=(d=s[r+1&7])^d>>>10,p^=(d=s[r+3&7])^d>>>3,p^=(d=s[r+4&7])^d<<7,d=s[r+7&7],s[r]=p^=(d^=d<<13)^d<<9,o.i=r+1&7,p},function n(s,r){var d,g=[];if(r===(0|r))g[0]=r;else for(r=""+r,d=0;d<r.length;++d)g[7&d]=g[7&d]<<15^r.charCodeAt(d)+g[d+1&7]<<13;for(;g.length<8;)g.push(0);for(d=0;d<8&&0===g[d];++d);for(8==d&&(g[7]=-1),s.x=g,s.i=0,d=256;d>0;--d)s.next()}(o,l)}function i(l,o){return o.x=l.x.slice(),o.i=l.i,o}function f(l,o){null==l&&(l=+new Date);var n=new h(l),s=o&&o.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var g=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===g);return g},r.int32=n.next,r.quick=r,s&&(s.x&&i(s,n),r.state=function(){return i(n,{})}),r}u&&u.exports?u.exports=f:t.amdD&&t.amdO?void 0!==(e=function(){return f}.call(C,t,C,u))&&(u.exports=e):this.xorshift7=f}(0,H=t.nmd(H))},13263:function(H,C,t){var e;!function(a,u){function h(l){var o=this,n="";o.next=function(){var r=o.x^o.x>>>2;return o.x=o.y,o.y=o.z,o.z=o.w,o.w=o.v,(o.d=o.d+362437|0)+(o.v=o.v^o.v<<4^r^r<<1)|0},o.x=0,o.y=0,o.z=0,o.w=0,o.v=0,l===(0|l)?o.x=l:n+=l;for(var s=0;s<n.length+64;s++)o.x^=0|n.charCodeAt(s),s==n.length&&(o.d=o.x<<10^o.x>>>4),o.next()}function i(l,o){return o.x=l.x,o.y=l.y,o.z=l.z,o.w=l.w,o.v=l.v,o.d=l.d,o}function f(l,o){var n=new h(l),s=o&&o.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var g=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===g);return g},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&i(s,n),r.state=function(){return i(n,{})}),r}u&&u.exports?u.exports=f:t.amdD&&t.amdO?void 0!==(e=function(){return f}.call(C,t,C,u))&&(u.exports=e):this.xorwow=f}(0,H=t.nmd(H))},52508:function(H,C,t){var e;!function(a,u,c){var d,h=256,o=c.pow(h,6),n=c.pow(2,52),s=2*n,r=255;function p(P,L,N){var O=[],b=M(v((L=1==L?{entropy:!0}:L||{}).entropy?[P,S(u)]:P??function T(){try{var P;return d&&(P=d.randomBytes)?P=P(h):(P=new Uint8Array(h),(a.crypto||a.msCrypto).getRandomValues(P)),S(P)}catch{var L=a.navigator,N=L&&L.plugins;return[+new Date,a,N,a.screen,S(u)]}}(),3),O),E=new g(O),$=function(){for(var W=E.g(6),Z=o,X=0;W<n;)W=(W+X)*h,Z*=h,X=E.g(1);for(;W>=s;)W/=2,Z/=2,X>>>=1;return(W+X)/Z};return $.int32=function(){return 0|E.g(4)},$.quick=function(){return E.g(4)/4294967296},$.double=$,M(S(E.S),u),(L.pass||N||function(W,Z,X,ut){return ut&&(ut.S&&_(ut,E),W.state=function(){return _(E,{})}),X?(c.random=W,Z):W})($,b,"global"in L?L.global:this==c,L.state)}function g(P){var L,N=P.length,O=this,b=0,E=O.i=O.j=0,$=O.S=[];for(N||(P=[N++]);b<h;)$[b]=b++;for(b=0;b<h;b++)$[b]=$[E=r&E+P[b%N]+(L=$[b])],$[E]=L;(O.g=function(W){for(var Z,X=0,ut=O.i,Dt=O.j,Y=O.S;W--;)Z=Y[ut=r&ut+1],X=X*h+Y[r&(Y[ut]=Y[Dt=r&Dt+Z])+(Y[Dt]=Z)];return O.i=ut,O.j=Dt,X})(h)}function _(P,L){return L.i=P.i,L.j=P.j,L.S=P.S.slice(),L}function v(P,L){var b,N=[],O=typeof P;if(L&&"object"==O)for(b in P)try{N.push(v(P[b],L-1))}catch{}return N.length?N:"string"==O?P:P+"\0"}function M(P,L){for(var O,N=P+"",b=0;b<N.length;)L[r&b]=r&(O^=19*L[r&b])+N.charCodeAt(b++);return S(L)}function S(P){return String.fromCharCode.apply(0,P)}if(M(c.random(),u),H.exports){H.exports=p;try{d=t(75042)}catch{}}else void 0!==(e=function(){return p}.call(C,t,C,H))&&(H.exports=e)}(typeof self<"u"?self:this,[],Math)},34004:(H,C,t)=>{"use strict";t.d(C,{Z:()=>r});const a={randomUUID:typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};var u,c=new Uint8Array(16);function h(){if(!u&&!(u=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return u(c)}for(var i=[],f=0;f<256;++f)i.push((f+256).toString(16).slice(1));const r=function s(d,p,g){if(a.randomUUID&&!p&&!d)return a.randomUUID();var _=(d=d||{}).random||(d.rng||h)();if(_[6]=15&_[6]|64,_[8]=63&_[8]|128,p){g=g||0;for(var v=0;v<16;++v)p[g+v]=_[v];return p}return function l(d,p=0){return(i[d[p+0]]+i[d[p+1]]+i[d[p+2]]+i[d[p+3]]+"-"+i[d[p+4]]+i[d[p+5]]+"-"+i[d[p+6]]+i[d[p+7]]+"-"+i[d[p+8]]+i[d[p+9]]+"-"+i[d[p+10]]+i[d[p+11]]+i[d[p+12]]+i[d[p+13]]+i[d[p+14]]+i[d[p+15]]).toLowerCase()}(_)}},75410:()=>{},48628:()=>{},31601:()=>{},67792:()=>{},34977:()=>{},75042:()=>{}}]);