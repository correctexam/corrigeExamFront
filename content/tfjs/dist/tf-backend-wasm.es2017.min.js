/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!(function (e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? t(exports, require('@tensorflow/tfjs-core'), require('fs'), require('path'), require('perf_hooks'), require('os'))
    : 'function' == typeof define && define.amd
    ? define(['exports', '@tensorflow/tfjs-core', 'fs', 'path', 'perf_hooks', 'os'], t)
    : t(
        (((e = 'undefined' != typeof globalThis ? globalThis : e || self).tf = e.tf || {}), (e.tf.wasm = e.tf.wasm || {})),
        e.tf,
        e.fs,
        e.path,
        e.perf_hooks,
        e.require$$4,
      );
})(this, function (e, t, n, a, r, u) {
  'use strict';
  function i(e, t) {
    return (
      t.forEach(function (t) {
        t &&
          'string' != typeof t &&
          !Array.isArray(t) &&
          Object.keys(t).forEach(function (n) {
            if ('default' !== n && !(n in e)) {
              var a = Object.getOwnPropertyDescriptor(t, n);
              Object.defineProperty(
                e,
                n,
                a.get
                  ? a
                  : {
                      enumerable: !0,
                      get: function () {
                        return t[n];
                      },
                    },
              );
            }
          });
      }),
      e
    );
  }
  var s, o;
  let d;
  !(function (e) {
    (e[(e.float32 = 0)] = 'float32'),
      (e[(e.int32 = 1)] = 'int32'),
      (e[(e.bool = 2)] = 'bool'),
      (e[(e.string = 3)] = 'string'),
      (e[(e.complex64 = 4)] = 'complex64');
  })(s || (s = {})),
    (function (e) {
      (e[(e.linear = 0)] = 'linear'),
        (e[(e.relu = 1)] = 'relu'),
        (e[(e.relu6 = 2)] = 'relu6'),
        (e[(e.prelu = 3)] = 'prelu'),
        (e[(e.leakyrelu = 4)] = 'leakyrelu'),
        (e[(e.sigmoid = 5)] = 'sigmoid'),
        (e[(e.elu = 6)] = 'elu');
    })(o || (o = {}));
  const l = {
    kernelName: t._FusedMatMul,
    backendName: 'wasm',
    setupFunc: function (e) {
      d = e.wasm.cwrap(t._FusedMatMul, null, [
        'number',
        'array',
        'number',
        'number',
        'array',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { a: u, b: i, bias: s, preluActivationWeights: l } = n;
      if ('float32' !== u.dtype || 'float32' !== i.dtype) throw new Error('_FusedMatMul for non non-float32 tensors not yet supported.');
      const { transposeA: p, transposeB: c, activation: m, leakyreluAlpha: f } = r,
        h = a.dataIdMap.get(u.dataId).id,
        b = a.dataIdMap.get(i.dataId).id;
      let _ = 0;
      if (null != s) {
        const e = a.dataIdMap.get(s.dataId);
        if (1 !== e.shape.length) throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);
        _ = e.id;
      }
      const y = null == l ? 0 : a.dataIdMap.get(l.dataId).id,
        g = o[m];
      if (null == g) throw new Error(`${m} activation not yet supported for FusedConv2D in the wasm backend.`);
      const k = p ? u.shape[2] : u.shape[1],
        I = c ? i.shape[1] : i.shape[2],
        w = t.broadcast_util.assertAndGetBroadcastShape(u.shape.slice(0, -2), i.shape.slice(0, -2)),
        M = a.makeOutput([...w, k, I], u.dtype),
        S = a.dataIdMap.get(M.dataId).id,
        A = new Uint8Array(new Int32Array(u.shape).buffer),
        v = new Uint8Array(new Int32Array(i.shape).buffer);
      return d(h, A, u.shape.length, b, v, i.shape.length, p, c, g, _, y, f || 0, S), M;
    },
  };
  function p(e, n) {
    let a;
    return {
      kernelName: e,
      backendName: 'wasm',
      setupFunc: function (t) {
        a = t.wasm.cwrap(e, null, ['number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const {
            backend: r,
            inputs: { x: u },
          } = e,
          i = r.dataIdMap.get(u.dataId).id,
          o = r.makeOutput(u.shape, n || u.dtype),
          d = r.dataIdMap.get(o.dataId).id;
        return 0 === t.util.sizeFromShape(o.shape) || a(i, s[u.dtype], d), o;
      },
    };
  }
  const c = p(t.Abs),
    m = p(t.Acos),
    f = p(t.Acosh);
  function h(e, n, a) {
    let r;
    return {
      kernelName: e,
      backendName: 'wasm',
      setupFunc: function (t) {
        r = t.wasm.cwrap(e, null, ['number', 'array', 'number', 'number', 'array', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const { backend: n, inputs: u } = e,
          { a: i, b: o } = u,
          d = n.dataIdMap.get(i.dataId).id,
          l = n.dataIdMap.get(o.dataId).id,
          p = null != a ? a : i.dtype,
          c = t.backend_util.assertAndGetBroadcastShape(i.shape, o.shape),
          m = n.makeOutput(c, p);
        if (0 === t.util.sizeFromShape(c)) return m;
        const f = new Uint8Array(new Int32Array(i.shape).buffer),
          h = new Uint8Array(new Int32Array(o.shape).buffer),
          b = n.dataIdMap.get(m.dataId).id;
        return r(d, f, i.shape.length, l, h, o.shape.length, s[i.dtype], b), m;
      },
    };
  }
  const b = h(t.Add);
  let _;
  const y = {
    kernelName: t.AddN,
    backendName: 'wasm',
    setupFunc: function (e) {
      _ = e.wasm.cwrap(t.AddN, null, ['array', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a } = e,
        r = a.makeOutput(n[0].shape, n[0].dtype);
      if (0 === t.util.sizeFromShape(r.shape)) return r;
      const u = n.map(e => a.dataIdMap.get(e.dataId).id),
        i = new Uint8Array(new Int32Array(u).buffer),
        o = a.dataIdMap.get(r.dataId).id;
      return _(i, u.length, s[r.dtype], o), r;
    },
  };
  function g(e) {
    const {
      inputs: { x: n },
      backend: a,
    } = e;
    if ('string' === n.dtype) return t.tensor(a.readSync(n.dataId), n.shape, n.dtype);
    const r = a.makeOutput(n.shape, n.dtype),
      u = a.typedArrayFromHeap(n);
    return a.typedArrayFromHeap(r).set(u), r;
  }
  const k = { kernelName: t.Identity, backendName: 'wasm', kernelFunc: g };
  let I;
  function w(e) {
    const { inputs: t, backend: n, attrs: a } = e,
      [r, u] = (function (e, t) {
        const n = [],
          a = [];
        for (let r = 0; r < e.length; ++r) 1 !== e[r] && n.push(e[r]), 1 !== e[t[r]] && a.push(t[r]);
        for (let e = 0; e < a.length; ++e) {
          let t = -1;
          for (let n = 0; n < a.length; ++n) a[n] >= e && (-1 === t || a[t] > a[n]) && (t = n);
          a[t] = e;
        }
        return [n, a];
      })(t.x.shape, a.perm);
    let i = !0;
    for (let e = 0; e < u.length; e++) u[e] !== e && (i = !1);
    const o = (function (e, t) {
        const n = new Array(e.length);
        for (let a = 0; a < n.length; a++) n[a] = e[t[a]];
        return n;
      })(t.x.shape, a.perm),
      d = { dataId: t.x.dataId, shape: r, dtype: t.x.dtype };
    if (i) {
      const e = g({ inputs: t, backend: n });
      return (e.shape = o), e;
    }
    const l = n.makeOutput(o, d.dtype),
      p = n.dataIdMap.get(d.dataId).id,
      c = n.dataIdMap.get(l.dataId).id,
      m = new Uint8Array(new Int32Array(u).buffer),
      f = new Uint8Array(new Int32Array(d.shape).buffer);
    return I(p, f, d.shape.length, s[d.dtype], c, m, u.length), l;
  }
  const M = {
    kernelName: t.Transpose,
    backendName: 'wasm',
    kernelFunc: w,
    setupFunc: function (e) {
      I = e.wasm.cwrap(t.Transpose, null, ['number', 'array', 'number', 'number', 'number', 'array', 'number']);
    },
  };
  function S(e, n, a) {
    const r = e.shape,
      u = e.shape.length,
      i = t.util.parseAxisParam(n, r);
    let s = i;
    const o = t.backend_util.getAxesPermutation(s, u);
    let d = null,
      l = !1;
    if (null != o) {
      const n = new Array(u);
      for (let e = 0; e < n.length; e++) n[e] = r[o[e]];
      (s = t.backend_util.getInnerMostAxes(s.length, u)), (d = w({ inputs: { x: e }, attrs: { perm: o }, backend: a }));
      const i = a.dataIdMap.get(e.dataId).id;
      a.dataIdMap.get(d.dataId).id !== i && (l = !0);
    }
    return { transposed: d, originalAxes: i, axes: s, inputWasTransposed: l };
  }
  let A;
  const v = {
    kernelName: t.All,
    backendName: 'wasm',
    setupFunc: function (e) {
      A = e.wasm.cwrap(t.All, null, ['number, number, number']);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { axis: u, keepDims: i } = r,
        { x: s } = a;
      let o = n.dataIdMap.get(s.dataId).id,
        d = s;
      const { transposed: l, axes: p, originalAxes: c, inputWasTransposed: m } = S(s, u, n);
      if (m) {
        (d = l), (o = n.dataIdMap.get(l.dataId).id);
      }
      const f = d.shape.length;
      t.backend_util.assertAxesAreInnerMostDims('all', p, f);
      const [h, b] = t.backend_util.computeOutAndReduceShapes(d.shape, p),
        _ = t.util.sizeFromShape(b),
        y = n.makeOutput(h, s.dtype);
      if (0 !== t.util.sizeFromShape(d.shape)) {
        const e = n.dataIdMap.get(y.dataId).id;
        A(o, _, e);
      }
      if ((m && n.disposeData(l.dataId), i)) {
        const e = t.backend_util.expandShapeToKeepDim(y.shape, c);
        y.shape = e;
      }
      return y;
    },
  };
  let x;
  const F = {
    kernelName: t.Any,
    backendName: 'wasm',
    setupFunc: function (e) {
      x = e.wasm.cwrap(t.Any, null, ['number, number, number']);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { axis: u, keepDims: i } = r,
        { x: s } = a;
      let o = n.dataIdMap.get(s.dataId).id,
        d = s;
      const { transposed: l, axes: p, originalAxes: c, inputWasTransposed: m } = S(s, u, n);
      if (m) {
        (d = l), (o = n.dataIdMap.get(l.dataId).id);
      }
      const f = d.shape.length;
      t.backend_util.assertAxesAreInnerMostDims('any', p, f);
      const [h, b] = t.backend_util.computeOutAndReduceShapes(d.shape, p),
        _ = t.util.sizeFromShape(b),
        y = n.makeOutput(h, s.dtype);
      if (0 !== t.util.sizeFromShape(d.shape)) {
        const e = n.dataIdMap.get(y.dataId).id;
        x(o, _, e);
      }
      if ((m && n.disposeData(l.dataId), i)) {
        const e = t.backend_util.expandShapeToKeepDim(y.shape, c);
        y.shape = e;
      }
      return y;
    },
  };
  function N(e) {
    let n;
    return {
      kernelName: e,
      backendName: 'wasm',
      setupFunc: function (t) {
        n = t.wasm.cwrap(e, null, ['number', 'number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const { backend: a, inputs: r, attrs: u } = e,
          { axis: i } = u,
          { x: o } = r,
          d = a.dataIdMap.get(o.dataId).id;
        let l = d,
          p = o;
        const { transposed: c, axes: m, inputWasTransposed: f } = S(o, i, a);
        if (f) {
          const e = a.dataIdMap.get(c.dataId).id;
          e !== d && ((p = c), (l = e));
        }
        const h = p.shape.slice(0, -1),
          b = a.makeOutput(h, 'int32'),
          _ = a.dataIdMap.get(b.dataId).id,
          y = t.util.sizeFromShape(b.shape),
          g = p.shape[m[0]];
        return n(l, s[p.dtype], y, g, _), f && a.disposeData(c.dataId), b;
      },
    };
  }
  const D = N(t.ArgMax),
    R = N(t.ArgMin),
    E = p(t.Asin),
    P = p(t.Asinh),
    C = p(t.Atan),
    W = h(t.Atan2),
    O = p(t.Atanh);
  let T;
  const z = {
    kernelName: t.AvgPool,
    backendName: 'wasm',
    setupFunc: function (e) {
      T = e.wasm.cwrap(t.AvgPool, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, attrs: a, backend: r } = e,
        u = n.x,
        i = r.dataIdMap.get(u.dataId).id,
        { filterSize: s, strides: o, pad: d, dimRoundingMode: l } = a,
        p = t.backend_util.computePool2DInfo(u.shape, s, o, 1, d, l),
        c = p.filterHeight,
        m = p.filterWidth,
        f = p.padInfo.top,
        h = p.padInfo.right,
        b = p.padInfo.bottom,
        _ = p.padInfo.left,
        y = p.strideHeight,
        g = p.strideWidth,
        k = p.inChannels;
      if ('channelsLast' !== p.dataFormat)
        throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);
      if (1 !== p.dilationWidth || 1 !== p.dilationHeight)
        throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);
      const I = r.makeOutput(p.outShape, 'float32'),
        w = r.dataIdMap.get(I.dataId).id;
      return T(i, u.shape[0], u.shape[1], u.shape[2], c, m, f, h, b, _, y, g, k, w), I;
    },
  };
  let B;
  const H = {
    kernelName: t.AvgPool3D,
    backendName: 'wasm',
    setupFunc: function (e) {
      B = e.wasm.cwrap('AvgPool3D', null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { x: u } = n,
        { filterSize: i, strides: s, pad: o, dimRoundingMode: d, dataFormat: l } = r,
        p = t.backend_util.computePool3DInfo(u.shape, i, s, 1, o, d, l),
        c = a.makeOutput(p.outShape, u.dtype);
      return (
        B(
          a.dataIdMap.get(u.dataId).id,
          a.dataIdMap.get(c.dataId).id,
          p.batchSize,
          p.inChannels,
          p.inDepth,
          p.inHeight,
          p.inWidth,
          p.outDepth,
          p.outHeight,
          p.outWidth,
          p.strideDepth,
          p.strideHeight,
          p.strideWidth,
          p.dilationDepth,
          p.dilationHeight,
          p.dilationWidth,
          p.effectiveFilterDepth,
          p.effectiveFilterHeight,
          p.effectiveFilterWidth,
          p.padInfo.front,
          p.padInfo.top,
          p.padInfo.left,
        ),
        c
      );
    },
  };
  let L;
  const G = {
    kernelName: t.AvgPool3DGrad,
    backendName: 'wasm',
    setupFunc: function (e) {
      L = e.wasm.cwrap('AvgPool3DGrad', null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { dy: u, input: i } = n,
        { filterSize: s, strides: o, pad: d, dimRoundingMode: l } = r,
        p = t.backend_util.computePool3DInfo(i.shape, s, o, 1, d, l),
        c = a.makeOutput(i.shape, i.dtype);
      return (
        L(
          a.dataIdMap.get(u.dataId).id,
          a.dataIdMap.get(c.dataId).id,
          p.batchSize,
          p.inChannels,
          p.inDepth,
          p.inHeight,
          p.inWidth,
          p.outDepth,
          p.outHeight,
          p.outWidth,
          p.strideDepth,
          p.strideHeight,
          p.strideWidth,
          p.dilationDepth,
          p.dilationHeight,
          p.dilationWidth,
          p.effectiveFilterDepth,
          p.effectiveFilterHeight,
          p.effectiveFilterWidth,
          p.padInfo.front,
          p.padInfo.top,
          p.padInfo.left,
          p.filterDepth,
          p.filterHeight,
          p.filterWidth,
        ),
        c
      );
    },
  };
  let U;
  const j = {
    kernelName: t.AvgPoolGrad,
    backendName: 'wasm',
    setupFunc: function (e) {
      U = e.wasm.cwrap('AvgPoolGrad', null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { dy: u, input: i } = n,
        { filterSize: s, strides: o, pad: d } = r,
        l = t.backend_util.computePool2DInfo(i.shape, s, o, 1, d),
        p = a.makeOutput(i.shape, i.dtype);
      return (
        U(
          a.dataIdMap.get(u.dataId).id,
          a.dataIdMap.get(p.dataId).id,
          l.batchSize,
          l.inChannels,
          l.inHeight,
          l.inWidth,
          l.outHeight,
          l.outWidth,
          l.strideHeight,
          l.strideWidth,
          l.dilationHeight,
          l.dilationWidth,
          l.effectiveFilterHeight,
          l.effectiveFilterWidth,
          l.padInfo.top,
          l.padInfo.left,
          l.filterHeight,
          l.filterWidth,
        ),
        p
      );
    },
  };
  function q(e) {
    const { inputs: n, attrs: a } = e,
      { x: r } = n,
      { shape: u } = a,
      i = t.util.sizeFromShape(r.shape),
      s = t.util.inferFromImplicitShape(u, i);
    return (
      t.util.assert(
        i === t.util.sizeFromShape(s),
        () => `new shape: ${s}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`,
      ),
      e.backend.incRef(r.dataId),
      { dataId: r.dataId, shape: s, dtype: r.dtype }
    );
  }
  const V = { kernelName: t.Reshape, backendName: 'wasm', kernelFunc: q };
  let $;
  const K = {
    kernelName: t.BatchMatMul,
    backendName: 'wasm',
    setupFunc: function (e) {
      $ = e.wasm.cwrap(t.BatchMatMul, null, ['number', 'array', 'number', 'number', 'array', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { a: u, b: i } = n,
        { transposeA: s, transposeB: o } = r;
      if ('float32' !== u.dtype || 'float32' !== i.dtype) throw new Error('BatchMatMul for non non-float32 tensors not yet supported.');
      const d = u.shape.length,
        l = i.shape.length,
        p = s ? u.shape[d - 2] : u.shape[d - 1],
        c = o ? i.shape[l - 1] : i.shape[l - 2],
        m = s ? u.shape[d - 1] : u.shape[d - 2],
        f = o ? i.shape[l - 2] : i.shape[l - 1],
        h = u.shape.slice(0, -2),
        b = i.shape.slice(0, -2),
        _ = t.util.sizeFromShape(h),
        y = t.util.sizeFromShape(b),
        g = t.broadcast_util.assertAndGetBroadcastShape(u.shape.slice(0, -2), i.shape.slice(0, -2)).concat([m, f]);
      t.util.assert(
        p === c,
        () =>
          `Error in matMul: inner shapes (${p}) and (${c}) of Tensors with shapes ${u.shape} and ${i.shape} and transposeA=${s} and transposeB=${o} must match.`,
      );
      const k = o ? [y, f, c] : [y, c, f],
        I = q({ inputs: { x: u }, backend: a, attrs: { shape: s ? [_, p, m] : [_, m, p] } }),
        w = q({ inputs: { x: i }, backend: a, attrs: { shape: k } }),
        M = a.dataIdMap.get(I.dataId).id,
        S = a.dataIdMap.get(w.dataId).id,
        A = s ? I.shape[2] : I.shape[1],
        v = o ? w.shape[1] : w.shape[2],
        x = Math.max(_, y),
        F = a.makeOutput([x, A, v], I.dtype),
        N = a.dataIdMap.get(F.dataId).id,
        D = new Uint8Array(new Int32Array(I.shape).buffer),
        R = new Uint8Array(new Int32Array(w.shape).buffer);
      return $(M, D, I.shape.length, S, R, w.shape.length, s, o, N), a.disposeData(I.dataId), a.disposeData(w.dataId), (F.shape = g), F;
    },
  };
  function X(e, n, a, r, u) {
    const i = t.slice_util.isSliceContinous(r, n, a),
      s = t.util.sizeFromShape(a),
      o = t.util.computeStrides(r);
    if (i) {
      const a = t.slice_util.computeFlatOffset(n, o);
      return 'string' === u ? e.slice(a, a + s) : e.subarray(a, a + s);
    }
    const d = 'string' === u ? t.backend_util.fromUint8ToStringArray(e) : e,
      l = t.buffer(r, u, d),
      p = t.buffer(a, u);
    for (let e = 0; e < p.size; ++e) {
      const t = p.indexToLoc(e),
        a = t.map((e, t) => e + n[t]);
      p.set(l.get(...a), ...t);
    }
    return 'string' === u ? t.backend_util.fromStringArrayToUint8(p.values) : p.values;
  }
  t.backend_util.RowPartitionType;
  class Q {
    constructor(e, n, a, r, u, i) {
      (this.separator = t.util.encodeString(e)),
        (this.nGramWidths = n),
        (this.leftPad = t.util.encodeString(a)),
        (this.rightPad = t.util.encodeString(r)),
        (this.padWidth = u),
        (this.preserveShort = i);
    }
    getPadWidth(e) {
      return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
    }
    getNumNGrams(e, t) {
      const n = this.getPadWidth(t);
      return Math.max(0, e + 2 * n - t + 1);
    }
    createNGrams(e, t, n, a, r, u) {
      for (let i = 0; i < r; ++i) {
        const s = this.getPadWidth(u),
          o = Math.max(0, s - i),
          d = Math.max(0, s - (r - (i + 1))),
          l = u - (o + d),
          p = t + (o > 0 ? 0 : i - s);
        let c = 0;
        c += o * this.leftPad.length;
        for (let t = 0; t < l; ++t) c += e[p + t].length;
        c += d * this.rightPad.length;
        (c += (o + d + l - 1) * this.separator.length), (n[a + i] = new Uint8Array(c));
        const m = n[a + i];
        let f = 0;
        const h = e => e.forEach(e => (m[f++] = e));
        for (let e = 0; e < o; ++e) h(this.leftPad), h(this.separator);
        for (let t = 0; t < l - 1; ++t) h(e[p + t]), h(this.separator);
        if (l > 0) {
          h(e[p + l - 1]);
          for (let e = 0; e < d; ++e) h(this.separator), h(this.rightPad);
        } else {
          for (let e = 0; e < d - 1; ++e) h(this.rightPad), h(this.separator);
          h(this.rightPad);
        }
      }
    }
    compute(e, n) {
      const a = e.length,
        r = n.length;
      if (r > 0) {
        let e = n[0];
        if (0 !== e) throw new Error(`First split value must be 0, got ${e}`);
        for (let t = 1; t < r; ++t) {
          let r = n[t] >= e;
          if (((r = r && n[t] <= a), !r)) throw new Error(`Invalid split value ${n[t]}, must be in [${e}, ${a}]`);
          e = n[t];
        }
        if (e !== a) throw new Error(`Last split value must be data size. Expected ${a}, got ${e}`);
      }
      const u = r - 1,
        i = t.util.getArrayFromDType('int32', r);
      if (0 === a || 0 === r) {
        const e = new Array(a);
        for (let e = 0; e <= u; ++e) i[e] = 0;
        return [e, i];
      }
      i[0] = 0;
      for (let e = 1; e <= u; ++e) {
        const t = n[e] - n[e - 1];
        let a = 0;
        this.nGramWidths.forEach(e => {
          a += this.getNumNGrams(t, e);
        }),
          this.preserveShort && t > 0 && 0 === a && (a = 1),
          (i[e] = i[e - 1] + a);
      }
      const s = new Array(i[u]);
      for (let t = 0; t < u; ++t) {
        const a = n[t];
        let r = i[t];
        if (
          (this.nGramWidths.forEach(u => {
            const i = n[t + 1] - n[t],
              o = this.getNumNGrams(i, u);
            this.createNGrams(e, a, s, r, o, u), (r += o);
          }),
          this.preserveShort && r === i[t])
        ) {
          const u = n[t + 1] - n[t];
          if (0 === u) continue;
          const i = u + 2 * this.padWidth,
            o = 1;
          this.createNGrams(e, a, s, r, o, i);
        }
      }
      return [s, i];
    }
  }
  function J(e, t, n, a) {
    if (!e.length) return;
    if (0 === t.length) {
      for (let t = 0; t < e.length; ++t) a.push(e.subarray(t, t + 1));
      return;
    }
    if (1 === t.length) {
      const r = t[0];
      let u = e.indexOf(r);
      for (; -1 !== u; ) {
        const t = e.subarray(0, u);
        (n && 0 === t.length) || a.push(t), (u = (e = e.subarray(u + 1)).indexOf(r));
      }
      return void ((n && 0 === e.length) || a.push(e));
    }
    let r = 0;
    for (let u = 0; u < e.length + 1; u++)
      if (u === e.length || -1 !== t.indexOf(e[u])) {
        const t = e.subarray(r, u);
        (n && 0 === t.length) || a.push(t), (r = u + 1);
      }
  }
  function Z(e) {
    const {
        inputs: { x: n },
        attrs: { begin: a, size: r },
        backend: u,
      } = e,
      [i, s] = t.slice_util.parseSliceParams(n, a, r),
      o = t.slice_util.isSliceContinous(n.shape, i, s),
      d = u.readSync(n.dataId),
      l = u.makeOutput(s, n.dtype),
      p = t.util.computeStrides(n.shape),
      c = u.dataIdMap.get(l.dataId);
    if (o) {
      const e = t.slice_util.computeFlatOffset(i, p);
      if ('string' === n.dtype) c.stringBytes = d.slice(e, e + t.util.sizeFromShape(s));
      else {
        u.typedArrayFromHeap(l).set(d.subarray(e, e + t.util.sizeFromShape(s)));
      }
      return l;
    }
    if ('string' === n.dtype) {
      const e = X(d, i, s, n.shape, n.dtype);
      return (c.stringBytes = e), l;
    }
    const m = u.typedArrayFromHeap(l),
      f = n.shape.length;
    if (2 === f)
      !(function (e, t, n, a, r) {
        let u = 0;
        const i = a[0],
          s = a[1],
          o = i + r[0];
        for (let a = i; a < o; a++) {
          const i = a * t + s;
          n.set(e.subarray(i, i + r[1]), u), (u += r[1]);
        }
      })(d, p[0], m, i, s);
    else if (3 === f)
      !(function (e, t, n, a, r, u) {
        let i = 0;
        const s = r[0],
          o = r[1],
          d = r[2],
          l = s + u[0],
          p = o + u[1];
        for (let r = s; r < l; r++)
          for (let s = o; s < p; s++) {
            const o = r * t + s * n + d;
            a.set(e.subarray(o, o + u[2]), i), (i += u[2]);
          }
      })(d, p[0], p[1], m, i, s);
    else if (4 === f)
      !(function (e, t, n, a, r, u, i) {
        let s = 0;
        const o = u[0],
          d = u[1],
          l = u[2],
          p = o + i[0],
          c = d + i[1],
          m = l + i[2],
          f = u[3];
        for (let u = o; u < p; u++)
          for (let o = d; o < c; o++)
            for (let d = l; d < m; d++) {
              const l = u * t + o * n + d * a + f;
              r.set(e.subarray(l, l + i[3]), s), (s += i[3]);
            }
      })(d, p[0], p[1], p[2], m, i, s);
    else {
      const e = X(d, i, s, n.shape, n.dtype);
      m.set(e);
    }
    return l;
  }
  const Y = { kernelName: t.Slice, backendName: 'wasm', kernelFunc: Z };
  const ee = {
    kernelName: t.BatchToSpaceND,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { x: u } = n,
        { blockShape: i, crops: s } = r,
        o = i.reduce((e, t) => e * t),
        d = t.backend_util.getReshaped(u.shape, i, o),
        l = t.backend_util.getPermuted(d.length, i.length),
        p = t.backend_util.getReshapedPermuted(u.shape, i, o),
        c = t.backend_util.getSliceBeginCoords(s, i.length),
        m = t.backend_util.getSliceSize(p, s, i.length),
        f = q({ inputs: { x: u }, backend: a, attrs: { shape: d } }),
        h = w({ inputs: { x: f }, backend: a, attrs: { perm: l } }),
        b = q({ inputs: { x: h }, backend: a, attrs: { shape: p } }),
        _ = Z({ inputs: { x: b }, backend: a, attrs: { begin: c, size: m } });
      return a.disposeData(f.dataId), a.disposeData(h.dataId), a.disposeData(b.dataId), _;
    },
  };
  let te;
  const ne = {
      kernelName: t.Bincount,
      backendName: 'wasm',
      setupFunc: function (e) {
        te = e.wasm.cwrap(t.Bincount, null, ['number', 'number', 'boolean', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const { backend: t, inputs: n, attrs: a } = e,
          { x: r, weights: u } = n,
          { size: i } = a,
          o = 0 !== u.shape.reduce((e, t) => e * t, 1),
          d = 1 === r.shape.length ? [i] : [r.shape[0], i],
          l = t.makeOutput(d, u.dtype);
        function p(e) {
          return t.dataIdMap.get(e.dataId).id;
        }
        return te(p(r), i, o, p(u), s[u.dtype], p(l)), l;
      },
    },
    ae = h(t.BitwiseAnd);
  const re = {
    kernelName: t.BroadcastArgs,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: n, backend: a } = e,
        { s0: r, s1: u } = n,
        i = a.typedArrayFromHeap(r),
        s = a.typedArrayFromHeap(u),
        o = t.backend_util.assertAndGetBroadcastShape(Array.from(i), Array.from(s));
      return a.makeOutput([o.length], 'int32', void 0, new Int32Array(o));
    },
  };
  function ue(e) {
    const {
        inputs: { x: t },
        attrs: { dtype: n },
        backend: a,
      } = e,
      r = a.makeOutput(t.shape, n),
      u = a.typedArrayFromHeap(t);
    return a.typedArrayFromHeap(r).set(u), r;
  }
  const ie = { kernelName: t.Cast, backendName: 'wasm', kernelFunc: ue },
    se = p(t.Ceil);
  let oe;
  const de = {
    kernelName: t.ClipByValue,
    backendName: 'wasm',
    setupFunc: function (e) {
      oe = e.wasm.cwrap(t.ClipByValue, null, ['number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { x: r } = t,
        { clipValueMin: u, clipValueMax: i } = a,
        s = n.dataIdMap.get(r.dataId).id,
        o = n.makeOutput(r.shape, r.dtype),
        d = n.dataIdMap.get(o.dataId).id;
      return oe(s, u, i, d), o;
    },
  };
  function le(e) {
    const { inputs: n, backend: a } = e,
      r = t.util.parseAxisParam(e.attrs.axis, n[0].shape)[0],
      u = n.map(e => e.shape);
    t.backend_util.assertParamsConsistent(u, r);
    let i = t.backend_util.computeOutShape(
      n.map(e => e.shape),
      r,
    );
    const s = n.filter(e => t.util.sizeFromShape(e.shape) > 0);
    if (1 === s.length) return g({ inputs: { x: s[0] }, backend: a });
    const o = a.makeOutput(i, n[0].dtype);
    if (0 === t.util.sizeFromShape(i)) return o;
    if ('string' === s[0].dtype) {
      const e = s.map(e => {
          const n = t.util.sizeFromShape(e.shape.slice(r));
          return q({ inputs: { x: e }, backend: a, attrs: { shape: [-1, n] } });
        }),
        u = e.map(e => ({ vals: a.readSync(e.dataId), shape: e.shape }));
      i = t.backend_util.computeOutShape(
        e.map(e => e.shape),
        1,
      );
      const d = 1 === e[0].shape[0],
        l = (function (e, n, a, r) {
          const u = t.util.getArrayFromDType(a, t.util.sizeFromShape(n));
          if (r && 'string' !== a) {
            let n = 0;
            e.forEach(e => {
              const a = t.util.sizeFromShape(e.shape);
              u.set(e.vals, n), (n += a);
            });
          } else {
            let r = 0;
            e.forEach(e => {
              const i = 'string' === a ? t.backend_util.fromUint8ToStringArray(e.vals) : e.vals;
              let s = 0;
              for (let t = 0; t < e.shape[0]; ++t) {
                const a = t * n[1] + r;
                for (let t = 0; t < e.shape[1]; ++t) u[a + t] = i[s++];
              }
              r += e.shape[1];
            });
          }
          return u;
        })(u, i, n[0].dtype, d),
        p = t.backend_util.computeOutShape(
          s.map(e => e.shape),
          r,
        );
      o.shape = p;
      return (a.dataIdMap.get(o.dataId).stringBytes = t.backend_util.fromStringArrayToUint8(l)), e.forEach(e => a.disposeData(e.dataId)), o;
    }
    const d = t.util.sizeFromShape(s[0].shape.slice(0, r));
    let l = 0;
    const p = s.map(e => {
        const n = t.util.sizeFromShape(e.shape.slice(r));
        return (l += n), n;
      }),
      c = s.map(e => a.typedArrayFromHeap(e)),
      m = a.typedArrayFromHeap(o);
    for (let e = 0; e < d; e++) {
      let t = e * l;
      for (let n = 0; n < c.length; n++) {
        const a = p[n],
          r = e * a,
          u = c[n].subarray(r, r + a);
        m.set(u, t), (t += a);
      }
    }
    return o;
  }
  const pe = { kernelName: t.Concat, backendName: 'wasm', kernelFunc: le };
  let ce;
  const me = {
    kernelName: t.Conv2D,
    backendName: 'wasm',
    setupFunc: function (e) {
      ce = e.wasm.cwrap(t.Conv2D, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, attrs: a, backend: r } = e,
        { x: u, filter: i } = n,
        s = r.dataIdMap.get(u.dataId).id,
        o = r.dataIdMap.get(i.dataId).id,
        { strides: d, dilations: l, pad: p, dimRoundingMode: c, dataFormat: m } = a,
        f = t.backend_util.convertConv2DDataFormat(m),
        h = t.backend_util.computeConv2DInfo(u.shape, i.shape, d, l, p, c, !1, f),
        b = h.filterHeight,
        _ = h.filterWidth,
        y = h.padInfo.top,
        g = h.padInfo.right,
        k = h.padInfo.bottom,
        I = h.padInfo.left,
        w = h.dilationHeight,
        M = h.dilationWidth,
        S = h.strideHeight,
        A = h.strideWidth,
        v = h.inChannels,
        x = h.outChannels,
        F = 'SAME' === h.padInfo.type ? 1 : 0;
      if ('channelsLast' !== h.dataFormat)
        throw new Error(`wasm backend Conv2D does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);
      const N = r.makeOutput(h.outShape, 'float32'),
        D = r.dataIdMap.get(N.dataId).id;
      return ce(s, u.shape[0], u.shape[1], u.shape[2], o, b, _, y, g, k, I, F, w, M, S, A, v, x, D), N;
    },
  };
  let fe;
  const he = {
    kernelName: t.Conv2DBackpropInput,
    backendName: 'wasm',
    setupFunc: function (e) {
      fe = e.wasm.cwrap(t.Conv2DBackpropInput, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { dy: u, filter: i } = a,
        { strides: s, pad: o, dataFormat: d, dimRoundingMode: l, inputShape: p } = r,
        c = t.backend_util.convertConv2DDataFormat(d),
        m = t.backend_util.computeConv2DInfo(p, i.shape, s, 1, o, l, !1, c),
        {
          batchSize: f,
          filterHeight: h,
          filterWidth: b,
          inChannels: _,
          inHeight: y,
          inWidth: g,
          outChannels: k,
          outHeight: I,
          outWidth: w,
          strideHeight: M,
          strideWidth: S,
        } = m,
        A = h - 1 - m.padInfo.top,
        v = b - 1 - m.padInfo.left,
        x = 'channelsLast' === m.dataFormat,
        F = t.util.computeStrides(m.inShape),
        N = t.util.computeStrides(u.shape),
        [D, R, E] = t.util.computeStrides(i.shape),
        P = F[0],
        C = x ? F[1] : F[2],
        W = x ? F[2] : 1,
        O = x ? 1 : F[1],
        T = N[0],
        z = x ? N[1] : N[2],
        B = x ? N[2] : 1,
        H = x ? 1 : N[1],
        L = n.makeOutput(m.inShape, 'float32'),
        G = n.dataIdMap.get(L.dataId).id,
        U = n.dataIdMap.get(u.dataId).id,
        j = n.dataIdMap.get(i.dataId).id;
      return fe(U, j, f, h, b, y, g, _, I, w, k, M, S, A, v, D, R, E, P, C, W, O, T, z, B, H, G), L;
    },
  };
  let be;
  const _e = {
    kernelName: t.Conv3D,
    backendName: 'wasm',
    setupFunc: function (e) {
      be = e.wasm.cwrap(t.Conv3D, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { x: u, filter: i } = n,
        { strides: s, pad: o, dilations: d } = r;
      if ('float32' !== u.dtype) throw new Error(`Tensor x must have dtype float32, got ${u.dtype}`);
      if ('float32' !== i.dtype) throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);
      const l = t.backend_util.computeConv3DInfo(u.shape, i.shape, s, d, o),
        p = a.makeOutput(l.outShape, u.dtype);
      return (
        be(
          a.dataIdMap.get(u.dataId).id,
          a.dataIdMap.get(i.dataId).id,
          a.dataIdMap.get(p.dataId).id,
          l.batchSize,
          l.inDepth,
          l.inHeight,
          l.inWidth,
          l.inChannels,
          l.outDepth,
          l.outHeight,
          l.outWidth,
          l.outChannels,
          l.strideDepth,
          l.strideHeight,
          l.strideWidth,
          l.dilationDepth,
          l.dilationHeight,
          l.dilationWidth,
          l.filterDepth,
          l.filterHeight,
          l.filterWidth,
          l.padInfo.front,
          l.padInfo.top,
          l.padInfo.left,
        ),
        p
      );
    },
  };
  let ye;
  const ge = {
    kernelName: t.Conv3DBackpropFilterV2,
    backendName: 'wasm',
    setupFunc: function (e) {
      ye = e.wasm.cwrap(t.Conv3DBackpropFilterV2, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { x: u, dy: i } = n,
        { strides: s, pad: o, filterShape: d } = r;
      if ('float32' !== u.dtype) throw new Error(`Tensor dy must have dtype float32, got ${u.dtype}`);
      if ('float32' !== i.dtype) throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);
      const l = t.backend_util.computeConv3DInfo(u.shape, d, s, 1, o),
        p = a.makeOutput(l.filterShape, i.dtype);
      return (
        ye(
          a.dataIdMap.get(u.dataId).id,
          a.dataIdMap.get(i.dataId).id,
          a.dataIdMap.get(p.dataId).id,
          l.batchSize,
          l.inDepth,
          l.inHeight,
          l.inWidth,
          l.inChannels,
          l.outDepth,
          l.outHeight,
          l.outWidth,
          l.outChannels,
          l.strideDepth,
          l.strideHeight,
          l.strideWidth,
          l.dilationDepth,
          l.dilationHeight,
          l.dilationWidth,
          l.filterDepth,
          l.filterHeight,
          l.filterWidth,
          l.padInfo.front,
          l.padInfo.top,
          l.padInfo.left,
        ),
        p
      );
    },
  };
  let ke;
  const Ie = {
      kernelName: t.Conv3DBackpropInputV2,
      backendName: 'wasm',
      setupFunc: function (e) {
        ke = e.wasm.cwrap(t.Conv3DBackpropInputV2, null, [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
        ]);
      },
      kernelFunc: function (e) {
        const { inputs: n, backend: a, attrs: r } = e,
          { dy: u, filter: i } = n,
          { pad: s, strides: o, inputShape: d } = r;
        if ('float32' !== u.dtype) throw new Error(`Tensor dy must have dtype float32, got ${u.dtype}`);
        if ('float32' !== i.dtype) throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);
        const l = t.backend_util.computeConv3DInfo(d, i.shape, o, 1, s),
          p = a.makeOutput(l.inShape, u.dtype);
        return (
          ke(
            a.dataIdMap.get(i.dataId).id,
            a.dataIdMap.get(u.dataId).id,
            a.dataIdMap.get(p.dataId).id,
            l.batchSize,
            l.inDepth,
            l.inHeight,
            l.inWidth,
            l.inChannels,
            l.outDepth,
            l.outHeight,
            l.outWidth,
            l.outChannels,
            l.strideDepth,
            l.strideHeight,
            l.strideWidth,
            l.dilationDepth,
            l.dilationHeight,
            l.dilationWidth,
            l.filterDepth,
            l.filterHeight,
            l.filterWidth,
            l.padInfo.front,
            l.padInfo.top,
            l.padInfo.left,
          ),
          p
        );
      },
    },
    we = p(t.Cos),
    Me = p(t.Cosh);
  var Se;
  let Ae;
  !(function (e) {
    (e[(e.bilinear = 0)] = 'bilinear'), (e[(e.nearest = 1)] = 'nearest');
  })(Se || (Se = {}));
  const ve = {
    kernelName: t.CropAndResize,
    backendName: 'wasm',
    setupFunc: function (e) {
      Ae = e.wasm.cwrap(t.CropAndResize, null, [
        'number',
        'number',
        'number',
        'number',
        'array',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: n, attrs: a } = e,
        { method: r, extrapolationValue: u, cropSize: i } = a,
        { image: s, boxes: o, boxInd: d } = n,
        l = o.shape[0],
        [p, c] = i,
        m = [l, p, c, s.shape[3]];
      let f,
        h = t.dataIdMap.get(s.dataId);
      'float32' !== s.dtype && ((f = ue({ backend: t, inputs: { x: s }, attrs: { dtype: 'float32' } })), (h = t.dataIdMap.get(f.dataId)));
      const b = h.id,
        _ = t.dataIdMap.get(o.dataId).id,
        y = t.dataIdMap.get(d.dataId).id,
        g = t.makeOutput(m, 'float32'),
        k = t.dataIdMap.get(g.dataId).id,
        I = new Uint8Array(new Int32Array(s.shape).buffer);
      return Ae(b, _, y, l, I, p, c, Se[r], u, k), null != f && t.disposeData(f.dataId), g;
    },
  };
  let xe;
  const Fe = {
    kernelName: t.Cumprod,
    backendName: 'wasm',
    setupFunc: function (e) {
      xe = e.wasm.cwrap(t.Cumprod, null, ['number', 'number', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { x: u } = n,
        { axis: i, exclusive: o, reverse: d } = r,
        l = u.shape.length;
      t.util.assert('float32' === u.dtype || 'int32' === u.dtype, () => `cumprod does not support ${u.dtype} tensors in the WASM backend`);
      const p = t.backend_util.getAxesPermutation([i], l);
      let c = u;
      null !== p && (c = w({ inputs: { x: u }, attrs: { perm: p }, backend: a }));
      const m = t.backend_util.getInnerMostAxes(1, l)[0];
      t.backend_util.assertAxesAreInnerMostDims('cumprod', [m], l);
      const f = a.makeOutput(c.shape, c.dtype),
        h = c.shape[m],
        b = a.dataIdMap.get(c.dataId).id,
        _ = a.dataIdMap.get(f.dataId).id;
      xe(b, o ? 1 : 0, d ? 1 : 0, h, _, s[u.dtype]);
      let y = f;
      if (null !== p) {
        (y = w({ inputs: { x: f }, attrs: { perm: t.backend_util.getUndoAxesPermutation(p) }, backend: a })),
          a.disposeData(c.dataId),
          a.disposeData(f.dataId);
      }
      return y;
    },
  };
  let Ne;
  const De = {
    kernelName: t.Cumsum,
    backendName: 'wasm',
    setupFunc: function (e) {
      Ne = e.wasm.cwrap(t.Cumsum, null, ['number', 'number', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { x: u } = n,
        { axis: i, exclusive: o, reverse: d } = r,
        l = u.shape.length;
      t.util.assert('float32' === u.dtype || 'int32' === u.dtype, () => `cumsum does not support ${u.dtype} tensors in the WASM backend`);
      const p = t.backend_util.getAxesPermutation([i], l);
      let c = u;
      null !== p && (c = w({ inputs: { x: u }, attrs: { perm: p }, backend: a }));
      const m = t.backend_util.getInnerMostAxes(1, l)[0];
      t.backend_util.assertAxesAreInnerMostDims('cumsum', [m], l);
      const f = a.makeOutput(c.shape, c.dtype),
        h = c.shape[m],
        b = a.dataIdMap.get(c.dataId).id,
        _ = a.dataIdMap.get(f.dataId).id;
      Ne(b, o ? 1 : 0, d ? 1 : 0, h, _, s[u.dtype]);
      let y = f;
      if (null !== p) {
        (y = w({ inputs: { x: f }, attrs: { perm: t.backend_util.getUndoAxesPermutation(p) }, backend: a })),
          a.disposeData(c.dataId),
          a.disposeData(f.dataId);
      }
      return y;
    },
  };
  let Re;
  const Ee = {
    kernelName: t.DenseBincount,
    backendName: 'wasm',
    setupFunc: function (e) {
      Re = e.wasm.cwrap('DenseBincount', null, ['number', 'array', 'number', 'number', 'boolean', 'number', 'number', 'boolean', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: n, attrs: a } = e,
        { x: r, weights: u } = n,
        { size: i, binaryOutput: o } = a,
        d = 0 !== u.shape.reduce((e, t) => e * t, 1),
        l = 1 === r.shape.length ? [i] : [r.shape[0], i],
        p = t.makeOutput(l, u.dtype);
      function c(e) {
        return t.dataIdMap.get(e.dataId).id;
      }
      return Re(c(r), new Uint8Array(new Int32Array(r.shape).buffer), r.shape.length, i, d, c(u), s[u.dtype], o, c(p)), p;
    },
  };
  let Pe;
  const Ce = {
    kernelName: t.DepthToSpace,
    backendName: 'wasm',
    setupFunc: function (e) {
      Pe = e.wasm.cwrap(t.DepthToSpace, null, ['number', 'number', 'number', 'array', 'number', 'array', 'array', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { x: u } = a,
        { blockSize: i, dataFormat: s } = r,
        o = u.shape[0],
        d = ('NHWC' === s ? u.shape[1] : u.shape[2]) * i,
        l = ('NHWC' === s ? u.shape[2] : u.shape[3]) * i,
        p = ('NHWC' === s ? u.shape[3] : u.shape[1]) / (i * i),
        c = 'NHWC' === s ? [o, d, l, p] : [o, p, d, l],
        m = n.makeOutput(c, 'float32'),
        f = n.dataIdMap.get(u.dataId).id,
        h = new Uint8Array(new Int32Array(t.util.computeStrides(u.shape)).buffer),
        b = new Uint8Array(new Int32Array(c).buffer),
        _ = new Uint8Array(new Int32Array(t.util.computeStrides(c)).buffer),
        y = n.dataIdMap.get(m.dataId).id;
      return Pe(f, i, 'NHWC' === s ? 1 : 0, h, u.shape.length - 1, b, _, c.length, y), m;
    },
  };
  let We;
  const Oe = {
    kernelName: t.DepthwiseConv2dNative,
    backendName: 'wasm',
    setupFunc: function (e) {
      We = e.wasm.cwrap(t.DepthwiseConv2dNative, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, attrs: a, backend: r } = e,
        { x: u, filter: i } = n,
        s = r.dataIdMap.get(u.dataId).id,
        o = r.dataIdMap.get(i.dataId).id,
        { strides: d, dilations: l, pad: p, dimRoundingMode: c } = a,
        m = null == l ? [1, 1] : l,
        f = t.backend_util.computeConv2DInfo(u.shape, i.shape, d, m, p, c, !0),
        h = f.filterHeight,
        b = f.filterWidth,
        _ = f.padInfo.top,
        y = f.padInfo.right,
        g = f.padInfo.bottom,
        k = f.padInfo.left,
        I = f.dilationHeight,
        w = f.dilationWidth,
        M = f.strideHeight,
        S = f.strideWidth,
        A = f.inChannels,
        v = f.outChannels,
        x = 'SAME' === f.padInfo.type ? 1 : 0;
      if ('channelsLast' !== f.dataFormat)
        throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);
      const F = r.makeOutput(f.outShape, 'float32'),
        N = r.dataIdMap.get(F.dataId).id;
      return We(s, u.shape[0], u.shape[1], u.shape[2], o, h, b, _, y, g, k, x, I, w, M, S, A, v, N), F;
    },
  };
  let Te;
  const ze = {
    kernelName: t.Diag,
    backendName: 'wasm',
    setupFunc: function (e) {
      Te = e.wasm.cwrap('Diag', null, ['number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a } = e,
        { x: r } = n,
        u = t.util.sizeFromShape(r.shape),
        i = a.makeOutput([...r.shape, ...r.shape], r.dtype);
      return Te(a.dataIdMap.get(r.dataId).id, s[r.dtype], u, a.dataIdMap.get(i.dataId).id), i;
    },
  };
  let Be;
  const He = {
    kernelName: t.Dilation2D,
    backendName: 'wasm',
    setupFunc: function (e) {
      Be = e.wasm.cwrap(t.Dilation2D, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { x: u, filter: i } = n,
        { strides: o, pad: d, dilations: l } = r;
      if (u.dtype !== i.dtype) throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${u.dtype} and ${i.dtype}`);
      const p = t.backend_util.computeDilation2DInfo(u.shape, i.shape, o, d, 'NHWC', l),
        c = a.makeOutput(p.outShape, u.dtype);
      return (
        Be(
          a.dataIdMap.get(u.dataId).id,
          a.dataIdMap.get(i.dataId).id,
          a.dataIdMap.get(c.dataId).id,
          s[u.dtype],
          p.batchSize,
          p.inChannels,
          p.inHeight,
          p.inWidth,
          p.outHeight,
          p.outWidth,
          p.strideHeight,
          p.strideWidth,
          p.dilationHeight,
          p.dilationWidth,
          p.filterHeight,
          p.filterWidth,
          p.padInfo.top,
          p.padInfo.left,
        ),
        c
      );
    },
  };
  let Le;
  const Ge = {
    kernelName: t.Dilation2DBackpropFilter,
    backendName: 'wasm',
    setupFunc: function (e) {
      Le = e.wasm.cwrap(t.Dilation2DBackpropFilter, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { x: u, filter: i, dy: o } = n,
        { strides: d, pad: l, dilations: p } = r;
      if (u.dtype !== i.dtype || u.dtype !== o.dtype)
        throw new Error(
          `Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${u.dtype}, ${i.dtype}, and ${o.dtype}`,
        );
      const c = t.backend_util.computeDilation2DInfo(u.shape, i.shape, d, l, 'NHWC', p),
        m = a.makeOutput(i.shape, i.dtype);
      return (
        Le(
          a.dataIdMap.get(u.dataId).id,
          a.dataIdMap.get(i.dataId).id,
          a.dataIdMap.get(o.dataId).id,
          a.dataIdMap.get(m.dataId).id,
          s[u.dtype],
          c.batchSize,
          c.inChannels,
          c.inHeight,
          c.inWidth,
          c.outHeight,
          c.outWidth,
          c.strideHeight,
          c.strideWidth,
          c.dilationHeight,
          c.dilationWidth,
          c.filterHeight,
          c.filterWidth,
          c.padInfo.top,
          c.padInfo.left,
        ),
        m
      );
    },
  };
  let Ue;
  const je = {
      kernelName: t.Dilation2DBackpropInput,
      backendName: 'wasm',
      setupFunc: function (e) {
        Ue = e.wasm.cwrap(t.Dilation2DBackpropInput, null, [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
        ]);
      },
      kernelFunc: function (e) {
        const { inputs: n, backend: a, attrs: r } = e,
          { x: u, filter: i, dy: o } = n,
          { strides: d, pad: l, dilations: p } = r;
        if (u.dtype !== i.dtype || u.dtype !== o.dtype)
          throw new Error(
            `Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${u.dtype}, ${i.dtype}, and ${o.dtype}`,
          );
        const c = t.backend_util.computeDilation2DInfo(u.shape, i.shape, d, l, 'NHWC', p),
          m = a.makeOutput(u.shape, u.dtype);
        return (
          Ue(
            a.dataIdMap.get(u.dataId).id,
            a.dataIdMap.get(i.dataId).id,
            a.dataIdMap.get(o.dataId).id,
            a.dataIdMap.get(m.dataId).id,
            s[u.dtype],
            c.batchSize,
            c.inChannels,
            c.inHeight,
            c.inWidth,
            c.outHeight,
            c.outWidth,
            c.strideHeight,
            c.strideWidth,
            c.dilationHeight,
            c.dilationWidth,
            c.filterHeight,
            c.filterWidth,
            c.padInfo.top,
            c.padInfo.left,
          ),
          m
        );
      },
    },
    qe = p(t.Elu);
  let Ve;
  const $e = {
      kernelName: t.EluGrad,
      backendName: 'wasm',
      setupFunc: function (e) {
        Ve = e.wasm.cwrap(t.EluGrad, null, ['number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const { inputs: t, backend: n } = e,
          { dy: a, y: r } = t,
          u = n.makeOutput(r.shape, 'float32'),
          i = e => n.dataIdMap.get(e.dataId).id;
        return Ve(i(r), i(a), i(u)), u;
      },
    },
    Ke = h(t.Equal, 0, 'bool'),
    Xe = p(t.Erf),
    Qe = p(t.Exp, 'float32');
  function Je(e) {
    const { inputs: n, attrs: a, backend: r } = e,
      { input: u } = n,
      { dim: i } = a,
      s = u.shape.length,
      o = u.shape.slice();
    let d = i;
    return (
      i < 0 && (t.util.assert(-(s + 1) <= i, () => `Axis must be in the interval [${-(s + 1)}, ${s}]`), (d = s + i + 1)),
      o.splice(d, 0, 1),
      q({ inputs: { x: u }, backend: r, attrs: { shape: o } })
    );
  }
  const Ze = { kernelName: t.ExpandDims, backendName: 'wasm', kernelFunc: Je },
    Ye = p(t.Expm1, 'float32');
  function et(e) {
    const {
      attrs: { shape: n, value: a },
      backend: r,
    } = e;
    let {
      attrs: { dtype: u },
    } = e;
    u = u || t.util.inferDtype(a);
    const i = r.makeOutput(n, u);
    return r.typedArrayFromHeap(i).fill(a), i;
  }
  const tt = { kernelName: t.Fill, backendName: 'wasm', kernelFunc: et };
  let nt;
  const at = {
      kernelName: t.FlipLeftRight,
      backendName: 'wasm',
      kernelFunc: function (e) {
        const { inputs: t, backend: n } = e,
          { image: a } = t,
          r = n.makeOutput(a.shape, a.dtype),
          u = n.dataIdMap.get(a.dataId).id,
          i = n.dataIdMap.get(r.dataId).id,
          [s, o, d, l] = a.shape;
        return nt(u, s, o, d, l, i), r;
      },
      setupFunc: function (e) {
        nt = e.wasm.cwrap(t.FlipLeftRight, null, ['number', 'number', 'number', 'number', 'number', 'number']);
      },
    },
    rt = p(t.Floor),
    ut = h(t.FloorDiv);
  let it;
  const st = {
    kernelName: t.FusedBatchNorm,
    backendName: 'wasm',
    setupFunc: function (e) {
      it = e.wasm.cwrap(t.FusedBatchNorm, null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { varianceEpsilon: u } = r,
        { x: i, mean: s, variance: o, offset: d, scale: l } = a,
        p = n.dataIdMap.get(i.dataId).id,
        c = n.dataIdMap.get(s.dataId).id,
        m = n.dataIdMap.get(o.dataId).id,
        f = null != d ? n.dataIdMap.get(d.dataId).id : 0,
        h = null != l ? n.dataIdMap.get(l.dataId).id : 0,
        b = n.makeOutput(i.shape, i.dtype);
      if (0 === t.util.sizeFromShape(i.shape)) return b;
      const _ = n.dataIdMap.get(b.dataId).id;
      return it(p, c, m, f, h, u, _), b;
    },
  };
  let ot;
  const dt = {
    kernelName: t.FusedConv2D,
    backendName: 'wasm',
    setupFunc: function (e) {
      ot = e.wasm.cwrap(t.FusedConv2D, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, attrs: a, backend: r } = e,
        { x: u, filter: i, bias: s, preluActivationWeights: d } = n,
        { strides: l, pad: p, dilations: c, dataFormat: m, dimRoundingMode: f, activation: h, leakyreluAlpha: b } = a,
        _ = t.backend_util.computeConv2DInfo(u.shape, i.shape, l, c, p, f),
        y = o[h];
      if (null == y) throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);
      const g = r.dataIdMap.get(u.dataId).id,
        k = r.dataIdMap.get(i.dataId).id,
        I = _.outChannels;
      let w = 0;
      if (null != s) {
        const e = r.dataIdMap.get(s.dataId);
        if (1 !== e.shape.length) throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);
        if (e.shape[0] !== I) throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${I})`);
        w = e.id;
      }
      const M = _.filterHeight,
        S = _.filterWidth,
        A = _.padInfo.top,
        v = _.padInfo.right,
        x = _.padInfo.bottom,
        F = _.padInfo.left,
        N = _.dilationHeight,
        D = _.dilationWidth,
        R = _.strideHeight,
        E = _.strideWidth,
        P = _.inChannels,
        C = 'SAME' === _.padInfo.type ? 1 : 0,
        W = _.batchSize,
        O = _.inHeight,
        T = _.inWidth;
      if ('NHWC' !== m) throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);
      const z = r.makeOutput(_.outShape, 'float32'),
        B = r.dataIdMap.get(z.dataId).id,
        H = null == d ? 0 : r.dataIdMap.get(d.dataId).id;
      return ot(g, W, O, T, k, M, S, w, A, v, x, F, C, N, D, R, E, P, I, y, H, b || 0, B), z;
    },
  };
  let lt;
  const pt = {
    kernelName: t.FusedDepthwiseConv2D,
    backendName: 'wasm',
    setupFunc: function (e) {
      lt = e.wasm.cwrap(t.FusedDepthwiseConv2D, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, attrs: a, backend: r } = e,
        { x: u, filter: i, bias: s, preluActivationWeights: d } = n,
        { strides: l, pad: p, dilations: c, dataFormat: m, dimRoundingMode: f, activation: h, leakyreluAlpha: b } = a,
        _ = t.backend_util.computeConv2DInfo(u.shape, i.shape, l, c, p, f, !0),
        y = o[h];
      if (null == y) throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);
      const g = r.dataIdMap.get(u.dataId).id,
        k = r.dataIdMap.get(i.dataId).id,
        I = _.outChannels;
      let w = 0;
      if (null != s) {
        const e = r.dataIdMap.get(s.dataId);
        if (1 !== e.shape.length) throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);
        if (e.shape[0] !== I)
          throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${I})`);
        w = e.id;
      }
      const M = _.filterHeight,
        S = _.filterWidth,
        A = _.padInfo.top,
        v = _.padInfo.right,
        x = _.padInfo.bottom,
        F = _.padInfo.left,
        N = _.dilationHeight,
        D = _.dilationWidth,
        R = _.strideHeight,
        E = _.strideWidth,
        P = _.inChannels,
        C = 'SAME' === _.padInfo.type ? 1 : 0,
        W = _.batchSize,
        O = _.inHeight,
        T = _.inWidth;
      if ('NHWC' !== m) throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);
      const z = r.makeOutput(_.outShape, 'float32'),
        B = r.dataIdMap.get(z.dataId).id,
        H = null == d ? 0 : r.dataIdMap.get(d.dataId).id;
      return lt(g, W, O, T, k, M, S, w, A, v, x, F, C, N, D, R, E, P, I, y, H, b || 0, B), z;
    },
  };
  let ct;
  const mt = {
    kernelName: t.GatherNd,
    backendName: 'wasm',
    setupFunc: function (e) {
      ct = e.wasm.cwrap(t.GatherNd, null, ['number', 'number', 'number', 'number', 'number', 'number', 'array', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a } = e,
        { params: r, indices: u } = a,
        [i, o, d, l] = t.gather_util.prepareAndValidate(r, u),
        p = n.makeOutput(i, r.dtype);
      if (0 === o) return p;
      const c = u.shape,
        m = c[c.length - 1],
        f = n.dataIdMap.get(r.dataId).id,
        h = n.dataIdMap.get(u.dataId).id,
        b = new Uint8Array(new Int32Array(l).buffer),
        _ = n.dataIdMap.get(p.dataId).id;
      return ct(f, s[r.dtype], h, o, m, d, b, _), p;
    },
  };
  let ft;
  const ht = {
      kernelName: t.GatherV2,
      backendName: 'wasm',
      setupFunc: function (e) {
        ft = e.wasm.cwrap('Gather', null, ['number', 'number', 'array', 'number', 'number', 'number', 'array', 'number']);
      },
      kernelFunc: function (e) {
        const { backend: n, inputs: a, attrs: r } = e,
          { x: u, indices: i } = a,
          { axis: o, batchDims: d } = r,
          l = t.util.parseAxisParam(o, u.shape)[0],
          p = n.readSync(i.dataId),
          c = u.shape[l];
        for (let e = 0; e < p.length; ++e) {
          const n = p[e];
          t.util.assert(n <= c - 1 && n >= 0, () => `GatherV2: the index value ${n} is not in [0, ${c - 1}]`);
        }
        const m = t.backend_util.segment_util.collectGatherOpShapeInfo(u, i, l, d),
          f = q({ inputs: { x: u }, attrs: { shape: [m.batchSize, m.outerSize, m.dimSize, m.sliceSize] }, backend: n }),
          h = t.util.sizeFromShape(i.shape),
          b = q({ inputs: { x: i }, attrs: { shape: [m.batchSize, h / m.batchSize] }, backend: n }),
          _ = [m.batchSize, m.outerSize, h / m.batchSize, m.sliceSize],
          y = n.makeOutput(_, u.dtype);
        if (0 === t.util.sizeFromShape(u.shape)) return y;
        const g = f.shape.length - 1,
          k = n.dataIdMap.get(f.dataId).id,
          I = n.dataIdMap.get(b.dataId).id,
          w = n.dataIdMap.get(y.dataId).id,
          M = new Uint8Array(new Int32Array(t.util.computeStrides(f.shape)).buffer),
          S = new Uint8Array(new Int32Array(t.util.computeStrides(_)).buffer);
        return (
          ft(k, s[u.dtype], M, g, I, m.batchSize, S, w), n.disposeData(f.dataId), n.disposeData(b.dataId), (y.shape = m.outputShape), y
        );
      },
    },
    bt = h(t.Greater, 0, 'bool'),
    _t = h(t.GreaterEqual, 0, 'bool'),
    yt = p(t.IsFinite, 'bool'),
    gt = p(t.IsInf, 'bool'),
    kt = p(t.IsNan, 'bool');
  let It;
  const wt = {
      kernelName: t.LeakyRelu,
      backendName: 'wasm',
      setupFunc: function (e) {
        It = e.wasm.cwrap(t.LeakyRelu, null, ['number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const {
            inputs: { x: n },
            attrs: { alpha: a },
            backend: r,
          } = e,
          u = r.dataIdMap.get(n.dataId).id,
          i = r.makeOutput(n.shape, 'float32');
        if (0 !== t.util.sizeFromShape(n.shape)) {
          const e = r.dataIdMap.get(i.dataId).id;
          It(u, s[n.dtype], a, e);
        }
        return i;
      },
    },
    Mt = h(t.Less, 0, 'bool'),
    St = h(t.LessEqual, 0, 'bool');
  let At;
  const vt = {
      kernelName: t.LinSpace,
      backendName: 'wasm',
      setupFunc: function (e) {
        At = e.wasm.cwrap(t.LinSpace, null, ['number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const { attrs: t, backend: n } = e,
          { start: a, stop: r, num: u } = t,
          i = Math.floor(u),
          s = n.makeOutput([i], 'float32');
        return At(n.dataIdMap.get(s.dataId).id, a, r, i), s;
      },
    },
    xt = p(t.Log),
    Ft = p(t.Log1p),
    Nt = h(t.LogicalAnd, 0, 'bool'),
    Dt = p(t.LogicalNot),
    Rt = h(t.LogicalOr, 0, 'bool'),
    Et = h(t.LogicalXor, 0, 'bool');
  let Pt;
  const Ct = {
    kernelName: t.LRN,
    backendName: 'wasm',
    setupFunc: function (e) {
      Pt = e.wasm.cwrap(t.LRN, null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { x: r } = t,
        { depthRadius: u, bias: i, alpha: s, beta: o } = a;
      if ('float32' !== r.dtype) throw new Error('LRN error: x must have dtype float32');
      const d = n.makeOutput(r.shape, r.dtype);
      return Pt(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(d.dataId).id, r.shape[3], u, i, s, o), d;
    },
  };
  let Wt;
  const Ot = {
    kernelName: t.LRNGrad,
    backendName: 'wasm',
    setupFunc: function (e) {
      Wt = e.wasm.cwrap(t.LRNGrad, null, ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { x: r, y: u, dy: i } = t,
        { depthRadius: s, bias: o, alpha: d, beta: l } = a;
      if ('float32' !== r.dtype || 'float32' !== u.dtype || 'float32' !== i.dtype)
        throw new Error('LRNGrad error: x, y, and dy must have dtype float32');
      const p = n.makeOutput(r.shape, r.dtype);
      return (
        Wt(
          n.dataIdMap.get(r.dataId).id,
          n.dataIdMap.get(u.dataId).id,
          n.dataIdMap.get(i.dataId).id,
          n.dataIdMap.get(p.dataId).id,
          i.shape[3],
          s,
          o,
          d,
          l,
        ),
        p
      );
    },
  };
  let Tt;
  const zt = {
      kernelName: t.Max,
      backendName: 'wasm',
      setupFunc: function (e) {
        Tt = e.wasm.cwrap(t.Max, null, ['number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const { backend: n, inputs: a, attrs: r } = e,
          { reductionIndices: u, keepDims: i } = r,
          { x: o } = a;
        let d = n.dataIdMap.get(o.dataId).id,
          l = o;
        const { transposed: p, axes: c, originalAxes: m, inputWasTransposed: f } = S(o, u, n);
        if (f) {
          (l = p), (d = n.dataIdMap.get(p.dataId).id);
        }
        const h = l.shape.length;
        t.backend_util.assertAxesAreInnerMostDims('max', c, h);
        const [b, _] = t.backend_util.computeOutAndReduceShapes(l.shape, c),
          y = t.util.sizeFromShape(_),
          g = n.makeOutput(b, o.dtype);
        if (0 !== t.util.sizeFromShape(l.shape)) {
          const e = n.dataIdMap.get(g.dataId).id;
          Tt(d, s[o.dtype], y, e);
        }
        if ((f && n.disposeData(p.dataId), i)) {
          const e = t.backend_util.expandShapeToKeepDim(g.shape, m);
          g.shape = e;
        }
        return g;
      },
    },
    Bt = h(t.Maximum);
  let Ht;
  const Lt = {
    kernelName: t.MaxPool,
    backendName: 'wasm',
    setupFunc: function (e) {
      Ht = e.wasm.cwrap(t.MaxPool, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, attrs: a, backend: r } = e,
        u = n.x,
        i = r.dataIdMap.get(u.dataId).id;
      t.util.assert('float32' === u.dtype, () => `Error in MaxPool: only float32 input is supported. Got ${u.dtype}.`);
      const { filterSize: s, strides: o, pad: d, dimRoundingMode: l } = a,
        p = t.backend_util.computePool2DInfo(u.shape, s, o, 1, d, l),
        c = p.filterHeight,
        m = p.filterWidth,
        f = p.padInfo.top,
        h = p.padInfo.right,
        b = p.padInfo.bottom,
        _ = p.padInfo.left,
        y = p.dilationHeight,
        g = p.dilationWidth,
        k = p.strideHeight,
        I = p.strideWidth,
        w = p.inChannels,
        M = p.outChannels;
      if ('channelsLast' !== p.dataFormat)
        throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);
      const S = r.makeOutput(p.outShape, 'float32'),
        A = r.dataIdMap.get(S.dataId).id;
      return Ht(i, u.shape[0], u.shape[1], u.shape[2], c, m, f, h, b, _, y, g, k, I, w, M, A), S;
    },
  };
  let Gt;
  const Ut = {
    kernelName: t.MaxPool3D,
    backendName: 'wasm',
    setupFunc: function (e) {
      Gt = e.wasm.cwrap('MaxPool3D', null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { x: u } = n,
        { filterSize: i, strides: s, pad: o, dimRoundingMode: d, dataFormat: l } = r,
        p = t.backend_util.computePool3DInfo(u.shape, i, s, 1, o, d, l),
        c = a.makeOutput(p.outShape, u.dtype);
      return (
        Gt(
          a.dataIdMap.get(u.dataId).id,
          a.dataIdMap.get(c.dataId).id,
          p.batchSize,
          p.inChannels,
          p.inDepth,
          p.inHeight,
          p.inWidth,
          p.outDepth,
          p.outHeight,
          p.outWidth,
          p.strideDepth,
          p.strideHeight,
          p.strideWidth,
          p.dilationDepth,
          p.dilationHeight,
          p.dilationWidth,
          p.effectiveFilterDepth,
          p.effectiveFilterHeight,
          p.effectiveFilterWidth,
          p.padInfo.front,
          p.padInfo.top,
          p.padInfo.left,
        ),
        c
      );
    },
  };
  let jt;
  const qt = {
    kernelName: t.MaxPool3DGrad,
    backendName: 'wasm',
    setupFunc: function (e) {
      jt = e.wasm.cwrap('MaxPool3DGrad', null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { dy: u, input: i } = n,
        { filterSize: s, strides: o, pad: d, dimRoundingMode: l } = r,
        p = t.backend_util.computePool3DInfo(i.shape, s, o, 1, d, l),
        c = a.makeOutput(i.shape, i.dtype);
      return (
        jt(
          a.dataIdMap.get(i.dataId).id,
          a.dataIdMap.get(u.dataId).id,
          a.dataIdMap.get(c.dataId).id,
          p.batchSize,
          p.inChannels,
          p.inDepth,
          p.inHeight,
          p.inWidth,
          p.outDepth,
          p.outHeight,
          p.outWidth,
          p.strideDepth,
          p.strideHeight,
          p.strideWidth,
          p.dilationDepth,
          p.dilationHeight,
          p.dilationWidth,
          p.effectiveFilterDepth,
          p.effectiveFilterHeight,
          p.effectiveFilterWidth,
          p.padInfo.front,
          p.padInfo.top,
          p.padInfo.left,
        ),
        c
      );
    },
  };
  let Vt;
  const $t = {
    kernelName: t.MaxPoolGrad,
    backendName: 'wasm',
    setupFunc: function (e) {
      Vt = e.wasm.cwrap('MaxPoolGrad', null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { dy: u, input: i } = n,
        { filterSize: s, strides: o, pad: d, dimRoundingMode: l } = r,
        p = t.backend_util.computePool2DInfo(i.shape, s, o, 1, d, l),
        c = a.makeOutput(i.shape, i.dtype);
      return (
        Vt(
          a.dataIdMap.get(i.dataId).id,
          a.dataIdMap.get(u.dataId).id,
          a.dataIdMap.get(c.dataId).id,
          p.batchSize,
          p.inChannels,
          p.inHeight,
          p.inWidth,
          p.outHeight,
          p.outWidth,
          p.strideHeight,
          p.strideWidth,
          p.dilationHeight,
          p.dilationWidth,
          p.effectiveFilterHeight,
          p.effectiveFilterWidth,
          p.padInfo.top,
          p.padInfo.left,
        ),
        c
      );
    },
  };
  let Kt;
  const Xt = {
    kernelName: t.MaxPoolWithArgmax,
    backendName: 'wasm',
    setupFunc: function (e) {
      Kt = e.wasm.cwrap('MaxPoolWithArgmax', null, [
        'number',
        'number',
        'number',
        'number',
        'boolean',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { x: u } = n,
        { filterSize: i, strides: o, pad: d, includeBatchInIndex: l } = r;
      t.util.assert(4 === u.shape.length, () => `Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`);
      const p = [1, 1];
      t.util.assert(
        t.backend_util.eitherStridesOrDilationsAreOne(o, p),
        () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`,
      );
      const c = t.backend_util.computePool2DInfo(u.shape, i, o, [1, 1], d),
        m = a.makeOutput(c.outShape, u.dtype),
        f = a.makeOutput(c.outShape, 'int32');
      return (
        Kt(
          a.dataIdMap.get(u.dataId).id,
          a.dataIdMap.get(m.dataId).id,
          a.dataIdMap.get(f.dataId).id,
          s[u.dtype],
          l,
          c.batchSize,
          c.inChannels,
          c.inHeight,
          c.inWidth,
          c.outHeight,
          c.outWidth,
          c.strideHeight,
          c.strideWidth,
          c.dilationHeight,
          c.dilationWidth,
          c.effectiveFilterHeight,
          c.effectiveFilterWidth,
          c.padInfo.top,
          c.padInfo.left,
        ),
        [m, f]
      );
    },
  };
  let Qt;
  const Jt = {
    kernelName: t.Mean,
    backendName: 'wasm',
    setupFunc: function (e) {
      Qt = e.wasm.cwrap(t.Mean, null, ['number, number, number']);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { axis: u, keepDims: i } = r,
        { x: s } = a,
        o = n.dataIdMap.get(s.dataId).id;
      let d = o,
        l = s;
      const { transposed: p, axes: c, originalAxes: m, inputWasTransposed: f } = S(s, u, n);
      let h = c;
      if (f) {
        const e = n.dataIdMap.get(p.dataId).id;
        e !== o && ((l = p), (d = e), (h = t.backend_util.getInnerMostAxes(h.length, l.shape.length)));
      }
      t.backend_util.assertAxesAreInnerMostDims('mean', h, l.shape.length);
      const [b, _] = t.backend_util.computeOutAndReduceShapes(l.shape, h),
        y = t.util.sizeFromShape(_);
      let g = l;
      'float32' !== l.dtype &&
        ((g = ue({ backend: n, inputs: { x: l }, attrs: { dtype: 'float32' } })), (d = n.dataIdMap.get(g.dataId).id));
      const k = n.makeOutput(b, 'float32');
      if (0 !== t.util.sizeFromShape(l.shape)) {
        const e = n.dataIdMap.get(k.dataId).id;
        Qt(d, y, e);
      }
      if ((f && n.disposeData(p.dataId), i)) {
        const e = t.backend_util.expandShapeToKeepDim(k.shape, m);
        k.shape = e;
      }
      return 'float32' !== l.dtype && n.disposeData(g.dataId), k;
    },
  };
  let Zt;
  const Yt = {
      kernelName: t.Min,
      backendName: 'wasm',
      setupFunc: function (e) {
        Zt = e.wasm.cwrap(t.Min, null, ['number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const { backend: n, inputs: a, attrs: r } = e,
          { axis: u, keepDims: i } = r,
          { x: o } = a,
          d = n.dataIdMap.get(o.dataId).id;
        let l = d,
          p = o;
        const { transposed: c, axes: m, originalAxes: f, inputWasTransposed: h } = S(o, u, n);
        if (h) {
          const e = n.dataIdMap.get(c.dataId).id;
          e !== d && ((p = c), (l = e));
        }
        const b = p.shape.length;
        t.backend_util.assertAxesAreInnerMostDims('min', m, b);
        const [_, y] = t.backend_util.computeOutAndReduceShapes(p.shape, m),
          g = t.util.sizeFromShape(y),
          k = n.makeOutput(_, p.dtype);
        if (0 !== t.util.sizeFromShape(p.shape)) {
          const e = n.dataIdMap.get(k.dataId).id;
          Zt(l, s[o.dtype], g, e);
        }
        if ((h && n.disposeData(c.dataId), i)) {
          const e = t.backend_util.expandShapeToKeepDim(k.shape, f);
          k.shape = e;
        }
        return k;
      },
    },
    en = h(t.Minimum);
  var tn;
  let nn;
  !(function (e) {
    (e[(e.reflect = 0)] = 'reflect'), (e[(e.symmetric = 1)] = 'symmetric');
  })(tn || (tn = {}));
  const an = {
    kernelName: t.MirrorPad,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const {
          inputs: { x: t },
          backend: n,
          attrs: { paddings: a, mode: r },
        } = e,
        u = a.map((e, n) => e[0] + t.shape[n] + e[1]),
        i = n.dataIdMap.get(t.dataId).id,
        o = n.makeOutput(u, t.dtype),
        d = n.dataIdMap.get(o.dataId).id,
        l = new Uint8Array(new Int32Array(t.shape).buffer),
        p = a.map(e => e[0]),
        c = a.map(e => e[1]),
        m = new Uint8Array(new Int32Array(p).buffer),
        f = new Uint8Array(new Int32Array(c).buffer);
      return nn(i, l, t.shape.length, s[t.dtype], m, f, tn[r], d), o;
    },
    setupFunc: function (e) {
      nn = e.wasm.cwrap(t.MirrorPad, null, ['number', 'array', 'number', 'number', 'array', 'array', 'number', 'number']);
    },
  };
  let rn;
  function un(e) {
    const {
        backend: n,
        inputs: { logits: a },
        attrs: { dim: r },
      } = e,
      u = n.dataIdMap.get(a.dataId).id,
      i = n.makeOutput(a.shape, a.dtype),
      s = n.dataIdMap.get(i.dataId).id,
      o = a.shape[r],
      d = t.util.sizeFromShape(a.shape) / o;
    return 0 === t.util.sizeFromShape(i.shape) || rn(u, s, o, d), i;
  }
  const sn = {
    kernelName: t.Softmax,
    backendName: 'wasm',
    setupFunc: function (e) {
      rn = e.wasm.cwrap(t.Softmax, null, ['number', 'number', 'number', 'number']);
    },
    kernelFunc: un,
  };
  let on;
  const dn = {
      kernelName: t.Multinomial,
      backendName: 'wasm',
      setupFunc: function (e) {
        on = e.wasm.cwrap(t.Multinomial, null, ['number', 'number', 'number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const { inputs: t, backend: n, attrs: a } = e,
          { logits: r } = t,
          { numSamples: u, seed: i, normalized: s } = a;
        if ('float32' !== r.dtype) throw new Error(`Tensor logits must have dtype float32, got ${r.dtype}`);
        const o = s ? r : un({ inputs: { logits: r }, backend: n, attrs: { dim: r.shape.length - 1 } }),
          [d, l] = o.shape,
          p = n.makeOutput([d, u], 'int32');
        return on(n.dataIdMap.get(o.dataId).id, d, l, u, i, n.dataIdMap.get(p.dataId).id), s || n.disposeData(o.dataId), p;
      },
    },
    ln = h(t.Mod),
    pn = h(t.Multiply),
    cn = p(t.Neg);
  function mn(e, t) {
    const n = new Int32Array(e.wasm.HEAPU8.buffer, t, 4),
      a = n[0],
      r = n[1],
      u = n[2],
      i = n[3];
    return e.wasm._free(t), { pSelectedIndices: a, selectedSize: r, pSelectedScores: u, pValidOutputs: i };
  }
  let fn;
  const hn = {
    kernelName: t.NonMaxSuppressionV3,
    backendName: 'wasm',
    setupFunc: function (e) {
      fn = e.wasm.cwrap(t.NonMaxSuppressionV3, 'number', ['number', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: n, attrs: a } = e,
        { iouThreshold: r, maxOutputSize: u, scoreThreshold: i } = a,
        { boxes: s, scores: o } = n,
        d = t.dataIdMap.get(s.dataId).id,
        l = t.dataIdMap.get(o.dataId).id,
        p = fn(d, l, u, r, i),
        { pSelectedIndices: c, selectedSize: m, pSelectedScores: f, pValidOutputs: h } = mn(t, p);
      return t.wasm._free(f), t.wasm._free(h), t.makeOutput([m], 'int32', c);
    },
  };
  let bn;
  const _n = {
    kernelName: t.NonMaxSuppressionV4,
    backendName: 'wasm',
    setupFunc: function (e) {
      bn = e.wasm.cwrap(t.NonMaxSuppressionV4, 'number', ['number', 'number', 'number', 'number', 'number', 'bool']);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: n, attrs: a } = e,
        { iouThreshold: r, maxOutputSize: u, scoreThreshold: i, padToMaxOutputSize: s } = a,
        { boxes: o, scores: d } = n,
        l = t.dataIdMap.get(o.dataId).id,
        p = t.dataIdMap.get(d.dataId).id,
        c = bn(l, p, u, r, i, s),
        { pSelectedIndices: m, selectedSize: f, pSelectedScores: h, pValidOutputs: b } = mn(t, c);
      return t.wasm._free(h), [t.makeOutput([f], 'int32', m), t.makeOutput([], 'int32', b)];
    },
  };
  let yn;
  const gn = {
      kernelName: t.NonMaxSuppressionV5,
      backendName: 'wasm',
      setupFunc: function (e) {
        yn = e.wasm.cwrap(t.NonMaxSuppressionV5, 'number', ['number', 'number', 'number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const { backend: t, inputs: n, attrs: a } = e,
          { iouThreshold: r, maxOutputSize: u, scoreThreshold: i, softNmsSigma: s } = a,
          { boxes: o, scores: d } = n,
          l = t.dataIdMap.get(o.dataId).id,
          p = t.dataIdMap.get(d.dataId).id,
          c = yn(l, p, u, r, i, s),
          { pSelectedIndices: m, selectedSize: f, pSelectedScores: h, pValidOutputs: b } = mn(t, c);
        return t.wasm._free(b), [t.makeOutput([f], 'int32', m), t.makeOutput([f], 'float32', h)];
      },
    },
    kn = h(t.NotEqual, 0, 'bool');
  let In;
  const wn = {
    kernelName: t.OneHot,
    backendName: 'wasm',
    setupFunc: function (e) {
      In = e.wasm.cwrap(t.OneHot, null, ['number', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { indices: r } = t,
        { dtype: u, depth: i, onValue: s, offValue: o } = a,
        d = n.makeOutput([...r.shape, i], u),
        l = n.dataIdMap.get(d.dataId).id,
        p = n.dataIdMap.get(r.dataId).id;
      return In(p, i, s, o, l), d;
    },
  };
  const Mn = {
    kernelName: t.OnesLike,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const {
          inputs: { x: t },
          backend: n,
        } = e,
        a = n.makeOutput(t.shape, t.dtype);
      return n.typedArrayFromHeap(a).fill(1), a;
    },
  };
  const Sn = {
    kernelName: t.Pack,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { axis: u } = r;
      if (1 === n.length) return Je({ inputs: { input: n[0] }, backend: a, attrs: { dim: u } });
      const i = n[0].shape,
        s = n[0].dtype;
      n.forEach(e => {
        t.util.assertShapesMatch(i, e.shape, 'All tensors passed to stack must have matching shapes'),
          t.util.assert(s === e.dtype, () => 'All tensors passed to stack must have matching dtypes');
      });
      const o = [],
        d = le({
          inputs: n.map(e => {
            const t = Je({ inputs: { input: e }, backend: a, attrs: { dim: u } });
            return o.push(t), t;
          }),
          backend: a,
          attrs: { axis: u },
        });
      return o.forEach(e => a.disposeData(e.dataId)), d;
    },
  };
  let An;
  const vn = {
      kernelName: t.PadV2,
      backendName: 'wasm',
      kernelFunc: function (e) {
        const {
            inputs: { x: n },
            backend: a,
            attrs: { paddings: r, constantValue: u },
          } = e,
          i = r.map((e, t) => e[0] + n.shape[t] + e[1]);
        if (0 === t.util.sizeFromShape(n.shape)) return et({ backend: a, attrs: { shape: i, value: u, dtype: n.dtype } });
        const o = a.dataIdMap.get(n.dataId).id,
          d = a.makeOutput(i, n.dtype),
          l = a.dataIdMap.get(d.dataId).id,
          p = new Uint8Array(new Int32Array(n.shape).buffer),
          c = r.map(e => e[0]),
          m = r.map(e => e[1]),
          f = new Uint8Array(new Int32Array(c).buffer),
          h = new Uint8Array(new Int32Array(m).buffer);
        return An(o, p, n.shape.length, s[n.dtype], f, h, u, l), d;
      },
      setupFunc: function (e) {
        An = e.wasm.cwrap(t.PadV2, null, ['number', 'array', 'number', 'number', 'array', 'array', 'number', 'number']);
      },
    },
    xn = h(t.Pow);
  let Fn;
  const Nn = {
    kernelName: t.Prelu,
    backendName: 'wasm',
    setupFunc: function (e) {
      Fn = e.wasm.cwrap(t.Prelu, null, ['number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n } = e,
        { x: a, alpha: r } = t,
        u = n.dataIdMap.get(a.dataId).id,
        i = n.dataIdMap.get(r.dataId).id;
      let s = u;
      const o = a;
      let d = o;
      'float32' !== o.dtype &&
        ((d = ue({ backend: n, inputs: { x: a }, attrs: { dtype: 'float32' } })), (s = n.dataIdMap.get(d.dataId).id));
      const l = n.makeOutput(a.shape, 'float32'),
        p = n.dataIdMap.get(l.dataId).id;
      return Fn(s, i, p), 'float32' !== o.dtype && n.disposeData(d.dataId), l;
    },
  };
  let Dn;
  const Rn = {
      kernelName: t.Prod,
      backendName: 'wasm',
      setupFunc: function (e) {
        Dn = e.wasm.cwrap(t.Prod, null, ['number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const { backend: n, inputs: a, attrs: r } = e,
          { axis: u, keepDims: i } = r,
          { x: o } = a,
          d = n.dataIdMap.get(o.dataId).id;
        let l = d,
          p = o;
        const { transposed: c, axes: m, originalAxes: f, inputWasTransposed: h } = S(o, u, n);
        let b = m;
        if (h) {
          const e = n.dataIdMap.get(c.dataId).id;
          e !== d && ((p = c), (l = e), (b = t.backend_util.getInnerMostAxes(b.length, p.shape.length)));
        }
        t.backend_util.assertAxesAreInnerMostDims('prod', b, p.shape.length);
        const [_, y] = t.backend_util.computeOutAndReduceShapes(p.shape, b),
          g = t.util.sizeFromShape(y),
          k = n.makeOutput(_, p.dtype);
        if (0 !== t.util.sizeFromShape(p.shape)) {
          const e = n.dataIdMap.get(k.dataId).id;
          Dn(l, g, s[k.dtype], e);
        }
        if ((h && n.disposeData(c.dataId), i)) {
          const e = t.backend_util.expandShapeToKeepDim(k.shape, f);
          k.shape = e;
        }
        return k;
      },
    },
    En = {
      kernelName: t.Range,
      backendName: 'wasm',
      kernelFunc: e => {
        const { backend: n, attrs: a } = e,
          { start: r, stop: u, step: i, dtype: s } = a,
          o = (function (e, n, a, r) {
            if (e === n || (e < n && a < 0) || (n < e && a > 1)) return t.util.makeZerosTypedArray(0, r);
            const u = Math.abs(Math.ceil((n - e) / a)),
              i = t.util.makeZerosTypedArray(u, r);
            n < e && 1 === a && (a = -1), (i[0] = e);
            for (let e = 1; e < i.length; e++) i[e] = i[e - 1] + a;
            return i;
          })(r, u, i, s),
          d = n.makeOutput([o.length], s);
        return n.typedArrayFromHeap(d).set(o), d;
      },
    },
    Pn = h(t.RealDiv),
    Cn = p(t.Reciprocal),
    Wn = p(t.Relu),
    On = p(t.Relu6);
  let Tn;
  const zn = {
    kernelName: t.ResizeBilinear,
    backendName: 'wasm',
    setupFunc: function (e) {
      Tn = e.wasm.cwrap(t.ResizeBilinear, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { images: u } = a,
        { alignCorners: i, halfPixelCenters: s, size: o } = r,
        [d, l] = o,
        [p, c, m, f] = u.shape,
        h = [p, d, l, f];
      let b,
        _ = n.dataIdMap.get(u.dataId);
      'float32' !== _.dtype && ((b = ue({ backend: n, inputs: { x: u }, attrs: { dtype: 'float32' } })), (_ = n.dataIdMap.get(b.dataId)));
      const y = _.id,
        g = n.makeOutput(h, 'float32');
      if (0 === t.util.sizeFromShape(u.shape)) return g;
      const k = n.dataIdMap.get(g.dataId).id;
      return Tn(y, p, c, m, f, d, l, i ? 1 : 0, s ? 1 : 0, k), null != b && n.disposeData(b.dataId), g;
    },
  };
  let Bn;
  const Hn = {
    kernelName: t.ResizeBilinearGrad,
    backendName: 'wasm',
    setupFunc: function (e) {
      Bn = e.wasm.cwrap(t.ResizeBilinearGrad, null, ['number', 'number', 'number', 'array', 'array', 'boolean']);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { images: r, dy: u } = t,
        { alignCorners: i } = a,
        s = n.makeOutput(r.shape, 'float32');
      let o,
        d = n.dataIdMap.get(r.dataId);
      return (
        'float32' !== d.dtype && ((o = ue({ backend: n, inputs: { x: r }, attrs: { dtype: 'float32' } })), (d = n.dataIdMap.get(o.dataId))),
        Bn(
          n.dataIdMap.get(r.dataId).id,
          n.dataIdMap.get(u.dataId).id,
          n.dataIdMap.get(s.dataId).id,
          new Uint8Array(new Int32Array(r.shape).buffer),
          new Uint8Array(new Int32Array(u.shape).buffer),
          i,
        ),
        null != o && n.disposeData(o.dataId),
        s
      );
    },
  };
  let Ln;
  const Gn = {
    kernelName: t.ResizeNearestNeighbor,
    backendName: 'wasm',
    setupFunc: function (e) {
      Ln = e.wasm.cwrap(t.ResizeNearestNeighbor, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { images: u } = a,
        { alignCorners: i, halfPixelCenters: s, size: o } = r,
        [d, l] = o,
        [p, c, m, f] = u.shape,
        h = [p, d, l, f],
        b = n.makeOutput(h, 'float32');
      if (0 === t.util.sizeFromShape(u.shape)) return b;
      let _,
        y = n.dataIdMap.get(u.dataId);
      'float32' !== y.dtype && ((_ = ue({ backend: n, inputs: { x: u }, attrs: { dtype: 'float32' } })), (y = n.dataIdMap.get(_.dataId)));
      const g = y.id,
        k = n.dataIdMap.get(b.dataId).id;
      return Ln(g, p, c, m, f, d, l, i ? 1 : 0, s ? 1 : 0, k), null != _ && n.disposeData(_.dataId), b;
    },
  };
  let Un;
  const jn = {
    kernelName: t.ResizeNearestNeighborGrad,
    backendName: 'wasm',
    setupFunc: function (e) {
      Un = e.wasm.cwrap(t.ResizeNearestNeighborGrad, null, ['number', 'number', 'number', 'array', 'array', 'boolean']);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { images: r, dy: u } = t,
        { alignCorners: i } = a,
        s = n.makeOutput(r.shape, 'float32');
      let o,
        d = n.dataIdMap.get(r.dataId);
      return (
        'float32' !== d.dtype && ((o = ue({ backend: n, inputs: { x: r }, attrs: { dtype: 'float32' } })), (d = n.dataIdMap.get(o.dataId))),
        Un(
          n.dataIdMap.get(r.dataId).id,
          n.dataIdMap.get(u.dataId).id,
          n.dataIdMap.get(s.dataId).id,
          new Uint8Array(new Int32Array(r.shape).buffer),
          new Uint8Array(new Int32Array(u.shape).buffer),
          i,
        ),
        null != o && n.disposeData(o.dataId),
        s
      );
    },
  };
  let qn;
  const Vn = {
    kernelName: t.Reverse,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { x: u } = n,
        { dims: i } = r,
        s = t.util.parseAxisParam(i, u.shape);
      if (0 === u.shape.length) return g({ inputs: { x: u }, backend: a });
      const o = a.makeOutput(u.shape, u.dtype),
        d = a.dataIdMap.get(u.dataId).id,
        l = a.dataIdMap.get(o.dataId).id,
        p = new Uint8Array(new Int32Array(s).buffer),
        c = new Uint8Array(new Int32Array(u.shape).buffer);
      qn(d, p, s.length, c, u.shape.length, l);
      const m = q({ inputs: { x: o }, attrs: { shape: u.shape }, backend: a });
      return a.disposeData(o.dataId), m;
    },
    setupFunc: function (e) {
      qn = e.wasm.cwrap(t.Reverse, null, ['number', 'array', 'number', 'array', 'number', 'number']);
    },
  };
  let $n;
  const Kn = {
      kernelName: t.RotateWithOffset,
      backendName: 'wasm',
      kernelFunc: function (e) {
        const { inputs: n, backend: a, attrs: r } = e,
          { image: u } = n,
          { radians: i, fillValue: s, center: o } = r,
          d = a.makeOutput(u.shape, u.dtype),
          l = a.dataIdMap.get(u.dataId).id,
          p = a.dataIdMap.get(d.dataId).id,
          [c, m, f, h] = u.shape,
          [b, _] = t.backend_util.getImageCenter(o, m, f),
          y = 'number' == typeof s ? [s, s, s, 0 === s ? 0 : 255] : [...s, 255],
          g = new Uint8Array(new Int32Array(y).buffer);
        return $n(l, c, m, f, h, i, b, _, g, y.length, p), d;
      },
      setupFunc: function (e) {
        $n = e.wasm.cwrap(t.RotateWithOffset, null, [
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'number',
          'array',
          'number',
          'number',
        ]);
      },
    },
    Xn = p(t.Round),
    Qn = p(t.Rsqrt);
  let Jn;
  const Zn = {
    kernelName: t.ScatterNd,
    backendName: 'wasm',
    setupFunc: function (e) {
      Jn = e.wasm.cwrap(t.ScatterNd, null, ['number', 'number', 'number', 'number', 'number', 'number', 'array', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { indices: u, updates: i } = a,
        { shape: o } = r,
        d = n.makeOutput(o, i.dtype);
      if (0 === t.util.sizeFromShape(o)) return d;
      const { sliceRank: l, numUpdates: p, sliceSize: c, strides: m, outputSize: f } = t.scatter_util.calculateShapes(i, u, o),
        h = n.dataIdMap.get(u.dataId).id,
        b = n.dataIdMap.get(i.dataId).id,
        _ = new Uint8Array(new Int32Array(m).buffer),
        y = n.dataIdMap.get(d.dataId).id;
      return Jn(h, b, s[i.dtype], l, p, c, _, f, y), d;
    },
  };
  let Yn;
  const ea = {
    kernelName: t.SearchSorted,
    backendName: 'wasm',
    setupFunc: function (e) {
      Yn = e.wasm.cwrap(t.SearchSorted, null, ['number', 'number', 'number', 'number', 'number', 'number', 'bool', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { sortedSequence: r, values: u } = t,
        { side: i } = a;
      if (r.dtype !== u.dtype)
        throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${r.dtype} and ${u.dtype}`);
      const o = n.makeOutput(u.shape, 'int32');
      function d(e) {
        return n.dataIdMap.get(e.dataId).id;
      }
      return Yn(d(r), d(u), r.shape[0], r.shape[1], u.shape[1], s[r.dtype], 'left' === i, d(o)), o;
    },
  };
  let ta;
  const na = {
      kernelName: t.Select,
      backendName: 'wasm',
      kernelFunc: function (e) {
        const { inputs: n, backend: a } = e,
          { condition: r, t: u, e: i } = n,
          s = a.dataIdMap.get(r.dataId).id,
          o = a.dataIdMap.get(u.dataId).id,
          d = a.dataIdMap.get(i.dataId).id,
          l = a.makeOutput(u.shape, u.dtype),
          p = a.dataIdMap.get(l.dataId).id,
          c = r.shape.length,
          m = u.shape.length,
          f = 0 === c || c > 1 || 1 === m ? 1 : t.util.sizeFromShape(u.shape.slice(1));
        return ta(s, o, d, f, p), l;
      },
      setupFunc: function (e) {
        ta = e.wasm.cwrap('SelectV2', null, ['number', 'number', 'number', 'number', 'number']);
      },
    },
    aa = p(t.Selu);
  let ra;
  const ua = {
      kernelName: 'Sigmoid',
      backendName: 'wasm',
      setupFunc: function (e) {
        ra = e.wasm.cwrap(t.Sigmoid, null, ['number', 'number']);
      },
      kernelFunc: function (e) {
        const {
            backend: n,
            inputs: { x: a },
          } = e,
          r = n.dataIdMap.get(a.dataId).id,
          u = n.makeOutput(a.shape, a.dtype),
          i = n.dataIdMap.get(u.dataId).id;
        return 0 === t.util.sizeFromShape(u.shape) || ra(r, i), u;
      },
    },
    ia = p(t.Sign),
    sa = p(t.Sin),
    oa = p(t.Sinh),
    da = p(t.Softplus);
  const la = {
    kernelName: t.SpaceToBatchND,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: n, backend: a, attrs: r } = e,
        { x: u } = n,
        { blockShape: i, paddings: s } = r,
        o = t.util.sizeFromShape(i),
        d = [[0, 0]];
      d.push(...s);
      for (let e = 1 + i.length; e < u.shape.length; ++e) d.push([0, 0]);
      const l = vn.kernelFunc({ inputs: { x: u }, backend: a, attrs: { paddings: d, constantValue: 0 } }),
        p = t.backend_util.getReshaped(l.shape, i, o, !1),
        c = t.backend_util.getPermuted(p.length, i.length, !1),
        m = t.backend_util.getReshapedPermuted(l.shape, i, o, !1),
        f = q({ inputs: { x: l }, backend: a, attrs: { shape: p } }),
        h = w({ inputs: { x: f }, backend: a, attrs: { perm: c } }),
        b = q({ inputs: { x: h }, backend: a, attrs: { shape: m } });
      return a.disposeData(l.dataId), a.disposeData(f.dataId), a.disposeData(h.dataId), b;
    },
  };
  let pa;
  const ca = {
    kernelName: t.SparseFillEmptyRows,
    backendName: 'wasm',
    setupFunc: function (e) {
      pa = e.wasm.cwrap('SparseFillEmptyRows', 'number', [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a } = e,
        { indices: r, values: u, denseShape: i, defaultValue: o } = a,
        d = r.shape[0],
        l = r.shape[1],
        p = n.readSync(i.dataId)[0],
        c = [d + p, l],
        m = n.dataIdMap.get(r.dataId).id,
        f = n.dataIdMap.get(u.dataId).id,
        h = n.dataIdMap.get(o.dataId).id,
        b = n.makeOutput(c, r.dtype),
        _ = n.dataIdMap.get(b.dataId).id,
        y = n.makeOutput(c.slice(0, 1), u.dtype),
        g = n.dataIdMap.get(y.dataId).id,
        k = n.makeOutput([p], 'bool'),
        I = n.dataIdMap.get(k.dataId).id,
        w = n.makeOutput([d], r.dtype),
        M = n.dataIdMap.get(w.dataId).id,
        S = n.makeOutput([4], 'int32'),
        A = n.dataIdMap.get(S.dataId).id,
        v = pa(m, f, s[u.dtype], d, p, l, h, _, g, I, M, A),
        x = n.readSync(S.dataId);
      let F;
      switch (x[0]) {
        case 1:
          F = t.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(x[1]);
          break;
        case 2:
          F = t.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(x[1], x[2]);
          break;
        case 3:
          F = t.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(x[1], x[2], x[3]);
          break;
        default:
          F = '';
      }
      if ((n.disposeData(S.dataId), F))
        throw (n.disposeData(b.dataId), n.disposeData(y.dataId), n.disposeData(k.dataId), n.disposeData(w.dataId), new Error(F));
      let N = b,
        D = y;
      return (
        v !== c[0] &&
          ((N = Z({ inputs: { x: b }, attrs: { begin: 0, size: [v, l] }, backend: n })),
          (D = Z({ inputs: { x: y }, attrs: { begin: 0, size: v }, backend: n })),
          n.disposeData(b.dataId),
          n.disposeData(y.dataId)),
        [N, D, k, w]
      );
    },
  };
  let ma;
  const fa = {
    kernelName: t.SparseReshape,
    backendName: 'wasm',
    setupFunc: function (e) {
      ma = e.wasm.cwrap(t.SparseReshape, null, ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a } = e,
        { inputIndices: r, inputShape: u, newShape: i } = a;
      if (2 !== r.shape.length) throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);
      if (1 !== u.shape.length) throw new Error(`Input shape should be a vector but received shape\n        ${u.shape}`);
      if (1 !== i.shape.length) throw new Error(`Target shape should be a vector but received shape ${i.shape}`);
      const s = n.dataIdMap.get(r.dataId).id,
        o = n.dataIdMap.get(u.dataId).id,
        d = n.dataIdMap.get(i.dataId).id,
        l = r.shape[0],
        p = t.util.sizeFromShape(i.shape),
        c = n.makeOutput([l, p], r.dtype),
        m = n.dataIdMap.get(c.dataId).id,
        f = n.makeOutput([p], i.dtype),
        h = n.dataIdMap.get(f.dataId).id,
        b = n.makeOutput([3], 'int32'),
        _ = n.dataIdMap.get(b.dataId).id;
      ma(s, o, d, l, m, h, _);
      const y = n.readSync(b.dataId);
      let g;
      switch (y[0]) {
        case 0:
          g = t.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1], y[2]);
          break;
        case 1:
          g = t.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(y[1], y[2]);
          break;
        case 2:
          g = t.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();
          break;
        case 3: {
          const e = Array.from(n.readSync(u.dataId)),
            a = Array.from(n.readSync(f.dataId));
          g = t.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(e, a);
          break;
        }
        case 4: {
          const e = Array.from(n.readSync(u.dataId)),
            a = Array.from(n.readSync(f.dataId));
          g = t.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(e, a);
          break;
        }
        default:
          g = '';
      }
      if ((n.disposeData(b.dataId), g)) throw (n.disposeData(c.dataId), n.disposeData(f.dataId), new Error(g));
      return [c, f];
    },
  };
  let ha;
  function ba(e) {
    ha = e.wasm.cwrap('SparseSegmentReduction', null, [
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
      'number',
    ]);
  }
  function _a(e, n) {
    const { backend: a, inputs: r } = e,
      { data: u, indices: i, segmentIds: o } = r,
      d = i.shape[0],
      l = a.readSync(o.dataId, d - 1, d)[0],
      p = d > 0 ? l + 1 : 0;
    if (p < 0) throw new Error(t.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    const c = u.shape.slice();
    c[0] = p;
    const m = a.dataIdMap.get(u.dataId).id,
      f = a.dataIdMap.get(i.dataId).id,
      h = a.dataIdMap.get(o.dataId).id,
      b = a.makeOutput(c, u.dtype),
      _ = a.dataIdMap.get(b.dataId).id,
      y = a.makeOutput([4], 'int32'),
      g = a.dataIdMap.get(y.dataId).id;
    ha(m, s[u.dtype], u.shape[0], f, h, _, g, n, 0);
    const k = a.readSync(y.dataId);
    let I;
    switch (k[0]) {
      case 0:
        I = t.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();
        break;
      case 1:
        I = t.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();
        break;
      case 2:
        I = t.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(k[1], k[2]);
        break;
      case 3:
        I = t.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(k[1], k[2], k[3]);
        break;
      default:
        I = '';
    }
    if ((a.disposeData(y.dataId), I)) throw (a.disposeData(b.dataId), new Error(I));
    return b;
  }
  const ya = {
    kernelName: t.SparseSegmentMean,
    backendName: 'wasm',
    setupFunc: ba,
    kernelFunc: function (e) {
      return _a(e, !0);
    },
  };
  const ga = {
    kernelName: t.SparseSegmentSum,
    backendName: 'wasm',
    setupFunc: ba,
    kernelFunc: function (e) {
      return _a(e, !1);
    },
  };
  let ka;
  const Ia = {
    kernelName: t.SparseToDense,
    backendName: 'wasm',
    setupFunc: function (e) {
      ka = e.wasm.cwrap(t.SparseToDense, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'array',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { sparseIndices: u, sparseValues: i, defaultValue: o } = a,
        { outputShape: d } = r,
        l = n.makeOutput(d, o.dtype);
      if (0 === t.util.sizeFromShape(d)) return l;
      const { sliceRank: p, numUpdates: c, sliceSize: m, strides: f, outputSize: h } = t.backend_util.calculateShapes(i, u, d),
        b = n.dataIdMap.get(u.dataId).id,
        _ = n.dataIdMap.get(i.dataId).id,
        y = n.dataIdMap.get(o.dataId).id,
        g = new Uint8Array(new Int32Array(f).buffer),
        k = n.dataIdMap.get(l.dataId).id;
      return ka(b, _, i.shape.length, y, s[o.dtype], p, c, m, g, h, k), l;
    },
  };
  const wa = {
      kernelName: t.SplitV,
      backendName: 'wasm',
      kernelFunc: function (e) {
        const { inputs: n, attrs: a, backend: r } = e,
          { x: u } = n,
          { numOrSizeSplits: i, axis: s } = a,
          o = t.util.parseAxisParam(s, u.shape)[0],
          d = t.backend_util.prepareSplitSize(u, i, o),
          l = new Array(u.shape.length).fill(0),
          p = u.shape.slice();
        return d.map(e => {
          const t = [...p];
          t[o] = e;
          const n = Z({ inputs: { x: u }, attrs: { begin: l, size: t }, backend: r });
          return (l[o] += e), n;
        });
      },
    },
    Ma = p(t.Sqrt),
    Sa = p(t.Square),
    Aa = h(t.SquaredDifference);
  let va;
  const xa = {
    kernelName: t.Step,
    backendName: 'wasm',
    setupFunc: function (e) {
      va = e.wasm.cwrap(t.Step, null, ['number', 'number', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { backend: t, inputs: n, attrs: a } = e,
        { alpha: r } = a,
        { x: u } = n,
        i = t.dataIdMap.get(u.dataId).id,
        o = t.makeOutput(u.shape, u.dtype),
        d = t.dataIdMap.get(o.dataId).id;
      return va(i, r, s[u.dtype], d), o;
    },
  };
  let Fa;
  const Na = {
    kernelName: t.StridedSlice,
    backendName: 'wasm',
    setupFunc: function (e) {
      Fa = e.wasm.cwrap(t.StridedSlice, null, [
        'number',
        'array',
        'number',
        'array',
        'array',
        'array',
        'array',
        'array',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { x: u } = a,
        { begin: i, end: s, strides: o, beginMask: d, endMask: l, ellipsisMask: p, newAxisMask: c, shrinkAxisMask: m } = r,
        {
          finalShapeSparse: f,
          finalShape: h,
          isIdentity: b,
          sliceDim0: _,
          isSimpleSlice: y,
          begin: g,
          end: k,
          strides: I,
        } = t.slice_util.sliceInfo(u.shape, i, s, o, d, l, p, c, m);
      let w;
      if (b) w = q({ inputs: { x: u }, backend: n, attrs: { shape: h } });
      else if (_ || y) {
        t.util.assert(u.shape.length >= 1, () => `Input must have rank at least 1, got: ${u.shape.length}`);
        const e = t.slice_util.computeOutShape(g, k, I),
          a = Z({ inputs: { x: u }, backend: n, attrs: { begin: g, size: e } });
        (w = q({ inputs: { x: a }, backend: n, attrs: { shape: h } })), n.disposeData(a.dataId);
      } else {
        const e = n.makeOutput(f, 'float32'),
          a = n.dataIdMap.get(u.dataId).id,
          r = new Uint8Array(new Int32Array(t.util.computeStrides(u.shape)).buffer),
          i = new Uint8Array(new Int32Array(g).buffer),
          s = new Uint8Array(new Int32Array(k).buffer),
          o = new Uint8Array(new Int32Array(I).buffer),
          d = new Uint8Array(new Int32Array(f).buffer),
          l = new Uint8Array(new Int32Array(t.util.computeStrides(f)).buffer),
          p = n.dataIdMap.get(e.dataId).id;
        Fa(a, r, u.shape.length, i, s, o, d, l, f.length, p),
          (w = q({ inputs: { x: e }, backend: n, attrs: { shape: h } })),
          n.disposeData(e.dataId);
      }
      return w;
    },
  };
  const Da = {
    kernelName: t.StringNGrams,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { backend: t, inputs: n, attrs: a } = e,
        { data: r, dataSplits: u } = n,
        { separator: i, nGramWidths: s, leftPad: o, rightPad: d, padWidth: l, preserveShortSequences: p } = a,
        c = t.readSync(r.dataId),
        m = t.readSync(u.dataId),
        [f, h] = (function (e, t, n, a, r, u, i, s) {
          return new Q(n, a, r, u, i, s).compute(e, t);
        })(c, m, i, s, o, d, l, p),
        b = t.makeOutput([f.length], 'string');
      t.dataIdMap.get(b.dataId).stringBytes = f;
      const _ = t.makeOutput(u.shape, 'int32');
      return t.typedArrayFromHeap(_).set(h), [b, _];
    },
  };
  const Ra = {
    kernelName: t.StringSplit,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { input: u, delimiter: i } = a,
        { skipEmpty: s } = r,
        o = n.readSync(u.dataId),
        d = n.readSync(i.dataId),
        [l, p, c] = (function (e, n, a) {
          const r = e.length,
            u = [];
          let i = 0,
            s = 0;
          const o = new Array(r);
          for (let t = 0; t < r; ++t) {
            const r = u.length;
            J(e[t], n, a, u);
            const d = u.length - r;
            (o[t] = d), (i += d), (s = Math.max(s, d));
          }
          const d = t.util.getArrayFromDType('int32', 2 * i),
            l = new Array(i),
            p = [r, s];
          let c = 0;
          for (let e = 0; e < r; ++e) for (let t = 0; t < o[e]; ++t) (d[2 * c] = e), (d[2 * c + 1] = t), (l[c] = u[c]), ++c;
          return [d, l, p];
        })(o, d[0], s),
        m = p.length,
        f = n.makeOutput([m, 2], 'int32');
      n.typedArrayFromHeap(f).set(l);
      const h = n.makeOutput([m], 'string');
      n.dataIdMap.get(h.dataId).stringBytes = p;
      const b = n.makeOutput([2], 'int32');
      return n.typedArrayFromHeap(b).set(c), [f, h, b];
    },
  };
  const Ea = {
      kernelName: t.StringToHashBucketFast,
      backendName: 'wasm',
      kernelFunc: function (e) {
        const { backend: n, inputs: a, attrs: r } = e,
          { input: u } = a,
          { numBuckets: i } = r,
          s = (function (e, n) {
            const a = t.util.getArrayFromDType('int32', e.length);
            for (let r = 0; r < e.length; ++r) a[r] = t.util.fingerPrint64(e[r]).modulo(n).getLowBitsUnsigned();
            return a;
          })(n.readSync(u.dataId), i),
          o = n.makeOutput(u.shape, 'int32');
        return n.typedArrayFromHeap(o).set(s), o;
      },
    },
    Pa = h(t.Sub);
  let Ca;
  const Wa = {
      kernelName: t.Sum,
      backendName: 'wasm',
      setupFunc: function (e) {
        Ca = e.wasm.cwrap(t.Sum, null, ['number', 'number', 'number', 'number']);
      },
      kernelFunc: function (e) {
        const { backend: n, inputs: a, attrs: r } = e,
          { axis: u, keepDims: i } = r,
          { x: o } = a,
          d = n.dataIdMap.get(o.dataId).id;
        let l = d,
          p = o;
        const { transposed: c, axes: m, originalAxes: f, inputWasTransposed: h } = S(o, u, n);
        let b = m;
        if (h) {
          const e = n.dataIdMap.get(c.dataId).id;
          e !== d && ((p = c), (l = e), (b = t.backend_util.getInnerMostAxes(b.length, p.shape.length)));
        }
        t.backend_util.assertAxesAreInnerMostDims('sum', b, p.shape.length);
        const [_, y] = t.backend_util.computeOutAndReduceShapes(p.shape, b),
          g = t.util.sizeFromShape(y),
          k = n.makeOutput(_, p.dtype);
        if (0 !== t.util.sizeFromShape(p.shape)) {
          const e = n.dataIdMap.get(k.dataId).id;
          Ca(l, g, s[k.dtype], e);
        }
        if ((h && n.disposeData(c.dataId), i)) {
          const e = t.backend_util.expandShapeToKeepDim(k.shape, f);
          k.shape = e;
        }
        return k;
      },
    },
    Oa = p(t.Tan),
    Ta = p(t.Tanh);
  let za;
  const Ba = {
    kernelName: t.TensorScatterUpdate,
    backendName: 'wasm',
    setupFunc: function (e) {
      za = e.wasm.cwrap(t.TensorScatterUpdate, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'array',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { tensor: u, indices: i, updates: o } = a,
        d = n.makeOutput(u.shape, u.dtype);
      if (0 === t.util.sizeFromShape(u.shape)) return d;
      const { sliceRank: l, numUpdates: p, sliceSize: c, strides: m, outputSize: f } = t.scatter_util.calculateShapes(o, i, u.shape),
        h = n.dataIdMap.get(i.dataId).id,
        b = n.dataIdMap.get(o.dataId).id,
        _ = n.dataIdMap.get(u.dataId).id,
        y = new Uint8Array(new Int32Array(m).buffer),
        g = n.dataIdMap.get(d.dataId).id;
      return za(h, b, s[o.dtype], l, p, c, y, f, g, _), d;
    },
  };
  let Ha;
  const La = {
    kernelName: t.Tile,
    backendName: 'wasm',
    setupFunc: function (e) {
      Ha = e.wasm.cwrap(t.Tile, null, ['number', 'array', 'number', 'array', 'number', 'number']);
    },
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { x: r } = t,
        u = n.dataIdMap.get(r.dataId).id,
        { reps: i } = a,
        o = new Array(r.shape.length);
      for (let e = 0; e < o.length; e++) o[e] = r.shape[e] * i[e];
      const d = new Uint8Array(new Int32Array(r.shape).buffer),
        l = new Uint8Array(new Int32Array(o).buffer),
        p = n.makeOutput(o, r.dtype),
        c = n.dataIdMap.get(p.dataId).id;
      return Ha(u, d, r.shape.length, l, o.length, s[p.dtype], c), p;
    },
  };
  let Ga;
  const Ua = {
    kernelName: t.TopK,
    backendName: 'wasm',
    setupFunc: function (e) {
      Ga = e.wasm.cwrap(t.TopK, null, ['number', 'array', 'number', 'number', 'number', 'bool', 'number', 'number']);
    },
    kernelFunc: ({ inputs: e, backend: t, attrs: n }) => {
      const { x: a } = e,
        { k: r, sorted: u } = n,
        i = t.dataIdMap.get(a.dataId).id,
        o = new Uint8Array(new Int32Array(a.shape).buffer),
        d = a.shape.slice();
      d[d.length - 1] = r;
      const l = t.makeOutput(d, a.dtype),
        p = t.dataIdMap.get(l.dataId).id,
        c = t.makeOutput(d, 'int32'),
        m = t.dataIdMap.get(c.dataId).id;
      return Ga(i, o, a.shape.length, s[a.dtype], r, u, p, m), [l, c];
    },
  };
  let ja;
  const qa = {
    kernelName: t.Transform,
    backendName: 'wasm',
    setupFunc: function (e) {
      ja = e.wasm.cwrap(t.Transform, null, [
        'number',
        'number',
        'bool',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'array',
        'number',
        'array',
        'number',
        'number',
        'number',
        'number',
        'number',
      ]);
    },
    kernelFunc: function (e) {
      const { backend: n, inputs: a, attrs: r } = e,
        { image: u, transforms: i } = a,
        { interpolation: s, fillMode: o, fillValue: d, outputShape: l } = r,
        [p, c, m, f] = u.shape,
        [h, b] = null != l ? l : [c, m],
        _ = [p, h, b, f],
        y = new Uint8Array(new Int32Array(t.util.computeStrides(u.shape)).buffer),
        g = new Uint8Array(new Int32Array(t.util.computeStrides(_)).buffer),
        k = n.makeOutput(_, u.dtype),
        I = n.dataIdMap.get(k.dataId).id,
        w = n.dataIdMap.get(u.dataId).id,
        M = n.dataIdMap.get(i.dataId).id,
        S = 'nearest' === s ? 1 : 2;
      let A;
      switch (o) {
        case 'constant':
        default:
          A = 1;
          break;
        case 'reflect':
          A = 2;
          break;
        case 'wrap':
          A = 3;
          break;
        case 'nearest':
          A = 4;
      }
      return ja(w, M, i.shape[0] > 1, p, h, b, f, m, c, y, u.shape.length - 1, g, _.length - 1, S, A, d, I), k;
    },
  };
  const Va = {
    kernelName: t.Unique,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: n, attrs: a, backend: r } = e,
        { axis: u } = a,
        { x: i } = n,
        {
          outputValues: s,
          outputShape: o,
          indices: d,
        } = (function (e, n, a, r) {
          const u = t.util.parseAxisParam(n, a)[0],
            i = [1, a[0], 1];
          for (let e = 0; e < u; e++) i[0] *= a[e];
          i[1] = a[u];
          for (let e = u + 1; e < a.length; e++) i[2] *= a[e];
          const s = new Map(),
            o = new Int32Array(a[u]),
            d = new t.TensorBuffer(i, r, e),
            l = [],
            p = 1 === i[0] && 1 === i[2];
          for (let t = 0; t < a[u]; t++) {
            let n;
            if (p) n = e[t].toString();
            else {
              const e = [];
              for (let n = 0; n < i[0]; n++) for (let a = 0; a < i[2]; a++) e.push(d.get(n, t, a));
              n = e.join(',');
            }
            const a = s.get(n);
            if (null != a) o[t] = a;
            else {
              const e = s.size;
              s.set(n, e), (o[t] = e), l.push(t);
            }
          }
          const c = i.slice();
          c[1] = s.size;
          const m = new t.TensorBuffer(c, r);
          l.forEach((e, t) => {
            for (let n = 0; n < i[0]; n++) for (let a = 0; a < i[2]; a++) m.set(d.get(n, e, a), n, t, a);
          });
          const f = a.slice();
          return (f[u] = c[1]), { outputValues: m.values, outputShape: f, indices: o };
        })(r.readSync(i.dataId), u, i.shape, i.dtype);
      return [r.makeOutput(o, i.dtype, void 0, s), r.makeOutput([d.length], 'int32', void 0, d)];
    },
  };
  const $a = {
    kernelName: t.Unpack,
    backendName: 'wasm',
    kernelFunc: function (e) {
      const { inputs: t, backend: n, attrs: a } = e,
        { value: r } = t;
      let { axis: u } = a;
      u < 0 && (u += r.shape.length);
      const i = r.shape[u],
        s = r.shape.length,
        o = new Array(s - 1);
      let d = 0;
      for (let e = 0; e < s; e++) e !== u && (o[d++] = r.shape[e]);
      const l = new Array(i),
        p = new Array(s).fill(0),
        c = r.shape.slice();
      c[u] = 1;
      for (let e = 0; e < l.length; e++) (p[u] = e), (l[e] = Z({ inputs: { x: r }, attrs: { begin: p, size: c }, backend: n }));
      return l.map(({ dataId: e, dtype: t }) => ({ dataId: e, dtype: t, shape: o }));
    },
  };
  const Ka = {
      kernelName: t.ZerosLike,
      backendName: 'wasm',
      kernelFunc: function (e) {
        const {
            inputs: { x: t },
            backend: n,
          } = e,
          a = n.makeOutput(t.shape, t.dtype);
        return n.typedArrayFromHeap(a).fill(0), a;
      },
    },
    Xa = [
      l,
      c,
      m,
      f,
      b,
      y,
      v,
      F,
      D,
      R,
      E,
      P,
      C,
      W,
      O,
      z,
      j,
      H,
      G,
      K,
      ee,
      ne,
      ae,
      re,
      ie,
      se,
      de,
      pe,
      me,
      he,
      _e,
      ge,
      Ie,
      we,
      Me,
      ve,
      Fe,
      De,
      Ee,
      Ce,
      Oe,
      ze,
      He,
      Ge,
      je,
      qe,
      $e,
      Ke,
      Xe,
      Qe,
      Ze,
      Ye,
      tt,
      at,
      rt,
      ut,
      st,
      dt,
      pt,
      mt,
      ht,
      bt,
      _t,
      k,
      yt,
      gt,
      kt,
      wt,
      Mt,
      St,
      vt,
      Ft,
      xt,
      Nt,
      Dt,
      Rt,
      Et,
      Ct,
      Ot,
      zt,
      Bt,
      Lt,
      Ut,
      qt,
      $t,
      Xt,
      Jt,
      Yt,
      en,
      an,
      dn,
      ln,
      pn,
      cn,
      hn,
      _n,
      gn,
      kn,
      wn,
      Mn,
      Sn,
      vn,
      xn,
      Nn,
      Rn,
      En,
      Pn,
      Cn,
      Wn,
      On,
      V,
      zn,
      Hn,
      Gn,
      jn,
      Vn,
      Kn,
      Xn,
      Qn,
      Zn,
      ea,
      na,
      aa,
      ua,
      ia,
      sa,
      oa,
      Y,
      sn,
      da,
      la,
      ca,
      fa,
      ya,
      ga,
      Ia,
      wa,
      Ma,
      Sa,
      Aa,
      xa,
      Na,
      Da,
      Ra,
      Ea,
      Pa,
      Wa,
      Oa,
      Ta,
      Ba,
      La,
      Ua,
      qa,
      M,
      Va,
      $a,
      Ka,
    ];
  for (const e of Xa) t.registerKernel(e);
  const Qa = t.env();
  Qa.registerFlag('WASM_HAS_SIMD_SUPPORT', async () => {
    try {
      return WebAssembly.validate(
        new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]),
      );
    } catch (e) {
      return !1;
    }
  }),
    Qa.registerFlag('WASM_HAS_MULTITHREAD_SUPPORT', async () => {
      if (Qa.get('IS_NODE')) return !1;
      try {
        return (
          new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),
          WebAssembly.validate(
            new Uint8Array([
              0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11,
            ]),
          )
        );
      } catch (e) {
        return !1;
      }
    });
  var Ja =
    'undefined' != typeof globalThis
      ? globalThis
      : 'undefined' != typeof window
      ? window
      : 'undefined' != typeof global
      ? global
      : 'undefined' != typeof self
      ? self
      : {};
  function Za(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
  }
  var Ya = { exports: {} };
  !(function (e, t) {
    var i,
      s =
        ((i = 'undefined' != typeof document && document.currentScript ? document.currentScript.src : void 0),
        'undefined' != typeof __filename && (i = i || __filename),
        function (e) {
          function t() {
            return P.buffer != T && V(P.buffer), z;
          }
          function s() {
            return P.buffer != T && V(P.buffer), B;
          }
          function o() {
            return P.buffer != T && V(P.buffer), H;
          }
          function d() {
            return P.buffer != T && V(P.buffer), L;
          }
          function l() {
            return P.buffer != T && V(P.buffer), G;
          }
          var p,
            c,
            m,
            f = 'undefined' != typeof (e = e || {}) ? e : {};
          (f.ready = new Promise(function (e, t) {
            (p = e), (c = t);
          })),
            'undefined' != typeof process &&
              process.listeners &&
              (m = {
                uncaughtException: process.listeners('uncaughtException'),
                unhandledRejection: process.listeners('unhandledRejection'),
              });
          var h,
            b,
            _,
            y = Object.assign({}, f),
            g = (e, t) => {
              throw t;
            },
            k = 'object' == typeof window,
            I = 'function' == typeof importScripts,
            w = 'object' == typeof process && 'object' == typeof process.versions && 'string' == typeof process.versions.node,
            M = f.ENVIRONMENT_IS_PTHREAD || !1,
            S = '';
          function A(e) {
            return f.locateFile ? f.locateFile(e, S) : S + e;
          }
          if (w) {
            var v = n,
              x = a;
            let e;
            (S = I ? x.dirname(S) + '/' : __dirname + '/'),
              (h = (e, t) => ((e = ue(e) ? new URL(e) : x.normalize(e)), v.readFileSync(e, t ? void 0 : 'utf8'))),
              (_ = e => {
                var t = h(e, !0);
                return t.buffer || (t = new Uint8Array(t)), t;
              }),
              (b = (e, t, n) => {
                (e = ue(e) ? new URL(e) : x.normalize(e)),
                  v.readFile(e, function (e, a) {
                    e ? n(e) : t(a.buffer);
                  });
              }),
              process.argv.length > 1 && process.argv[1].replace(/\\/g, '/'),
              process.argv.slice(2),
              process.on('uncaughtException', function (e) {
                if (!(e instanceof oe)) throw e;
              }),
              process.on('unhandledRejection', function (e) {
                throw e;
              }),
              (g = (e, t) => {
                if (Z()) throw ((process.exitCode = e), t);
                var n;
                (n = t) instanceof oe || E('exiting due to exception: ' + n), process.exit(e);
              }),
              (f.inspect = function () {
                return '[Emscripten Module object]';
              });
            try {
              e = require('worker_threads');
            } catch (e) {
              throw (
                (console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),
                e)
              );
            }
            Ja.Worker = e.Worker;
          } else
            (k || I) &&
              (I ? (S = self.location.href) : 'undefined' != typeof document && document.currentScript && (S = document.currentScript.src),
              'undefined' != typeof i && i && (S = i),
              (S = 0 !== S.indexOf('blob:') ? S.substr(0, S.replace(/[?#].*/, '').lastIndexOf('/') + 1) : ''),
              w ||
                ((h = e => {
                  var t = new XMLHttpRequest();
                  return t.open('GET', e, !1), t.send(null), t.responseText;
                }),
                I &&
                  (_ = e => {
                    var t = new XMLHttpRequest();
                    return t.open('GET', e, !1), (t.responseType = 'arraybuffer'), t.send(null), new Uint8Array(t.response);
                  }),
                (b = (e, t, n) => {
                  var a = new XMLHttpRequest();
                  a.open('GET', e, !0),
                    (a.responseType = 'arraybuffer'),
                    (a.onload = () => {
                      200 == a.status || (0 == a.status && a.response) ? t(a.response) : n();
                    }),
                    (a.onerror = n),
                    a.send(null);
                })));
          w && 'undefined' == typeof performance && (Ja.performance = r.performance);
          var F = console.log.bind(console),
            N = console.warn.bind(console);
          w && ((F = e => v.writeSync(1, e + '\n')), (N = e => v.writeSync(2, e + '\n')));
          var D,
            R = f.print || F,
            E = f.printErr || N;
          Object.assign(f, y),
            (y = null),
            f.arguments && f.arguments,
            f.thisProgram && f.thisProgram,
            f.quit && (g = f.quit),
            f.wasmBinary && (D = f.wasmBinary);
          var P,
            C,
            W = f.noExitRuntime || !0;
          'object' != typeof WebAssembly && ae('no native wasm support detected');
          var O,
            T,
            z,
            B,
            H,
            L,
            G,
            U = !1,
            j = 'undefined' != typeof TextDecoder ? new TextDecoder('utf8') : void 0;
          function q(e, t, n) {
            for (var a = (t >>>= 0) + n, r = t; e[r] && !(r >= a); ) ++r;
            if (r - t > 16 && e.buffer && j) return j.decode(e.buffer instanceof SharedArrayBuffer ? e.slice(t, r) : e.subarray(t, r));
            for (var u = ''; t < r; ) {
              var i = e[t++];
              if (128 & i) {
                var s = 63 & e[t++];
                if (192 != (224 & i)) {
                  var o = 63 & e[t++];
                  if (
                    (i = 224 == (240 & i) ? ((15 & i) << 12) | (s << 6) | o : ((7 & i) << 18) | (s << 12) | (o << 6) | (63 & e[t++])) <
                    65536
                  )
                    u += String.fromCharCode(i);
                  else {
                    var d = i - 65536;
                    u += String.fromCharCode(55296 | (d >> 10), 56320 | (1023 & d));
                  }
                } else u += String.fromCharCode(((31 & i) << 6) | s);
              } else u += String.fromCharCode(i);
            }
            return u;
          }
          function V(e) {
            (T = e),
              (f.HEAP8 = z = new Int8Array(e)),
              (f.HEAP16 = new Int16Array(e)),
              (f.HEAP32 = H = new Int32Array(e)),
              (f.HEAPU8 = B = new Uint8Array(e)),
              (f.HEAPU16 = new Uint16Array(e)),
              (f.HEAPU32 = L = new Uint32Array(e)),
              (f.HEAPF32 = new Float32Array(e)),
              (f.HEAPF64 = G = new Float64Array(e));
          }
          M && (T = f.buffer);
          var $,
            K = f.INITIAL_MEMORY || 16777216;
          if (M) (P = f.wasmMemory), (T = f.buffer);
          else if (f.wasmMemory) P = f.wasmMemory;
          else if (!((P = new WebAssembly.Memory({ initial: K / 65536, maximum: 65536, shared: !0 })).buffer instanceof SharedArrayBuffer))
            throw (
              (E(
                'requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag',
              ),
              w && E('(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)'),
              Error('bad memory'))
            );
          P && (T = P.buffer), (K = T.byteLength), V(T);
          var X = [],
            Q = [],
            J = [];
          function Z() {
            return W;
          }
          function Y() {
            M || fe(Q);
          }
          var ee,
            te = 0,
            ne = null;
          function ae(e) {
            f.onAbort && f.onAbort(e), E((e = 'Aborted(' + e + ')')), (U = !0), (O = 1), (e += '. Build with -sASSERTIONS for more info.');
            var t = new WebAssembly.RuntimeError(e);
            throw (c(t), t);
          }
          function re(e) {
            return e.startsWith('data:application/octet-stream;base64,');
          }
          function ue(e) {
            return e.startsWith('file://');
          }
          function ie(e) {
            try {
              if (e == ee && D) return new Uint8Array(D);
              if (_) return _(e);
              throw 'both async and sync fetching of the wasm failed';
            } catch (e) {
              ae(e);
            }
          }
          re((ee = 'tfjs-backend-wasm-threaded-simd.wasm')) || (ee = A(ee));
          var se = {};
          function oe(e) {
            (this.name = 'ExitStatus'), (this.message = 'Program terminated with exit(' + e + ')'), (this.status = e);
          }
          function de(e) {
            var t,
              n = me.pthreads[e];
            n || ae(t), me.returnWorkerToPool(n);
          }
          function le(e) {
            var t = me.getNewWorker();
            if (!t) return 6;
            me.runningWorkers.push(t), (me.pthreads[e.pthread_ptr] = t), (t.pthread_ptr = e.pthread_ptr);
            var n = { cmd: 'run', start_routine: e.startRoutine, arg: e.arg, pthread_ptr: e.pthread_ptr };
            return (
              (t.runPthread = () => {
                w && t.ref(), t.postMessage(n, e.transferList), delete t.runPthread;
              }),
              t.loaded && t.runPthread(),
              0
            );
          }
          function pe(e) {
            if (M) return Me(1, 1, e);
            (O = e), Z() || (me.terminateAllThreads(), f.onExit && f.onExit(e), (U = !0)), g(e, new oe(e));
          }
          var ce = function (e, t) {
              if (((O = e), !t && M)) throw (he(e), 'unwind');
              pe(e);
            },
            me = {
              unusedWorkers: [],
              runningWorkers: [],
              tlsInitFunctions: [],
              pthreads: {},
              init: function () {
                M ? me.initWorker() : me.initMainThread();
              },
              initMainThread: function () {
                for (var e = 8; e--; ) me.allocateUnusedWorker();
              },
              initWorker: function () {
                W = !1;
              },
              setExitStatus: function (e) {
                O = e;
              },
              terminateAllThreads: function () {
                for (var e of Object.values(me.pthreads)) me.returnWorkerToPool(e);
                for (var e of me.unusedWorkers) e.terminate();
                me.unusedWorkers = [];
              },
              returnWorkerToPool: function (e) {
                var t = e.pthread_ptr;
                delete me.pthreads[t],
                  me.unusedWorkers.push(e),
                  me.runningWorkers.splice(me.runningWorkers.indexOf(e), 1),
                  (e.pthread_ptr = 0),
                  w && e.unref(),
                  Ge(t);
              },
              receiveObjectTransfer: function (e) {},
              threadInitTLS: function () {
                me.tlsInitFunctions.forEach(e => e());
              },
              loadWasmModuleToWorker: function (e, t) {
                (e.onmessage = n => {
                  var a,
                    r = n.data,
                    u = r.cmd;
                  if (
                    (e.pthread_ptr && (me.currentProxiedOperationCallerThread = e.pthread_ptr), r.targetThread && r.targetThread != We())
                  ) {
                    var i = me.pthreads[r.targetThread];
                    return (
                      i
                        ? i.postMessage(r, r.transferList)
                        : E(
                            'Internal error! Worker sent a message "' +
                              u +
                              '" to target pthread ' +
                              r.targetThread +
                              ', but that thread no longer exists!',
                          ),
                      void (me.currentProxiedOperationCallerThread = void 0)
                    );
                  }
                  'processProxyingQueue' === u
                    ? ke(r.queue)
                    : 'spawnThread' === u
                    ? le(r)
                    : 'cleanupThread' === u
                    ? de(r.thread)
                    : 'killThread' === u
                    ? (function (e) {
                        var t = me.pthreads[e];
                        delete me.pthreads[e],
                          t.terminate(),
                          Ge(e),
                          me.runningWorkers.splice(me.runningWorkers.indexOf(t), 1),
                          (t.pthread_ptr = 0);
                      })(r.thread)
                    : 'cancelThread' === u
                    ? ((a = r.thread), me.pthreads[a].postMessage({ cmd: 'cancel' }))
                    : 'loaded' === u
                    ? ((e.loaded = !0), w && e.unref(), t && t(e), e.runPthread && e.runPthread())
                    : 'print' === u
                    ? R('Thread ' + r.threadId + ': ' + r.text)
                    : 'printErr' === u
                    ? E('Thread ' + r.threadId + ': ' + r.text)
                    : 'alert' === u
                    ? alert('Thread ' + r.threadId + ': ' + r.text)
                    : 'setimmediate' === r.target
                    ? e.postMessage(r)
                    : 'callHandler' === u
                    ? f[r.handler](...r.args)
                    : u && E('worker sent an unknown command ' + u),
                    (me.currentProxiedOperationCallerThread = void 0);
                }),
                  (e.onerror = e => {
                    throw (E('worker sent an error! ' + e.filename + ':' + e.lineno + ': ' + e.message), e);
                  }),
                  w &&
                    (e.on('message', function (t) {
                      e.onmessage({ data: t });
                    }),
                    e.on('error', function (t) {
                      e.onerror(t);
                    }),
                    e.on('detachedExit', function () {}));
                var n = [];
                for (var a of ['onExit', 'onAbort', 'print', 'printErr']) f.hasOwnProperty(a) && n.push(a);
                e.postMessage({ cmd: 'load', handlers: n, urlOrBlob: f.mainScriptUrlOrBlob || i, wasmMemory: P, wasmModule: C });
              },
              allocateUnusedWorker: function () {
                var e,
                  t = A('tfjs-backend-wasm-threaded-simd.worker.js');
                (e = new Worker(t)), me.unusedWorkers.push(e);
              },
              getNewWorker: function () {
                return (
                  0 == me.unusedWorkers.length && (me.allocateUnusedWorker(), me.loadWasmModuleToWorker(me.unusedWorkers[0])),
                  me.unusedWorkers.pop()
                );
              },
            };
          function fe(e) {
            for (; e.length > 0; ) e.shift()(f);
          }
          function he(e) {
            if (M) return Me(2, 0, e);
            try {
              ce(e);
            } catch (e) {
              !(function (e) {
                if (e instanceof oe || 'unwind' == e) return O;
                g(1, e);
              })(e);
            }
          }
          (f.PThread = me),
            (f.establishStackSpace = function () {
              var e = We(),
                t = o()[(e + 52) >>> 2],
                n = o()[(e + 56) >>> 2];
              je(t, t - n), Ve(t);
            });
          var be,
            _e = [];
          function ye(e, t, n, a) {
            return M ? Me(3, 1, e, t, n, a) : ge(e, t, n, a);
          }
          function ge(e, t, n, a) {
            if ('undefined' == typeof SharedArrayBuffer)
              return E('Current environment does not support SharedArrayBuffer, pthreads are not available!'), 6;
            var r = [];
            if (M && 0 === r.length) return ye(e, t, n, a);
            var u = { startRoutine: n, pthread_ptr: e, arg: a, transferList: r };
            return M ? ((u.cmd = 'spawnThread'), postMessage(u, r), 0) : le(u);
          }
          function ke(e) {
            Atomics.store(o(), e >> 2, 1), We() && Le(e), Atomics.compareExchange(o(), e >> 2, 1, 0);
          }
          function Ie(e) {
            Ie.shown || (Ie.shown = {}), Ie.shown[e] || ((Ie.shown[e] = 1), w && (e = 'warning: ' + e), E(e));
          }
          function we(e) {
            var t = qe(),
              n = e();
            return Ve(t), n;
          }
          function Me(e, t) {
            var n = arguments.length - 2,
              a = arguments;
            return we(() => {
              for (var r = n, u = $e(8 * r), i = u >> 3, s = 0; s < n; s++) {
                var o = a[2 + s];
                l()[(i + s) >>> 0] = o;
              }
              return Te(e, r, u, t);
            });
          }
          (f.invokeEntryPoint = function (e, t) {
            var n,
              a,
              r = ((a = _e[(n = e)]) || (n >= _e.length && (_e.length = n + 1), (_e[n] = a = $.get(n))), a)(t);
            Z() ? me.setExitStatus(r) : Ue(r);
          }),
            (f.executeNotifiedProxyingQueue = ke),
            (be = w
              ? () => {
                  var e = process.hrtime();
                  return 1e3 * e[0] + e[1] / 1e6;
                }
              : () => performance.timeOrigin + performance.now());
          var Se = [];
          function Ae(e) {
            try {
              return P.grow((e - T.byteLength + 65535) >>> 16), V(P.buffer), 1;
            } catch (e) {}
          }
          function ve(e) {
            return M ? Me(4, 1, e) : 52;
          }
          function xe(e, t, n, a, r) {
            return M ? Me(5, 1, e, t, n, a, r) : 70;
          }
          var Fe = [null, [], []];
          function Ne(e, t) {
            var n = Fe[e];
            0 === t || 10 === t ? ((1 === e ? R : E)(q(n, 0)), (n.length = 0)) : n.push(t);
          }
          function De(e, t, n, a) {
            if (M) return Me(6, 1, e, t, n, a);
            for (var r = 0, u = 0; u < n; u++) {
              var i = d()[t >>> 2],
                o = d()[(t + 4) >>> 2];
              t += 8;
              for (var l = 0; l < o; l++) Ne(e, s()[(i + l) >>> 0]);
              r += o;
            }
            return (d()[a >>> 2] = r), 0;
          }
          function Re(e) {
            return f['_' + e];
          }
          function Ee(e, n, a, r, u) {
            var i = {
              string: e => {
                var t = 0;
                if (null != e && 0 !== e) {
                  var n = 1 + (e.length << 2);
                  !(function (e, t, n) {
                    !(function (e, t, n, a) {
                      if (!(a > 0)) return 0;
                      n >>>= 0;
                      for (var r = n + a - 1, u = 0; u < e.length; ++u) {
                        var i = e.charCodeAt(u);
                        if ((i >= 55296 && i <= 57343 && (i = (65536 + ((1023 & i) << 10)) | (1023 & e.charCodeAt(++u))), i <= 127)) {
                          if (n >= r) break;
                          t[n++ >>> 0] = i;
                        } else if (i <= 2047) {
                          if (n + 1 >= r) break;
                          (t[n++ >>> 0] = 192 | (i >> 6)), (t[n++ >>> 0] = 128 | (63 & i));
                        } else if (i <= 65535) {
                          if (n + 2 >= r) break;
                          (t[n++ >>> 0] = 224 | (i >> 12)), (t[n++ >>> 0] = 128 | ((i >> 6) & 63)), (t[n++ >>> 0] = 128 | (63 & i));
                        } else {
                          if (n + 3 >= r) break;
                          (t[n++ >>> 0] = 240 | (i >> 18)),
                            (t[n++ >>> 0] = 128 | ((i >> 12) & 63)),
                            (t[n++ >>> 0] = 128 | ((i >> 6) & 63)),
                            (t[n++ >>> 0] = 128 | (63 & i));
                        }
                      }
                      t[n >>> 0] = 0;
                    })(e, s(), t, n);
                  })(e, (t = $e(n)), n);
                }
                return t;
              },
              array: e => {
                var n = $e(e.length);
                return (
                  (function (e, n) {
                    t().set(e, n >>> 0);
                  })(e, n),
                  n
                );
              },
            };
            function o(e) {
              return 'string' === n ? ((t = e), (t >>>= 0) ? q(s(), t, a) : '') : 'boolean' === n ? Boolean(e) : e;
              var t, a;
            }
            var d = Re(e),
              l = [],
              p = 0;
            if (r)
              for (var c = 0; c < r.length; c++) {
                var m = i[a[c]];
                m ? (0 === p && (p = qe()), (l[c] = m(r[c]))) : (l[c] = r[c]);
              }
            var f = d.apply(null, l);
            return (f = (function (e) {
              return 0 !== p && Ve(p), o(e);
            })(f));
          }
          me.init();
          var Pe = [null, pe, he, ye, ve, xe, De],
            Ce = {
              __emscripten_init_main_thread_js: function (e) {
                Oe(e, !I, 1, !k), me.threadInitTLS();
              },
              __emscripten_thread_cleanup: function (e) {
                M ? postMessage({ cmd: 'cleanupThread', thread: e }) : de(e);
              },
              __pthread_create_js: ge,
              _emscripten_default_pthread_stack_size: function () {
                return 65536;
              },
              _emscripten_get_now_is_monotonic: function () {
                return !0;
              },
              _emscripten_notify_task_queue: function (e, t, n, a) {
                if (e == t) setTimeout(() => ke(a));
                else if (M) postMessage({ targetThread: e, cmd: 'processProxyingQueue', queue: a });
                else {
                  var r = me.pthreads[e];
                  if (!r) return;
                  r.postMessage({ cmd: 'processProxyingQueue', queue: a });
                }
                return 1;
              },
              _emscripten_set_offscreencanvas_size: function (e, t, n) {
                return -1;
              },
              abort: function () {
                ae('');
              },
              emscripten_check_blocking_allowed: function () {
                w ||
                  I ||
                  Ie(
                    'Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread',
                  );
              },
              emscripten_date_now: function () {
                return Date.now();
              },
              emscripten_get_heap_max: function () {
                return 4294901760;
              },
              emscripten_get_now: be,
              emscripten_memcpy_big: function (e, t, n) {
                s().copyWithin(e >>> 0, t >>> 0, (t + n) >>> 0);
              },
              emscripten_num_logical_cores: function () {
                return w ? u.cpus().length : navigator.hardwareConcurrency;
              },
              emscripten_receive_on_main_thread_js: function (e, t, n) {
                Se.length = t;
                for (var a = n >> 3, r = 0; r < t; r++) Se[r] = l()[(a + r) >>> 0];
                return (e < 0 ? se[-e - 1] : Pe[e]).apply(null, Se);
              },
              emscripten_resize_heap: function (e) {
                var t = s().length;
                if ((e >>>= 0) <= t) return !1;
                var n,
                  a,
                  r = 4294901760;
                if (e > r) return !1;
                for (var u = 1; u <= 4; u *= 2) {
                  var i = t * (1 + 0.2 / u);
                  if (((i = Math.min(i, e + 100663296)), Ae(Math.min(r, (n = Math.max(e, i)) + (((a = 65536) - (n % a)) % a))))) return !0;
                }
                return !1;
              },
              emscripten_unwind_to_js_event_loop: function () {
                throw 'unwind';
              },
              exit: ce,
              fd_close: ve,
              fd_seek: xe,
              fd_write: De,
              memory: P || f.wasmMemory,
            };
          !(function () {
            var e = { env: Ce, wasi_snapshot_preview1: Ce };
            function t(e, t) {
              var n,
                a,
                r = e.exports;
              if (
                ((f.asm = r),
                (n = f.asm._emscripten_tls_init),
                me.tlsInitFunctions.push(n),
                ($ = f.asm.__indirect_function_table),
                (a = f.asm.__wasm_call_ctors),
                Q.unshift(a),
                (C = t),
                !M)
              ) {
                var u = me.unusedWorkers.length;
                me.unusedWorkers.forEach(function (e) {
                  me.loadWasmModuleToWorker(e, function () {
                    --u ||
                      (function (e) {
                        if ((te--, f.monitorRunDependencies && f.monitorRunDependencies(te), 0 == te && ne)) {
                          var t = ne;
                          (ne = null), t();
                        }
                      })();
                  });
                });
              }
            }
            function n(e) {
              t(e.instance, e.module);
            }
            function a(t) {
              return (function () {
                if (!D && (k || I)) {
                  if ('function' == typeof fetch && !ue(ee))
                    return fetch(ee, { credentials: 'same-origin' })
                      .then(function (e) {
                        if (!e.ok) throw "failed to load wasm binary file at '" + ee + "'";
                        return e.arrayBuffer();
                      })
                      .catch(function () {
                        return ie(ee);
                      });
                  if (b)
                    return new Promise(function (e, t) {
                      b(
                        ee,
                        function (t) {
                          e(new Uint8Array(t));
                        },
                        t,
                      );
                    });
                }
                return Promise.resolve().then(function () {
                  return ie(ee);
                });
              })()
                .then(function (t) {
                  return WebAssembly.instantiate(t, e);
                })
                .then(function (e) {
                  return e;
                })
                .then(t, function (e) {
                  E('failed to asynchronously prepare wasm: ' + e), ae(e);
                });
            }
            if ((M || (te++, f.monitorRunDependencies && f.monitorRunDependencies(te)), f.instantiateWasm))
              try {
                return f.instantiateWasm(e, t);
              } catch (e) {
                E('Module.instantiateWasm callback failed with error: ' + e), c(e);
              }
            (D || 'function' != typeof WebAssembly.instantiateStreaming || re(ee) || ue(ee) || w || 'function' != typeof fetch
              ? a(n)
              : fetch(ee, { credentials: 'same-origin' }).then(function (t) {
                  return WebAssembly.instantiateStreaming(t, e).then(n, function (e) {
                    return E('wasm streaming compile failed: ' + e), E('falling back to ArrayBuffer instantiation'), a(n);
                  });
                })
            ).catch(c);
          })(),
            (f.___wasm_call_ctors = function () {
              return (f.___wasm_call_ctors = f.asm.__wasm_call_ctors).apply(null, arguments);
            }),
            (f._init = function () {
              return (f._init = f.asm.init).apply(null, arguments);
            }),
            (f._init_with_threads_count = function () {
              return (f._init_with_threads_count = f.asm.init_with_threads_count).apply(null, arguments);
            }),
            (f._get_threads_count = function () {
              return (f._get_threads_count = f.asm.get_threads_count).apply(null, arguments);
            }),
            (f._register_tensor = function () {
              return (f._register_tensor = f.asm.register_tensor).apply(null, arguments);
            }),
            (f._dispose_data = function () {
              return (f._dispose_data = f.asm.dispose_data).apply(null, arguments);
            }),
            (f._dispose = function () {
              return (f._dispose = f.asm.dispose).apply(null, arguments);
            }),
            (f._Abs = function () {
              return (f._Abs = f.asm.Abs).apply(null, arguments);
            }),
            (f._Acos = function () {
              return (f._Acos = f.asm.Acos).apply(null, arguments);
            }),
            (f._Acosh = function () {
              return (f._Acosh = f.asm.Acosh).apply(null, arguments);
            }),
            (f._Add = function () {
              return (f._Add = f.asm.Add).apply(null, arguments);
            }),
            (f._AddN = function () {
              return (f._AddN = f.asm.AddN).apply(null, arguments);
            }),
            (f._All = function () {
              return (f._All = f.asm.All).apply(null, arguments);
            }),
            (f._Any = function () {
              return (f._Any = f.asm.Any).apply(null, arguments);
            }),
            (f._ArgMax = function () {
              return (f._ArgMax = f.asm.ArgMax).apply(null, arguments);
            }),
            (f._ArgMin = function () {
              return (f._ArgMin = f.asm.ArgMin).apply(null, arguments);
            }),
            (f._Asin = function () {
              return (f._Asin = f.asm.Asin).apply(null, arguments);
            }),
            (f._Asinh = function () {
              return (f._Asinh = f.asm.Asinh).apply(null, arguments);
            }),
            (f._Atan = function () {
              return (f._Atan = f.asm.Atan).apply(null, arguments);
            }),
            (f._Atan2 = function () {
              return (f._Atan2 = f.asm.Atan2).apply(null, arguments);
            }),
            (f._Atanh = function () {
              return (f._Atanh = f.asm.Atanh).apply(null, arguments);
            }),
            (f._AvgPool = function () {
              return (f._AvgPool = f.asm.AvgPool).apply(null, arguments);
            }),
            (f._AvgPool3D = function () {
              return (f._AvgPool3D = f.asm.AvgPool3D).apply(null, arguments);
            }),
            (f._AvgPool3DGrad = function () {
              return (f._AvgPool3DGrad = f.asm.AvgPool3DGrad).apply(null, arguments);
            }),
            (f._AvgPoolGrad = function () {
              return (f._AvgPoolGrad = f.asm.AvgPoolGrad).apply(null, arguments);
            }),
            (f._BatchMatMul = function () {
              return (f._BatchMatMul = f.asm.BatchMatMul).apply(null, arguments);
            }),
            (f._Bincount = function () {
              return (f._Bincount = f.asm.Bincount).apply(null, arguments);
            }),
            (f._BitwiseAnd = function () {
              return (f._BitwiseAnd = f.asm.BitwiseAnd).apply(null, arguments);
            }),
            (f._Ceil = function () {
              return (f._Ceil = f.asm.Ceil).apply(null, arguments);
            }),
            (f._ClipByValue = function () {
              return (f._ClipByValue = f.asm.ClipByValue).apply(null, arguments);
            }),
            (f._Conv2D = function () {
              return (f._Conv2D = f.asm.Conv2D).apply(null, arguments);
            }),
            (f._Conv2DBackpropInput = function () {
              return (f._Conv2DBackpropInput = f.asm.Conv2DBackpropInput).apply(null, arguments);
            }),
            (f._Conv3D = function () {
              return (f._Conv3D = f.asm.Conv3D).apply(null, arguments);
            }),
            (f._Conv3DBackpropFilterV2 = function () {
              return (f._Conv3DBackpropFilterV2 = f.asm.Conv3DBackpropFilterV2).apply(null, arguments);
            }),
            (f._Conv3DBackpropInputV2 = function () {
              return (f._Conv3DBackpropInputV2 = f.asm.Conv3DBackpropInputV2).apply(null, arguments);
            }),
            (f._Cos = function () {
              return (f._Cos = f.asm.Cos).apply(null, arguments);
            }),
            (f._Cosh = function () {
              return (f._Cosh = f.asm.Cosh).apply(null, arguments);
            }),
            (f._CropAndResize = function () {
              return (f._CropAndResize = f.asm.CropAndResize).apply(null, arguments);
            }),
            (f._Cumprod = function () {
              return (f._Cumprod = f.asm.Cumprod).apply(null, arguments);
            }),
            (f._Cumsum = function () {
              return (f._Cumsum = f.asm.Cumsum).apply(null, arguments);
            }),
            (f._DenseBincount = function () {
              return (f._DenseBincount = f.asm.DenseBincount).apply(null, arguments);
            }),
            (f._DepthToSpace = function () {
              return (f._DepthToSpace = f.asm.DepthToSpace).apply(null, arguments);
            }),
            (f._DepthwiseConv2dNative = function () {
              return (f._DepthwiseConv2dNative = f.asm.DepthwiseConv2dNative).apply(null, arguments);
            }),
            (f._Diag = function () {
              return (f._Diag = f.asm.Diag).apply(null, arguments);
            }),
            (f._Dilation2D = function () {
              return (f._Dilation2D = f.asm.Dilation2D).apply(null, arguments);
            }),
            (f._Dilation2DBackpropFilter = function () {
              return (f._Dilation2DBackpropFilter = f.asm.Dilation2DBackpropFilter).apply(null, arguments);
            }),
            (f._Dilation2DBackpropInput = function () {
              return (f._Dilation2DBackpropInput = f.asm.Dilation2DBackpropInput).apply(null, arguments);
            }),
            (f._Elu = function () {
              return (f._Elu = f.asm.Elu).apply(null, arguments);
            }),
            (f._EluGrad = function () {
              return (f._EluGrad = f.asm.EluGrad).apply(null, arguments);
            }),
            (f._Equal = function () {
              return (f._Equal = f.asm.Equal).apply(null, arguments);
            }),
            (f._Erf = function () {
              return (f._Erf = f.asm.Erf).apply(null, arguments);
            }),
            (f._Exp = function () {
              return (f._Exp = f.asm.Exp).apply(null, arguments);
            }),
            (f._Expm1 = function () {
              return (f._Expm1 = f.asm.Expm1).apply(null, arguments);
            }),
            (f._FlipLeftRight = function () {
              return (f._FlipLeftRight = f.asm.FlipLeftRight).apply(null, arguments);
            }),
            (f._Floor = function () {
              return (f._Floor = f.asm.Floor).apply(null, arguments);
            }),
            (f._FloorDiv = function () {
              return (f._FloorDiv = f.asm.FloorDiv).apply(null, arguments);
            }),
            (f._FusedBatchNorm = function () {
              return (f._FusedBatchNorm = f.asm.FusedBatchNorm).apply(null, arguments);
            }),
            (f._FusedConv2D = function () {
              return (f._FusedConv2D = f.asm.FusedConv2D).apply(null, arguments);
            }),
            (f._FusedDepthwiseConv2D = function () {
              return (f._FusedDepthwiseConv2D = f.asm.FusedDepthwiseConv2D).apply(null, arguments);
            }),
            (f._Gather = function () {
              return (f._Gather = f.asm.Gather).apply(null, arguments);
            }),
            (f._GatherNd = function () {
              return (f._GatherNd = f.asm.GatherNd).apply(null, arguments);
            }),
            (f._Greater = function () {
              return (f._Greater = f.asm.Greater).apply(null, arguments);
            }),
            (f._GreaterEqual = function () {
              return (f._GreaterEqual = f.asm.GreaterEqual).apply(null, arguments);
            }),
            (f._IsFinite = function () {
              return (f._IsFinite = f.asm.IsFinite).apply(null, arguments);
            }),
            (f._IsInf = function () {
              return (f._IsInf = f.asm.IsInf).apply(null, arguments);
            }),
            (f._IsNan = function () {
              return (f._IsNan = f.asm.IsNan).apply(null, arguments);
            }),
            (f._LRN = function () {
              return (f._LRN = f.asm.LRN).apply(null, arguments);
            }),
            (f._LRNGrad = function () {
              return (f._LRNGrad = f.asm.LRNGrad).apply(null, arguments);
            }),
            (f._LeakyRelu = function () {
              return (f._LeakyRelu = f.asm.LeakyRelu).apply(null, arguments);
            }),
            (f._Less = function () {
              return (f._Less = f.asm.Less).apply(null, arguments);
            }),
            (f._LessEqual = function () {
              return (f._LessEqual = f.asm.LessEqual).apply(null, arguments);
            }),
            (f._LinSpace = function () {
              return (f._LinSpace = f.asm.LinSpace).apply(null, arguments);
            }),
            (f._Log = function () {
              return (f._Log = f.asm.Log).apply(null, arguments);
            }),
            (f._Log1p = function () {
              return (f._Log1p = f.asm.Log1p).apply(null, arguments);
            }),
            (f._LogicalAnd = function () {
              return (f._LogicalAnd = f.asm.LogicalAnd).apply(null, arguments);
            }),
            (f._LogicalNot = function () {
              return (f._LogicalNot = f.asm.LogicalNot).apply(null, arguments);
            }),
            (f._LogicalOr = function () {
              return (f._LogicalOr = f.asm.LogicalOr).apply(null, arguments);
            }),
            (f._LogicalXor = function () {
              return (f._LogicalXor = f.asm.LogicalXor).apply(null, arguments);
            }),
            (f._Max = function () {
              return (f._Max = f.asm.Max).apply(null, arguments);
            }),
            (f._MaxPool = function () {
              return (f._MaxPool = f.asm.MaxPool).apply(null, arguments);
            }),
            (f._MaxPool3D = function () {
              return (f._MaxPool3D = f.asm.MaxPool3D).apply(null, arguments);
            }),
            (f._MaxPool3DGrad = function () {
              return (f._MaxPool3DGrad = f.asm.MaxPool3DGrad).apply(null, arguments);
            }),
            (f._MaxPoolGrad = function () {
              return (f._MaxPoolGrad = f.asm.MaxPoolGrad).apply(null, arguments);
            }),
            (f._MaxPoolWithArgmax = function () {
              return (f._MaxPoolWithArgmax = f.asm.MaxPoolWithArgmax).apply(null, arguments);
            }),
            (f._Maximum = function () {
              return (f._Maximum = f.asm.Maximum).apply(null, arguments);
            }),
            (f._Mean = function () {
              return (f._Mean = f.asm.Mean).apply(null, arguments);
            }),
            (f._Min = function () {
              return (f._Min = f.asm.Min).apply(null, arguments);
            }),
            (f._Minimum = function () {
              return (f._Minimum = f.asm.Minimum).apply(null, arguments);
            }),
            (f._MirrorPad = function () {
              return (f._MirrorPad = f.asm.MirrorPad).apply(null, arguments);
            }),
            (f._Mod = function () {
              return (f._Mod = f.asm.Mod).apply(null, arguments);
            }),
            (f._Multinomial = function () {
              return (f._Multinomial = f.asm.Multinomial).apply(null, arguments);
            }),
            (f._Multiply = function () {
              return (f._Multiply = f.asm.Multiply).apply(null, arguments);
            }),
            (f._Neg = function () {
              return (f._Neg = f.asm.Neg).apply(null, arguments);
            }),
            (f._NonMaxSuppressionV3 = function () {
              return (f._NonMaxSuppressionV3 = f.asm.NonMaxSuppressionV3).apply(null, arguments);
            }),
            (f._NonMaxSuppressionV4 = function () {
              return (f._NonMaxSuppressionV4 = f.asm.NonMaxSuppressionV4).apply(null, arguments);
            }),
            (f._NonMaxSuppressionV5 = function () {
              return (f._NonMaxSuppressionV5 = f.asm.NonMaxSuppressionV5).apply(null, arguments);
            }),
            (f._NotEqual = function () {
              return (f._NotEqual = f.asm.NotEqual).apply(null, arguments);
            }),
            (f._OneHot = function () {
              return (f._OneHot = f.asm.OneHot).apply(null, arguments);
            }),
            (f._PadV2 = function () {
              return (f._PadV2 = f.asm.PadV2).apply(null, arguments);
            }),
            (f._Pow = function () {
              return (f._Pow = f.asm.Pow).apply(null, arguments);
            }),
            (f._Prelu = function () {
              return (f._Prelu = f.asm.Prelu).apply(null, arguments);
            }),
            (f._Prod = function () {
              return (f._Prod = f.asm.Prod).apply(null, arguments);
            }),
            (f._RealDiv = function () {
              return (f._RealDiv = f.asm.RealDiv).apply(null, arguments);
            }),
            (f._Reciprocal = function () {
              return (f._Reciprocal = f.asm.Reciprocal).apply(null, arguments);
            }),
            (f._Relu = function () {
              return (f._Relu = f.asm.Relu).apply(null, arguments);
            }),
            (f._Relu6 = function () {
              return (f._Relu6 = f.asm.Relu6).apply(null, arguments);
            }),
            (f._ResizeBilinear = function () {
              return (f._ResizeBilinear = f.asm.ResizeBilinear).apply(null, arguments);
            }),
            (f._ResizeBilinearGrad = function () {
              return (f._ResizeBilinearGrad = f.asm.ResizeBilinearGrad).apply(null, arguments);
            }),
            (f._ResizeNearestNeighbor = function () {
              return (f._ResizeNearestNeighbor = f.asm.ResizeNearestNeighbor).apply(null, arguments);
            }),
            (f._ResizeNearestNeighborGrad = function () {
              return (f._ResizeNearestNeighborGrad = f.asm.ResizeNearestNeighborGrad).apply(null, arguments);
            }),
            (f._Reverse = function () {
              return (f._Reverse = f.asm.Reverse).apply(null, arguments);
            }),
            (f._RotateWithOffset = function () {
              return (f._RotateWithOffset = f.asm.RotateWithOffset).apply(null, arguments);
            }),
            (f._Round = function () {
              return (f._Round = f.asm.Round).apply(null, arguments);
            }),
            (f._Rsqrt = function () {
              return (f._Rsqrt = f.asm.Rsqrt).apply(null, arguments);
            }),
            (f._ScatterNd = function () {
              return (f._ScatterNd = f.asm.ScatterNd).apply(null, arguments);
            }),
            (f._SearchSorted = function () {
              return (f._SearchSorted = f.asm.SearchSorted).apply(null, arguments);
            }),
            (f._SelectV2 = function () {
              return (f._SelectV2 = f.asm.SelectV2).apply(null, arguments);
            }),
            (f._Selu = function () {
              return (f._Selu = f.asm.Selu).apply(null, arguments);
            }),
            (f._Sigmoid = function () {
              return (f._Sigmoid = f.asm.Sigmoid).apply(null, arguments);
            }),
            (f._Sign = function () {
              return (f._Sign = f.asm.Sign).apply(null, arguments);
            }),
            (f._Sin = function () {
              return (f._Sin = f.asm.Sin).apply(null, arguments);
            }),
            (f._Sinh = function () {
              return (f._Sinh = f.asm.Sinh).apply(null, arguments);
            }),
            (f._Softmax = function () {
              return (f._Softmax = f.asm.Softmax).apply(null, arguments);
            }),
            (f._Softplus = function () {
              return (f._Softplus = f.asm.Softplus).apply(null, arguments);
            }),
            (f._SparseFillEmptyRows = function () {
              return (f._SparseFillEmptyRows = f.asm.SparseFillEmptyRows).apply(null, arguments);
            }),
            (f._SparseReshape = function () {
              return (f._SparseReshape = f.asm.SparseReshape).apply(null, arguments);
            }),
            (f._SparseSegmentReduction = function () {
              return (f._SparseSegmentReduction = f.asm.SparseSegmentReduction).apply(null, arguments);
            }),
            (f._SparseToDense = function () {
              return (f._SparseToDense = f.asm.SparseToDense).apply(null, arguments);
            }),
            (f._Sqrt = function () {
              return (f._Sqrt = f.asm.Sqrt).apply(null, arguments);
            }),
            (f._Square = function () {
              return (f._Square = f.asm.Square).apply(null, arguments);
            }),
            (f._SquaredDifference = function () {
              return (f._SquaredDifference = f.asm.SquaredDifference).apply(null, arguments);
            }),
            (f._Step = function () {
              return (f._Step = f.asm.Step).apply(null, arguments);
            }),
            (f._StridedSlice = function () {
              return (f._StridedSlice = f.asm.StridedSlice).apply(null, arguments);
            }),
            (f._Sub = function () {
              return (f._Sub = f.asm.Sub).apply(null, arguments);
            }),
            (f._Sum = function () {
              return (f._Sum = f.asm.Sum).apply(null, arguments);
            }),
            (f._Tan = function () {
              return (f._Tan = f.asm.Tan).apply(null, arguments);
            }),
            (f._Tanh = function () {
              return (f._Tanh = f.asm.Tanh).apply(null, arguments);
            }),
            (f._TensorScatterUpdate = function () {
              return (f._TensorScatterUpdate = f.asm.TensorScatterUpdate).apply(null, arguments);
            }),
            (f._Tile = function () {
              return (f._Tile = f.asm.Tile).apply(null, arguments);
            }),
            (f._TopK = function () {
              return (f._TopK = f.asm.TopK).apply(null, arguments);
            }),
            (f._Transform = function () {
              return (f._Transform = f.asm.Transform).apply(null, arguments);
            }),
            (f._Transpose = function () {
              return (f._Transpose = f.asm.Transpose).apply(null, arguments);
            }),
            (f.__FusedMatMul = function () {
              return (f.__FusedMatMul = f.asm._FusedMatMul).apply(null, arguments);
            }),
            (f._malloc = function () {
              return (f._malloc = f.asm.malloc).apply(null, arguments);
            }),
            (f._free = function () {
              return (f._free = f.asm.free).apply(null, arguments);
            }),
            (f.__emscripten_tls_init = function () {
              return (f.__emscripten_tls_init = f.asm._emscripten_tls_init).apply(null, arguments);
            });
          var We = (f._pthread_self = function () {
            return (We = f._pthread_self = f.asm.pthread_self).apply(null, arguments);
          });
          f.___errno_location = function () {
            return (f.___errno_location = f.asm.__errno_location).apply(null, arguments);
          };
          var Oe = (f.__emscripten_thread_init = function () {
            return (Oe = f.__emscripten_thread_init = f.asm._emscripten_thread_init).apply(null, arguments);
          });
          (f.__emscripten_thread_crashed = function () {
            return (f.__emscripten_thread_crashed = f.asm._emscripten_thread_crashed).apply(null, arguments);
          }),
            (f._emscripten_main_thread_process_queued_calls = function () {
              return (f._emscripten_main_thread_process_queued_calls = f.asm.emscripten_main_thread_process_queued_calls).apply(
                null,
                arguments,
              );
            }),
            (f._emscripten_main_browser_thread_id = function () {
              return (f._emscripten_main_browser_thread_id = f.asm.emscripten_main_browser_thread_id).apply(null, arguments);
            });
          var Te = (f._emscripten_run_in_main_runtime_thread_js = function () {
            return (Te = f._emscripten_run_in_main_runtime_thread_js = f.asm.emscripten_run_in_main_runtime_thread_js).apply(
              null,
              arguments,
            );
          });
          f._emscripten_dispatch_to_thread_ = function () {
            return (f._emscripten_dispatch_to_thread_ = f.asm.emscripten_dispatch_to_thread_).apply(null, arguments);
          };
          var ze,
            Be,
            He,
            Le = (f.__emscripten_proxy_execute_task_queue = function () {
              return (Le = f.__emscripten_proxy_execute_task_queue = f.asm._emscripten_proxy_execute_task_queue).apply(null, arguments);
            }),
            Ge = (f.__emscripten_thread_free_data = function () {
              return (Ge = f.__emscripten_thread_free_data = f.asm._emscripten_thread_free_data).apply(null, arguments);
            }),
            Ue = (f.__emscripten_thread_exit = function () {
              return (Ue = f.__emscripten_thread_exit = f.asm._emscripten_thread_exit).apply(null, arguments);
            }),
            je = (f._emscripten_stack_set_limits = function () {
              return (je = f._emscripten_stack_set_limits = f.asm.emscripten_stack_set_limits).apply(null, arguments);
            }),
            qe = (f.stackSave = function () {
              return (qe = f.stackSave = f.asm.stackSave).apply(null, arguments);
            }),
            Ve = (f.stackRestore = function () {
              return (Ve = f.stackRestore = f.asm.stackRestore).apply(null, arguments);
            }),
            $e = (f.stackAlloc = function () {
              return ($e = f.stackAlloc = f.asm.stackAlloc).apply(null, arguments);
            });
          function Ke(e) {
            if (!(te > 0)) {
              if (M) return p(f), Y(), void startWorker(f);
              !(function () {
                if (f.preRun)
                  for ('function' == typeof f.preRun && (f.preRun = [f.preRun]); f.preRun.length; ) (e = f.preRun.shift()), X.unshift(e);
                var e;
                fe(X);
              })(),
                te > 0 ||
                  (f.setStatus
                    ? (f.setStatus('Running...'),
                      setTimeout(function () {
                        setTimeout(function () {
                          f.setStatus('');
                        }, 1),
                          t();
                      }, 1))
                    : t());
            }
            function t() {
              ze ||
                ((ze = !0),
                (f.calledRun = !0),
                U ||
                  (Y(),
                  p(f),
                  f.onRuntimeInitialized && f.onRuntimeInitialized(),
                  (function () {
                    if (!M) {
                      if (f.postRun)
                        for ('function' == typeof f.postRun && (f.postRun = [f.postRun]); f.postRun.length; )
                          (e = f.postRun.shift()), J.unshift(e);
                      var e;
                      fe(J);
                    }
                  })()));
            }
          }
          if (
            ((f.dynCall_iijjiiii = function () {
              return (f.dynCall_iijjiiii = f.asm.dynCall_iijjiiii).apply(null, arguments);
            }),
            (f.dynCall_jiji = function () {
              return (f.dynCall_jiji = f.asm.dynCall_jiji).apply(null, arguments);
            }),
            (f.keepRuntimeAlive = Z),
            (f.wasmMemory = P),
            (f.cwrap = function (e, t, n, a) {
              var r = (n = n || []).every(e => 'number' === e || 'boolean' === e);
              return 'string' !== t && r && !a
                ? Re(e)
                : function () {
                    return Ee(e, t, n, arguments);
                  };
            }),
            (f.ExitStatus = oe),
            (f.PThread = me),
            (ne = function e() {
              ze || Ke(), ze || (ne = e);
            }),
            f.preInit)
          )
            for ('function' == typeof f.preInit && (f.preInit = [f.preInit]); f.preInit.length > 0; ) f.preInit.pop()();
          if (
            (Ke(),
            m &&
              (Be = {
                uncaughtException: process.listeners('uncaughtException').filter(function (e) {
                  return !m.uncaughtException.indexOf(e) > -1;
                }),
                unhandledRejection: process.listeners('unhandledRejection').filter(function (e) {
                  return !m.unhandledRejection.indexOf(e) > -1;
                }),
              }),
            'undefined' != typeof WasmBackendModule)
          )
            He = WasmBackendModule;
          else {
            if ('undefined' == typeof e) throw new Error('Could not find wasm module in post.js');
            He = e;
          }
          if (Be) {
            var Xe = He._dispose;
            He._dispose = function () {
              Xe(),
                Be.uncaughtException.forEach(function (e) {
                  process.removeListener('uncaughtException', e);
                }),
                Be.unhandledRejection.forEach(function (e) {
                  process.removeListener('unhandledRejection', e);
                });
            };
          }
          return e.ready;
        });
    e.exports = s;
  })(Ya);
  var er = Ya.exports,
    tr = Za(er),
    nr = i({ __proto__: null, default: tr }, [er]),
    ar =
      '"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};',
    rr = { exports: {} };
  !(function (e, t) {
    var r,
      u =
        ((r = 'undefined' != typeof document && document.currentScript ? document.currentScript.src : void 0),
        'undefined' != typeof __filename && (r = r || __filename),
        function (e) {
          var t,
            u,
            i,
            s = 'undefined' != typeof (e = e || {}) ? e : {};
          (s.ready = new Promise(function (e, n) {
            (t = e), (u = n);
          })),
            'undefined' != typeof process &&
              process.listeners &&
              (i = {
                uncaughtException: process.listeners('uncaughtException'),
                unhandledRejection: process.listeners('unhandledRejection'),
              });
          var o,
            d,
            l,
            p = Object.assign({}, s),
            c = 'object' == typeof window,
            m = 'function' == typeof importScripts,
            f = 'object' == typeof process && 'object' == typeof process.versions && 'string' == typeof process.versions.node,
            h = '';
          if (f) {
            var b = n,
              _ = a;
            (h = m ? _.dirname(h) + '/' : __dirname + '/'),
              (o = (e, t) => ((e = B(e) ? new URL(e) : _.normalize(e)), b.readFileSync(e, t ? void 0 : 'utf8'))),
              (l = e => {
                var t = o(e, !0);
                return t.buffer || (t = new Uint8Array(t)), t;
              }),
              (d = (e, t, n) => {
                (e = B(e) ? new URL(e) : _.normalize(e)),
                  b.readFile(e, function (e, a) {
                    e ? n(e) : t(a.buffer);
                  });
              }),
              process.argv.length > 1 && process.argv[1].replace(/\\/g, '/'),
              process.argv.slice(2),
              process.on('uncaughtException', function (e) {
                if (!(e instanceof L)) throw e;
              }),
              process.on('unhandledRejection', function (e) {
                throw e;
              }),
              (s.inspect = function () {
                return '[Emscripten Module object]';
              });
          } else
            (c || m) &&
              (m ? (h = self.location.href) : 'undefined' != typeof document && document.currentScript && (h = document.currentScript.src),
              r && (h = r),
              (h = 0 !== h.indexOf('blob:') ? h.substr(0, h.replace(/[?#].*/, '').lastIndexOf('/') + 1) : ''),
              (o = e => {
                var t = new XMLHttpRequest();
                return t.open('GET', e, !1), t.send(null), t.responseText;
              }),
              m &&
                (l = e => {
                  var t = new XMLHttpRequest();
                  return t.open('GET', e, !1), (t.responseType = 'arraybuffer'), t.send(null), new Uint8Array(t.response);
                }),
              (d = (e, t, n) => {
                var a = new XMLHttpRequest();
                a.open('GET', e, !0),
                  (a.responseType = 'arraybuffer'),
                  (a.onload = () => {
                    200 == a.status || (0 == a.status && a.response) ? t(a.response) : n();
                  }),
                  (a.onerror = n),
                  a.send(null);
              }));
          var y,
            g,
            k = s.print || console.log.bind(console),
            I = s.printErr || console.warn.bind(console);
          Object.assign(s, p),
            (p = null),
            s.arguments && s.arguments,
            s.thisProgram && s.thisProgram,
            s.quit && s.quit,
            s.wasmBinary && (y = s.wasmBinary),
            s.noExitRuntime,
            'object' != typeof WebAssembly && T('no native wasm support detected');
          var w,
            M,
            S,
            A,
            v = !1,
            x = 'undefined' != typeof TextDecoder ? new TextDecoder('utf8') : void 0;
          function F(e, t, n) {
            for (var a = (t >>>= 0) + n, r = t; e[r] && !(r >= a); ) ++r;
            if (r - t > 16 && e.buffer && x) return x.decode(e.subarray(t, r));
            for (var u = ''; t < r; ) {
              var i = e[t++];
              if (128 & i) {
                var s = 63 & e[t++];
                if (192 != (224 & i)) {
                  var o = 63 & e[t++];
                  if (
                    (i = 224 == (240 & i) ? ((15 & i) << 12) | (s << 6) | o : ((7 & i) << 18) | (s << 12) | (o << 6) | (63 & e[t++])) <
                    65536
                  )
                    u += String.fromCharCode(i);
                  else {
                    var d = i - 65536;
                    u += String.fromCharCode(55296 | (d >> 10), 56320 | (1023 & d));
                  }
                } else u += String.fromCharCode(((31 & i) << 6) | s);
              } else u += String.fromCharCode(i);
            }
            return u;
          }
          function N(e) {
            (w = e),
              (s.HEAP8 = M = new Int8Array(e)),
              (s.HEAP16 = new Int16Array(e)),
              (s.HEAP32 = new Int32Array(e)),
              (s.HEAPU8 = S = new Uint8Array(e)),
              (s.HEAPU16 = new Uint16Array(e)),
              (s.HEAPU32 = A = new Uint32Array(e)),
              (s.HEAPF32 = new Float32Array(e)),
              (s.HEAPF64 = new Float64Array(e));
          }
          s.INITIAL_MEMORY;
          var D,
            R,
            E = [],
            P = [],
            C = [],
            W = 0,
            O = null;
          function T(e) {
            s.onAbort && s.onAbort(e), I((e = 'Aborted(' + e + ')')), (v = !0), (e += '. Build with -sASSERTIONS for more info.');
            var t = new WebAssembly.RuntimeError(e);
            throw (u(t), t);
          }
          function z(e) {
            return e.startsWith('data:application/octet-stream;base64,');
          }
          function B(e) {
            return e.startsWith('file://');
          }
          function H(e) {
            try {
              if (e == D && y) return new Uint8Array(y);
              if (l) return l(e);
              throw 'both async and sync fetching of the wasm failed';
            } catch (e) {
              T(e);
            }
          }
          function L(e) {
            (this.name = 'ExitStatus'), (this.message = 'Program terminated with exit(' + e + ')'), (this.status = e);
          }
          function G(e) {
            for (; e.length > 0; ) e.shift()(s);
          }
          function U(e) {
            try {
              return g.grow((e - w.byteLength + 65535) >>> 16), N(g.buffer), 1;
            } catch (e) {}
          }
          z((D = 'tfjs-backend-wasm.wasm')) || ((R = D), (D = s.locateFile ? s.locateFile(R, h) : h + R));
          var j = [null, [], []];
          function q(e, t) {
            var n = j[e];
            0 === t || 10 === t ? ((1 === e ? k : I)(F(n, 0)), (n.length = 0)) : n.push(t);
          }
          function V(e) {
            return s['_' + e];
          }
          function $(e, t, n, a, r) {
            var u = {
              string: e => {
                var t = 0;
                if (null != e && 0 !== e) {
                  var n = 1 + (e.length << 2);
                  !(function (e, t, n) {
                    !(function (e, t, n, a) {
                      if (!(a > 0)) return 0;
                      n >>>= 0;
                      for (var r = n + a - 1, u = 0; u < e.length; ++u) {
                        var i = e.charCodeAt(u);
                        if ((i >= 55296 && i <= 57343 && (i = (65536 + ((1023 & i) << 10)) | (1023 & e.charCodeAt(++u))), i <= 127)) {
                          if (n >= r) break;
                          t[n++ >>> 0] = i;
                        } else if (i <= 2047) {
                          if (n + 1 >= r) break;
                          (t[n++ >>> 0] = 192 | (i >> 6)), (t[n++ >>> 0] = 128 | (63 & i));
                        } else if (i <= 65535) {
                          if (n + 2 >= r) break;
                          (t[n++ >>> 0] = 224 | (i >> 12)), (t[n++ >>> 0] = 128 | ((i >> 6) & 63)), (t[n++ >>> 0] = 128 | (63 & i));
                        } else {
                          if (n + 3 >= r) break;
                          (t[n++ >>> 0] = 240 | (i >> 18)),
                            (t[n++ >>> 0] = 128 | ((i >> 12) & 63)),
                            (t[n++ >>> 0] = 128 | ((i >> 6) & 63)),
                            (t[n++ >>> 0] = 128 | (63 & i));
                        }
                      }
                      t[n >>> 0] = 0;
                    })(e, S, t, n);
                  })(e, (t = ee(n)), n);
                }
                return t;
              },
              array: e => {
                var t = ee(e.length);
                return (
                  (function (e, t) {
                    M.set(e, t >>> 0);
                  })(e, t),
                  t
                );
              },
            };
            function i(e) {
              return 'string' === t ? ((n = e), (n >>>= 0) ? F(S, n, a) : '') : 'boolean' === t ? Boolean(e) : e;
              var n, a;
            }
            var s = V(e),
              o = [],
              d = 0;
            if (a)
              for (var l = 0; l < a.length; l++) {
                var p = u[n[l]];
                p ? (0 === d && (d = Z()), (o[l] = p(a[l]))) : (o[l] = a[l]);
              }
            var c = s.apply(null, o);
            return (c = (function (e) {
              return 0 !== d && Y(d), i(e);
            })(c));
          }
          var K = {
            abort: function () {
              T('');
            },
            emscripten_get_heap_max: function () {
              return 4294901760;
            },
            emscripten_memcpy_big: function (e, t, n) {
              S.copyWithin(e >>> 0, t >>> 0, (t + n) >>> 0);
            },
            emscripten_resize_heap: function (e) {
              var t,
                n,
                a = S.length,
                r = 4294901760;
              if ((e >>>= 0) > r) return !1;
              for (var u = 1; u <= 4; u *= 2) {
                var i = a * (1 + 0.2 / u);
                if (((i = Math.min(i, e + 100663296)), U(Math.min(r, (t = Math.max(e, i)) + (((n = 65536) - (t % n)) % n))))) return !0;
              }
              return !1;
            },
            fd_close: function (e) {
              return 52;
            },
            fd_seek: function (e, t, n, a, r) {
              return 70;
            },
            fd_write: function (e, t, n, a) {
              for (var r = 0, u = 0; u < n; u++) {
                var i = A[t >>> 2],
                  s = A[(t + 4) >>> 2];
                t += 8;
                for (var o = 0; o < s; o++) q(e, S[(i + o) >>> 0]);
                r += s;
              }
              return (A[a >>> 2] = r), 0;
            },
          };
          !(function () {
            var e = { env: K, wasi_snapshot_preview1: K };
            function t(e, t) {
              var n,
                a = e.exports;
              (s.asm = a),
                N((g = s.asm.memory).buffer),
                s.asm.__indirect_function_table,
                (n = s.asm.__wasm_call_ctors),
                P.unshift(n),
                (function (e) {
                  if ((W--, s.monitorRunDependencies && s.monitorRunDependencies(W), 0 == W && O)) {
                    var t = O;
                    (O = null), t();
                  }
                })();
            }
            function n(e) {
              t(e.instance);
            }
            function a(t) {
              return (function () {
                if (!y && (c || m)) {
                  if ('function' == typeof fetch && !B(D))
                    return fetch(D, { credentials: 'same-origin' })
                      .then(function (e) {
                        if (!e.ok) throw "failed to load wasm binary file at '" + D + "'";
                        return e.arrayBuffer();
                      })
                      .catch(function () {
                        return H(D);
                      });
                  if (d)
                    return new Promise(function (e, t) {
                      d(
                        D,
                        function (t) {
                          e(new Uint8Array(t));
                        },
                        t,
                      );
                    });
                }
                return Promise.resolve().then(function () {
                  return H(D);
                });
              })()
                .then(function (t) {
                  return WebAssembly.instantiate(t, e);
                })
                .then(function (e) {
                  return e;
                })
                .then(t, function (e) {
                  I('failed to asynchronously prepare wasm: ' + e), T(e);
                });
            }
            if ((W++, s.monitorRunDependencies && s.monitorRunDependencies(W), s.instantiateWasm))
              try {
                return s.instantiateWasm(e, t);
              } catch (e) {
                I('Module.instantiateWasm callback failed with error: ' + e), u(e);
              }
            (y || 'function' != typeof WebAssembly.instantiateStreaming || z(D) || B(D) || f || 'function' != typeof fetch
              ? a(n)
              : fetch(D, { credentials: 'same-origin' }).then(function (t) {
                  return WebAssembly.instantiateStreaming(t, e).then(n, function (e) {
                    return I('wasm streaming compile failed: ' + e), I('falling back to ArrayBuffer instantiation'), a(n);
                  });
                })
            ).catch(u);
          })(),
            (s.___wasm_call_ctors = function () {
              return (s.___wasm_call_ctors = s.asm.__wasm_call_ctors).apply(null, arguments);
            }),
            (s._init = function () {
              return (s._init = s.asm.init).apply(null, arguments);
            }),
            (s._init_with_threads_count = function () {
              return (s._init_with_threads_count = s.asm.init_with_threads_count).apply(null, arguments);
            }),
            (s._get_threads_count = function () {
              return (s._get_threads_count = s.asm.get_threads_count).apply(null, arguments);
            }),
            (s._register_tensor = function () {
              return (s._register_tensor = s.asm.register_tensor).apply(null, arguments);
            }),
            (s._dispose_data = function () {
              return (s._dispose_data = s.asm.dispose_data).apply(null, arguments);
            }),
            (s._dispose = function () {
              return (s._dispose = s.asm.dispose).apply(null, arguments);
            }),
            (s._Abs = function () {
              return (s._Abs = s.asm.Abs).apply(null, arguments);
            }),
            (s._Acos = function () {
              return (s._Acos = s.asm.Acos).apply(null, arguments);
            }),
            (s._Acosh = function () {
              return (s._Acosh = s.asm.Acosh).apply(null, arguments);
            }),
            (s._Add = function () {
              return (s._Add = s.asm.Add).apply(null, arguments);
            }),
            (s._AddN = function () {
              return (s._AddN = s.asm.AddN).apply(null, arguments);
            }),
            (s._All = function () {
              return (s._All = s.asm.All).apply(null, arguments);
            }),
            (s._Any = function () {
              return (s._Any = s.asm.Any).apply(null, arguments);
            }),
            (s._ArgMax = function () {
              return (s._ArgMax = s.asm.ArgMax).apply(null, arguments);
            }),
            (s._ArgMin = function () {
              return (s._ArgMin = s.asm.ArgMin).apply(null, arguments);
            }),
            (s._Asin = function () {
              return (s._Asin = s.asm.Asin).apply(null, arguments);
            }),
            (s._Asinh = function () {
              return (s._Asinh = s.asm.Asinh).apply(null, arguments);
            }),
            (s._Atan = function () {
              return (s._Atan = s.asm.Atan).apply(null, arguments);
            }),
            (s._Atan2 = function () {
              return (s._Atan2 = s.asm.Atan2).apply(null, arguments);
            }),
            (s._Atanh = function () {
              return (s._Atanh = s.asm.Atanh).apply(null, arguments);
            }),
            (s._AvgPool = function () {
              return (s._AvgPool = s.asm.AvgPool).apply(null, arguments);
            }),
            (s._AvgPool3D = function () {
              return (s._AvgPool3D = s.asm.AvgPool3D).apply(null, arguments);
            }),
            (s._AvgPool3DGrad = function () {
              return (s._AvgPool3DGrad = s.asm.AvgPool3DGrad).apply(null, arguments);
            }),
            (s._AvgPoolGrad = function () {
              return (s._AvgPoolGrad = s.asm.AvgPoolGrad).apply(null, arguments);
            }),
            (s._BatchMatMul = function () {
              return (s._BatchMatMul = s.asm.BatchMatMul).apply(null, arguments);
            }),
            (s._Bincount = function () {
              return (s._Bincount = s.asm.Bincount).apply(null, arguments);
            }),
            (s._BitwiseAnd = function () {
              return (s._BitwiseAnd = s.asm.BitwiseAnd).apply(null, arguments);
            }),
            (s._Ceil = function () {
              return (s._Ceil = s.asm.Ceil).apply(null, arguments);
            }),
            (s._ClipByValue = function () {
              return (s._ClipByValue = s.asm.ClipByValue).apply(null, arguments);
            }),
            (s._Conv2D = function () {
              return (s._Conv2D = s.asm.Conv2D).apply(null, arguments);
            }),
            (s._Conv2DBackpropInput = function () {
              return (s._Conv2DBackpropInput = s.asm.Conv2DBackpropInput).apply(null, arguments);
            }),
            (s._Conv3D = function () {
              return (s._Conv3D = s.asm.Conv3D).apply(null, arguments);
            }),
            (s._Conv3DBackpropFilterV2 = function () {
              return (s._Conv3DBackpropFilterV2 = s.asm.Conv3DBackpropFilterV2).apply(null, arguments);
            }),
            (s._Conv3DBackpropInputV2 = function () {
              return (s._Conv3DBackpropInputV2 = s.asm.Conv3DBackpropInputV2).apply(null, arguments);
            }),
            (s._Cos = function () {
              return (s._Cos = s.asm.Cos).apply(null, arguments);
            }),
            (s._Cosh = function () {
              return (s._Cosh = s.asm.Cosh).apply(null, arguments);
            }),
            (s._CropAndResize = function () {
              return (s._CropAndResize = s.asm.CropAndResize).apply(null, arguments);
            }),
            (s._Cumprod = function () {
              return (s._Cumprod = s.asm.Cumprod).apply(null, arguments);
            }),
            (s._Cumsum = function () {
              return (s._Cumsum = s.asm.Cumsum).apply(null, arguments);
            }),
            (s._DenseBincount = function () {
              return (s._DenseBincount = s.asm.DenseBincount).apply(null, arguments);
            }),
            (s._DepthToSpace = function () {
              return (s._DepthToSpace = s.asm.DepthToSpace).apply(null, arguments);
            }),
            (s._DepthwiseConv2dNative = function () {
              return (s._DepthwiseConv2dNative = s.asm.DepthwiseConv2dNative).apply(null, arguments);
            }),
            (s._Diag = function () {
              return (s._Diag = s.asm.Diag).apply(null, arguments);
            }),
            (s._Dilation2D = function () {
              return (s._Dilation2D = s.asm.Dilation2D).apply(null, arguments);
            }),
            (s._Dilation2DBackpropFilter = function () {
              return (s._Dilation2DBackpropFilter = s.asm.Dilation2DBackpropFilter).apply(null, arguments);
            }),
            (s._Dilation2DBackpropInput = function () {
              return (s._Dilation2DBackpropInput = s.asm.Dilation2DBackpropInput).apply(null, arguments);
            }),
            (s._Elu = function () {
              return (s._Elu = s.asm.Elu).apply(null, arguments);
            }),
            (s._EluGrad = function () {
              return (s._EluGrad = s.asm.EluGrad).apply(null, arguments);
            }),
            (s._Equal = function () {
              return (s._Equal = s.asm.Equal).apply(null, arguments);
            }),
            (s._Erf = function () {
              return (s._Erf = s.asm.Erf).apply(null, arguments);
            }),
            (s._Exp = function () {
              return (s._Exp = s.asm.Exp).apply(null, arguments);
            }),
            (s._Expm1 = function () {
              return (s._Expm1 = s.asm.Expm1).apply(null, arguments);
            }),
            (s._FlipLeftRight = function () {
              return (s._FlipLeftRight = s.asm.FlipLeftRight).apply(null, arguments);
            }),
            (s._Floor = function () {
              return (s._Floor = s.asm.Floor).apply(null, arguments);
            }),
            (s._FloorDiv = function () {
              return (s._FloorDiv = s.asm.FloorDiv).apply(null, arguments);
            }),
            (s._FusedBatchNorm = function () {
              return (s._FusedBatchNorm = s.asm.FusedBatchNorm).apply(null, arguments);
            }),
            (s._FusedConv2D = function () {
              return (s._FusedConv2D = s.asm.FusedConv2D).apply(null, arguments);
            }),
            (s._FusedDepthwiseConv2D = function () {
              return (s._FusedDepthwiseConv2D = s.asm.FusedDepthwiseConv2D).apply(null, arguments);
            }),
            (s._Gather = function () {
              return (s._Gather = s.asm.Gather).apply(null, arguments);
            }),
            (s._GatherNd = function () {
              return (s._GatherNd = s.asm.GatherNd).apply(null, arguments);
            }),
            (s._Greater = function () {
              return (s._Greater = s.asm.Greater).apply(null, arguments);
            }),
            (s._GreaterEqual = function () {
              return (s._GreaterEqual = s.asm.GreaterEqual).apply(null, arguments);
            }),
            (s._IsFinite = function () {
              return (s._IsFinite = s.asm.IsFinite).apply(null, arguments);
            }),
            (s._IsInf = function () {
              return (s._IsInf = s.asm.IsInf).apply(null, arguments);
            }),
            (s._IsNan = function () {
              return (s._IsNan = s.asm.IsNan).apply(null, arguments);
            }),
            (s._LRN = function () {
              return (s._LRN = s.asm.LRN).apply(null, arguments);
            }),
            (s._LRNGrad = function () {
              return (s._LRNGrad = s.asm.LRNGrad).apply(null, arguments);
            }),
            (s._LeakyRelu = function () {
              return (s._LeakyRelu = s.asm.LeakyRelu).apply(null, arguments);
            }),
            (s._Less = function () {
              return (s._Less = s.asm.Less).apply(null, arguments);
            }),
            (s._LessEqual = function () {
              return (s._LessEqual = s.asm.LessEqual).apply(null, arguments);
            }),
            (s._LinSpace = function () {
              return (s._LinSpace = s.asm.LinSpace).apply(null, arguments);
            }),
            (s._Log = function () {
              return (s._Log = s.asm.Log).apply(null, arguments);
            }),
            (s._Log1p = function () {
              return (s._Log1p = s.asm.Log1p).apply(null, arguments);
            }),
            (s._LogicalAnd = function () {
              return (s._LogicalAnd = s.asm.LogicalAnd).apply(null, arguments);
            }),
            (s._LogicalNot = function () {
              return (s._LogicalNot = s.asm.LogicalNot).apply(null, arguments);
            }),
            (s._LogicalOr = function () {
              return (s._LogicalOr = s.asm.LogicalOr).apply(null, arguments);
            }),
            (s._LogicalXor = function () {
              return (s._LogicalXor = s.asm.LogicalXor).apply(null, arguments);
            }),
            (s._Max = function () {
              return (s._Max = s.asm.Max).apply(null, arguments);
            }),
            (s._MaxPool = function () {
              return (s._MaxPool = s.asm.MaxPool).apply(null, arguments);
            }),
            (s._MaxPool3D = function () {
              return (s._MaxPool3D = s.asm.MaxPool3D).apply(null, arguments);
            }),
            (s._MaxPool3DGrad = function () {
              return (s._MaxPool3DGrad = s.asm.MaxPool3DGrad).apply(null, arguments);
            }),
            (s._MaxPoolGrad = function () {
              return (s._MaxPoolGrad = s.asm.MaxPoolGrad).apply(null, arguments);
            }),
            (s._MaxPoolWithArgmax = function () {
              return (s._MaxPoolWithArgmax = s.asm.MaxPoolWithArgmax).apply(null, arguments);
            }),
            (s._Maximum = function () {
              return (s._Maximum = s.asm.Maximum).apply(null, arguments);
            }),
            (s._Mean = function () {
              return (s._Mean = s.asm.Mean).apply(null, arguments);
            }),
            (s._Min = function () {
              return (s._Min = s.asm.Min).apply(null, arguments);
            }),
            (s._Minimum = function () {
              return (s._Minimum = s.asm.Minimum).apply(null, arguments);
            }),
            (s._MirrorPad = function () {
              return (s._MirrorPad = s.asm.MirrorPad).apply(null, arguments);
            }),
            (s._Mod = function () {
              return (s._Mod = s.asm.Mod).apply(null, arguments);
            }),
            (s._Multinomial = function () {
              return (s._Multinomial = s.asm.Multinomial).apply(null, arguments);
            }),
            (s._Multiply = function () {
              return (s._Multiply = s.asm.Multiply).apply(null, arguments);
            }),
            (s._Neg = function () {
              return (s._Neg = s.asm.Neg).apply(null, arguments);
            }),
            (s._NonMaxSuppressionV3 = function () {
              return (s._NonMaxSuppressionV3 = s.asm.NonMaxSuppressionV3).apply(null, arguments);
            }),
            (s._NonMaxSuppressionV4 = function () {
              return (s._NonMaxSuppressionV4 = s.asm.NonMaxSuppressionV4).apply(null, arguments);
            }),
            (s._NonMaxSuppressionV5 = function () {
              return (s._NonMaxSuppressionV5 = s.asm.NonMaxSuppressionV5).apply(null, arguments);
            }),
            (s._NotEqual = function () {
              return (s._NotEqual = s.asm.NotEqual).apply(null, arguments);
            }),
            (s._OneHot = function () {
              return (s._OneHot = s.asm.OneHot).apply(null, arguments);
            }),
            (s._PadV2 = function () {
              return (s._PadV2 = s.asm.PadV2).apply(null, arguments);
            }),
            (s._Pow = function () {
              return (s._Pow = s.asm.Pow).apply(null, arguments);
            }),
            (s._Prelu = function () {
              return (s._Prelu = s.asm.Prelu).apply(null, arguments);
            }),
            (s._Prod = function () {
              return (s._Prod = s.asm.Prod).apply(null, arguments);
            }),
            (s._RealDiv = function () {
              return (s._RealDiv = s.asm.RealDiv).apply(null, arguments);
            }),
            (s._Reciprocal = function () {
              return (s._Reciprocal = s.asm.Reciprocal).apply(null, arguments);
            }),
            (s._Relu = function () {
              return (s._Relu = s.asm.Relu).apply(null, arguments);
            }),
            (s._Relu6 = function () {
              return (s._Relu6 = s.asm.Relu6).apply(null, arguments);
            }),
            (s._ResizeBilinear = function () {
              return (s._ResizeBilinear = s.asm.ResizeBilinear).apply(null, arguments);
            }),
            (s._ResizeBilinearGrad = function () {
              return (s._ResizeBilinearGrad = s.asm.ResizeBilinearGrad).apply(null, arguments);
            }),
            (s._ResizeNearestNeighbor = function () {
              return (s._ResizeNearestNeighbor = s.asm.ResizeNearestNeighbor).apply(null, arguments);
            }),
            (s._ResizeNearestNeighborGrad = function () {
              return (s._ResizeNearestNeighborGrad = s.asm.ResizeNearestNeighborGrad).apply(null, arguments);
            }),
            (s._Reverse = function () {
              return (s._Reverse = s.asm.Reverse).apply(null, arguments);
            }),
            (s._RotateWithOffset = function () {
              return (s._RotateWithOffset = s.asm.RotateWithOffset).apply(null, arguments);
            }),
            (s._Round = function () {
              return (s._Round = s.asm.Round).apply(null, arguments);
            }),
            (s._Rsqrt = function () {
              return (s._Rsqrt = s.asm.Rsqrt).apply(null, arguments);
            }),
            (s._ScatterNd = function () {
              return (s._ScatterNd = s.asm.ScatterNd).apply(null, arguments);
            }),
            (s._SearchSorted = function () {
              return (s._SearchSorted = s.asm.SearchSorted).apply(null, arguments);
            }),
            (s._SelectV2 = function () {
              return (s._SelectV2 = s.asm.SelectV2).apply(null, arguments);
            }),
            (s._Selu = function () {
              return (s._Selu = s.asm.Selu).apply(null, arguments);
            }),
            (s._Sigmoid = function () {
              return (s._Sigmoid = s.asm.Sigmoid).apply(null, arguments);
            }),
            (s._Sign = function () {
              return (s._Sign = s.asm.Sign).apply(null, arguments);
            }),
            (s._Sin = function () {
              return (s._Sin = s.asm.Sin).apply(null, arguments);
            }),
            (s._Sinh = function () {
              return (s._Sinh = s.asm.Sinh).apply(null, arguments);
            }),
            (s._Softmax = function () {
              return (s._Softmax = s.asm.Softmax).apply(null, arguments);
            }),
            (s._Softplus = function () {
              return (s._Softplus = s.asm.Softplus).apply(null, arguments);
            }),
            (s._SparseFillEmptyRows = function () {
              return (s._SparseFillEmptyRows = s.asm.SparseFillEmptyRows).apply(null, arguments);
            }),
            (s._SparseReshape = function () {
              return (s._SparseReshape = s.asm.SparseReshape).apply(null, arguments);
            }),
            (s._SparseSegmentReduction = function () {
              return (s._SparseSegmentReduction = s.asm.SparseSegmentReduction).apply(null, arguments);
            }),
            (s._SparseToDense = function () {
              return (s._SparseToDense = s.asm.SparseToDense).apply(null, arguments);
            }),
            (s._Sqrt = function () {
              return (s._Sqrt = s.asm.Sqrt).apply(null, arguments);
            }),
            (s._Square = function () {
              return (s._Square = s.asm.Square).apply(null, arguments);
            }),
            (s._SquaredDifference = function () {
              return (s._SquaredDifference = s.asm.SquaredDifference).apply(null, arguments);
            }),
            (s._Step = function () {
              return (s._Step = s.asm.Step).apply(null, arguments);
            }),
            (s._StridedSlice = function () {
              return (s._StridedSlice = s.asm.StridedSlice).apply(null, arguments);
            }),
            (s._Sub = function () {
              return (s._Sub = s.asm.Sub).apply(null, arguments);
            }),
            (s._Sum = function () {
              return (s._Sum = s.asm.Sum).apply(null, arguments);
            }),
            (s._Tan = function () {
              return (s._Tan = s.asm.Tan).apply(null, arguments);
            }),
            (s._Tanh = function () {
              return (s._Tanh = s.asm.Tanh).apply(null, arguments);
            }),
            (s._TensorScatterUpdate = function () {
              return (s._TensorScatterUpdate = s.asm.TensorScatterUpdate).apply(null, arguments);
            }),
            (s._Tile = function () {
              return (s._Tile = s.asm.Tile).apply(null, arguments);
            }),
            (s._TopK = function () {
              return (s._TopK = s.asm.TopK).apply(null, arguments);
            }),
            (s._Transform = function () {
              return (s._Transform = s.asm.Transform).apply(null, arguments);
            }),
            (s._Transpose = function () {
              return (s._Transpose = s.asm.Transpose).apply(null, arguments);
            }),
            (s.__FusedMatMul = function () {
              return (s.__FusedMatMul = s.asm._FusedMatMul).apply(null, arguments);
            }),
            (s._malloc = function () {
              return (s._malloc = s.asm.malloc).apply(null, arguments);
            }),
            (s._free = function () {
              return (s._free = s.asm.free).apply(null, arguments);
            }),
            (s.___errno_location = function () {
              return (s.___errno_location = s.asm.__errno_location).apply(null, arguments);
            });
          var X,
            Q,
            J,
            Z = (s.stackSave = function () {
              return (Z = s.stackSave = s.asm.stackSave).apply(null, arguments);
            }),
            Y = (s.stackRestore = function () {
              return (Y = s.stackRestore = s.asm.stackRestore).apply(null, arguments);
            }),
            ee = (s.stackAlloc = function () {
              return (ee = s.stackAlloc = s.asm.stackAlloc).apply(null, arguments);
            });
          function te(e) {
            function n() {
              X ||
                ((X = !0),
                (s.calledRun = !0),
                v ||
                  (G(P),
                  t(s),
                  s.onRuntimeInitialized && s.onRuntimeInitialized(),
                  (function () {
                    if (s.postRun)
                      for ('function' == typeof s.postRun && (s.postRun = [s.postRun]); s.postRun.length; )
                        (e = s.postRun.shift()), C.unshift(e);
                    var e;
                    G(C);
                  })()));
            }
            W > 0 ||
              ((function () {
                if (s.preRun)
                  for ('function' == typeof s.preRun && (s.preRun = [s.preRun]); s.preRun.length; ) (e = s.preRun.shift()), E.unshift(e);
                var e;
                G(E);
              })(),
              W > 0 ||
                (s.setStatus
                  ? (s.setStatus('Running...'),
                    setTimeout(function () {
                      setTimeout(function () {
                        s.setStatus('');
                      }, 1),
                        n();
                    }, 1))
                  : n()));
          }
          if (
            ((s.dynCall_iijjiiii = function () {
              return (s.dynCall_iijjiiii = s.asm.dynCall_iijjiiii).apply(null, arguments);
            }),
            (s.dynCall_jiji = function () {
              return (s.dynCall_jiji = s.asm.dynCall_jiji).apply(null, arguments);
            }),
            (s.cwrap = function (e, t, n, a) {
              var r = (n = n || []).every(e => 'number' === e || 'boolean' === e);
              return 'string' !== t && r && !a
                ? V(e)
                : function () {
                    return $(e, t, n, arguments);
                  };
            }),
            (O = function e() {
              X || te(), X || (O = e);
            }),
            s.preInit)
          )
            for ('function' == typeof s.preInit && (s.preInit = [s.preInit]); s.preInit.length > 0; ) s.preInit.pop()();
          if (
            (te(),
            i &&
              (Q = {
                uncaughtException: process.listeners('uncaughtException').filter(function (e) {
                  return !i.uncaughtException.indexOf(e) > -1;
                }),
                unhandledRejection: process.listeners('unhandledRejection').filter(function (e) {
                  return !i.unhandledRejection.indexOf(e) > -1;
                }),
              }),
            'undefined' != typeof e)
          )
            J = e;
          else {
            if ('undefined' == typeof WasmBackendModuleThreadedSimd) throw new Error('Could not find wasm module in post.js');
            J = WasmBackendModuleThreadedSimd;
          }
          if (Q) {
            var ne = J._dispose;
            J._dispose = function () {
              ne(),
                Q.uncaughtException.forEach(function (e) {
                  process.removeListener('uncaughtException', e);
                }),
                Q.unhandledRejection.forEach(function (e) {
                  process.removeListener('unhandledRejection', e);
                });
            };
          }
          return e.ready;
        });
    e.exports = u;
  })(rr);
  var ur = rr.exports,
    ir = Za(ur);
  const sr = tr || nr,
    or = ir || i({ __proto__: null, default: ir }, [ur]);
  class dr extends t.KernelBackend {
    constructor(e) {
      super(),
        (this.wasm = e),
        (this.dataIdNextNumber = 1),
        this.wasm.tfjs.initWithThreadsCount(yr),
        (gr = this.wasm.tfjs.getThreadsCount()),
        (this.dataIdMap = new t.DataStorage(this, t.engine()));
    }
    write(e, t, n) {
      const a = { id: this.dataIdNextNumber++ };
      return this.move(a, e, t, n, 1), a;
    }
    numDataIds() {
      return this.dataIdMap.numDataIds();
    }
    async time(e) {
      const n = t.util.now();
      e();
      return { kernelMs: t.util.now() - n };
    }
    move(e, n, a, r, u) {
      const i = this.dataIdNextNumber++;
      if ('string' === r) {
        const t = n;
        return void this.dataIdMap.set(e, { id: i, stringBytes: t, shape: a, dtype: r, memoryOffset: null, refCount: u });
      }
      const s = t.util.sizeFromShape(a),
        o = s * t.util.bytesPerElement(r),
        d = this.wasm._malloc(o) >>> 0;
      this.dataIdMap.set(e, { id: i, memoryOffset: d, shape: a, dtype: r, refCount: u }),
        this.wasm.tfjs.registerTensor(i, s, d),
        null != n && this.wasm.HEAPU8.set(new Uint8Array(n.buffer, n.byteOffset, o), d);
    }
    async read(e) {
      return this.readSync(e);
    }
    readSync(e, n, a) {
      const { memoryOffset: r, dtype: u, shape: i, stringBytes: s } = this.dataIdMap.get(e);
      if ('string' === u) return (null != n && 0 !== n) || !(null == a || a >= s.length) ? s.slice(n, a) : s;
      (n = n || 0), (a = a || t.util.sizeFromShape(i));
      const o = t.util.bytesPerElement(u);
      return (function (e, t) {
        switch (t) {
          case 'float32':
            return new Float32Array(e);
          case 'int32':
            return new Int32Array(e);
          case 'bool':
            return new Uint8Array(e);
          default:
            throw new Error(`Unknown dtype ${t}`);
        }
      })(this.wasm.HEAPU8.slice(r + n * o, r + a * o).buffer, u);
    }
    disposeData(e, t = !1) {
      if (this.dataIdMap.has(e)) {
        const n = this.dataIdMap.get(e);
        if ((n.refCount--, !t && n.refCount > 0)) return !1;
        this.wasm._free(n.memoryOffset), this.wasm.tfjs.disposeData(n.id), this.dataIdMap.delete(e);
      }
      return !0;
    }
    refCount(e) {
      if (this.dataIdMap.has(e)) {
        return this.dataIdMap.get(e).refCount;
      }
      return 0;
    }
    incRef(e) {
      const t = this.dataIdMap.get(e);
      null != t && t.refCount++;
    }
    floatPrecision() {
      return 32;
    }
    getMemoryOffset(e) {
      return this.dataIdMap.get(e).memoryOffset;
    }
    dispose() {
      this.wasm.tfjs.dispose(), 'PThread' in this.wasm && this.wasm.PThread.terminateAllThreads(), (this.wasm = null);
    }
    memory() {
      return { unreliable: !1 };
    }
    makeOutput(e, n, a, r) {
      let u;
      if (null == a) u = this.write(null != r ? r : null, e, n);
      else {
        const r = this.dataIdNextNumber++;
        (u = { id: r }), this.dataIdMap.set(u, { id: r, memoryOffset: a, shape: e, dtype: n, refCount: 1 });
        const i = t.util.sizeFromShape(e);
        this.wasm.tfjs.registerTensor(r, i, a);
      }
      return { dataId: u, shape: e, dtype: n };
    }
    typedArrayFromHeap({ shape: e, dtype: n, dataId: a }) {
      const r = this.wasm.HEAPU8.buffer,
        { memoryOffset: u } = this.dataIdMap.get(a),
        i = t.util.sizeFromShape(e);
      switch (n) {
        case 'float32':
          return new Float32Array(r, u, i);
        case 'int32':
          return new Int32Array(r, u, i);
        case 'bool':
          return new Uint8Array(r, u, i);
        default:
          throw new Error(`Unknown dtype ${n}`);
      }
    }
  }
  function lr(e, t, n) {
    if (null != mr) return mr;
    let a = 'tfjs-backend-wasm.wasm';
    return (
      e && t ? (a = 'tfjs-backend-wasm-threaded-simd.wasm') : e && (a = 'tfjs-backend-wasm-simd.wasm'),
      null != hr && null != hr[a] ? hr[a] : n + a
    );
  }
  async function pr() {
    const [e, n] = await Promise.all([t.env().getAsync('WASM_HAS_SIMD_SUPPORT'), t.env().getAsync('WASM_HAS_MULTITHREAD_SUPPORT')]);
    return new Promise((a, r) => {
      const u = {};
      var i;
      (u.locateFile = (t, a) => {
        if (t.endsWith('.worker.js')) {
          const e = ar.replace(/\n/g, '\\n'),
            t = new Blob([e], { type: 'application/javascript' });
          return URL.createObjectURL(t);
        }
        return t.endsWith('.wasm') ? lr(e, n, null != fr ? fr : a) : a + t;
      }),
        _r &&
          (u.instantiateWasm =
            ((i = lr(e, n, null != fr ? fr : '')),
            (e, n) => (
              t.util.fetch(i, { credentials: 'same-origin' }).then(t => {
                t.ok || e.env.a(`failed to load wasm binary file at '${i}'`),
                  t.arrayBuffer().then(t => {
                    WebAssembly.instantiate(t, e).then(e => {
                      n(e.instance, e.module);
                    });
                  });
              }),
              {}
            )));
      let s,
        o = !1;
      (u.onAbort = () => {
        if (o) return;
        if (br) return;
        br = !0;
        r({
          message:
            'Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers',
        });
      }),
        n && e && null == mr
          ? ((u.mainScriptUrlOrBlob = new Blob(['var WasmBackendModuleThreadedSimd = ' + sr.toString()], { type: 'text/javascript' })),
            (s = sr(u)))
          : (s = or(u)),
        s
          .then(e => {
            (o = !0), (br = !1);
            (e.tfjs = {
              init: e.cwrap('init', null, []),
              initWithThreadsCount: e.cwrap('init_with_threads_count', null, ['number']),
              getThreadsCount: e.cwrap('get_threads_count', 'number', []),
              registerTensor: e.cwrap('register_tensor', null, ['number', 'number', 'number']),
              disposeData: e.cwrap('dispose_data', null, ['number']),
              dispose: e.cwrap('dispose', null, []),
            }),
              a({ wasm: e });
          })
          .catch(r);
    });
  }
  const cr = ['tfjs-backend-wasm.wasm', 'tfjs-backend-wasm-simd.wasm', 'tfjs-backend-wasm-threaded-simd.wasm'];
  let mr = null,
    fr = null,
    hr = {},
    br = !1,
    _r = !1;
  let yr = -1,
    gr = -1;
  t.registerBackend(
    'wasm',
    async () => {
      const { wasm: e } = await pr();
      return new dr(e);
    },
    2,
  ),
    (e.BackendWasm = dr),
    (e.getThreadsCount = function () {
      if (-1 === gr) throw new Error('WASM backend not initialized.');
      return gr;
    }),
    (e.setThreadsCount = function (e) {
      yr = e;
    }),
    (e.setWasmPath = function (e, n = !1) {
      if ((t.deprecationWarn('setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release.'), br))
        throw new Error(
          'The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`',
        );
      (mr = e), (_r = n);
    }),
    (e.setWasmPaths = function (e, t = !1) {
      if (br)
        throw new Error(
          'The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`',
        );
      if ('string' == typeof e) fr = e;
      else {
        hr = e;
        const t = cr.filter(e => null == hr[e]);
        if (t.length > 0)
          throw new Error(
            `There were no entries found for the following binaries: ${t.join(
              ',',
            )}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`,
          );
      }
      _r = t;
    }),
    (e.version_wasm = '4.13.0');
});
//# sourceMappingURL=tf-backend-wasm.es2017.min.js.map
